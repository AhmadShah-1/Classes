

1. 819. Most common Word
Given a string paragraph and a string array of the banned words banned, return the most frequent word that is not banned. It is guaranteed there is at least one word that is not banned, and that the answer is unique.
The words in paragraph are case-insensitive and the answer should be returned in lowercase.
Note that words can not contain punctuation symbols.

Example 1:
Input: paragraph = "Bob hit a ball, the hit BALL flew far after it was hit.", banned = ["hit"]
Output: "ball"
```C++
class Solution {
public:
    string mostCommonWord(string paragraph, vector<string>& banned) {
        for (char& c : paragraph){
            if (ispunct(c)){
                c = ' ';
            }else{
                c = tolower(c);
            }
        }

        unordered_set<string> bannedSet(banned.begin(), banned.end());
        unordered_map<string, int> wordCount;

        stringstream ss(paragraph);
        string word;
        while(ss >> word){
            if (bannedSet.find(word) == bannedSet.end())
            wordCount[word] += 1;
        }

        string result;
        int maxCount = 0;
        for (auto& entry : wordCount){
            if (entry.second > maxCount){
                maxCount = entry.second;
                result = entry.first;
            }
        }
        return result;
    }
};
```



2. 1268. Search Suggestions System
```C++
class Solution {
public:
    vector<vector<string>> suggestedProducts(vector<string>& products, string searchWord) { 
        sort(products.begin(), products.end());
        vector<vector<string>> suggestions;


  
       string prefix;
       for (char c : searchWord){
            prefix += c;
            auto it = lower_bound(products.begin(), products.end(), prefix);

            vector<string> temp1;
            for (int i = 0; i < 3 && it+i != products.end(); ++i){
                if((*(it+i)).compare(0, prefix.size(), prefix) == 0){
                    temp1.push_back(*(it+i));
                }else{
                    break;
                }
            }
            suggestions.push_back(temp1);
        }

        return suggestions;
    }
};
```



3. 8. String to Integer (atoi)
```C++
#include <cctype> //helps characterize strings
#include <algorithm> //modify string
#include <string> 
#include <sstream>

using namespace std;

class Solution {
public:
    int myAtoi(string s) {
        // Move all string chars to builder
        string builder;
        // Keep track of signage; True is negative
        int isNegative = 0;
        int num;
        char part;

        stringstream ss(s);

        while (ss >> part){
            if (part == ' '){
                continue;
            }

            if (part == '-' && builder.size() <= 0){
                isNegative = 1;
                continue;
            }else if(isdigit(part) == true){
                builder += part;            
            }else{
                break;
            }
        }

        num = (builder.size() > 0 ? stoi(builder) * ((isNegative == 1) ? -1 : 1) : 0);

        return num;

    }
};
```

```C++
class Solution {
public:
    int myAtoi(string s) {
        int i = 0, n = s.length();
        int sign = 1;
        long result = 0;

        // Skip leading spaces
        while (i < n && s[i] == ' ') i++;

        // Check for sign
        if (i < n && (s[i] == '+' || s[i] == '-')) {
            sign = (s[i] == '-') ? -1 : 1;
            i++;
        }

        // Build number digit by digit
        while (i < n && isdigit(s[i])) {
            result = result * 10 + (s[i] - '0');

            // Check for overflow
            if (result * sign >= INT_MAX) return INT_MAX;
            if (result * sign <= INT_MIN) return INT_MIN;

            i++;
        }

        return static_cast<int>(result * sign);
    }
};

```



4. 1. Two Sum
```C++
#include <unordered_map>
#include <string>
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {

        unordered_map<int, int> differenceHash = {};

        for (int i = 0; i < nums.size(); ++i){
            int difference = target - nums[i];
            if(differenceHash.find(difference) != differenceHash.end()){
                return {differenceHash[difference], i};
            }else{
                differenceHash[nums[i]] = i;
            }
        }

        return {};

```

