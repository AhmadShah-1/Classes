

#### References:
![[Pasted image 20250622115810.png]]

Accessing the memory address using reference variable:
```C++
string food = "Pizza";  
cout << &food; // Outputs 0x6dfed4
```




#### Pointer
![[Pasted image 20250622120003.png]]
![[Pasted image 20250622120142.png]]



#### Pass value by reference
Here you can alter the actual values firstnum and secondnum by manipulating x and y
![[Pasted image 20250622123627.png]]


#### Lambda Functions
```C++
int main(){
	int x = 3;

	auto show = [x](int a, int b){
	cout<< a + b + x <<endl;
	}

	show(3, 4);
}
```
Here the [] captures existing variables from outside, the () is what you can input into it, then the {} define what the function actually does with all the info



#### Classes
![[Pasted image 20250622124852.png]]
For example: in real life, a car is an object. The car has attributes, such as weight and color, and methods, such as drive and brake.

Attributes and methods are basically variables and functions that belongs to the class. These are often referred to as "class members".


#### Constructors
![[Pasted image 20250622125504.png]]
Constructor Rules:
The constructor has the same name as the class.
It has no return type (not even void).
It is usually declared public.
It is automatically called when an object is created.

There is also constructor overloading, where you can have multiple "Car()" functions with different parameters, and the one that matches will be called upon


#### Encapsulation
The meaning of Encapsulation, is to make sure that "sensitive" data is hidden from users.
To achieve this, you must declare class variables/attributes as private (cannot be accessed from outside the class).

Think of an employee's salary:
The salary is private - the employee can't change it directly
Only their manager can update it or share it when appropriate
Encapsulation works the same way. The data is hidden, and only trusted methods can access or modify it.

Use getters and setters to modify and retrieve data:
![[Pasted image 20250622152021.png]]


#### Inheritance
Inheritance allows one class to reuse attributes and methods from another class. It helps you write cleaner, more efficient code by avoiding duplication.

We group the "inheritance concept" into two categories:
derived class (child) - the class that inherits from another class
base class (parent) - the class being inherited from

To inherit from a class, use the : symbol.
Below Car inherits Vehicle:
![[Pasted image 20250622152142.png]]

###### The Protected Specifier
Public makes it available to those outside of the class, private makes it available to chose within the class
Protected is similar to private but it can also be accessed in the inherited class


#### Polymorphism
Polymorphism means "many forms", and it occurs when we have many classes that are related to each other by inheritance.

Like we specified in the previous chapter; Inheritance lets us inherit attributes and methods from another class. Polymorphism uses those methods to perform different tasks. This allows us to perform a single action in different ways.

For example, imagine a base class Animal with a method called makeSound(). Derived classes of Animals could be Pigs, Cats, Dogs, Birds, etc. Every animal can "make a sound", but each one sounds different:
Pig: wee wee
Dog: bow wow
Bird: tweet tweet

![[Pasted image 20250622152812.png]]


#### Templates
Templates let you write a function or class that works with different data types.
They help avoid repeating code and make programs more flexible.
![[Pasted image 20250622153117.png]]

![[Pasted image 20250622153138.png]]




#### Vectors
The difference between an array and a vector, is that the size of an array cannot be modified (you cannot add or remove elements from an array). A vector however, can grow or shrink in size as needed.
```C++
vector<string> cars = {"Volvo", "BMW", "Ford", "Mazda"};

for (string car : cars){
	cout<< car << endl;
}

// You can access an element by index
cout<<cars[0]<<endl;

// You can also access the first and last element
cout<<cars.front()<<endl;
cout<<cars.back()<<endl;

// Change Value
cars[0] = "Honda";

//To add value use .pushback()
cars.pushback("Tesla");

//To remove the last element use .pop_back()
//Elements are only added and removed from the end, if you need to remove from the start too, use deque instead
cars.pop_back();

//To return the size or length
cout<<cars.size()<<endl;

//To check if a Vector is empty
cout<<cars.empty()<<endl; //Outputs 1 if empty
```


#### List
A list is similar to a vector in that it can store multiple elements of the same type and dynamically grow in size.
However, two major differences between lists and vectors are:
1. You can add and remove elements from both the beginning and at the end of a list, while vectors are generally optimized for adding and removing at the end.
2. Unlike vectors, a list does not support random access, meaning you cannot directly jump to a specific index, or access elements by index numbers.

```C++
//Call on library
#include <list>

list<string> cars = {"Honda", "Tesla"};

//Access the first and last element
cout<<list.front()<<endl;
cout<<list.back()<<endl;

//Change only the first or last element
cars.front() = "Opel";
cars.back() = "Toyota";

//Add values to it fron front or back
cars.push_front("Tesla");
cars.push_back("VW");

//To remove element from front or back
cars.pop_front();
cars.pop_back();

//Size of List
cout<<cars.size()<<endl;

//Check if empty
cout<<cars.empty()<<endl; // 1 if is empty

//You cannot loop through index, only for-each (or iterators)
for(string car : cars){
	cout<<car<<endl;
}

```

#### Stack
A stack stores multiple elements in a specific order, called LIFO.

```C++
//Include library
#include <stack>

//You cannot add elements to a stack at declaration as you can with list and vectors
stack<string> cars;

//Add Elements
cars.push("Tesla");
cars.push("VW");
cars.push("Honda");

//You can see the first element
cout<<cars.top()<<endl;

//Change top value
cars.top() = "BMW";

//Remove top value
cars.pop();

//Size of stack
cout<<cars.size()<<endl;

//Check if empty
cout<<cars.empty()<<endl; //1 if empty
```

#### Queue
A queue stores multiple elements in a specific order, called FIFO. It has access to remove elements from the front, and add elements to the back, like a normal queue line; BUT you can read and change the first and last elements

```C++
//Include library
#include <queue>

//Cannot add elements at declaration
queue<string> cars;

//Add elements
queue.push("Volvo");
queue.push("Volvo");
queue.push("Volvo");

//Access front and back
cout<<queue.front()<<endl;
cout<<queue.back()<<endl;

//Change front and back elements
queue.front() = "Tesla";
queue.back() = "BMW";

//Remove the front element
cars.pop()   //In other structures this would remove the back, but here its the front

//Return the size
cout<<cars.size()<<endl;

//Check if empty
cout<<cars.empty()<<endl;
```

#### Deque
A deque (stands for double-ended queue) however, is more flexible, as elements can be added and removed from both ends (at the front and the back). You can also access elements by index numbers.
```C++
//Include library
#include <deque>

//You can add elements at the start of declaration
deque<string> cars = {"Volvo", "Telsa"};

//Print all items from deque
for(string car : cars){
	cout<<car<<endl;
}

//Access by index
cout<<cars[0]<<endl;

//Access by front or back
cout<<cars.front()<<endl;
cout<<cars.back()<<endl;

//Change a deque element
cars[0] = "Opel";

//Add deque elements to front or back
cars.push_front("Opal");
cars.push_back("Opal");

//Remove elements from front or back
cars.pop_front();
cars.pop_back();

//Return size
cout<<cars.size()<<endl;

//Check if empty
cout<<cars.empty()<<endl;
```


#### Sets
A set stores unique elements where they:
- Are sorted automatically in ascending order.
- Are unique, meaning equal or duplicate values are ignored.
- Can be added or removed, but the value of an existing element cannot be changed.
- Cannot be accessed by index numbers, because the order is based on sorting and not indexing.

```C++
#Include library
#include <set>

//You can add element at declartion
set<string> cars = {"Volvo", "BMW", "Ford"};

//Print out all
for (string car : cars){  //Elements within it are automatically assorted alphabetically
	//So here (BMW, Ford, Volvo), if it were numbers it would be sorted numerically
	cout<<car<<endl; 
}

//To force it to sort in reverse, use the greater<type> functor
set<int, greater<int>> numbers = {1, 2, 6, 3}

//Elements are unique, no duplicates
set<string> cars = {"Volvo", "Tesla", "Volvo"}  //Only one Volvo would be saved

//Add elements
cars.insert("BMW");

//Remove elements
cars.erase("Volvo");

//Remove all elemetns
cars.clear();

//Return size
cout<<cars.size()<<endl;

//Check if empty
cout<<cars.empty()<<endl;
```


#### Maps
A map stores elements in "key/value" pairs.
Elements in a map are:
1. Accessible by keys (not index), and each key is unique.
2. Automatically sorted in ascending order by their keys.

```C++
//Include Library
#include <map>

//You can add elements at declaration
map<string, int> people = {{"John", 12}, {"Lewis", 22}};

//Access values by key
cout<<"John is "<<people["John"]<<"years old"<<endl;

//Change Value
people["John"] = 32;

//Add Element, two ways
people["Jacob"] = 22;
people.insert({"Jacob", 22});

//Remove specific element
people.erase("John")

//Remove all elements
people.clear()

//Return Size
cout<<people.size()<<endl;

//Check if empty
cout<<people.empty()<<endl;

//You can check if an element exists
cout<<people.count("John");

//To loop through it, use "auto"
for (auto person : people){
	//person.first is the key, and person.last is the value
	cout<<person.first<<person.second<<endl;
}

//To reverse the order of key orders use greater<type> functor
map<string, int, greater<string>> people = {{"John", 12}, {"Lewis", 22}};

```

### Iterators
When you are just reading the elements, and don't need to modify them, the for-each loop is much simpler and cleaner than iterators.

However, when you need to add, modify, or remove elements during iteration, iterate in reverse, or skip elements, you should use iterators.

begin() and end() are functions that belong to data structures, such as vectors and lists.
- begin() returns an iterator that points to the first element of the data structure.
- end() returns an iterator that points to one position after the last element.

```C++
#include <vector>
vector<string> cars = {"Volvo", "BMW"};

//Loop using iterator
for (auto it = cars.begin(); it != cars.end(); ){
	if(*it == "BMW"){
		it = cars.erase(it);     //Remove "BMW"
	}else{
		++it;
	}
}

//Loop in Reverse
for (auto it = cars.rbegin(); it != cars.rend(); ++it)


//THIS IS SIMILIAR IN EVERY DATA STRUCTURE, HOWEVER MAPS IS SLIGHTLY DIFFERENT
map<string, int> people {{"John", 30}, {"Lewis", 29}};

//You have to use -> instead of . to access key and value
//You could also do (*it).first too because the it needs to be dereferenced
//So it really is the same for maps, but an extra thing to think about
for (auto it = people.begin(); it != people.end(); ++it){
	cout<< it->first << it->second <<endl;
}

```

#### Algorithms
Another important feature of iterators is that they are used with different algorithm functions, such as sort() and find() (found in the \<algorithm> library), to sort and search for elements in a data structure.

For example, the sort() function takes iterators (typically returned by begin() and end()) as parameters to sort elements in a data structure from the beginning to the end.

Sort:
```C++
//We will sort a vector in order
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main(){
	vector<string> cars = {"Volvo", "BMW", "Tesla"};
	//Sort the cars in alphabetical order
	sort(cars.begin(), cars.end());

	vector<int> numbers = {1, 2, 3, 4};
	//Sort by numbers
	sort(numbers.begin(), numbers.end());

	//YOU CAN ALSO REVERSE THE ORDER WITH .rbegin() AND .rend()
	sort(numbers.rebegin(), number.rend())

	//To sort only specific elements
	sort(numbers.begin() + 3, numbers.end());

	

}
```

Find:
```C++
//We will sort a vector in order
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main(){
	vector<int> numbers = {1, 7, 3, 5, 9, 2};

	//Search for the number 3
	auto it = find(numbers.begin(), numbers.end(), 3);

	//Search for an element greater than (first item to fulfill it)
	//Find first occurance greater than 5
	auto it = upper_bound(numbers.begin(), numbers.end(), 5);  

	//Find smallest element in vecotr
	auto it = min_element(numbers.begin(), numbers.end());

	//Find largest element
	auto it = max_element(numbers.begin(), numbers.end());
}

```

Binary Search:
```C++
//To find if a value exists in a sorted vector
//Similiar to find() but is faster, REMEMBER TO SORT FIRST
#include <algorithms>
vector<int> numbers = {1, 2, 3, 4, 5};
sort(numbers.begin(), numbers.end());

if (binary_search(numbers.begin(), numbers.end(). 5)){
	cout<<"found"<<endl;
}else{
	cout<<"not found"<<endl;
}
```

Modify:
```C++
//We will copy elements from one vector to another
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main(){
	vector<int> numbers = {1, 7, 3, 5, 9, 2};

	//Create vector that can store 6 integers
	vector<int> copiedNumbers(6);

	//Copy elements from over
	copy(numbers.begin(), numbers.end(), copiedNumbers.begin());
}

```


Search by Pattern:
```C++
//To find if a vector is contained within another vector
#include algorithms
vector<int> numbers = {1, 2, 3, 4, 5, 6};
vector<int> target = {2, 3, 4};

if (search(numbers.begin(), numbers.end(), target.begin(), target.end()) != numbers.end()){
	cout<<"target was found"<<endl;
}else{
	count<<"target was not found"<<endl;
}
```

Search if all occurrences exist:
```C++
#include algorithms
vector<int> numbers = {1, 2, 3, 4, 5, 6};
vector<int> target = {2, 3, 4};

sort(numbers.begin(), numbers.end());

if (includes(numbers.begin(), numbers.end(), target.begin(), target.end())){
	cout<<"found"<<endl;
}else{
	cout<<"not found"<<endl;
}

```

