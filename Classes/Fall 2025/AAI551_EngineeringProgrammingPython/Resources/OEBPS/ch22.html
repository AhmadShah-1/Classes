<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xml:lang="en"
lang="en"
xmlns="http://www.w3.org/1999/xhtml"
xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<title>Learning Python, 6th Edition</title>
<link rel="stylesheet" type="text/css" href="override_v1.css"/>
<link rel="stylesheet" type="text/css" href="epub.css"/>
</head>
<body>
<div id="book-content">
<div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 22. Modules: The Big Picture"><div class="chapter" id="modules_the_big_picture">
<h1><span class="label">Chapter 22. </span>Modules: The Big Picture</h1>
<p>This chapter begins our in-depth look at the Python <em>module</em>—the highest-level program organization unit, which packages program code and data for reuse, and provides self-contained namespaces that minimize variable name clashes across your programs. Modules were introduced in <a data-type="xref" href="ch03.html#how_you_run_programs">Chapter 3</a>, and we’ve been using them more and more since <a data-type="xref" href="ch16.html#function_basics">Chapter 16</a>, but this part of the book provides a focused, detailed look at this Python tool.</p>
<p>This first chapter in <a data-type="xref" href="part05.html#modules_and_packages">Part V</a> reviews module basics, and offers a general look at the role of modules in the overall structure of programs. In the chapters that follow, we’ll dig into the coding details behind that theory. Along the way, we’ll also flesh out module fine points omitted so far—you’ll learn about reloads, the <code>__name__</code> and <code>__all__</code> attributes, package imports, relative import syntax, namespace packages, the <code>__getattr__</code> hook, the <code>__main__.py</code> file, and so on. Because modules and classes are really just glorified <em>namespaces</em>, this part formalizes namespace concepts as well.</p>
<section data-type="sect1" data-pdf-bookmark="Module Essentials"><div class="sect1" id="module_essentials">
<h1>Module Essentials</h1>
<p>In simple and concrete terms, modules typically correspond to Python source code <em>files</em>. Each file of code is a module automatically, and modules import other modules to use the names they define. Modules might also correspond to extensions coded in external <em>languages</em> such as C, Java, or C#, and even to entire <em>directories</em> in package imports, which extend the model for nested files. In all their forms, modules <a contenteditable="false" data-type="indexterm" data-primary="modules" data-secondary="import statement" id="id3374"></a><a contenteditable="false" data-type="indexterm" data-primary="modules" data-secondary="from statement" id="id3375"></a><a contenteditable="false" data-type="indexterm" data-primary="modules" data-secondary="importlib.reload" id="id3376"></a>are processed with two statements and one tool:</p>
<dl>
<dt><code>import</code></dt>
<dd>Lets a client (importer) fetch a module as a whole</dd>
<dt><code>from</code></dt>
<dd>Allows clients to fetch particular names from a module</dd>
<dt><code>importlib.reload</code></dt>
<dd>Provides a way to reload a module’s code without stopping Python</dd>
</dl>
<p>We’ve used imports in prior examples to load both Python standard-library modules, as well as code files that reside in the current directory—the one we are in when launching the REPL or a script file. While straightforward on the surface, these tools imply an underlying model that’s richer than you might think. Before we delve into its details, though, let’s begin by getting a handle on the purpose of modules in our Python programs.</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Why Use Modules?"><div class="sect1" id="why_use_modulesquestion_mark">
<h1>Why Use Modules?</h1>
<p>In short, modules provide an easy way <a contenteditable="false" data-type="indexterm" data-primary="modules" data-secondary="namespaces" id="id3377"></a><a contenteditable="false" data-type="indexterm" data-primary="namespaces" id="id3378"></a>to organize components into a system, by serving as self-contained packages of variables known as <em>namespaces</em>. All the names defined at the top level of a module file become attributes of the imported module object, but a file’s names can’t be seen without imports, and don’t clash with names in other files.</p>
<p>This model is related to <a contenteditable="false" data-type="indexterm" data-primary="modules" data-secondary="global scope" id="id3379"></a>the scopes we studied in the last part of this book. As we learned in <a data-type="xref" href="ch17.html#scopes">Chapter 17</a>, imports give access to names in a module’s <em>global scope</em>. The file surrounding a function is always that function’s own global scope, but imports allow one file to see the global names of another file as attributes. That is, the module file’s global scope <em>morphs</em> into the module object’s attribute namespace when it is imported.</p>
<p>Ultimately, this allows us to link individual files into a larger program system, with three primary <span class="keep-together">benefits:</span></p>
<dl>
<dt>Code reuse</dt>
<dd>Modules make code permanent. Because a <a contenteditable="false" data-type="indexterm" data-primary="modules" data-secondary="code reuse" id="id3380"></a><a contenteditable="false" data-type="indexterm" data-primary="code reuse" data-secondary="modules" id="id3381"></a>module’s code is saved in a file, you can both run it multiple times and use it in multiple programs. As you’ve learned, code you type at a Python REPL goes away when you exit Python, but code in module files can be <em>rerun</em> as many times as you wish. Moreover, the tools you define in modules may be <em>reused</em> by any number of external clients, and in programs coded both now and in the future.</dd>
<dt>Minimizing redundancy</dt>
<dd>Module reuse naturally enables shared <a contenteditable="false" data-type="indexterm" data-primary="modules" data-secondary="redundancy" id="id3382"></a><a contenteditable="false" data-type="indexterm" data-primary="redundancy" data-secondary="modules" id="id3383"></a>copies of common code. If more than one file uses the same or similar code, you can write it once in a module that can then be imported by many clients. For example, in the prior chapter’s benchmarking examples, test scripts imported common timer and test-runner functions, instead of repeating them. In other words, modules—like functions—help us factor code to avoid the <em>redundancy</em> that results from copy-and-paste programming. As for functions, this minimizes work when common code must be changed.</dd>
<dt>Namespace partitioning</dt>
<dd>Modules are also the highest-level namespace structure in a Python program. Although they are fundamentally <a contenteditable="false" data-type="indexterm" data-primary="modules" data-secondary="namespaces" data-tertiary="partitioning" id="id3384"></a><a contenteditable="false" data-type="indexterm" data-primary="namespaces" data-secondary="modules" data-tertiary="partitioning" id="id3385"></a>just packages of names, these packages are also <em>self-contained</em>—you can never see a name in another file unless you explicitly import that file. Much like the local scopes of functions, this helps avoid name clashes across your programs. In fact, you can’t avoid this feature—everything “lives” in a module. Because both the code you run and the objects you create are always implicitly enclosed in modules, modules group components by nature.</dd>
</dl>
<p>At least that’s the abstract story. To truly understand the role of modules in a Python system, we need to digress for a moment and explore the general structure of a Python program.</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Python Program Architecture"><div class="sect1" id="python_program_architecture">
<h1>Python Program Architecture</h1>
<p>So far in this book, many examples <a contenteditable="false" data-type="indexterm" data-primary="architecture" data-seealso="program architecture" id="id3386"></a>have sugarcoated the complexity of Python programs. In practice, programs usually involve more than just one file. For all but the simplest scripts, your programs will take the form of <em>multifile</em> systems—as the code-benchmarking programs of the preceding chapter <span class="keep-together">illustrated</span>. Even if you can get by with coding a single file yourself, you will almost certainly wind up using external files that someone else has already written.</p>
<p>This section reviews the general <em>architecture</em> of Python programs—the way you divide a program into a collection of source code files (a.k.a. modules) and link the parts into a whole. As you’ll see, Python fosters a <em>modular</em> program structure that groups functionality into coherent and reusable units, in ways that are almost automatic. Along the way, this section also explores the central concepts of Python modules, imports, and object attributes.</p>
<section data-type="sect2" data-pdf-bookmark="How to Structure a Program"><div class="sect2" id="how_to_structure_a_program">
<h2>How to Structure a Program</h2>
<p>At a base level, a Python program consists of text files <a contenteditable="false" data-type="indexterm" data-primary="program architecture" data-secondary="files" data-tertiary="text files" id="id3387"></a><a contenteditable="false" data-type="indexterm" data-primary="program architecture" data-secondary="files" data-tertiary="top-level" id="id3388"></a><a contenteditable="false" data-type="indexterm" data-primary="program architecture" data-secondary="modules" data-tertiary="files" id="id3389"></a><a contenteditable="false" data-type="indexterm" data-primary="modules" data-secondary="program architecture" id="id3390"></a><a contenteditable="false" data-type="indexterm" data-primary="files" data-secondary="program architecture" id="id3391"></a>containing Python <em>statements</em>, with one main <em>top-level</em> file, and zero or more supplemental files known as <em>modules</em>.</p>
<p>Here’s how this works. The top-level (a.k.a. <em>script</em>) file contains the main flow of control of your <span class="keep-together">program—this</span> is the file you run to launch your application. The module files are libraries of tools, used to group components used by the top-level file, and possibly elsewhere. Top-level files use tools defined in module files, and modules use tools defined in other modules.</p>
<p>Although they are files of code too, module files generally don’t do anything when run directly; rather, they define tools intended for use in other files. A file <em>imports</em> a module to gain access to the tools it defines, which are known as its <em>attributes</em>—variable names attached to objects such as functions. Ultimately, we import modules and access their attributes to use their tools.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Imports and Attributes"><div class="sect2" id="imports_and_attributes">
<h2>Imports and Attributes</h2>
<p>To make this a bit more concrete, <a data-type="xref" href="#program_architecture_in_python">Figure 22-1</a> sketches the structure of a Python program composed of three <a contenteditable="false" data-type="indexterm" data-primary="program architecture" data-secondary="modules" data-tertiary="importing" id="parmp"></a><a contenteditable="false" data-type="indexterm" data-primary="program architecture" data-secondary="attributes" id="prgrttb"></a><a contenteditable="false" data-type="indexterm" data-primary="attributes" id="attburt"></a><a contenteditable="false" data-type="indexterm" data-primary="imports" data-secondary="modules" id="iprtsm"></a><a contenteditable="false" data-type="indexterm" data-primary="modules" data-secondary="importing" id="mdlprt"></a>files: <em>a.py</em>, <em>b.py</em>, and <em>c.py</em>. The file <em>a.py</em> is chosen to be the <em>top-level</em> script file; it will be a simple text file of statements, which is executed from top to bottom when launched. The files <em>b.py</em> and <em>c.py</em> are <em>modules</em>; they are simple text files of statements as well, but they are not usually launched directly. Instead, as explained previously, modules are normally imported by other files that wish to use the tools the modules define.</p>
<figure><div id="program_architecture_in_python" class="figure">
<img src="assets/lpy6_2201.png" alt="" width="938" height="566"/>
<h6><span class="label">Figure 22-1. </span>Program architecture in Python</h6>
</div></figure>
<p>For instance, suppose the file <em>b.py</em> in <a data-type="xref" href="#program_architecture_in_python">Figure 22-1</a> defines a function called <code>job</code> for external use, per <a data-type="xref" href="#example_twotwo_onedot_bdotpy_left_paren">Example 22-1</a> (and ignoring <em>c.py</em> for the moment). As you learned when studying functions in <a data-type="xref" href="part04.html#functions_and_generators">Part IV</a>, <em>b.py</em> will contain a Python <code>def</code> statement to generate the function, which you can later run by passing values in parentheses after the function’s name.</p>
<div data-type="example" id="example_twotwo_onedot_bdotpy_left_paren">
<h5><span class="label">Example 22-1. </span>b.py (module)</h5>
<pre data-type="programlisting">def job(tool):
    print(tool, 'coder')</pre>
</div>
<p>This function probably seems trivial at this point in this book, but we’re keeping it simple to focus on module basics. Now, suppose <em>a.py</em> wants to use <code>job</code>. To this end, it might contain Python statements like those in <a data-type="xref" href="#example_twotwo_twodot_adotpy_left_paren">Example 22-2</a>.</p>
<div data-type="example" id="example_twotwo_twodot_adotpy_left_paren">
<h5><span class="label">Example 22-2. </span>a.py (script)</h5>
<pre data-type="programlisting">import b
b.job('Python')</pre>
</div>
<p>The first of these, a Python <code>import</code> statement, gives the file <em>a.py</em> access to everything defined by <em>top-level code</em>—that is, code not nested inside a function or class—within the file <em>b.py</em>. The code <code>import b</code> roughly means:</p>
<blockquote>
<p>Load the file <em>b.py</em> (unless it’s already loaded), and give me access to all its attributes through the name <code>b</code>.</p>
</blockquote>
<p>To satisfy such goals, <code>import</code> (and, as you’ll see later, <code>from</code>) statements execute and load other files on request. More formally, in Python, cross-file module linking is not resolved until such <code>import</code> statements are executed at <em>runtime</em>; their net effect is to assign module names—simple variables like <code>b</code>—to loaded module <em>objects</em>. In fact, the module name used in an <code>import</code> statement serves two purposes: it identifies the external <em>file</em> to be loaded (by base name <code>b</code> here), but it also becomes a <em>variable</em> assigned to the loaded module.</p>
<p>Similarly, objects <em>defined</em> by a module’s code are also created at runtime, while the import is executing: <code>import</code> literally runs statements in the target file one at a time to create its contents. Along the way, every name assigned at the top level of the file becomes an attribute of the module, accessible to importers. For example, the second of the statements in <em>a.py</em> calls the function <code>job</code> defined in the module <code>b</code>—and created by running its <code>def</code> statement during the import—using object attribute notation. The code <code>b.job</code> means:</p>
<blockquote>
<p>Fetch the value of the name <code>job</code> that lives within the object <code>b</code>.</p>
</blockquote>
<p>This happens to be a callable function in our example, so we pass a string in parentheses (<code>'Python'</code>). If you run <em>a.py</em>, the words “Python coder” will be printed—hardly a shocker if you’ve read prior chapters, but illustrative.</p>
<p>As we’ve seen, the <code><em>object</em>.<em>attribute</em></code> notation is general and pervasive in Python code because most objects have useful attributes that are fetched with the “.” operator. Some attributes reference callable objects like functions that take action (e.g., a salary computer), while others are simple values that denote data (e.g., a person’s name).</p>
<p class="pagebreak-before">Imports are similarly general because any file can import tools from any other file. For instance, the file <em>a.py</em> in <a data-type="xref" href="#program_architecture_in_python">Figure 22-1</a> may import <em>b.py</em> to call its function, but <em>b.py</em> might also import <em>c.py</em> to leverage different tools defined there. In fact, import chains can go as deep as you like: in this example, module <code>a</code> can import <code>b</code>, which can import <code>c</code>, which can import <code>b</code> again, and so on. More realistically, in the benchmarking code of the prior chapter, test scripts imported runner modules, which imported timer <span class="keep-together">modules</span>.</p>
<p>The main point behind all this is that modules (and module packages, described in <a data-type="xref" href="ch24.html#module_packages">Chapter 24</a>) are the topmost level of <em>code reuse</em> in Python. Components coded in module files can be used both in your original program and in any other programs you may write later. For instance, if we later discover that the function <code>b.job</code> in <a data-type="xref" href="#example_twotwo_onedot_bdotpy_left_paren">Example 22-1</a> is widely useful, we can deploy it in completely different programs; all we have to do is import <code>b</code> again from the other programs. While unlikely in this simple demo, modules by nature <a contenteditable="false" data-type="indexterm" data-primary="program architecture" data-secondary="attributes" data-startref="prgrttb" id="id3392"></a><a contenteditable="false" data-type="indexterm" data-primary="attributes" data-startref="attburt" id="id3393"></a>create packages of reusable tools.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Standard-Library Modules"><div class="sect2" id="standard_library_modules">
<h2>Standard-Library Modules</h2>
<p>Notice the rightmost portion of <a data-type="xref" href="#program_architecture_in_python">Figure 22-1</a>. As we’ve seen along the way, some of the modules that your programs will <a contenteditable="false" data-type="indexterm" data-primary="program architecture" data-secondary="modules" data-tertiary="standard-library" id="id3394"></a><a contenteditable="false" data-type="indexterm" data-primary="modules" data-secondary="standard-library modules" id="id3395"></a><a contenteditable="false" data-type="indexterm" data-primary="standard library" data-secondary="modules" id="id3396"></a>import are provided by Python itself and are not files you will code.</p>
<p>Python automatically comes with a large collection of utility modules known as the <em>standard library</em>. This collection, hundreds of modules large at last count, contains platform-independent support for common programming tasks: operating system interfaces, object persistence, text pattern matching, network and internet scripting, GUI construction, multithreading, and much more.</p>
<p>None of these tools are part of the Python <em>language</em> itself, but you can use them by simply importing the appropriate modules on any standard Python installation. Because they are standard-library modules, you can also be reasonably sure that they will be available and will work portably on most platforms on which you will run Python code.</p>
<p>This book’s examples employ a few of the standard library’s modules—<code>time</code>, <code>timeit</code>, <code>sys</code>, and <code>os</code> in the last chapter’s code, for instance—but we’ll really only scratch the surface of the library’s story here. For a complete look, browse the Python standard-library reference manual, available online at <em>python.org</em> and elsewhere. See <a data-type="xref" href="ch15.html#the_documentation_interlude">Chapter 15</a> for more on these manuals; the <em>PyDoc</em> tool discussed there also provides library-module info and lists every importable module, including the standard library.</p>
<p>Because there are so many standard-library modules, browsing is the best way to get a feel for what tools are available. You can also find tutorials on Python library tools in books that cover application-level programming, but the standard manuals are free, viewable in <a contenteditable="false" data-type="indexterm" data-primary="program architecture" data-secondary="modules" data-tetiary="importing" data-startref="parmp" id="id3397"></a>any web browser, and updated each time Python is rereleased. As of Python 3.10, <code>sys.stdlib_module_names</code> also provides a simple list of all standard-library modules—importable or not:</p>
<pre data-type="programlisting">$ <code><strong>python3</strong></code>
&gt;&gt;&gt; <code><strong>len(sys.stdlib_module_names)</strong> </code>          <code><em># That's a lot of modules</em></code>
300</pre>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="How Imports Work"><div class="sect1" id="how_imports_work">
<h1>How Imports Work</h1>
<p>The prior section talked about importing modules without fully explaining what happens when you do so. Because imports are at the heart of program structure in Python, this section goes into more formal detail on the import operation to make this process less abstract.</p>
<p>Some C programmers like to compare the Python module import operation to a <code>C #include</code>, but they really shouldn’t—in Python, imports are not textual insertions of one file into another. They are really <em>runtime</em> operations that perform three <a contenteditable="false" data-type="indexterm" data-primary="imports" data-secondary="as runtime operations" id="id3398"></a><a contenteditable="false" data-type="indexterm" data-primary="runtime operations" data-secondary="imports" id="id3399"></a>distinct steps the first time a program imports a given file:</p>
<ol>
<li><p><em>Find</em> the module’s file.</p></li>
<li><p><em>Compile</em> it to bytecode (if needed).</p></li>
<li><p><em>Run</em> the module’s code to build the objects it defines.</p></li>
</ol>
<p>To help you better understand module imports, the following sections explore each of these steps in turn.</p>
<p>First, though, bear in mind that all three of these steps are carried out only the <em>first time</em> a module is imported during a program’s execution. Later imports of the same module in a program’s run bypass all three of these steps and simply fetch the already loaded module in memory.</p>
<p>Python does this by storing loaded modules in a normal dictionary named <code>sys.modules</code>, and checking for a module’s name there at the start of an import operation. In fact, <code>sys.modules['<em>name</em>']</code> means the same as <code><em>name</em></code> after an <code>import <em>name</em></code>, and <code>sys.modules</code>’ keys iterator or <code>keys</code> method lists all imported modules:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>import sys, os</strong></code><strong></strong>
&gt;&gt;&gt; <code><strong>sys.modules['os'] is os</strong> </code>               <code><em># Name string =&gt; module</em></code>
True
&gt;&gt;&gt; <code><strong>sorted(sys.modules)</strong></code>                    <code><em># Or sys.modules.keys()</em></code>
…<code><em>names of all loaded modules</em></code>…</pre>
<p>We’ll explore other roles for <code>sys.modules</code> in upcoming chapters. On imports, though, if the requested module is not already present in <code>sys.modules</code>, a three-step process begins.</p>
<section data-type="sect2" data-pdf-bookmark="Step 1: Find It"><div class="sect2" id="step_one_find_it">
<h2>Step 1: Find It</h2>
<p>First, Python must locate the <a contenteditable="false" data-type="indexterm" data-primary="imports" data-secondary="modules" data-startref="iprtsm" id="id3400"></a><a contenteditable="false" data-type="indexterm" data-primary="modules" data-secondary="importing" data-startref="mdlprt" id="id3401"></a><a contenteditable="false" data-type="indexterm" data-primary="import statement" data-secondary="modules" id="id3402"></a>module file referenced by an <code>import</code> statement. Notice that the <code>import</code> statement in the prior section’s example names the file without a <em>.py</em> extension and without its directory path: it just says <code>import b</code>, instead of something like <code>import c:\dir\b.py</code> or similar on Unix. Path and extension details are omitted in imports on purpose; instead, Python uses a standard <em>module search path</em> along with known file types to locate the module file corresponding to an <code>import</code> statement.</p>
<p>Because this is the main part of the import operation that programmers must know about, we’ll return to this topic by itself in a moment.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Step 2: Compile It (Maybe)"><div class="sect2" id="step_two_compile_it_left_parenthesismay">
<h2>Step 2: Compile It (Maybe)</h2>
<p>After finding a source code file that matches an <code>import</code> statement by <a contenteditable="false" data-type="indexterm" data-primary="imports" data-secondary="modules" data-tertiary="bytecode" id="pmdbycd"></a><a contenteditable="false" data-type="indexterm" data-primary="modules" data-secondary="importing" data-tertiary="bytecode" id="mdmpby"></a><a contenteditable="false" data-type="indexterm" data-primary="bytecode" id="id3403"></a>traversing the module search path, Python next compiles it to a lower-level form known as <em>bytecode</em>, if necessary. We discussed bytecode in <a data-type="xref" href="ch02.html#how_python_runs_programs">Chapter 2</a>, but it’s a bit richer than explained there.</p>
<p>When you first import a module, Python compiles the module’s <em>.py</em> source code file to bytecode, and saves the bytecode in a file with a <em>.pyc</em> extension if possible. On later program runs, Python will load the bytecode from its <em>.pyc</em> file and skip the compile step, as long as the bytecode file uses a compatible format and was made by the importing Python, and you have not edited and saved the source code file since the bytecode file was made.</p>
<p>Importantly, if you change a module’s source code, its bytecode file will be re-created the next time you run a program that imports the module. This ensures that a module’s bytecode is always in sync with its source, and your Python.</p>
<p>All of this is automatic and can generally be taken on faith by most Python users, but a brief look at the complete story can help make the process less mysterious than it should be. In more detail, bytecode files can be created in two flavors, the first of which is used by default, and the second of which came online in Python 3.7:</p>
<ul>
<li><p><em>Timestamp-based</em> bytecode files are <a contenteditable="false" data-type="indexterm" data-primary="bytecode" data-secondary="timestamp-based files" id="id3404"></a><a contenteditable="false" data-type="indexterm" data-primary="timestamp-based bytecode files" id="id3405"></a>created by simply importing modules and are the default, original, and most common option. This is the flavor to use if you want imports to be fast, and don’t have atypical needs.</p></li>
<li><p><em>Hash-based</em> bytecode files are <a contenteditable="false" data-type="indexterm" data-primary="bytecode" data-secondary="hash-based files" id="id3406"></a><a contenteditable="false" data-type="indexterm" data-primary="hash-based bytecode files" id="id3407"></a>created by using the <code>compileall</code> or <code>py_compile</code> library modules. Once created, the Python command-line switch <code>--check-hash-based-pycs</code> may be used to configure their operation (see Python’s manual for this flag’s three options).</p></li>
</ul>
<p>In either model, Python automatically <a contenteditable="false" data-type="indexterm" data-primary="bytecode" data-secondary="magic number" id="id3408"></a>saves enough info to know when a bytecode file must be re-created. Specifically, bytecode files embed a “<em>magic</em>” number identifying the bytecode’s format, along with either the source code file’s last-modified <em>timestamp</em> and <em>size</em>, or a <em>hash</em> value derived from the source code file’s content. Bytecode filenames also include the implementation name and version of the <em>Python</em> that created them.</p>
<p>When a module is imported, Python <a contenteditable="false" data-type="indexterm" data-primary="imports" data-secondary="modules" data-tertiary="previous imports" id="id3409"></a><a contenteditable="false" data-type="indexterm" data-primary="modules" data-secondary="importing" data-tertiary="previous imports" id="id3410"></a>first checks to see if it was previously imported by the program, and uses the already loaded module if so. Otherwise, it looks for a usable bytecode file corresponding to the module’s source code file, by comparing the info saved with the bytecode file against the current specs of the running Python and the source code file. A <em>.pyc</em> bytecode file is usable if it has the same base name as the source code file, and:</p>
<ul>
<li><p>Uses a <em>compatible</em> format—by checking the “magic” number</p></li>
<li><p>Is <em>up to date</em> with the source code file—by comparing either saved timestamp and size, or hash value</p></li>
<li><p>Was created by the running <em>Python</em>—by inspecting implementation and version tags in the filename</p></li>
</ul>
<p>If there is a bytecode file that passes all these checks, it is loaded, and the compilation step is skipped. If not, the source code is compiled to bytecode, and either saved or resaved in a bytecode file with all the noted info.</p>
<p>Programs still run if bytecode files cannot be saved (compiled code is then simply created in memory and discarded on exit), and the <code>-B</code> Python command-line switch can turn off bytecode saves, though it’s rarely needed. When they are saved, bytecode files are written to and loaded from a subdirectory named <code>__pycache__</code> that’s located alongside their corresponding source code files.</p>
<p>The <code>__pycache__</code> subdirectory avoids both clutter in your source code folders, and contention and recompiles when multiple Pythons are installed. For example, here’s what happens when the same module file in this chapter’s examples folder is imported by three different Pythons—two CPythons, and the PyPy we used in the preceding chapter (on Windows, use <code>dir</code> and <code>py</code> instead of <code>ls</code> and Python commands here):</p>
<pre class="pagebreak-before" data-type="programlisting">$ <code><strong>ls</strong></code>
codefile.py

$ <code><strong>python3.12</strong></code>
&gt;&gt;&gt; <code><strong>import codefile</strong></code>

$ <code><strong>python3.8</strong></code>
&gt;&gt;&gt; <code><strong>import codefile</strong></code>

$ <code><strong>pypy3</strong></code>
&gt;&gt;&gt;&gt; <code><strong>import codefile</strong></code>

$ <code><strong>ls</strong></code>
__pycache__   codefile.py
$ <code><strong>ls __pycache__</strong></code>
codefile.cpython-312.pyc     codefile.cpython-38.pyc     codefile.pypy310.pyc</pre>
<p>Technically, the <code>__pycache__</code> subdirectory was introduced in Python 3.2 and isn’t available earlier, but this book is focused on Python 3.X only, and you’re very unlikely to come across a 3.1 or 3.0 in the wild today.</p>
<p>Also, keep in mind that bytecode compilation happens when a file is being <em>imported</em>. Because of this, you will not usually see a <em>.pyc</em> bytecode file for the <em>top-level</em> file of your program, unless it is also imported elsewhere—only imported files leave behind <em>.pyc</em> files on your machine. The bytecode of top-level files is used internally and discarded; bytecode of imported files is saved in files to speed up future imports.</p>
<p>Top-level files are often designed to be executed directly and not imported at all. Later, though, you’ll see that it is possible to design a file that serves <em>both</em> as the top-level code of a program and as a module of tools to be imported. Such a file may be either executed and imported and does generate a <em>.pyc</em> in the latter role. To learn how this works, watch for the discussion of the special <code>__name__</code> attribute and <code>__main__</code> in <a data-type="xref" href="ch25.html#module_odds_and_ends">Chapter 25</a>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><em>Running from bytecode only</em>: As a now-special case, programs will also run if Python finds <em>only</em> bytecode files but no source code files, though this involves more than just deleting your <em>.py</em> files. As of Python 3.2, it generally requires that <em>m.pyc</em> files be located where <em>m.py</em> files normally would be—via either moving and renaming from <code>__pycache__</code> or generating with the <code>legacy</code> option of Python’s <code>compileall</code> (<code>-b</code> in its command-line mode). For instance, the following makes <em>.pyc</em> files from all <em>.py</em> files in the current directory without requiring moves and renames:</p>
<pre data-type="programlisting">$ <code><strong>python3 -m compileall -b -l .</strong></code></pre>
<p>Running from just bytecode requires a compatible Python and doesn’t fully conceal your code, but is used by some tools to ship programs in standalone form when the hosting Python version can <a contenteditable="false" data-type="indexterm" data-primary="imports" data-secondary="modules" data-tertiary="bytecode" data-startref="pmdbycd" id="id3411"></a><a contenteditable="false" data-type="indexterm" data-primary="modules" data-secondary="importing" data-tertiary="bytecode" data-startref="mdmpby" id="id3412"></a>be included or ensured. See Python docs for more info, and the related solution in <a data-type="xref" class="select:nopage" href="app02.html#part_icomma_getting_started">“Part I, Getting Started”</a> in <a data-type="xref" href="app02.html#appendix_b_solutions_to_end_of_part_exe">Appendix B</a>.</p>
</div>
</div></section>
<section data-type="sect2" class="pagebreak-before" data-pdf-bookmark="Step 3: Run It"><div class="sect2" id="step_three_run_it">
<h2 class="less_space">Step 3: Run It</h2>
<p>After compiling or loading the module’s bytecode, the final step of an import operation executes the <a contenteditable="false" data-type="indexterm" data-primary="imports" data-secondary="modules" data-tertiary="bytecode execution" id="id3413"></a><a contenteditable="false" data-type="indexterm" data-primary="modules" data-secondary="importing" data-tertiary="bytecode execution" id="id3414"></a><a contenteditable="false" data-type="indexterm" data-primary="bytecode" data-secondary="executing" id="id3415"></a>bytecode. This effectively runs all the statements in the module’s file in turn, from top to bottom, and any assignments made to names during this step generate attributes of the resulting module object. This is how the tools defined by the module’s code are created. For instance, <code>def</code> statements in a file are run at import time to create functions and assign attributes within the module to those functions. The functions can then be called later in the program by the file’s importers.</p>
<p>Because this last import step actually runs the file’s code, if any top-level code in a module file does real work, you’ll see its results at import time. For example, top-level <code>print</code> statements in a module show output when the file is imported. Function <code>def</code> statements (and <code>class</code> statements up later in this book) simply define objects for later use.</p>
<p>As you can see, import operations involve quite a bit of work—they search for files, possibly run a compiler, and run Python code. Because of this, any given module is imported only <em>once</em> per process by default. Future imports skip all three import steps and reuse the already loaded module in memory, per the <code>sys.modules</code> check noted earlier. If you need to import a file again after it has already been loaded (for example, to support dynamic customizations), you can force the issue with an <code>importlib.reload</code> call—a tool we’ll study in the next chapter.</p>
<p>Bear in mind that this process is completely <em>automatic</em>—it’s a side effect of running programs—and most programmers probably won’t care about or even notice the mechanics, apart from faster startups due to skipped compile steps. One part of this process is likely to show up on your radar, though, per the next section’s elaboration.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="The Module Search Path"><div class="sect1" id="the_module_search_path">
<h1>The Module Search Path</h1>
<p>As mentioned earlier, the part of the import procedure that most programmers <em>will</em> need to care about is <a contenteditable="false" data-type="indexterm" data-primary="module search path" id="id3416"></a>usually the first “find it” part—locating the file to be imported. Because you may need to tell Python where to look to find files to import, you need to know how to tap into its <em>module search path</em> (the set of directories searched) in order to extend it. This section covers the components that make up the search path and describes how to mod it for folders of your own.</p>
<p>Special case: <em>built-in</em> modules like <code>sys</code>, coded in C and statically linked into Python<a contenteditable="false" data-type="indexterm" data-primary="built-in modules, module search path and" id="id3417"></a><a contenteditable="false" data-type="indexterm" data-primary="module search path" data-secondary="built-in modules" id="id3418"></a>, as well as <em>frozen</em> modules like <code>os</code>, optimized for faster startup as of Python 3.11, are always checked first before scanning the module search path and hence take precedence. Given that there are only a few standard-library modules in these categories, we can safely ignore them here and focus on the search used for the vast majority of modules you’ll import—including your own. If you’re curious, <code>sys.builtin_module_names</code> lists the items in the first of these extrasearch categories:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>sum(1 for m in sys.builtin_module_names if m[0] != '_')</strong>   </code>     <code><em># Count non _X</em></code>
11</pre>
<section data-type="sect2" data-pdf-bookmark="Search-Path Components"><div class="sect2" id="search_path_components">
<h2>Search-Path Components</h2>
<p>In many cases, you can rely on the automatic nature of the module search path and won’t need to configure this path at all. If you want to be able to import user-defined files across directory boundaries, though, you will need to customize this path. Roughly, Python’s module search path is composed of the concatenation of the following components, some of which are preset for you and some of which you can tailor to tell Python where to look:</p>
<ol class="pagebreak-before">
<li><p>The home directory of the program</p></li>
<li><p>Directories listed in <code>PYTHONPATH</code> (if set)</p></li>
<li><p>Standard-library directories and files</p></li>
<li><p>The <em>site-packages</em> directory of third-party extensions</p></li>
<li><p>The directories listed in any <em>.pth</em> files (if present)</p></li>
</ol>
<p>Ultimately, the concatenation of these five components initializes the built-in <code>sys.path</code>—a changeable list of directory-name strings that are searched from first to last for imported files (we’ll revisit this later in this section). The first, third, and fourth components of the search path are defined automatically. The <em>second</em> and <em>fifth</em> components, though, can be used to extend the path to include your own source code directories. Here’s a rundown on all five:</p>
<dl>
<dt>Home directory (automatic)</dt>
<dd><p>Python first looks for the imported <a contenteditable="false" data-type="indexterm" data-primary="module search path" data-secondary="home directory" id="id3419"></a><a contenteditable="false" data-type="indexterm" data-primary="directories" data-secondary="module search path" id="id3420"></a>file in the code’s “home” directory. The meaning of this entry depends on how you are running the code. When you’re running a <em>program</em>, this entry is the directory containing your program’s top-level script file. When you’re working <em>interactively</em> in a REPL, this entry is instead the directory in which you are currently working (which is why we’ve used this directory for imported files so far). Code run with Python’s <code>-c</code> and <code>-m</code> switches used in earlier chapters also uses the current working directory for the home component.</p>
<p>Because this directory is always searched first, if a program is located entirely in a <em>single</em> directory, all of its imports will work automatically with no path configuration required. On the other hand, because this directory is searched first, its files will also <em>override</em> modules of the same name in directories elsewhere on the path; be careful not to accidentally hide standard-library modules this way if you need them in your program, or use <em>package</em> tools you’ll meet later that can partially sidestep this issue with nested folders.</p>
<p>Also remember that this home directory pertains only to the search path used to resolve <em>imports</em>, and does not impact the current working directory used for relative <em>filenames</em> in your script. Pathless files created by a script will still show up where you are when you launch it (specifically, in the folder returned by <code>os.getcwd</code>), not in the script’s home folder at the front of the module search path. Module imports and file access are disjoint ideas.</p></dd>
<dt>Any <code>PYTHONPATH</code> directories (configurable)</dt>
<dd><p>Next, Python searches all <a contenteditable="false" data-type="indexterm" data-primary="module search path" data-secondary="PYTHONPATH directory" id="modpydr"></a><a contenteditable="false" data-type="indexterm" data-primary="directories" data-secondary="module search path" data-tertiary="PYTHONPATH" id="id3421"></a><a contenteditable="false" data-type="indexterm" data-primary="PYTHONPATH directory" id="id3422"></a>directories listed in your <code>PYTHONPATH</code> environment variable setting, from left to right (assuming you have set this at all: it’s not generally preset for you). In brief, <code>PYTHONPATH</code> is simply a list of user-defined and platform-specific names of directories that contain Python source code or bytecode files. You can add all the directories from which you wish to be able to import, and Python will extend the module search path to include all the directories your <span class="keep-together"><code>PYTHONPATH</code></span> lists. See <a data-type="xref" href="app01.html#appendix_a_platform_usage_tips">Appendix A</a> for tips on setting this variable.</p>
<p>Because Python searches the home directory first, this setting is only important when importing files <em>across</em> directory boundaries—that is, if you need to import a file that is stored in a <em>different</em> directory from the file that imports it. You may need to set your <code>PYTHONPATH</code> variable once you start writing substantial programs and tools, but when you’re first starting out, as long as you save all your module files in the directory in which you’re working (i.e., the home directory) your imports will work without needing to make this setting.</p></dd>
<dt>Standard-library directories (automatic)</dt>
<dd>Next, Python automatically searches <a contenteditable="false" data-type="indexterm" data-primary="module search path" data-secondary="standard-library directories" id="id3423"></a><a contenteditable="false" data-type="indexterm" data-primary="directories" data-secondary="module search path" data-tertiary="standard-library directories" id="id3424"></a><a contenteditable="false" data-type="indexterm" data-primary="standard library" data-secondary="directories, module search path" id="id3425"></a>the directories where the standard-library modules are installed on your machine. These include modules coded in Python, and others coded in C. Because these directories are always searched, they normally do not need to be added to your <code>PYTHONPATH</code> (or included in path files, ahead).</dd>
<dt>The standard-library <span class="plain">site-packages</span> directory of third-party extensions (automatic)</dt>
<dd>Next, Python automatically adds the <em>site-packages</em> subdirectory of its standard library to the module <a contenteditable="false" data-type="indexterm" data-primary="module search path" data-secondary="site-packages directory" id="id3426"></a><a contenteditable="false" data-type="indexterm" data-primary="directories" data-secondary="module search path" data-tertiary="site-packages" id="id3427"></a><a contenteditable="false" data-type="indexterm" data-primary="site-packages directory" id="id3428"></a>search path. By convention, this is the place where most third-party extensions are installed, often automatically by Python’s <code>pip</code> install tool. Because the <em>site-packages</em> install directory of such extensions is always part of the module search path, clients can import the modules of these extensions without any path settings.</dd>
<dt>Any <span class="plain">.pth</span> path-file directories (configurable)</dt>
<dd><p>Finally, a lesser-used feature of Python allows users to add directories to the module search path by <a contenteditable="false" data-type="indexterm" data-primary="module search path" data-secondary=".pth path-file directory" data-secondary-sortas="pth path-file directory" id="id3429"></a><a contenteditable="false" data-type="indexterm" data-primary="directories" data-secondary="module search path" data-tertiary=".pth path-file" id="id3430"></a>simply listing them, one per line, in a text file whose name ends with a <em>.pth</em> suffix (for “path”). These path-configuration files are a somewhat advanced installation-related feature; we won’t cover them fully here, but they provide an alternative to <code>PYTHONPATH</code> settings.</p>
<p>In short, text files of directory names dropped in an appropriate directory can serve roughly the same role as the <code>PYTHONPATH</code> environment variable setting. For instance, a file with <em>.pth</em> extension and any name may be placed in the <em>site-packages</em> subdirectory of the installed Python’s standard library to extend the module search path. To locate this subdirectory inspect <code>sys.path</code> for a path ending in <em>site-packages</em>, per its coverage ahead.</p>
<p>When such a file is present, Python will add the directories listed on each line of the file, from first to last, near the end of the module search path list—currently after the <em>site-packages</em> directory as described here. In fact, Python will collect the directory names in <em>all</em> the <em>.pth</em> path files it finds and filter out any duplicates and nonexistent entries. Because they are files rather than shell settings, path files can apply to all users of a given Python, instead of just one user or shell, and may be simpler to set up than environment variables in some contexts.</p>
<p>For more details on this feature, consult Python’s library manual, and especially its documentation for the standard-library module <code>site</code>—this module configures the locations of Python libraries and path files, and its documentation describes the expected locations of path files in general. When getting started, though, you may be better served by setting <code>PYTHONPATH</code>, and only if you must import across directories. Path files are used more often by third-party libraries installed in Python’s <em>site-packages</em>.</p></dd>
</dl>
<p>All that being said, Python’s import mechanism is wildly extensible, and even more convoluted than described here. For example, <code>PYTHONPATH</code> entries may also name <em>ZIP files</em> treated like read-only folders; <code>PYTHONHOME</code> can set standard-library locations; a file named with suffix <em>._pth</em> can fully override <code>sys.path</code> norms; “virtual environments” made with the module <code>venv</code> avoid package version clashes by localizing search paths to install folders; the relative-import “.” syntax of <a data-type="xref" href="ch24.html#module_packages">Chapter 24</a> constrains module search in packages; and all this has morphed regularly, and may again.</p>
<p>While this book covers common usage, its description is intentionally narrow for space, durability, and audience. You should consult Python’s manuals for more on the imports story if and when unique requirements arise.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Configuring the Search Path"><div class="sect2" id="configuring_the_search_path">
<h2>Configuring the Search Path</h2>
<p>The net effect of all of the foregoing is <a contenteditable="false" data-type="indexterm" data-primary="module search path" data-secondary="configuring" id="id3431"></a><a contenteditable="false" data-type="indexterm" data-primary="directories" data-secondary="module search path" data-tertiary="PYTHONPATH" id="id3432"></a><a contenteditable="false" data-type="indexterm" data-primary="PYTHONPATH directory" data-secondary="configuration search path" id="id3433"></a>that both the <code>PYTHONPATH</code> and path file components of the search path allow you to tailor the places where imports look for files. The way you set environment variables and where you store path files varies per platform. For instance, on macOS and Windows, you might set <code>PYTHONPATH</code> to a list of directories separated by colons and semicolons, respectively, like this:</p>
<pre data-type="programlisting">/Users/me/pycode/utilities:/Volumes/ssd/pycode/package1      <code><em># Unix paths list</em></code>
C:\Users\me\pycode\utilities;d:\pycode\package1              <code><em># Windows paths list</em></code></pre>
<p>On Unix systems (e.g., macOS, Linux, and Android), an <code>export</code> shell command sets environment variables for the shell and anything it runs, and can be coded in startup files like <em>~/.bash_profile</em> for permanence. The following on macOS sets the path to enable imports of modules from the code folders of Chapters <a data-xrefstyle="select:labelnumber" data-type="xref" href="ch21.html#the_benchmarking_interlude">21</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch20.html#comprehensions_and_generations">20</a> (“…” is snipped text):</p>
<pre data-type="programlisting">$ <code><strong>pwd</strong></code>
/Users/me/…/LP6E/Chapter22
$ <code><strong>export PYTHONPATH=/Users/me/…/LP6E/Chapter21:/Users/me/…/LP6E/Chapter20</strong></code>

$ <code><strong>python3</strong></code>
&gt;&gt;&gt; <code><strong>import pybench, permute</strong></code>
&gt;&gt;&gt; <code><strong>pybench</strong></code>
&lt;module 'pybench' from '/Users/me/…/LP6E/Chapter21/pybench.py'&gt;
&gt;&gt;&gt; <code><strong>permute</strong></code>
&lt;module 'permute' from '/Users/me/…/LP6E/Chapter20/permute.py'&gt;

&gt;&gt;&gt; <code><strong>permute.permute1([1, 2, 3, 4])</strong></code>
&gt;&gt;&gt; <code><strong>pybench.runner([(100, 5, '[x ** 2 for x in range(2 ** 16)]')])</strong></code></pre>
<p>Path syntax like “..” for parent folders also works on <code>PYTHONPATH</code> and is interpreted relative to the current working directory—which is not necessarily the home directory of launched programs, if their top-level scripts live elsewhere. Windows consoles use similar commands (e.g., replace <code>export</code> with <code>set</code>, or use <code>setx</code> for permanence), but Windows users generally set environment variables in <em>Settings</em>; search for the environment-variables GUI there.</p>
<p>Instead of—or in addition to—<code>PYTHONPATH</code>, you might create a text file in your Python install’s <span class="keep-together"><em>site-packages</em></span> folder named with a <em>.pth</em> extension (e.g., <em>mypath.pth</em>), which looks like this on macOS:</p>
<pre data-type="programlisting">/Users/me/pycode/utilities               <code><em># Unix .pth paths file</em></code>
/Volumes/ssd/pycode/package1             <code><em># One path per line</em></code></pre>
<p>These settings are analogous on all platforms, but the details vary too widely for fully inclusive coverage here. See <a data-type="xref" href="app01.html#appendix_a_platform_usage_tips">Appendix A</a> for pointers on extending your module search path with <code>PYTHONPATH</code> on various platforms.</p>
<p>To see how your Python configures the module search path on your platform, and to find the location <a contenteditable="false" data-type="indexterm" data-primary="module search path" data-secondary="PYTHONPATH directory" data-startref="modpydr" id="id3434"></a>of its <em>site-packages</em> folder which can host path files, you can always <a contenteditable="false" data-type="indexterm" data-primary="module search path" data-secondary="configuring" data-startref="mdschpfg" id="id3435"></a>inspect <code>sys.path</code>—the topic of the next section.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="The sys.path List"><div class="sect2" id="the_sysdotpath_list">
<h2>The sys.path List</h2>
<p>If you want to see how the module <a contenteditable="false" data-type="indexterm" data-primary="module search path" data-secondary="sys.path list" id="mdspsypt"></a>search path is truly configured on your machine, print the built-in <code>sys.path</code> list. This list of directory-name strings <em>is</em> the actual module search path within Python; on imports, Python searches each directory in this list from left to right and uses the first file match it finds.</p>
<section data-type="sect3" data-pdf-bookmark="Inspecting the module search path"><div class="sect3" id="inspecting_the_module_search_path">
<h3>Inspecting the module search path</h3>
<p>Python configures <code>sys.path</code> at program startup, merging the path components we met earlier. The result is a list of directories searched on each import of a new file. Python exposes this list for multiple reasons. For one thing, it provides a way to <em>verify</em> the search-path settings you’ve made—if you don’t see your settings somewhere in this list after restarting Python, you need to recheck your work. On macOS, for example, with these custom settings:</p>
<ul>
<li><p><code>PYTHONPATH</code> set to <code>/Users/me/pycode1:/Users/me/pycode2</code></p></li>
<li><p>A <em>mypath.pth</em> path file in the Python install’s <em>site-packages</em> that lists <code>/Users/me/pycode3</code></p></li>
</ul>
<p>The search path looks like this when inspected in a REPL or printed from a script:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>import sys</strong></code>
&gt;&gt;&gt; <code><strong>sys.path</strong></code>
['', '/Users/me/pycode1', '/Users/me/pycode2', 
'/Library/Frameworks/Python.framework/Versions/3.12/lib/python312.zip',
'/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12',
'/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/lib-dynload',
'/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages', 
'/Users/me/pycode3']</pre>
<p>The empty string at the front means the current directory, and the two custom settings are merged in per the order given earlier. The rest are standard-library folders and files, and the <em>site-packages</em> home for third-party extensions.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Changing the module search path"><div class="sect3" id="changing_the_module_search_path">
<h3>Changing the module search path</h3>
<p>The <code>sys.path</code> list also provides a way for scripts to <em>tailor</em> their search paths manually at runtime. By modifying the program-wide <code>sys.path</code> list, you modify the search path for all future imports made anywhere in a program’s run. Such changes last only for the duration of the single run, however; <span class="keep-together"><code>PYTHONPATH</code></span> and <em>.pth</em> files offer more permanent ways to modify the path—the first per user, and the second per installed Python.</p>
<p>On the other hand, some programs really <em>do</em> need to change <code>sys.path</code>. Scripts that run on web servers, for example, often run as the user “nobody” to limit machine access. Because such scripts cannot usually depend on “nobody” to have set <code>PYTHONPATH</code> in any particular way (grammatically incorrect but true), they sometimes set <code>sys.path</code> manually to include required source directories, prior to running import statements. A <code>sys.path.append</code>, <code>sys.path.insert</code>, or other list operation will often suffice, though will endure for a single program run only:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>sys.path.append('/Users/me/pycode4')</strong></code>    <code><em># Extend search path for this run</em></code>
&gt;&gt;&gt; <code><strong>import <em>module</em></strong></code>                           <code><em># All imports search the new dir last</em></code></pre>
<p>You can mod <code>sys.path</code> arbitrarily in code to influence future imports, and this also works in a REPL. Bear in mind, though, that deleting folders may remove access to important tools, and your changes will be discarded when the program or REPL ends. To make <a contenteditable="false" data-type="indexterm" data-primary="module search path" data-secondary="sys.path list" data-startref="mdspsypt" id="id3436"></a>path changes span scripts and sessions, use other techniques instead.</p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Module File Selection"><div class="sect2" id="module_file_selection">
<h2>Module File Selection</h2>
<p>Besides folders, file <em>types</em> also factor <a contenteditable="false" data-type="indexterm" data-primary="module search path" data-secondary="file selection" id="mdspsfsl"></a>into imports. As noted earlier, filename extensions (e.g., <em>.py</em>) are omitted from import statements by design: Python chooses the first file it can find on the search path that matches the imported name. This need not, however, be a <em>.py</em> source code file or a <em>.pyc</em> bytecode file, as the next section explains.</p>
<section data-type="sect3" data-pdf-bookmark="Module sources"><div class="sect3" id="module_sources">
<h3>Module sources</h3>
<p>Really, imports are the point <a contenteditable="false" data-type="indexterm" data-primary="module search path" data-secondary="file sources" id="id3437"></a>of interface to a host of <em>external components</em>—source code, bytecode, compiled extensions, ZIP files, Java classes, and more. Python automatically selects any type that matches a module’s name. For example, an <code>import</code> statement of the form <code>import b</code> might today load or resolve to any of the following:</p>
<ul>
<li><p>A <em>source code</em> file named <em>b.py</em></p></li>
<li><p>A <em>bytecode</em> file in <em>__pycache__</em> named <em>b.cpython-312.pyc</em> or similar</p></li>
<li><p>A <em>bytecode</em> file named <em>b.pyc</em> if no <em>b.py</em> source code file was located</p></li>
<li><p>A <em>directory</em> named <em>b</em>, for package imports described in <a data-type="xref" href="ch24.html#module_packages">Chapter 24</a></p></li>
<li><p>A compiled <em>built-in</em> module, coded in C and statically linked into Python when it is built</p></li>
<li><p>A compiled <em>extension</em> module (e.g., <em>b.so</em> or <em>b.pyd</em>) coded in C and dynamically linked on import</p></li>
<li><p>A source or bytecode file embedded in a <em>ZIP file</em>, automatically extracted when imported</p></li>
<li><p>An <em>in-memory</em> image’s module, for frozen (standalone) executables</p></li>
<li><p>A <em>Java</em> class, in the Jython version of Python</p></li>
<li><p>A <em>.NET</em> component, in the IronPython version of Python</p></li>
</ul>
<p>Most of the items on this list extend imports beyond simple files. To importers, though, differences in the loaded file type are completely irrelevant, both when importing and when fetching module attributes. Saying <code>import b</code> gets whatever module <code>b</code> is, according to your module search path, and <code>b.<em>attr</em></code> fetches an item in the module, be it a Python variable or a linked-in C function. Some standard-library modules used in this book, for example, are actually coded in C, not Python; because they look just like Python-coded module files, their clients don’t have to care.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Selection priorities"><div class="sect3" id="selection_priorities">
<h3>Selection priorities</h3>
<p>Given all the options listed in the prior section, there is a potential for conflicts. Python will always load the item with a matching name found in the first (leftmost) directory of your module search path, during the left-to-right scan of <code>sys.path</code>. But what happens if it finds multiple matching items in the <em>same</em> directory? In this case, Python follows a standard picking order, though this order is not guaranteed to stay the same over time or across implementations.</p>
<p>In general, you should not depend on which type of file Python will choose within a given directory—make your module names distinct, or configure your module search path to make your module-selection preferences <a contenteditable="false" data-type="indexterm" data-primary="module search path" data-secondary="file selection" data-startref="mdspsfsl" id="id3438"></a>explicit.</p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Path Outliers: Standalones and Packages"><div class="sect2" id="path_outliers_standalones_and_packages">
<h2>Path Outliers: Standalones and Packages</h2>
<p>Finally, while all of the foregoing reflects <a contenteditable="false" data-type="indexterm" data-primary="module search path" data-secondary="standalones" id="id3439"></a><a contenteditable="false" data-type="indexterm" data-primary="module search path" data-secondary="packages" id="id3440"></a>normal module usage, some tools bend the rules enough to merit a word in closing. For instance, module search paths are not relevant when you run <em>standalone executables</em> discussed in <a data-type="xref" href="ch02.html#how_python_runs_programs">Chapter 2</a>, which typically embed bytecode within their runnable files, and run without path settings. This is a delivery option outside the scope of this book, but see <a data-type="xref" href="app01.html#appendix_a_platform_usage_tips">Appendix A</a> for another overview of options in this domain.</p>
<p>In addition, while it’s syntactically illegal to include path and extension details in a standard import, <em>package imports</em>, covered in <a data-type="xref" href="ch24.html#module_packages">Chapter 24</a>, allow import statements to include <em>part</em> of the directory path leading to a file as a set of period-separated names. Even so, package imports still rely on the normal module search path to locate the <em>leftmost</em> directory in a package path (they are relative to a directory in the search path), and cannot make use of any platform-specific <em>path syntax</em> in the import statements (such syntax works only on the search path). As hinted earlier, packages can also use “.” syntax to restrict import searches—but we’ll save this story for <a data-type="xref" href="ch24.html#module_packages">Chapter 24</a>.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Chapter Summary"><div class="sect1" id="chapter_summary-id00033">
<h1>Chapter Summary</h1>
<p>In this chapter, we covered the basics of modules and explored the operation of <code>import</code> statements. We learned that imports find the designated file on the module search path, compile it to bytecode, and execute all of its statements to generate its contents. We also learned how to configure the search path to be able to import from directories other than the home and standard-library directories, primarily with <code>PYTHONPATH</code> settings.</p>
<p>As this chapter also discussed, the import operation and modules are at the heart of program architecture in Python. Larger programs are divided into multiple files, which are linked together at runtime by imports. Imports in turn use the module search path to locate files, and modules define attributes for external use. The net effect divides a program’s logic into reusable and self-contained software <span class="keep-together">components</span>.</p>
<p>You’ll see what this all means in terms of actual statements and code in the next chapter. Before we move on, though, let’s run through the usual chapter quiz.</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Test Your Knowledge: Quiz"><div class="sect1" id="test_your_knowledge_quiz-id000165">
<h1>Test Your Knowledge: Quiz</h1>
<ol>
<li><p>How does a module source code file become a module object?</p></li>
<li><p>Why might you have to set your <code>PYTHONPATH</code> environment variable?</p></li>
<li><p>Name the five major components of the module search path.</p></li>
<li><p>Name four file types that Python might load in response to an import operation.</p></li>
<li><p>What is a module namespace, and what does a module’s namespace contain?</p></li>
</ol>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Test Your Knowledge: Answers"><div class="sect1" id="test_your_knowledge_answers-id000164">
<h1>Test Your Knowledge: Answers</h1>
<ol>
<li><p>A module’s source code file automatically becomes a module object when that module is imported. Technically, the module’s source code is run during the import, one statement at a time, and all the names assigned in the process become attributes of the generated module object.</p></li>
<li><p>You need to set <code>PYTHONPATH</code> only to import from directories other than Python’s standard library and the “home” directory—the current directory when working interactively, or the directory containing your program’s top-level file. In practice, this might be required for nontrivial programs that use libraries of tools.</p></li>
<li><p>The five major components of the module search path are the top-level script’s home directory (the directory containing it), all directories listed in the <code>PYTHONPATH</code> environment variable, the standard-library directories, the <em>site-packages</em> root directory for third-party extension installs, and all directories listed in <em>.pth</em> path files located in standard places. Of these, programmers can customize <code>PYTHONPATH</code> and <em>.pth</em> files.</p></li>
<li><p>Python might load a source code (<em>.py</em>) file, a bytecode (<em>.pyc</em>) file, a C extension module, or a directory of the same name for package imports. Imports may also load more exotic things such as ZIP file components, Java classes under the Jython version of Python, .NET components under IronPython, and statically linked C modules that have no files present at all. In fact, with import extensions, imports can load nearly arbitrary items.</p></li>
<li><p>A module namespace is a self-contained package of variables, which are known as the <em>attributes</em> of the module object. A module’s namespace contains all the names assigned by code at the top level of the module file (i.e., not nested in <code>def</code> or <code>class</code> statements). A module’s global scope <em>morphs</em> into the module object’s attributes namespace. A module’s namespace may also be altered by assignments from other files that import it, though this is generally frowned upon (see <a data-type="xref" href="ch17.html#scopes">Chapter 17</a> for more on the downsides of cross-file changes).</p></li>
</ol>
</div></section>
</div></section></div>
</div>
</body>
</html>