<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xml:lang="en"
lang="en"
xmlns="http://www.w3.org/1999/xhtml"
xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<title>Learning Python, 6th Edition</title>
<link rel="stylesheet" type="text/css" href="override_v1.css"/>
<link rel="stylesheet" type="text/css" href="epub.css"/>
</head>
<body>
<div id="book-content">
<div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 35. Exception Objects"><div class="chapter" id="exception_objects">
<h1><span class="label">Chapter 35. </span>Exception Objects</h1>
<p>So far, this book has been somewhat vague about what an exception actually <em>is</em>. This chapter clears up the mystery by disclosing the facts behind exception objects—both built-in and user-defined. As suggested in the preceding chapters, exceptions are identified by <em>class instance objects</em>. This is what is raised and propagated along by exception <a contenteditable="false" data-type="indexterm" data-primary="exceptions" data-secondary="class instance objects" id="id4435"></a>processing, and the source of the class matched against <code>except</code> clauses in <code>try</code> statements.</p>
<p>Although this means you must use object-oriented programming to define new exceptions in your programs—and introduces a knowledge dependency lamented in the prior chapter’s note—basing exceptions on classes and OOP offers a number of benefits. Among them, class-based exceptions support:</p>
<dl>
<dt>Flexible exception categories</dt><dd><p>Exception classes allow code to choose specificity and ease <a contenteditable="false" data-type="indexterm" data-primary="exception classes" id="id4436"></a><a contenteditable="false" data-type="indexterm" data-primary="classes" data-secondary="exception classes" id="id4437"></a>future changes. Adding new exception subclasses, for example, need not require changes in <code>try</code> statements.</p></dd>
<dt>State information and behavior</dt><dd><p>Exception classes provide a natural place <a contenteditable="false" data-type="indexterm" data-primary="state" data-secondary="exception classes" id="id4438"></a><a contenteditable="false" data-type="indexterm" data-primary="exception classes" data-secondary="state and" id="id4439"></a>to store context for use in the <code>try</code> handler. Both attributes and methods, for example, are available on the raised instance.</p></dd>
<dt>Reuse by inheritance</dt><dd><p>Exceptions classes <a contenteditable="false" data-type="indexterm" data-primary="code reuse" data-secondary="exceptions" id="id4440"></a><a contenteditable="false" data-type="indexterm" data-primary="exceptions" data-secondary="code reuse" id="id4441"></a>can participate in inheritance hierarchies to obtain and customize common behavior. Inherited error displays, for example, can provide a common look and feel.</p></dd>
</dl>
<p>Because of these advantages, class-based exceptions support program evolution and larger systems well. As you’ll learn here, all built-in exceptions are identified by classes and are organized into an inheritance tree for the reasons just listed. You can do the same with user-defined exceptions of your own.</p>
<p>In fact, the built-in exceptions we’ll study here turn out to be integral to new exceptions you define. Because Python largely requires user-defined exceptions to inherit from built-in exception classes that provide useful defaults for printing and state, the task of coding user-defined exceptions also involves understanding the roles of these built-ins.</p>
<section data-type="sect1" class="pagebreak-before" data-pdf-bookmark="Exception Classes"><div class="sect1" id="exception_classes">
<h1 class="less_space">Exception Classes</h1>
<p>Whether built-in or user-defined, exceptions work much of their magic by <em>superclass relationships</em>: a raised <a contenteditable="false" data-type="indexterm" data-primary="exceptions" data-secondary="superclasses" id="id4442"></a><a contenteditable="false" data-type="indexterm" data-primary="superclasses" data-secondary="exceptions" id="id4443"></a>exception matches an <code>except</code> clause if that clause names the exception’s class or any superclass of it. Put another way, a <code>try</code> statement’s <code>except</code> matches both the class it lists, as well as all of that class’s subclasses lower in the class tree.</p>
<p>The net effect is that class exceptions naturally <a contenteditable="false" data-type="indexterm" data-primary="exceptions" data-secondary="hierarchies" id="id4444"></a><a contenteditable="false" data-type="indexterm" data-primary="exception classes" data-secondary="hierarchies" id="id4445"></a>support the construction of exception <em>hierarchies</em>: superclasses become <em>category</em> names, and subclasses become <em>specific</em> kinds of exceptions within a category. By naming a general exception superclass, an <code>except</code> clause can catch an entire category of exceptions—any more specific subclass will match.</p>
<p>In addition to this category idea, class-based exceptions support exception state information and allow exceptions to inherit common behaviors, as noted. To see how all these assets come together in code, let’s turn to an example.</p>
<section data-type="sect2" data-pdf-bookmark="Coding Exceptions Classes"><div class="sect2" id="coding_exceptions_classes">
<h2>Coding Exceptions Classes</h2>
<p>In the file listed in <a data-type="xref" href="#example_threefive_onedot_categoricdotpy">Example 35-1</a>, <em>categoric.py</em>, we define a superclass called <code>General</code> and two subclasses called <code>Specific1</code> and <code>Specific2</code>. This example illustrates the notion of exception categories—<code>General</code> is a category name, and its two subclasses are specific types of exceptions within the category. Handlers that catch <code>General</code> will also catch any subclasses of it, including <code>Specific1</code> and <code>Specific2</code>.</p>
<div data-type="example" id="example_threefive_onedot_categoricdotpy">
<h5><span class="label">Example 35-1. </span>categoric.py</h5>
<pre data-type="programlisting">class General(Exception): pass
class Specific1(General): pass
class Specific2(General): pass

def raiser0():
    X = General()            <code><em># Raise superclass instance</em></code>
    raise X

def raiser1():
    X = Specific1()          <code><em># Raise subclass instance</em></code>
    raise X

def raiser2():
    X = Specific2()          <code><em># Raise different subclass instance</em></code>
    raise X

for func in (raiser0, raiser1, raiser2):
    try:
        func()
    except General:          <code><em># Match General or any subclass of it</em></code>
        import sys
        print('caught:', sys.exc_info()[0])</pre>
</div>
<p>When this example runs, its <code>try</code> statement catches and reports instances of all three of its classes because the  <code>except</code> clause names their common superclass:</p>
<pre data-type="programlisting">$ <code><strong>python3 categoric.py</strong></code>
caught: &lt;class '__main__.General'&gt;
caught: &lt;class '__main__.Specific1'&gt;
caught: &lt;class '__main__.Specific2'&gt;</pre>
<p>This code is mostly straightforward, but here are a few points to notice:</p>
<dl>
<dt>Exception superclass</dt>
<dd>Classes used to build exception category <a contenteditable="false" data-type="indexterm" data-primary="exception superclass" id="id4446"></a><a contenteditable="false" data-type="indexterm" data-primary="superclasses" data-secondary="exception superclass" id="id4447"></a><a contenteditable="false" data-type="indexterm" data-primary="exception classes" data-secondary="superclasses" id="id4448"></a>trees have very few requirements—in fact, in this example, they are mostly empty, with bodies that do nothing but <code>pass</code>. Notice, though, how the top-level class here inherits from the built-in <code>Exception</code> class. This is required: classes that don’t inherit from a built-in exception class won’t work in most exception contexts. The built-in superclass is normally <code>Exception</code>, the root for nonexit exceptions, but may also be <code>BaseException</code>, the root for all exceptions, or other. Although we don’t employ it here, <code>Exception</code> provides behavior you’ll meet later that makes inheriting from it useful, required or not.</dd>
<dt>Raising instances</dt>
<dd>In this code, we call classes <a contenteditable="false" data-type="indexterm" data-primary="exception classes" data-secondary="raising instances" id="id4449"></a>to make <em>instances</em> for the <code>raise</code> statements (notice the parentheses). In the class exception model, we always raise and catch a class instance object. If we list a class name without parentheses in a <code>raise</code>, Python makes an instance for us by calling the class with no constructor arguments. Exception instances can be created before the <code>raise</code>, as done here, or within the <code>raise</code> statement itself.</dd>
<dt>Catching categories</dt>
<dd>This code includes functions <a contenteditable="false" data-type="indexterm" data-primary="exception classes" data-secondary="categories, catching" id="id4450"></a>that raise instances of all three of our classes as exceptions, as well as a top-level <code>try</code> that calls the functions and catches <code>General</code> exceptions. The same <code>try</code> also catches the two specific exceptions because they are subclasses of <code>General</code>—that is, members of its category.</dd>
<dt>Exception details</dt>
<dd>The exception handler here <a contenteditable="false" data-type="indexterm" data-primary="exception classes" data-secondary="exception details" id="id4451"></a>uses the <code>sys.exc_info</code> call, which is one way to fetch the exception being handled in a generic fashion. As you’ll see in more detail in the next chapter, the first item in this call’s result tuple is the class of the exception raised, and the second is the actual instance raised. In a general <code>except</code> clause like the one here that catches all classes in a category, <code>sys.exc_info</code> can be used to determine exactly what has occurred.</dd>
</dl>
<p>The last point merits elaboration. When an exception is caught, we can be sure that the instance raised is an instance of the class listed in the <code>except</code> or one of its subclasses. Because of that, the specific kind of exception raised can also be had via the <code>type</code> result or <code>__class__</code> attribute of the instance, regardless of how the instance is obtained.</p>
<p>To demo, the variant in <a data-type="xref" href="#example_threefive_twodot_categorictwodo">Example 35-2</a> works the same as the prior example but uses the <code>as</code> extension in its <code>except</code> clause to directly assign a variable to the instance raised, from which <code>type</code> yields the exception’s kind.</p>
<div data-type="example" id="example_threefive_twodot_categorictwodo">
<h5><span class="label">Example 35-2. </span>categoric2.py</h5>
<pre data-type="programlisting">class General(Exception): pass
class Specific1(General): pass
class Specific2(General): pass

def raiser0(): raise General()
def raiser1(): raise Specific1()
def raiser2(): raise Specific2()

for func in (raiser0, raiser1, raiser2):
    try:
        func()
    except General as X:                 <code><em># X is the raised instance</em></code>
        print('caught:', type(X))        <code><em># Same as sys.exc_info()[0], X.__class__</em></code></pre>
</div>
<p>Because the <code>except</code>’s <code>as</code> can be used to access the exception directly this way, <code>sys.exc_info</code> is more useful for <em>empty</em> <code>except</code> clauses that do not otherwise have a way to access the instance or its class. More importantly, well-designed programs usually should <em>not have to care</em> about which specific exception was raised at all—calling methods of the exception instance should automatically dispatch to behavior tailored for the exception raised.</p>
<p>There’s more on this and <code>sys.exc_info</code> and its ilk in the next chapter. Also, see <a data-type="xref" href="ch29.html#class_coding_details">Chapter 29</a> and <a data-type="xref" href="part06.html#classes_and_oop">Part VI</a> at large if you’ve forgotten what <code>__class__</code> means in an instance, and the prior chapter for a review of the <code>as</code> used here.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Why Exception Hierarchies?"><div class="sect2" id="why_exception_hierarchiesquestion_mark">
<h2>Why Exception Hierarchies?</h2>
<p>Because there are only three possible exceptions in the prior section’s examples, it doesn’t really do justice <a contenteditable="false" data-type="indexterm" data-primary="exceptions" data-secondary="hierarchies" id="xcprrchh"></a><a contenteditable="false" data-type="indexterm" data-primary="exception classes" data-secondary="hierarchies" id="xcpxchrr"></a>to the utility of class exceptions. In principle, we could achieve the same effects by coding a list of exception names in a parenthesized tuple within the <code>except</code> clause:</p>
<pre data-type="programlisting">try:
    func()
except (General, Specific1, Specific2):     <code><em># Catch any of these</em></code>
    …</pre>
<p>This approach may work for smaller, self-contained code. For large or high exception hierarchies, however, it will probably be easier to catch categories using class-based categories than to list every member of a category in a single <code>except</code> clause. Perhaps more importantly, you can extend exception hierarchies as software needs evolve by adding new subclasses without breaking existing handler code.</p>
<p>Suppose, for example, you code a numeric programming library in Python to be used by a large number of people. While you are writing your library, you identify two things that can go wrong with numbers in your code—division by zero and numeric overflow. You document these as the two standalone exceptions that your library may raise:</p>
<pre data-type="programlisting"><code><em># mathlib.py</em></code>
class Divzero(Exception): pass
class Oflow(Exception): pass

def func():
    …
    raise Divzero()
…<code><em>and so on</em></code>…</pre>
<p>Now, when people use your library, they typically wrap calls to your functions or classes in <code>try</code> statements that catch your two exceptions; after all, if they do not catch your exceptions, exceptions from your library will kill their code:</p>
<pre data-type="programlisting"><code><em># client.py</em></code>
import mathlib

try:
    mathlib.func()
except (mathlib.Divzero, mathlib.Oflow):
    …<code><em>handle and recover</em></code>…</pre>
<p>This works fine, and lots of people start using your library. Six months down the road, though, you revise it (as programmers are prone to do). Along the way, you identify a new thing that can go <span class="keep-together">wrong—underflow</span>, perhaps—and add that as a new exception:</p>
<pre data-type="programlisting"><code><em># mathlib.py</em></code>
class Divzero(Exception): pass
class Oflow(Exception): pass
<code><strong>class Uflow(Exception): pass</strong></code></pre>
<p>Unfortunately, when you re-release your code, you create a maintenance problem for your users. If they’ve listed your exceptions explicitly, they now have to go back and change every place they call your library to include the newly added exception name:</p>
<pre data-type="programlisting"><code><em># client.py</em></code>
try:
    mathlib.func()
except (mathlib.Divzero, mathlib.Oflow, <code><strong>mathlib.Uflow</strong></code>):
    …<code><em>handle and recover</em></code>…</pre>
<p>This may not be the end of the world. If your library is used only in-house, you can make the changes yourself. You might also ship a Python script that tries to fix such code automatically (it would probably be only a few dozen lines, and it would guess right at least some of the time). If many people have to change all their <code>try</code> statements each time you alter your exception set, though, this is not exactly the politest of upgrade policies.</p>
<p>Your users might try to avoid this pitfall by coding empty <code>except</code> clauses to catch <em>all</em> possible <span class="keep-together">exceptions</span>:</p>
<pre data-type="programlisting"><code><em># client.py</em></code>
try:
    mathlib.func()
<code><strong>except:</strong></code>                            <code><em># Catch everything here (or catch Exception)</em></code>
    …<code><em>handle and recover</em></code>…</pre>
<p>But as noted in the prior chapter, this workaround might catch more than they bargained for—things like running out of memory, keyboard interrupts (Ctrl+C), system exits, and even typos in their own <code>try</code> block’s code will all trigger exceptions, and such things should pass, not be caught and erroneously classified as library errors. Catching the <code>Exception</code> superclass improves on this but still intercepts—and thus may mask—program errors.</p>
<p>And really, in this scenario, users want to catch and recover from <em>only</em> the specific exceptions the library is defined and documented to raise. If any other exception occurs during a library call, it’s likely a genuine bug in the library (and it’s probably time to contact the vendor). As a rule of thumb, it’s usually better to be specific than general in exception handlers—an idea we’ll revisit as a “gotcha” in the next chapter.</p>
<p>So what to do, then? In principle again, the library module could provide a tuple object that contains all the exceptions it can possibly raise. The client could then import the tuple and name it in an <code>except</code> clause to catch all the library’s exceptions (recall that using a tuple catches any of its exceptions). This would work and support mods, but you’d need to keep the tuple up-to-date with library exceptions, and that’s both error-prone and tedious.</p>
<p>Class exception hierarchies solve this dilemma better. Rather than defining your library’s exceptions as a set of autonomous classes, arrange them into a class tree with a common superclass to encompass the entire category:</p>
<pre data-type="programlisting" class="pagebreak-before"><code><em># mathlib.py</em></code>
<code><strong>class NumErr(Exception): pass</strong></code>
class Divzero(<code><strong>NumErr</strong></code>): pass
class Oflow(<code><strong>NumErr</strong></code>): pass

def func():
    …
    raise DivZero()
…<code><em>and so on</em></code>…</pre>
<p>This way, users of your library simply need to list the common superclass (i.e., <em>category</em>) to catch all of your library’s exceptions—both now and in the future:</p>
<pre data-type="programlisting"><code><em># client.py</em></code>
import mathlib

try:
    mathlib.func()
except mathlib.<code><strong>NumErr</strong></code>:
    …<code><em>handle and recover</em></code>…</pre>
<p>When you go back and hack (update) your code again now, you can add new exceptions as new <em>subclasses</em> of the common superclass:</p>
<pre data-type="programlisting"><code><em># mathlib.py</em></code>
…
<code><strong>class Uflow(NumErr): pass</strong></code></pre>
<p>The end result is that user code that catches your library’s exceptions will keep working, <em>unchanged</em>. In fact, you are free to add, delete, and change exceptions arbitrarily in the future—as long as clients name the superclass, and that superclass remains intact, they are insulated from changes in your exceptions set. In other words, class exceptions provide a better answer to maintenance issues than other solutions can.</p>
<p>Class-based exception hierarchies also support state retention and inheritance in ways that make them ideal in <a contenteditable="false" data-type="indexterm" data-primary="exceptions" data-secondary="hierarchies" data-startref="xcprrchh" id="id4452"></a><a contenteditable="false" data-type="indexterm" data-primary="exception classes" data-secondary="hierarchies" data-startref="xcpxchrr" id="id4453"></a>larger programs. To understand these roles, though, we first need to see how user-defined exception classes relate to the built-in exceptions from which they inherit.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Built-in Exception Classes"><div class="sect1" id="built_in_exception_classes">
<h1>Built-in Exception Classes</h1>
<p>The prior section’s example wasn’t really pulled out of thin air. All built-in exceptions that Python itself may raise <a contenteditable="false" data-type="indexterm" data-primary="exception classes" data-secondary="built-in" id="id4454"></a><a contenteditable="false" data-type="indexterm" data-primary="built-in exception classes" id="id4455"></a>are predefined class objects. Moreover, they are organized into a shallow hierarchy with general superclass categories and specific subclass types, much like the prior section’s final exceptions class tree.</p>
<p>All the familiar exceptions you’ve seen (e.g., <code>SyntaxError</code>) are really just predefined classes, available as built-in names in the module named <code>builtins</code>. In addition, Python organizes the built-in exceptions into a hierarchy to support a variety of catching modes. For example:</p>
<dl>
<dt><code>BaseException</code>: topmost root, with printing and constructor defaults</dt>
<dd>The top-level root superclass of exceptions. This <a contenteditable="false" data-type="indexterm" data-primary="exception classes" data-secondary="built-in" data-tertiary="BaseException" id="id4456"></a><a contenteditable="false" data-type="indexterm" data-primary="built-in exception classes" data-secondary="BaseException" id="id4457"></a><a contenteditable="false" data-type="indexterm" data-primary="BaseException exception class" id="id4458"></a>class is not supposed to be directly inherited by user-defined classes (use <code>Exception</code> instead). It provides default printing and state retention behavior inherited by subclasses. If the <code>str</code> built-in is called on an instance of this class (e.g., by <code>print</code>), the class returns the display strings of the constructor arguments passed when the instance was created (or an empty string if there were no arguments). In addition, unless subclasses replace this class’s constructor, all of the arguments passed to this class at instance construction time are stored in its <code>args</code> attribute as a tuple.</dd>
<dt><code>Exception</code>: root of user-defined exceptions</dt>
<dd>The top-level root superclass of <a contenteditable="false" data-type="indexterm" data-primary="exception classes" data-secondary="built-in" data-tertiary="Exception" id="id4459"></a><a contenteditable="false" data-type="indexterm" data-primary="built-in exception classes" data-secondary="Exception" id="id4460"></a><a contenteditable="false" data-type="indexterm" data-primary="exception classes" data-secondary="Exception" id="id4461"></a>application-related exceptions. This is an immediate subclass of <code>BaseException</code> and is a superclass to every other built-in exception, except the system exit event classes (<code>SystemExit</code>, <code>KeyboardInterrupt</code>, and <code>GeneratorExit</code>) and an exception-group class we’ll ignore here. Nearly all user-defined classes should inherit from this class, not <code>BaseException</code>. When this convention is followed, naming <code>Exception</code> in a <code>try</code> statement’s handler ensures that your program will catch everything but system exit events, which should normally be allowed to pass. In effect, <code>Exception</code> becomes a catchall in <code>try</code> statements but is more accurate than an empty <code>except</code>.</dd>
<dt><code>ArithmeticError</code>: root of numeric errors<a contenteditable="false" data-type="indexterm" data-primary="exception classes" data-secondary="built-in" data-tertiary="ArithmeticError" id="id4462"></a><a contenteditable="false" data-type="indexterm" data-primary="built-in exception classes" data-secondary="ArithmeticError" id="id4463"></a><a contenteditable="false" data-type="indexterm" data-primary="ArithmeticError exception class" id="id4464"></a></dt>
<dd>A subclass of <code>Exception</code>, and the superclass of all numeric errors. Its subclasses identify specific numeric errors: <code>OverflowError</code>, <code>ZeroDivisionError</code>, and <code>FloatingPointError</code>.</dd>
<dt><code>LookupError</code>: root of <a contenteditable="false" data-type="indexterm" data-primary="exception classes" data-secondary="built-in" data-tertiary="LookupError" id="id4465"></a><a contenteditable="false" data-type="indexterm" data-primary="built-in exception classes" data-secondary="LookupError" id="id4466"></a><a contenteditable="false" data-type="indexterm" data-primary="LookupError exception class" id="id4467"></a>indexing errors</dt>
<dd>A subclass of <code>Exception</code>, and the superclass category for indexing errors for both sequences and mappings: <code>IndexError</code> and <code>KeyError</code>.</dd>
<dt><code>OSError</code>: root of IO and <a contenteditable="false" data-type="indexterm" data-primary="exception classes" data-secondary="built-in" data-tertiary="OSError" id="id4468"></a><a contenteditable="false" data-type="indexterm" data-primary="built-in exception classes" data-secondary="OSError" id="id4469"></a><a contenteditable="false" data-type="indexterm" data-primary="OSError exception class" id="id4470"></a>other system-function errors, with details</dt>
<dd>A subclass of <code>Exception</code>, with attributes for error details (e.g., <code>errno</code>, <code>strerror</code>, and <code>filename</code>), and subclasses for specific errors: <code>FileNotFoundError</code>, <code>PermissionError</code>, <code>TimeoutError</code>, and more.</dd>
</dl>
<p>And so on—because the built-in exception set is prone to frequent changes, this book doesn’t document it exhaustively. You can read further about its contents and structure in the Python library manual.</p>
<section data-type="sect2" data-pdf-bookmark="Built-in Exception Categories"><div class="sect2" id="built_in_exception_categories">
<h2>Built-in Exception Categories</h2>
<p>The built-in class tree <a contenteditable="false" data-type="indexterm" data-primary="exceptions" data-secondary="categories" id="id4471"></a>allows you to choose how specific or general your handlers will be. For example, because the built-in exception <code>ArithmeticError</code> is a superclass for more specific exceptions such as <code>OverflowError</code> and <code>ZeroDivisionError</code>:</p>
<ul>
<li><p>By listing <code>ArithmeticError</code> in a <code>try</code>, you will catch <em>any</em> kind of numeric error raised.</p></li>
<li><p>By listing <code>ZeroDivisionError</code>, you will intercept <em>just</em> that specific type of error and no others.</p></li>
</ul>
<p>Similarly, because <code>Exception</code> is the superclass of all application-level exceptions, you can generally use it as a <em>catchall</em>—as outlined in the prior chapter, the effect is much like an empty <code>except</code>, but it allows system exit exceptions to pass and propagate as they usually should:</p>
<pre data-type="programlisting">try:
    …
except Exception:                               <code><em># Exits not caught here</em></code>
    …<code><em>handle all application exceptions</em></code>…
else:
    …<code><em>handle no-exception case</em></code>…</pre>
<p>This technique is reliable because Python requires all classes to derive from built-in exceptions. Still, this scheme suffers most of the same potential pitfalls as the empty <code>except</code>, as described in the prior chapter—it might intercept exceptions intended for elsewhere, and it might mask genuine <span class="keep-together">programming</span> errors. Since this is such a common issue, we’ll revisit it one more time as a “gotcha” in the next chapter.</p>
<p>Whether or not you will leverage the categories in the built-in class tree, it serves as a good example. By using similar techniques for class exceptions in your own code, you can provide exception sets that are flexible and easily modified.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Default Printing and State"><div class="sect2" id="default_printing_and_state">
<h2>Default Printing and State</h2>
<p>Built-in exceptions also provide <a contenteditable="false" data-type="indexterm" data-primary="exceptions" data-secondary="built-in" data-tertiary="default printing" id="xpbdfp"></a><a contenteditable="false" data-type="indexterm" data-primary="printing" data-secondary="exceptions, built-in" id="pxpblt"></a><a contenteditable="false" data-type="indexterm" data-primary="state" data-secondary="exceptions, built-in" id="sttxpbl"></a><a contenteditable="false" data-type="indexterm" data-primary="exceptions" data-secondary="built-in" data-tertiary="state" id="xpcblstt"></a>default print displays and state retention, which is often as much logic as user-defined classes require. Unless you redefine the constructors your classes inherit from built-ins, any constructor arguments you pass to these classes are automatically saved in the instance’s <code>args</code> tuple attribute and are automatically displayed when the instance is printed. An empty tuple and display string are used if no constructor arguments are passed, and a single argument displays as itself (not as a tuple) and serves as message details.</p>
<p>This explains why arguments passed to <em>built-in</em> exception classes show up in error messages—any constructor arguments are attached to the instance and displayed when the instance is printed:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>raise IndexError</strong> </code>                    <code><em># Same as IndexError(): no arguments</em></code>
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
IndexError

&gt;&gt;&gt; <code><strong>raise IndexError('bad')</strong></code>              <code><em># Constructor argument attached, printed</em></code>
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
IndexError: bad
 
&gt;&gt;&gt; <code><strong>i = IndexError('bad', 'stuff')</strong></code>       <code><em># Available in object attribute "args"</em></code>
&gt;&gt;&gt; <code><strong>i.args</strong></code>
('bad', 'stuff')
&gt;&gt;&gt; <code><strong>print(i)  </strong>  </code>                         <code><em># Displays args when printed manually</em></code>
('bad', 'stuff')
&gt;&gt;&gt; <code><strong>i</strong></code>                                    <code><em># Uses repr for echo, str for print</em></code>
IndexError('bad', 'stuff')</pre>
<p>The same holds true for <em>user-defined</em> exceptions because they inherit the constructor and display methods present in their built-in superclasses:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>class E(Exception): pass</strong></code>
 
&gt;&gt;&gt; <code><strong>raise E</strong></code>
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
E

&gt;&gt;&gt; <code><strong>raise E('bad')</strong></code>
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
E: bad

&gt;&gt;&gt; <code><strong>i = E('bad', 'stuff')</strong></code>
&gt;&gt;&gt; <code><strong>i.args</strong></code>
('bad', 'stuff')
&gt;&gt;&gt; <code><strong>print(i)</strong></code>
('bad', 'stuff')
&gt;&gt;&gt; <code><strong>i</strong></code>
E('bad', 'stuff')</pre>
<p>When intercepted in a <code>try</code> statement, the exception instance object gives access to both the original constructor arguments and the display method:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>try:</strong></code>
...     <code><strong>raise E('bad')</strong> </code>                    <code><em># Displays + saves constructor args</em></code>
... <code><strong>except E as X:</strong></code>
...     <code><strong>print(f'{X} - {X.args} - {X!r}')</strong></code>
...
bad - ('bad',) - E('bad')

&gt;&gt;&gt; <code><strong>try:</strong></code>
...     <code><strong>raise E('bad', 'stuff')</strong>  </code>          <code><em># Multiple args save/display a tuple</em></code>
... <code><strong>except E as X:</strong></code>
...     <code><strong>print(f'{X} - {X.args} - {X!r}')</strong></code>
...
('bad', 'stuff') - ('bad', 'stuff') - E('bad', 'stuff')</pre>
<p>Note that exception instance objects are not strings themselves, but use the <code>__str__</code> and <code>__repr__</code> operator-overloading methods we studied in <a data-type="xref" href="ch30.html#operator_overloading-id000103">Chapter 30</a> to provide display strings for <code>print</code> and other contexts. To concatenate with real strings, perform manual conversions: <code>str(X)</code>, <code>'%s' % X</code>, <code>f'{X}'</code>, and the like.</p>
<p>Although this automatic state and display <a contenteditable="false" data-type="indexterm" data-primary="exceptions" data-secondary="built-in" data-tertiary="default printing" data-startref="xpbdfp" id="id4472"></a><a contenteditable="false" data-type="indexterm" data-primary="printing" data-secondary="exceptions, built-in" data-startref="pxpblt" id="id4473"></a><a contenteditable="false" data-type="indexterm" data-primary="state" data-secondary="exceptions, built-in" data-startref="sttxpbl" id="id4474"></a><a contenteditable="false" data-type="indexterm" data-primary="exceptions" data-secondary="built-in" data-tertiary="state" data-startref="xpcblstt" id="id4475"></a>support is useful by itself, for more specific display and state retention needs, you can always redefine inherited methods such as <code>__str__</code> and <code>__init__</code> in <span class="keep-together"><code>Exception</code></span> subclasses—as the next section shows.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Custom Print Displays"><div class="sect1" id="custom_print_displays">
<h1>Custom Print Displays</h1>
<p>As we saw in the preceding section, by default, instances <a contenteditable="false" data-type="indexterm" data-primary="exceptions" data-secondary="built-in" data-tertiary="custom printing" id="xepbsmp"></a><a contenteditable="false" data-type="indexterm" data-primary="printing" data-secondary="exceptions, built-in" data-tertiary="custom printing" id="prspbcpr"></a>of class-based exceptions display whatever you passed to the class constructor when they are caught and printed:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>class MyBad(Exception): pass</strong></code>

&gt;&gt;&gt; <code><strong>try:</strong></code>
...     <code><strong>raise MyBad('Sorry--my mistake!')</strong></code>
... <code><strong>except MyBad as X:</strong></code>
...     <code><strong>print(X)</strong></code>
...
Sorry--my mistake!</pre>
<p>This inherited default display model is also used if the exception is displayed as part of an error message when the exception is not caught:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>raise MyBad('Sorry--my mistake!')</strong></code>
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
MyBad: Sorry--my mistake!</pre>
<p>For many roles, this is sufficient. To provide a more custom display, though, you can define one of two string-representation overloading methods in your class (<code>__repr__</code> or <code>__str__</code>) to return the string you want to display for your exception. The string the method returns will be displayed if the exception either is caught and printed or reaches the default handler:</p>
<pre class="pagebreak-before" data-type="programlisting">&gt;&gt;&gt; <code><strong>class MyBad(Exception):</strong></code>
        <code><strong>def __str__(self):</strong></code>
            <code><strong>return 'Stuff happens...'</strong></code>

&gt;&gt;&gt; <code><strong>try:</strong></code>
...     <code><strong>raise MyBad()</strong></code>
... <code><strong>except MyBad as X:</strong></code>
...     <code><strong>print(X)</strong></code>
...
Stuff happens...

&gt;&gt;&gt; <code><strong>raise MyBad()</strong></code>
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
MyBad: Stuff happens...</pre>
<p>Whatever your method returns is included in error messages for uncaught exceptions and used when exceptions are printed explicitly. The method returns a hardcoded string here to illustrate, but it can also perform arbitrary text processing, possibly using state information attached to the instance object. The next section looks at state information options.</p>
<p>First, though, one fine point: you generally must redefine <code>__str__</code> for exception display purposes because the built-in exception superclasses already have a <code>__str__</code> method, and <code>__str__</code> is preferred to <code>__repr__</code> in some contexts—including error-message displays. If you define a <code>__repr__</code>, printing will happily call the built-in superclass’s <code>__str__</code> instead:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>class Oops(Exception):
        def __repr__(self): return 'Custom display not used'</strong></code>

&gt;&gt;&gt; <code><strong>raise Oops("Nobody's perfect")</strong></code>
…
Oops: Nobody's perfect</pre>
<p>But a custom <code>__str__</code> is used if defined:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>class Oops(Exception):
        def __str__(self): return 'Custom display used'</strong></code>

&gt;&gt;&gt; <code><strong>raise Oops("Nobody's perfect")</strong></code>
…
Oops: Custom display used</pre>
<p>See <a data-type="xref" href="ch30.html#operator_overloading-id000103">Chapter 30</a> for more details on these <a contenteditable="false" data-type="indexterm" data-primary="exceptions" data-secondary="built-in" data-tertiary="custom printing" data-startref="xepbsmp" id="id4476"></a><a contenteditable="false" data-type="indexterm" data-primary="printing" data-secondary="exceptions, built-in" data-tertiary="custom printing" data-startref="prspbcpr" id="id4477"></a>special operator-overloading methods.</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Custom State and Behavior"><div class="sect1" id="custom_state_and_behavior">
<h1>Custom State and Behavior</h1>
<p>Besides supporting flexible hierarchies, exception classes also provide storage for extra state information as <a contenteditable="false" data-type="indexterm" data-primary="state" data-secondary="exceptions, built-in" data-tertiary="custom" id="ttxtlcm"></a><a contenteditable="false" data-type="indexterm" data-primary="exceptions" data-secondary="built-in" data-tertiary="state" id="pxcblstt"></a>instance <em>attributes</em>. As discussed earlier, built-in exception superclasses provide a default constructor that automatically saves constructor arguments in an instance tuple attribute named <code>args</code>. Although the default constructor is adequate for many cases, for more custom needs we can provide a constructor of our own. In addition, classes may define methods for use in handlers that provide <span class="keep-together">precoded</span> exception processing logic.</p>
<section data-type="sect2" class="pagebreak-before" data-pdf-bookmark="Providing Exception Details"><div class="sect2" id="providing_exception_details">
<h2 class="less_space">Providing Exception Details</h2>
<p>When an exception is raised, it may cross arbitrary file boundaries—the <code>raise</code> statement that triggers <a contenteditable="false" data-type="indexterm" data-primary="exceptions" data-secondary="details" id="id4478"></a>an exception and the <code>try</code> statement that catches it may be in completely different module files. It is not generally feasible to store extra details in global variables because the <code>try</code> statement might not know which file the globals reside in. Passing extra state information along in the exception itself allows the <code>try</code> statement to access it more reliably.</p>
<p>With classes, this is nearly automatic. As we’ve seen, when an exception is raised, Python passes the class instance object along with the exception. Code in <code>try</code> statements can access the raised instance by listing an extra variable after the <code>as</code> keyword in an <code>except</code> handler. This provides a natural hook for supplying data and behavior to the handler. Generic instance-access tools like <code>sys.exc_info</code> used earlier enable the same interfaces.</p>
<p>For example, a program that parses data files might signal a formatting error by raising an exception instance that is filled out with extra details about the error (the input file here isn’t real because this demo dies before reading it!):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>class FormatError(Exception):
        def __init__(self, line, file):</strong>  </code>          <code><em># Custom constructor</em><strong>
            self.line = line
            self.file = file

</strong></code>&gt;&gt;&gt; <code><strong>def parser(file):   </strong>  </code>                         <code><em># Parse the file first</em></code>
        <code><strong>raise FormatError(62, file=file)</strong> </code>          <code><em># When an error is found</em></code>

&gt;&gt;&gt; <code><strong>try:</strong></code>
...     <code><strong>parser('code.py')</strong></code>
... <code><strong>except FormatError as X:</strong></code>
...     <code><strong>print(f'Error at: {X.file} #{X.line}')</strong></code>     <code><em># Custom state info
</em></code>...
Error at: code.py #62</pre>
<p>In the <code>except</code> clause here, the variable <code>X</code> is assigned a reference to the instance that was generated when the exception was raised. This gives access to the attributes attached to the instance by the custom constructor. Although we could rely on the default state retention of built-in superclasses, it’s less relevant to our application (and doesn’t support the keyword arguments used in the prior example):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>class FormatError(Exception): pass</strong></code>             <code><em># Inherited constructor</em></code>

&gt;&gt;&gt; <code><strong>def parser(file):
        raise FormatError(file, 62)</strong></code>                <code><em># No keywords allowed!</em></code>

&gt;&gt;&gt; <code><strong>try:</strong></code>
...     <code><strong>parser('code.py')</strong></code>
... <code><strong>except FormatError as X:</strong></code>
...     <code><strong>print(f'Error at: {X.args[0]} #{X.args[1]}')</strong></code>     <code><em># Generic state info
</em></code>...
Error at: code.py #62</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Providing Exception Methods"><div class="sect2" id="providing_exception_methods">
<h2>Providing Exception Methods</h2>
<p>Besides enabling application-specific <a contenteditable="false" data-type="indexterm" data-primary="exceptions" data-secondary="methods" id="pexhtm"></a>state and display, classes also support extra behavior for exception objects. That is, the exception class can also define unique <em>methods</em> to be called in handlers. The file <em>parsely.py</em> in <a data-type="xref" href="#example_threefive_threedot_parselydotpy">Example 35-3</a>, for example, adds a method that uses exception custom state information to log errors to a file automatically.</p>
<div data-type="example" id="example_threefive_threedot_parselydotpy">
<h5><span class="label">Example 35-3. </span>parsely.py</h5>
<pre data-type="programlisting">from time import asctime

class FormatError(Exception):
    logfile = 'parser-errors.txt'
    def __init__(self, line, file):
        self.line = line
        self.file = file
    def logerror(self):
        with open(self.logfile, 'a') as log:
            print(f'Error at: {self.file} #{self.line} [{asctime()}]', file=log)

def parser(file):
    # Parse a file here...
    raise FormatError(line=62, file=file)

if __name__ == '__main__':
    try:
        parser('code.py')
    except FormatError as exc:
        exc.logerror()</pre>
</div>
<p>When run, this script appends its error message to a file in response to method calls in the exception handler (use <code>type</code> instead of the Unix <code>cat</code> on Windows, and see Python manuals for <code>time.asctime</code>):</p>
<pre data-type="programlisting">$ <code><strong>python3 parsely.py</strong></code>
$ <code><strong>python3 parsely.py</strong></code>
$ <code><strong>cat parser-errors.txt</strong></code>
Error at: code.py #62 [Sat Jul 13 12:22:19 2024]
Error at: code.py #62 [Sat Jul 13 12:22:25 2024]</pre>
<p>In such a class, methods (like <code>logerror</code>) may also be inherited from superclasses, and instance attributes (like <code>line</code> and <code>file</code>) provide a place to save state information that provides extra context for use in later method calls. Moreover, exception classes are free to customize and extend inherited <span class="keep-together">behavior</span>:</p>
<pre data-type="programlisting">class CustomFormatError(FormatError):
    def logerror(self):
        …<code><em>something unique here</em></code>…
…
raise CustomFormatError(…)
…
try:
    …
except FormatError as exc:
    exc.logError()               <code><em># Runs the raised class's version</em></code></pre>
<p>In other words, because they are defined with classes, all the benefits of OOP that we studied in <a data-type="xref" href="part06.html#classes_and_oop">Part VI</a> are available for use with exceptions in Python.</p>
<p>Two final notes here: first, the raised instance object assigned to <code>exc</code> in this code is also available generically as the second item in the result tuple of the <code>sys.exc_info()</code> call used earlier—a tool that returns information about the exception being handled. This call can be used if you do not list an exception name in an <code>except</code> clause but still need access to the exception that occurred, or to any of its attached state information or methods. And second, although our class’s <code>logerror</code> method appends a custom message to a logfile, it could also generate Python’s standard error message with <a contenteditable="false" data-type="indexterm" data-primary="state" data-secondary="exceptions, built-in" data-tertiary="custom" data-startref="ttxtlcm" id="id4479"></a><a contenteditable="false" data-type="indexterm" data-primary="exceptions" data-secondary="built-in" data-tertiary="state" data-startref="pxcblstt" id="id4480"></a><a contenteditable="false" data-type="indexterm" data-primary="exceptions" data-secondary="methods" data-startref="pexhtm" id="id4481"></a>stack trace using tools in the <code>traceback</code> standard-library module, which uses traceback objects.</p>
<p>To learn more about <code>sys.exc_info</code> and tracebacks, though, we need to move ahead to the next chapter.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Exception Groups: Yet Another Star!"><div class="sect1" id="exception_groups_yet_another_starexclam">
<h1>Exception Groups: Yet Another Star!</h1>
<p>But wait—just when you thought it was safe to put exceptions in the win column, the exceptions story has recently <a contenteditable="false" data-type="indexterm" data-primary="exception groups" id="xepgpr"></a>sprouted yet another wild plot twist, which is sufficiently limited and arcane to pass as an optional follow-up topic for most Python learners (and was deferred until now for this reason). Lest it crop up in one of those silly job interviews that favor the inane over the practical, though, here’s a quick peek.</p>
<p>Let’s get right to the code. As we’ve seen, <code>try</code> statements normally run at most <em>one</em> matching handler clause, plus an optional <code>finally</code> on exit:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>try:</strong></code>
...     <code><strong>raise IndexError()</strong></code>
... <code><strong>except IndexError:</strong></code>
...     <code><strong>print('Got IE')</strong></code>
... <code><strong>except (SyntaxError, TypeError):</strong></code>
...     <code><strong>print('Got SE')</strong></code>
... 
Got IE</pre>
<p>Python 3.11, though, adds the ability <a contenteditable="false" data-type="indexterm" data-primary="try statement" data-secondary="except* clause" id="trystxptc"></a>to trigger <em>multiple</em> matching handlers in a single <code>try</code> statement by wrapping them in an <em>exception group</em> and catching them with <code>except*</code> clauses:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>try:</strong></code>
...     <code><strong>raise ExceptionGroup('Many', [IndexError(), SyntaxError()])</strong></code>
... <code><strong>except* IndexError:</strong></code>
...     <code><strong>print('Got IE')</strong></code>
... <code><strong>except* (SyntaxError, TypeError):</strong></code>
...     <code><strong>print('Got SE')</strong></code>
... 
Got IE
Got SE</pre>
<p>In a nutshell, each <code>except*</code> clause can process and consume one exception, or one batch of them, in the group. Here, the first clause runs for <code>IndexError</code> and the second for <code>SyntaxError</code> (a tuple means “any” as before). The <em>group</em> is simply an exception object made by calling a built-in exception class provided for this role, passing a message-string label used in displays, along with a sequence of exceptions to be matched by <code>except*</code> clauses in a <code>try</code>.</p>
<p>Syntactically, an empty <code>except*</code> is not allowed, and a basic <code>except</code> cannot be mixed with <code>except*</code>—but an <code>else</code> and <code>finally</code> can. Moreover, <code>except*</code> cannot host a <code>break</code>, <code>continue</code>, or <code>return</code>—but <code>except</code> can. Like the awkward <code>except</code>/<code>else</code>/<code>finally</code> mixing rules before it, these special cases probably qualify <code>except*</code> as a distinct statement form; adding it to the mix makes <code>try</code> an overloaded jumble of semi-related functionality.</p>
<p>Semantically, each <code>except*</code> clause executes at most once, and consumes all matching exceptions in the group. In addition, each exception in the group is handled by at most one <code>except*</code> clause—the topmost clause that matches it; optional <code>as</code> variables are assigned exception groups—with attributes like <span class="keep-together"><code>exceptions</code></span> that expose their contents; and any <em>unmatched</em> exceptions in the group are reraised after the <code>try</code> statement processes matches—with a top-level message that denotes those unmatched:</p>
<pre class="pagebreak-before" data-type="programlisting">&gt;&gt;&gt; <code><strong>excs = ExceptionGroup('Many', [IndexError(), SyntaxError(), TypeError()])</strong></code>
&gt;&gt;&gt; <code><strong>try:</strong></code>
...     <code><strong>raise excs</strong></code>
... <code><strong>except* IndexError as E:</strong></code>
...     <code><strong>print(f'Got IE: {E} =&gt; {E.exceptions}')</strong></code>
... <code><strong>except* SyntaxError as E:</strong></code>
...     <code><strong>print(f'Got SE: {E} =&gt; {E.exceptions}')</strong></code>
... 
Got IE: Many (1 sub-exception) =&gt; (IndexError(),)
Got SE: Many (1 sub-exception) =&gt; (SyntaxError(),)
  + Exception Group Traceback (most recent call last):
  |   File "&lt;stdin&gt;", line 2, in &lt;module&gt;
  | ExceptionGroup: Many (1 sub-exception)
  +-+---------------- 1 ----------------
    | TypeError
    +------------------------------------</pre>
<p>When the group has multiple exceptions of the <em>same</em> type, a matching <code>except*</code> consumes them all and can process them in normal iteration code. As also shown next, <em>spaces</em> around the <code>*</code> are allowed and ignored—despite all the <code>except*</code> labels in docs, and more reflective of the wildcard nature of these <span class="keep-together">clauses</span>:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>try:</strong></code>
...     <code><strong>raise ExceptionGroup('Dups', [IndexError(), TypeError(1), TypeError(2)])</strong></code>
... <code><strong>except *IndexError:</strong></code>
...     <code><strong>print('Got IE')</strong></code>
... <code><strong>except *TypeError as E:</strong></code>
...     <code><strong>print(f'Got TE: {E} =&gt; {E.exceptions}')</strong></code>
... 
Got IE
Got TE: Dups (2 sub-exceptions) =&gt; (TypeError(1), TypeError(2))</pre>
<p>As usual, a group’s exception matches an <code>except*</code> that names its class or one of its <em>superclasses</em>. Because of this, the <em>ordering</em> of clauses is both subtle and important—the first match wins and removes exceptions from the group. In the following, for example, the first clause gobbles <code>IndexError</code> via its <code>LookupError</code> superclass, along with the two <code>TypeError</code>s in the group (but reversing the clauses’ order would handle <code>IndexError</code> separately):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>try:</strong></code>
...     <code><strong>raise ExceptionGroup('Dups', [IndexError(), TypeError(1), TypeError(2)])</strong></code>
... <code><strong>except* (TypeError, LookupError) as E:</strong></code>
...     <code><strong>print('Got1:', E)</strong></code>
... <code><strong>except* IndexError as E:</strong></code>
...     <code><strong>print('Got2:', E)</strong></code>
... 
Got1: Dups (3 sub-exceptions)</pre>
<p>The <code>except*</code> can also match basic <em>individual</em> exceptions, which are automatically wrapped in a group to appease group-based code in the handler:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>try:</strong></code>
...     <code><strong>raise IndexError</strong></code>
... <code><strong>except* IndexError as E:</strong></code>
...    <code><strong>print(f'Got IE: {E} =&gt; {E.exceptions}')</strong></code>
... 
Got IE:  (1 sub-exception) =&gt; (IndexError(),)</pre>
<p>And a basic <code>except</code> can catch a group as a <em>collective</em> and process it manually, but an <code>except*</code> cannot catch a group because it would be ambiguous (a schism of the sort that’s usually a hallmark of an ad hoc extension):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>try:</strong></code>
...     <code><strong>raise ExceptionGroup('Lots', [IndexError(), SyntaxError()])</strong></code>
... <code><strong>except Exception as E:</strong></code>
...     <code><strong>print(f'Got group: {E} =&gt; {E.exceptions}')</strong></code>
...     <code><strong>for exc in E.exceptions:</strong></code>
...         <code><strong>print('With exc:', type(exc))</strong></code>
... 
Got group: Lots (2 sub-exceptions) =&gt; (IndexError(), SyntaxError())
With exc: &lt;class 'IndexError'&gt;
With exc: &lt;class 'SyntaxError'&gt;</pre>
<p>Finally, for comparison, here’s a <em>catchall</em> in both models—though there’s no reason to use <code>except*</code> to catch a single exception (unless overly complicated code is your thing):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>try:</strong></code>
...     <code><strong>raise ExceptionGroup('Dups', [IndexError()])</strong></code>
... <code><strong>except* Exception as E:</strong></code>
...     <code><strong>print(type(E.exceptions[0]))</strong></code>
... 
&lt;class 'IndexError'&gt;

&gt;&gt;&gt; <code><strong>try:</strong></code>
...     <code><strong>raise IndexError()</strong></code>
... <code><strong>except Exception as E:</strong></code>
...     <code><strong>print(type(E))</strong></code>
... 
&lt;class 'IndexError'&gt;</pre>
<p>For another exception-groups example, see the next chapter’s <a data-type="xref" href="ch36.html#example_threesix_twodot_nested_exc_grou">Example 36-2</a>, which demos how runtime nesting consumes items in groups (short story: groups propagate until empty, then die like individual exceptions).</p>
<p>Design concerns aside, the “why” of <code>except*</code> is even more elusive than the “how.” While it’s conceivable that some programs may wish to collect a set of exceptions and send them to a <code>try</code> statement as a <em>batch</em>, it’s harder to understand why these wildly rare programs could not be expected to package with normal exception objects and process with normal iteration code—instead of convoluting the Python language for everyone.</p>
<p>Because exception groups are an obscure tool with very narrow roles, we’ll defer to Python’s manuals for more info on this esoteric <code>try</code> extension that, like many a Python mod, seems to blow up complexity radically to address a purported need that somehow managed to <a contenteditable="false" data-type="indexterm" data-primary="exception groups" data-startref="xepgpr" id="id4482"></a><a contenteditable="false" data-type="indexterm" data-primary="try statement" data-secondary="except* clause" data-startref="trystxptc" id="id4483"></a>go unnoticed for all of Python’s first three decades+. How did we live?</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Chapter Summary"><div class="sect1" id="chapter_summary-id00046">
<h1>Chapter Summary</h1>
<p>In this chapter, we explored both built-in exceptions and ways to code exceptions of our own. As we learned, exceptions are implemented as class instance objects. Exception classes support the concept of exception hierarchies that ease maintenance, allow data and behavior to be attached to exceptions as instance attributes and methods, and allow exceptions to inherit tools from superclasses as usual in OOP.</p>
<p>We saw that in a <code>try</code> statement, catching a superclass catches that class as well as all subclasses below it in the class tree—superclasses become exception category names, and subclasses become more specific exception types within those categories. We also saw that the built-in exception superclasses we must inherit from provide usable defaults for printing and state retention, which we can override if desired.</p>
<p>Finally, armed with our new knowledge of exception objects, we also peeked at exception groups and the <code>except*</code> clause, used to run multiple handlers in a <code>try</code>. We questioned whether this extension’s convolution of <code>try</code> statements is justified by its perceived roles; it’s a lot to ask of most Python users, but this question is ultimately yours to answer.</p>
<p>The next chapter wraps up this part of the book by exploring some common use cases for exceptions and surveying tools commonly used by Python programmers. Before we get there, though, here’s this chapter’s quiz.</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Test Your Knowledge: Quiz"><div class="sect1" id="test_your_knowledge_quiz-id000191">
<h1>Test Your Knowledge: Quiz</h1>
<ol>
<li><p>What are the two main constraints on user-defined exceptions in Python?</p></li>
<li><p>How are raised exceptions matched to <code>except</code> handler clauses?</p></li>
<li><p>Name two ways that you can attach context information to exception objects.</p></li>
<li><p>Name two ways that you can specify the error-message text for exception objects.</p></li>
<li><p>What do <code>except*</code> clauses do in a <code>try</code> statement?</p></li>
</ol>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Test Your Knowledge: Answers"><div class="sect1" id="test_your_knowledge_answers-id000190">
<h1>Test Your Knowledge: Answers</h1>
<ol>
<li><p>Exceptions must be defined by <em>classes</em> (that is, a class instance object is raised and caught). In addition, exception classes must be derived from the <em>built-in</em> class <code>BaseException</code> or one of its subclasses; most programs inherit from its <code>Exception</code> subclass to support catchall handlers for normal kinds of exceptions.</p></li>
<li><p>Exceptions match by superclass relationships: naming a <em>superclass</em> in an exception handler will catch instances of that class, as well as instances of any of its <em>subclasses</em> lower in the class tree. Because of this, you can think of superclasses as general exception categories and subclasses as more specific types of exceptions within those categories.</p></li>
<li><p>You can attach context information to exceptions with either custom or default constructors. A <em>custom</em> constructor can fill out attributes in a raised instance object that are specific to the program. For simpler needs, built-in exception superclasses provide a <em>default</em> constructor that stores its arguments on the instance automatically as tuple attribute <code>args</code>. Handlers can list a variable to be assigned to the raised instance, then go through this name to access attached state information and call any methods defined in the class.</p></li>
<li><p>The error-message text in exceptions can be specified with a custom <code>__str__</code> operator-overloading method. For simpler needs, built-in exception superclasses automatically display anything you pass to the class constructor. Operations like <code>print</code> and <code>str</code> automatically fetch the display string of an exception object when it is printed either explicitly or as part of an error message.</p></li>
<li><p>In a <code>try</code>, <code>except*</code> is used to run possibly <em>multiple</em> handlers for exceptions raised as part of a <em>group</em>. The <code>except*</code> also comes with heavy semantics, has special-case syntax and rules, does not combine with basic <code>except</code>, and is rarely useful in most Python programs. Nevertheless, there it is.</p></li>
</ol>
</div></section>
</div></section></div>
</div>
</body>
</html>