<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xml:lang="en"
lang="en"
xmlns="http://www.w3.org/1999/xhtml"
xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<title>Learning Python, 6th Edition</title>
<link rel="stylesheet" type="text/css" href="override_v1.css"/>
<link rel="stylesheet" type="text/css" href="epub.css"/>
</head>
<body>
<div id="book-content">
<div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 7. String Fundamentals"><div class="chapter" id="string_fundamentals">
<h1><span class="label">Chapter 7. </span>String Fundamentals</h1>
<p>So far, we’ve studied numbers and explored Python’s dynamic typing model. The next major type on our in-depth object tour is the Python <em>string</em>—an ordered collection of characters <a contenteditable="false" data-type="indexterm" data-primary="strings" id="id1905"></a>used to store and represent text- and bytes-based information. We looked briefly at strings in <a data-type="xref" href="ch04.html#introducing_python_objects">Chapter 4</a>. Here, we will revisit them to fill in details we skipped earlier.</p>
<p>Before we get started, let’s get clear on what we <em>won’t</em> be covering here. <a data-type="xref" href="ch04.html#introducing_python_objects">Chapter 4</a> also briefly previewed <em>Unicode</em> strings and files—tools for dealing <a contenteditable="false" data-type="indexterm" data-primary="strings" data-secondary="Unicode" id="id1906"></a><a contenteditable="false" data-type="indexterm" data-primary="Unicode" data-secondary="strings" id="id1907"></a>with non-ASCII text. Unicode is a key tool for programmers, especially those who work in the internet domain. It can pop up, for example, in web pages, emails, GUI toolkits, file-processing tools, XML and JSON text, and more. At the same time, Unicode can be a heavy topic for programmers just starting out, and a complete understanding of it relies on tools that we haven’t yet studied in full, like files.</p>
<p>In light of that, this book splits its strings coverage between the essentials here, and their extension to Unicode and byte strings in <a data-type="xref" href="ch37.html#unicode_and_byte_strings">Chapter 37</a> of its advanced topics part. That is, this chapter tells only part of the string story in Python—the part that most scripts use, and most Python learners need to know up front. Despite this limited scope, everything we learn here will apply directly to Unicode and bytes processing, too, because Python text strings <em>are</em> Unicode, even if they’re simple ASCII text, and byte strings are simply strings constrained to byte values.</p>
<p>After you’ve learned the basics here, <a data-type="xref" href="ch37.html#unicode_and_byte_strings">Chapter 37</a> is recommended reading for the rest of the string saga, and most programmers will want to follow up with its coverage eventually. Unicode is rarely optional in programming today, though it’s best deferred until you’ve had a chance to master strings in general. So let’s get started!</p>
<section data-type="sect1" data-pdf-bookmark="String Object Basics"><div class="sect1" id="string_object_basics">
<h1>String Object Basics</h1>
<p>From a functional perspective, strings can be used to represent just about anything that can be encoded as text or bytes. In the text department, this includes symbols and words (e.g., your name), contents of text files loaded into memory, internet addresses, Python source code, and so on. Strings can also be used to hold the raw bytes used for media files and network transfers, and both the encoded and decoded forms of non-ASCII Unicode text.</p>
<p>You may have used strings <a contenteditable="false" data-type="indexterm" data-primary="strings" data-secondary="character arrays and" id="id1908"></a>in other languages, too. Python’s strings serve the same role as character arrays in languages such as C, but they are a somewhat higher-level tool than arrays. Unlike in C, strings in Python come with a powerful set of precoded processing tools. Also unlike languages such as C, Python has no distinct type for individual characters; instead, you just use one-character strings for one-character info.</p>
<p>Strictly speaking, Python <a contenteditable="false" data-type="indexterm" data-primary="strings" data-secondary="as immutable sequences" id="id1909"></a><a contenteditable="false" data-type="indexterm" data-primary="immutable sequences, strings" id="id1910"></a>strings are categorized as <em>immutable sequences</em>, meaning that the characters they contain have a left-to-right positional order and cannot be changed in place. In fact, strings are the first representative <a contenteditable="false" data-type="indexterm" data-primary="strings" data-secondary="sequences" id="id1911"></a><a contenteditable="false" data-type="indexterm" data-primary="sequences" data-secondary="strings" id="id1912"></a>of the larger class of objects called <em>sequences</em> that we will explore here. Pay attention to the sequence operations covered in this chapter, because they will work the same on other sequence types you’ll meet later, such as lists and tuples.</p>
<p>As a first step, <a data-type="xref" href="#common_string_literals_and_operations">Table 7-1</a> previews common string literals and operations discussed in this chapter, by abstract example (don’t expect its code snippets to run!). As it shows, empty strings are written as a pair of quotation marks (single or double) with nothing in between, and there are a variety of ways to code strings. For processing, strings support <em>expression</em> operations <a contenteditable="false" data-type="indexterm" data-primary="strings" data-secondary="expressions" id="id1913"></a><a contenteditable="false" data-type="indexterm" data-primary="expressions" data-secondary="strings" id="id1914"></a><a contenteditable="false" data-type="indexterm" data-primary="strings" data-secondary="concatenation" id="id1915"></a><a contenteditable="false" data-type="indexterm" data-primary="concatenation" id="id1916"></a><a contenteditable="false" data-type="indexterm" data-primary="strings" data-secondary="slicing" id="id1917"></a><a contenteditable="false" data-type="indexterm" data-primary="slicing" id="id1918"></a><a contenteditable="false" data-type="indexterm" data-primary="strings" data-secondary="combining" id="id1919"></a><a contenteditable="false" data-type="indexterm" data-primary="strings" data-secondary="section extraction" id="id1920"></a><a contenteditable="false" data-type="indexterm" data-primary="strings" data-secondary="indexing" id="id1921"></a><a contenteditable="false" data-type="indexterm" data-primary="strings" data-secondary="fetching by offset" id="id1922"></a>such as concatenation (combining strings), slicing (extracting sections), indexing (fetching by offset), and so on. Besides expressions, Python also provides <a contenteditable="false" data-type="indexterm" data-primary="strings" data-secondary="methods" id="id1923"></a><a contenteditable="false" data-type="indexterm" data-primary="strings" data-secondary="modules" id="id1924"></a><a contenteditable="false" data-type="indexterm" data-primary="modules" data-secondary="strings" id="id1925"></a>a set of string <em>methods</em> that implement common string-specific tasks, as well as <em>modules</em> for more advanced text-processing <a contenteditable="false" data-type="indexterm" data-primary="string literals" data-secondary="operations" id="id1926"></a>tasks such as pattern matching.</p>
<table class="border" id="common_string_literals_and_operations">
<caption><span class="label">Table 7-1. </span>Common string literals and operations</caption>
<thead>
<tr>
<th>Operation</th>
<th>Interpretation</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>S = ''</code></td>
<td>Empty string</td>
</tr>
<tr>
<td><code>S = "app's"</code></td>
<td>Double quotes, same as single</td>
</tr>
<tr>
<td><code>S = 'c\no\td\x00e'</code></td>
<td>Escape sequences</td>
</tr>
<tr>
<td><code>S = """…<code><em>multiline</em></code>…"""</code></td>
<td>Triple-quoted block strings</td>
</tr>
<tr>
<td><code>S = r'\temp\data.txt'</code></td>
<td>Raw strings (ignore escapes)</td>
</tr>
<tr>
<td><code>B = b'h\xc4ck'</code></td>
<td>Byte strings (<a data-type="xref" href="ch04.html#introducing_python_objects">Chapter 4</a>, <a data-type="xref" href="ch37.html#unicode_and_byte_strings">Chapter 37</a>)</td>
</tr>
<tr>
<td><code>S = 'py\U0001F40D'</code></td>
<td>Unicode strings (<a data-type="xref" href="ch04.html#introducing_python_objects">Chapter 4</a>, <a data-type="xref" href="ch37.html#unicode_and_byte_strings">Chapter 37</a>)</td>
</tr>
<tr>
<td><code>S = u'py\U0001F40D'</code></td>
<td>Python 2.X compatibility (<a data-type="xref" href="ch37.html#unicode_and_byte_strings">Chapter 37</a>)</td>
</tr>
<tr>
<td><code>S1 + S2</code><br/>
<code>S * 3</code></td>
<td>Concatenate, repeat</td>
</tr>
<tr>
<td><code>S[i]</code><br/>
<code>S[i:j]</code><br/>
<code>len(S)</code></td>
<td>Index, slice, length</td>
</tr>
<tr>
<td><code>S1 &gt; S2, S1 == S2</code></td>
<td>Comparisons: magnitude, equality</td>
</tr>
<tr>
<td><code>'a %s coder' % kind</code></td>
<td>String-formatting expression</td>
</tr>
<tr>
<td><code>'a {0} coder'.format(kind)</code></td>
<td>String-formatting method</td>
</tr>
<tr>
<td><code>f'a {kind} coder'</code></td>
<td>String-formatting literal (3.6+)</td>
</tr>
<tr>
<td><code>S.find('od')</code><br/>
  <code>S.rstrip()</code><br/>
  <code>S.replace('od', 'ood')</code><br/>
  <code>S.split(',')</code><br/>
  <code>S.isdigit()</code><br/>
  <code>S.lower()</code><br/>
  <code>S.endswith('thon')</code><br/>
  <code>S.join(strlist)</code><br/>
  <code>S.encode('utf8')</code><br/>
  <code>B.decode('latin1')</code><br/></td>
<td>String methods (see ahead for all 43): search,<br/>
remove whitespace,<br/>
replacement,<br/>
split on delimiter,<br/>
content test,<br/>
case conversion,<br/>
end test,<br/>
delimiter join,<br/>
Unicode encoding,<br/>
Unicode decoding, etc. (see <a data-type="xref" href="#string_method_calls_in_python_threedoto">Table 7-3</a>)</td>
</tr>
<tr>
<td><code>'py' in S.lower()</code><br/>
<code>for x in S: print(x)</code><br/>
<code>[c * 2 for c in S]</code><br/>
 <code>map(ord, S)</code></td>
<td>Membership, iteration</td>
</tr>
<tr>
<td><code>re.match('Py(.*)on', line)</code></td>
<td>Pattern matching: library module</td>
</tr>
</tbody>
</table>
<p>Beyond the core set of string tools in <a data-type="xref" href="#common_string_literals_and_operations">Table 7-1</a>, Python also supports more advanced pattern-based string processing with the standard library’s <code>re</code> (for “regular expression”) module demoed in <a data-type="xref" href="ch37.html#unicode_and_byte_strings">Chapter 37</a>, and even higher-level text processing tools such as HTML, JSON, and XML parsers. This book and this chapter, though, are focused on the fundamentals represented by <a data-type="xref" href="#common_string_literals_and_operations">Table 7-1</a>.</p>
<p>This chapter begins with an overview of string literal forms and string expressions, then moves on to look at more advanced tools such as string methods and formatting. Python comes with many string tools, and we won’t cover them all here; the complete story is chronicled in the Python library manual. Our goal here is to explore enough commonly used tools to give you a representative sample; methods we won’t see in action here are analogous to those we will.</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="String Literals"><div class="sect1" id="string_literals">
<h1>String Literals</h1>
<p>By and large, strings are fairly easy to use in Python. The first thing you need to know about them, though, is that <a contenteditable="false" data-type="indexterm" data-primary="string literals" data-secondary="format" id="id1927"></a>there are many ways to write them in your code:</p>
<ul>
<li><p>Single quotes: <code>'cod"e'</code></p></li>
<li><p>Double quotes: <code>"cod'e"</code></p></li>
<li><p>Triple quotes: <code>'''…code…'''</code>, <code>"""…code…"""</code></p></li>
<li><p>Escape sequences: <code>"c\to\nd\0e"</code></p></li>
<li><p>Raw strings: <code>r"C:\new\test.bin"</code></p></li>
<li><p>(<a data-type="xref" href="ch37.html#unicode_and_byte_strings">Chapter 37</a>) Bytes literals: <code>b'co\x01de'</code></p></li>
<li><p>(<a data-type="xref" href="ch37.html#unicode_and_byte_strings">Chapter 37</a>) Unicode literals: <code>'h\u00c4ck'</code></p></li>
</ul>
<p>The single- and double-quoted forms are by far the most common; the others serve specialized roles, and we’re postponing further discussion of the last two advanced forms until <a data-type="xref" href="ch37.html#unicode_and_byte_strings">Chapter 37</a>. Let’s take a quick look at all the other options in turn.</p>
<section data-type="sect2" data-pdf-bookmark="Single and Double Quotes Are the Same"><div class="sect2" id="single_and_double_quotes_are_the_same">
<h2>Single and Double Quotes Are the Same</h2>
<p>Around Python strings, single- and double-quote <a contenteditable="false" data-type="indexterm" data-primary="string literals" data-secondary="quotes" id="sgltqt"></a>characters are interchangeable, though they must match, and must be straight quotes (beware tools that autocorrect to slanted quotes!). That is, string literals can be written enclosed in either two single or two double straight quotes—the two forms work the same and return the same type of object. For example, the following two strings, coded at the usual REPL, are identical once they are read by Python:</p>
<pre data-type="programlisting">$ <code><strong>python3</strong></code>
&gt;&gt;&gt; <code><strong>'python', "python"</strong></code>
('python', 'python')</pre>
<p>The reason for supporting both is that it allows you to embed a quote character of the other variety inside a string without escaping it with a backslash. You may embed a double-quote character in a string enclosed in single-quote characters, and vice versa, without having to use the escapes you’ll meet in a moment:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>'python"s', "python's"</strong>   </code>               <code><em># Mixed quotes sans escapes</em></code>
('python"s', "python's")</pre>
<p>This book generally prefers to use <em>single</em> quotes around strings just because they are marginally easier to read, except in cases where a single quote is embedded in the string. This is a purely subjective style choice, but Python displays strings this way, too, and most Python programmers do the same today, so you probably should too.</p>
<p>Note that the comma is important in the <a contenteditable="false" data-type="indexterm" data-primary="strings" data-secondary="concatenation" id="id1928"></a><a contenteditable="false" data-type="indexterm" data-primary="concatenation" data-secondary="strings" id="id1929"></a>preceding code. Without it, Python <em>automatically concatenates</em> adjacent string literals of any kind. It is almost as simple to add a <code>+</code> operator between them to invoke concatenation explicitly, but adjacent literals are concatenated early when your code is read (and as you’ll learn ahead, wrapping this form in parentheses also allows it to span multiple lines for larger blocks of text that can’t use triple quotes):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>title = "Learning " 'Python' " 6E"</strong></code>      <code><em># Implicit concatenation when read</em></code>
&gt;&gt;&gt; <code><strong>title</strong></code>
'Learning Python 6E'</pre>
<p>Adding commas between these strings would result in a tuple, not a string. Also notice in all of these outputs that Python prints strings in single quotes unless they embed one. If needed, you can also embed quote characters by escaping them with backslashes:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>'python\'s', "python\"s"</strong></code>
("python's", 'python"s')</pre>
<p>To understand why, you need to move on <a contenteditable="false" data-type="indexterm" data-primary="string literals" data-secondary="quotes" data-startref="sgltqt" id="id1930"></a>to learn how escapes work in general.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Escape Sequences Are Special Characters"><div class="sect2" id="escape_sequences_are_special_characters">
<h2>Escape Sequences Are Special Characters</h2>
<p>The prior example embedded a quote <a contenteditable="false" data-type="indexterm" data-primary="strings" data-secondary="escape characters" id="stresccc"></a><a contenteditable="false" data-type="indexterm" data-primary="escape characters" id="excchc"></a><a contenteditable="false" data-type="indexterm" data-primary="special characters, escape sequences" id="spcccp"></a>inside a string by preceding it with a backslash (<code>\</code>). This is representative of a general pattern in strings: backslashes are used to introduce special character codings known as <em>escape sequences</em>.</p>
<p>Escape sequences let us embed characters in strings that cannot easily be inserted into a string literal or typed on a keyboard. The character <code>\</code>, and one or more characters following it in the string literal, are replaced with a <em>single</em> character in the resulting string object, which has the value specified by the escape sequence. For example, here is a five-character string that embeds a newline and a tab:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>s = 'a\nb\tc'</strong></code></pre>
<p>The two characters <code>\n</code> <a contenteditable="false" data-type="indexterm" data-primary="newline character" id="id1931"></a><a contenteditable="false" data-type="indexterm" data-primary="strings" data-secondary="newline characters" id="id1932"></a>stand for a single character—the <em>newline</em> character (technically speaking, code-point value 10, which means newline in Unicode and its ASCII subset). Similarly, the sequence <code>\t</code> is replaced with the <em>tab</em> character (code point 9). The way this string looks when printed depends on how you print it. The interactive echo shows the special characters as escapes, but <code>print</code> interprets them instead:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>s</strong></code>
'a\nb\tc'
&gt;&gt;&gt; <code><strong>print(s)</strong></code>
a
b       c</pre>
<p>To be completely sure how <a contenteditable="false" data-type="indexterm" data-primary="len function" id="id1933"></a><a contenteditable="false" data-type="indexterm" data-primary="functions" data-secondary="len" id="id1934"></a>many actual characters are in this string, use the built-in <code>len</code> function—it returns the actual number of characters in a string, regardless of how it is coded or displayed:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>len(s)</strong></code>
5</pre>
<p>This string is five characters long: it contains an ASCII <code>a</code>, a newline character, an ASCII <code>b</code>, and so on.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><em>But length is not bytes</em>: If you’re accustomed to all-ASCII text, it’s tempting to think of this <code>len</code> result as meaning five <em>bytes</em> too, but you probably shouldn’t. Really, “bytes” in today’s <em>Unicode</em> world doesn’t hold the meaning it once did. For one thing, the Python string object includes admin data that makes it larger in memory than its text alone.</p>
<p>For another, string <a contenteditable="false" data-type="indexterm" data-primary="Unicode" data-secondary="code points" id="id1935"></a><a contenteditable="false" data-type="indexterm" data-primary="code points" id="id1936"></a>content and length both reflect <em>code points</em> (identifying numbers) assigned by Unicode, and a single character’s code point does not necessarily map to a single byte—either when decoded in memory or encoded in files. Under encoding UTF-16, for example, ASCII <a contenteditable="false" data-type="indexterm" data-primary="Unicode" data-secondary="UTF-16" id="id1937"></a><a contenteditable="false" data-type="indexterm" data-primary="UTF-16 encoding" id="id1938"></a>characters are multiple bytes in files and may be any size at all in memory depending on how Python allocates their space. Moreover, code-point values of non-ASCII characters like <img src="assets/snake_1f40d.png" width="160" height="160"/> and <img src="assets/thumbs-up_1f44d.png" width="160" height="160"/> are far too large to fit in an 8-bit byte in any form.</p>
<p>In fact, Python defines <code>str</code> strings <a contenteditable="false" data-type="indexterm" data-primary="strings" data-secondary="code points" id="id1939"></a>formally as <em>sequences of Unicode code points</em>, not bytes, to make this clear. There’s much more on how Unicode text obviates bytes in <a data-type="xref" href="ch37.html#unicode_and_byte_strings">Chapter 37</a> when you’re ready to take the plunge. For now, to avoid confusion, think <em>characters</em> instead of <em>bytes</em> in strings.</p>
</div>
<p>Notice that the original <a contenteditable="false" data-type="indexterm" data-primary="strings" data-secondary="backslash characters" id="strbkcc"></a><a contenteditable="false" data-type="indexterm" data-primary="backslash characters" data-secondary="strings" id="bckccg"></a>backslash characters in the preceding examples are not really stored with the string in memory; they are used only to describe special character values to be stored in the string. For coding such special characters, Python recognizes a full set of escape code sequences, listed for reference in <a data-type="xref" href="#string_backslash_characters">Table 7-2</a>.</p>
<table class="border" id="string_backslash_characters">
<caption><span class="label">Table 7-2. </span>String backslash characters</caption>
<thead>
<tr>
<th>Escape</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\\</code></td>
<td>Backslash (stores one <code>\</code>)</td>
</tr>
<tr>
<td><code>\'</code></td>
<td>Single quote (stores <code>'</code>)</td>
</tr>
<tr>
<td><code>\"</code></td>
<td>Double quote (stores <code>"</code>)</td>
</tr>
<tr>
<td><code>\n</code></td>
<td>Newline (a.k.a. linefeed)</td>
</tr>
<tr>
<td><code>\r</code></td>
<td>Carriage return (e.g., in Windows <code>\r\n</code>)</td>
</tr>
<tr>
<td><code>\t</code></td>
<td>Horizontal tab</td>
</tr>
<tr>
<td><code>\v</code></td>
<td>Vertical tab</td>
</tr>
<tr>
<td><code>\a</code></td>
<td>Bell (where supported)</td>
</tr>
<tr>
<td><code>\b</code></td>
<td>Backspace</td>
</tr>
<tr>
<td><code>\f</code></td>
<td>Formfeed</td>
</tr>
<tr>
<td><code>\x<code><em>hh</em></code></code></td>
<td>Hexadecimal code-point or byte value (exactly 2 hex digits)</td>
</tr>
<tr>
<td><code>\<code><em>ooo</em></code></code></td>
<td>Octal code-point or byte value (up to 3 digits, 377 ceiling)</td>
</tr>
<tr>
<td><code>\0</code></td>
<td>Null: octal binary 0 character (doesn’t end string)</td>
</tr>
<tr>
<td><code>\u<code><em>hhhh</em></code></code></td>
<td>Unicode character code point, 16-bit value (exactly 4 hex digits)</td>
</tr>
<tr>
<td><code>\U<code><em>hhhhhhhh</em></code></code></td>
<td>Unicode character code point, 32-bit value (exactly 8 hex digits) </td>
</tr>
<tr>
<td><code>\N{<code><em>name</em></code>}</code></td>
<td>Character with ID <code><em>name</em></code> in Unicode database</td>
</tr>
<tr>
<td><code>\<code><em>newline</em></code></code></td>
<td>Ignored (precedes a continuation line)</td>
</tr>
<tr>
<td><code>\<code><em>other</em></code></code></td>
<td>Retained verbatim, but a warning in 3.12, an error in the future</td>
</tr>
</tbody>
</table>
<p>Some of <a data-type="xref" href="#string_backslash_characters">Table 7-2</a>’s escapes come with usage rules. Again for reference, here are the fine points:</p>
<ul>
<li><p>The <code>\x</code>, <code>\u</code>, and <code>\U</code> escape sequences require exactly two, four, and eight hexadecimal digits, respectively. Use digits <code>0</code>–<code>9</code> and <code>A</code>–<code>F</code> (uppercase or lowercase) for <code><em>h</em></code>.</p></li>
<li><p>The <code>\o</code> escape accepts one to three octal digits and issues a warning for values over <code>\377</code> in Python 3.12 because values too big for a byte cause issues in byte strings. Use digits <code>0</code>–<code>7</code> for <code><em>o</em></code>.</p></li>
<li><p>Both <code>\u</code> and <code>\U</code> are recognized only in <code>str</code> text-string literals (e.g., <code>'…'</code>), where they give a character’s Unicode code-point value. This is the code point’s decoded value.</p></li>
<li><p><code>\x</code> and <code>\o</code> escapes work in both <code>bytes</code> byte-string literals (<code>b'…'</code>), where they give a byte’s absolute value; and in <code>str</code> text-string literals, where they give a character’s Unicode code-point value.</p></li>
<li><p>Lettered escapes like <code>\n</code> stand for their Unicode code points in text and their ASCII encodings <a contenteditable="false" data-type="indexterm" data-primary="strings" data-secondary="backslash characters" data-startref="strbkcc" id="id1940"></a><a contenteditable="false" data-type="indexterm" data-primary="backslash characters" data-secondary="strings" data-startref="bckccg" id="id1941"></a>in bytes, even if the two values agree (there is more on Unicode escapes in <a data-type="xref" href="ch37.html#unicode_and_byte_strings">Chapter 37</a>).</p></li>
</ul>
<p>Let’s get back to running code. Some string escape sequences allow you to embed absolute values as characters of a string. When you do this, you’re really giving the <em>code-point</em> value of the desired character. For instance, here’s a five-character string that embeds two characters with zero values (coded as octal escapes of one digit):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>s = 'a\0b\0c'</strong></code>
&gt;&gt;&gt; <code><strong>s</strong></code>
'a\x00b\x00c'
&gt;&gt;&gt; <code><strong>len(s)</strong></code>
5</pre>
<p>The character associated with <a contenteditable="false" data-type="indexterm" data-primary="NULL character" id="id1942"></a><a contenteditable="false" data-type="indexterm" data-primary="strings" data-secondary="NULL character" id="id1943"></a>code point 0 is generally known as NULL (or NUL). Importantly, in Python, a character like this does not terminate a string the way a “null byte” typically does in C. Instead, Python keeps both the string’s length and text in memory. In fact, <em>no</em> character terminates a string in Python. Here’s a string that is all absolute escape codes—an absolute 1 and 2 (coded in octal), followed by an absolute 3 (coded in hexadecimal), and nonprintables all:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>s = '\001\002\x03'</strong></code>
&gt;&gt;&gt; <code><strong>s</strong></code>
'\x01\x02\x03'
&gt;&gt;&gt; <code><strong>len(s)</strong></code>
3</pre>
<p class="pagebreak-before">Notice that Python displays nonprintable characters in hex, regardless of how they were specified. When needed, you can freely combine characters, absolute-value escapes, and the more symbolic escapes in <a data-type="xref" href="#string_backslash_characters">Table 7-2</a>. To demo, the following string contains the characters “HACK”, a tab and newline, and an absolute zero character coded in hex:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>S = 'H\tA\nC\x00K'</strong></code>
&gt;&gt;&gt; <code><strong>S</strong></code>
'H\tA\nC\x00K'
&gt;&gt;&gt; <code><strong>len(S)</strong></code>
7
&gt;&gt;&gt; <code><strong>print(S)</strong></code>
H   A
CK</pre>
<p>This becomes more important to know when you process binary data files in Python. Because their contents are represented as strings in your scripts, it’s OK to process binary files that contain any sorts of binary byte values. When opened in binary modes, files return raw bytes from the external file as <code>bytes</code>—a string variant that supports most of the syntax and tools in this chapter (you’ll find more on files and <code>bytes</code> in Chapters <a data-xrefstyle="select:labelnumber" data-type="xref" href="ch04.html#introducing_python_objects">4</a>, <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch09.html#tuplescomma_filescomma_and_everything_e">9</a>, and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch37.html#unicode_and_byte_strings">37</a>).</p>
<p>Two limits in <a data-type="xref" href="#string_backslash_characters">Table 7-2</a> merit callouts. First of all, <em>octal</em> escapes with values too large for a byte issue warnings as of Python 3.12 and will be errors soon—despite the fact that these escapes in <em>text</em> strings denote code points, not bytes:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>'\400'</strong></code>
&lt;stdin&gt;:1: SyntaxWarning: invalid octal escape sequence '\400'
'Ā'</pre>
<p>This seems unlikely to break much code, but the last entry in <a data-type="xref" href="#string_backslash_characters">Table 7-2</a> may: if Python does not recognize the character after a <code>\</code> as being a valid escape code, it simply keeps the backslash in the resulting string—at least for the moment:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>x = 'C:\py\code'</strong></code>    
&lt;stdin&gt;:1: SyntaxWarning: invalid escape sequence '\p'

&gt;&gt;&gt; <code><strong>x</strong></code>                         <code><em># Keeps \ literally (and displays it as \\)</em></code>
<code><strong>'C:\\py\\code'</strong></code>
&gt;&gt;&gt; <code><strong>len(x)</strong></code>                    <code><em># But not for long: don't rely on this anymore!</em></code>
10</pre>
<p>Despite this behavior being expected (and even relied upon) for three decades, it has recently been judged bad and has started issuing a warning when used. In Python 3.12, it invokes a syntax warning that doesn’t stop your program but clutters your output with nags. Worse, this will be treated as a programming-ending <em>error</em> in a future Python, so you should not use this going forward—and are expected to change all the code you’ve written in the past that does!</p>
<p>Even without this backward-incompatible Python change, though, strings that rely on this behavior seem as likely to lose backslashes in escapes as to retain them elsewhere. Instead, code <a contenteditable="false" data-type="indexterm" data-primary="strings" data-secondary="escape characters" data-startref="stresccc" id="id1944"></a><a contenteditable="false" data-type="indexterm" data-primary="escape characters" data-startref="excchc" id="id1945"></a><a contenteditable="false" data-type="indexterm" data-primary="special characters, escape sequences" data-startref="spcccp" id="id1946"></a>literal backslashes explicitly such that they are retained in your strings in all Pythons, by either doubling them with <code>\\</code> (an escape for one <code>\</code>), or using raw strings—the topic of the next section.</p>
</div></section>
<section data-type="sect2" class="pagebreak-before" data-pdf-bookmark="Raw Strings Suppress Escapes"><div class="sect2" id="raw_strings_suppress_escapes">
<h2 class="less_space">Raw Strings Suppress Escapes</h2>
<p>As we’ve already seen, escape sequences <a contenteditable="false" data-type="indexterm" data-primary="strings" data-secondary="raw" id="strrww"></a><a contenteditable="false" data-type="indexterm" data-primary="raw strings" data-secondary="escape sequences and" id="rwsgcq"></a><a contenteditable="false" data-type="indexterm" data-primary="escape characters" data-secondary="raw strings" id="escccwt"></a>are handy for embedding special characters in strings. Sometimes, though, the special treatment of backslashes for introducing escapes can lead to trouble. It’s surprisingly common, for instance, to see Python newcomers trying to open a file on Windows with a filename argument that looks something like this:</p>
<pre data-type="programlisting">myfile = open('C:\new\text.dat', 'w')</pre>
<p>thinking that they will open a file called <em>text.dat</em> in the directory <em>C:\new</em>. The problem with this is that <code>\n</code> is taken to stand for a newline character, and <code>\t</code> is replaced with a tab. In effect, the call tries to open a file named <em>C:(newline)ew(tab)ext.dat</em>, with usually less-than-stellar results.</p>
<p>This is just the sort of thing that <em>raw strings</em> are meant to address. If the letter <code>r</code> (uppercase or lowercase, but usually the latter) appears just before the opening quote of any string literal covered in this chapter, it turns off the escape mechanism. The result is that Python retains your backslashes <em>literally</em>, exactly as they appear in the string. Hence, to fix the filename problem, just remember to add the letter <code>r</code> on <span class="keep-together">Windows</span>:</p>
<pre data-type="programlisting">myfile = open(<code><strong>r</strong></code>'C:\new\text.dat', 'w')         <code><em># Works: disable \ escapes</em></code></pre>
<p>Alternatively, because, as noted in the preceding section, two backslashes are really an escape sequence for one backslash, you can keep your backslashes by simply doubling them up when they should be taken verbatim:</p>
<pre data-type="programlisting">myfile = open('C:<code><strong>\\</strong></code>new<code><strong>\\</strong></code>text.dat', 'w')        <code><em># Also works: \\ means \</em></code></pre>
<p>In fact, Python itself sometimes uses this doubling scheme when it prints strings with embedded <span class="keep-together">backslashes</span>:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>path = r'C:\new\text.dat'</strong>   </code>               <code><em># Raw string: keep \s</em></code>
&gt;&gt;&gt; <code><strong>path</strong></code>                                       <code><em># Show as Python code</em></code>
'C:\\new\\text.dat'
&gt;&gt;&gt; <code><strong>print(path)</strong></code>                                <code><em># User-friendly format</em></code>
C:\new\text.dat
&gt;&gt;&gt; <code><strong>len(path)</strong></code>                                  <code><em># String length: \s
</em></code>15</pre>
<p>As covered in <a data-type="xref" href="ch05.html#numbers_and_expressions">Chapter 5</a>, the default format at the interactive prompt prints results as if they were code, and therefore escapes backslashes in the output. The <code>print</code> statement provides a more user-friendly format that shows that there is actually only one backslash in each spot. To verify this is the case, you can check the result of the built-in <code>len</code> function, which returns the number of characters in the string, independent of display formats. If you count the characters in the <code>print(path)</code> output, you’ll see that there really is just 1 character per backslash, for a total of 15.</p>
<p>Besides directory paths on Windows, raw strings are also commonly used for <em>regular expressions</em> in text pattern matching, supported with the <code>re</code> module introduced in <a data-type="xref" href="ch37.html#unicode_and_byte_strings">Chapter 37</a>. Also note that Python scripts can usually use <em>forward</em> slashes in directory paths on both Windows and Unix because this slash is interpreted portably (e.g., <code>'C:<strong>/</strong>new<strong>/</strong>text.dat'</code> works when opening Windows files, too). Raw strings are useful for paths using native Windows backslashes, though, and any other time you want to ensure that Python will leave your <code>\</code> alone. They also work for triple-quoted strings to suppress escapes (and future invalid-escape errors!) in text of the sort up next.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><em>Raw-string quirk</em>: Despite its role, even a raw string <em>cannot end</em> in a single backslash, because the backslash escapes the following quote character. That is, <code>r'…\'</code> is not a valid string literal: you still must escape the surrounding quote character to embed it in the string, and Python assumes that is your intent. The upshot is that a raw string cannot end in an odd number of backslashes, including one. If you need to end a raw string with a single backslash, you can use two and slice off the second (<code>r'…\\'[:-1]</code>), tack one on manually (<code>r'…' + '\\'</code>), or skip the raw string syntax and just double up the backslashes in a normal string (<code>'…\\'</code>). All three of these forms create the same two-character string with a Unicode ellipsis <a contenteditable="false" data-type="indexterm" data-primary="strings" data-secondary="raw" data-startref="strrww" id="id1947"></a><a contenteditable="false" data-type="indexterm" data-primary="raw strings" data-secondary="escape sequences and" data-startref="rwsgcq" id="id1948"></a><a contenteditable="false" data-type="indexterm" data-primary="escape characters" data-secondary="raw strings" data-startref="escccwt" id="id1949"></a>and one backslash.</p>
</div>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Triple Quotes and Multiline Strings"><div class="sect2" id="triple_quotes_and_multiline_strings">
<h2>Triple Quotes and Multiline Strings</h2>
<p>So far, you’ve seen single quotes, double quotes, escapes, and raw strings in action. Python also has a triple-quoted <a contenteditable="false" data-type="indexterm" data-primary="strings" data-secondary="triple-quotes" id="strtrp"></a><a contenteditable="false" data-type="indexterm" data-primary="triple-quoted strings" id="trpqg"></a><a contenteditable="false" data-type="indexterm" data-primary="strings" data-secondary="block strings" id="stbkst"></a><a contenteditable="false" data-type="indexterm" data-primary="block strings" id="blksgr"></a><a contenteditable="false" data-type="indexterm" data-primary="strings" data-secondary="multiline" id="stgmtln"></a><a contenteditable="false" data-type="indexterm" data-primary="multiline strings" id="mlttrg"></a>string literal format, sometimes called a <em>block string</em>, that is a syntactic convenience for coding multiline data. This form begins with three quotes (of either the single or double variety), is followed by any number of lines of text, and is closed with the same triple-quote sequence that opened it. Single and double quotes embedded in the string’s text may be, but do not have to be, escaped—the string does not end until Python sees three unescaped quotes of the same kind used to start the literal. For example:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>quip = """Python strings</strong></code>
... <code> <strong> sure have</strong></code>
... <code><strong>a lot of options"""</strong></code>
&gt;&gt;&gt; 
&gt;&gt;&gt; <code><strong>quip</strong></code>
'Python strings\n  sure have\na lot of options'</pre>
<p>This string spans three lines. As you learned in <a data-type="xref" href="ch03.html#how_you_run_programs">Chapter 3</a>, the interactive prompt changes to <code>...</code> on continuation lines like this in some interfaces, but not in others. This book omits the dots in some examples to enable cut-and-paste, but don’t type them yourself if they’re listed as they are here but absent in your REPL, and extrapolate as needed.</p>
<p>Prompts aside, Python collects all the triple-quoted text in this example into a single multiline string, with embedded newline characters (<code>\n</code>) at the places where your code has physical line breaks. Notice that, as in the literal, the second line in the result has leading spaces, but the third does not—what you type is truly what you get. To see the string with the newlines interpreted, print it instead of echoing:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>print(quip)</strong></code>
Python strings
  sure have
a lot of options</pre>
<p>In fact, triple-quoted strings will retain all the enclosed text, <em>including</em> any to the right of your code that you might intend as <em>comments</em>. So don’t do this—put your comments above or below the quoted text, or use the automatic concatenation of adjacent strings mentioned earlier, with explicit newlines if needed, and surrounding parentheses to allow line spans (you’ll learn more about this latter form when you study syntax rules in Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch10.html#introducing_python_statements">10</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch12.html#if_and_match_selections">12</a>):</p>
<pre class="pagebreak-before" data-type="programlisting">&gt;&gt;&gt; <code><strong>menu = """</strong></code>
... <code><strong>Open           # Comments here added to string!</strong></code>
... <code><strong>Save           # Ditto</strong></code>
... <code><strong>"""</strong></code>
&gt;&gt;&gt; <code><strong>menu</strong></code>
'\nOpen           # Comments here added to string!\nSave           # Ditto\n'

&gt;&gt;&gt; <code><strong>menu = (</strong></code>
... <code><strong>'Open\n'       # Comments here ignored</strong></code>
... <code><strong>'Save\n'       # But newlines not automatic</strong></code>
... <code><strong>)</strong></code>
&gt;&gt;&gt; <code><strong>menu</strong></code>
'Open\nSave\n'</pre>
<p>So why use triple-quoted strings? For one thing, they <a contenteditable="false" data-type="indexterm" data-primary="multiline text, triple-quoted strings" id="id1950"></a>are useful anytime you need <em>multiline text</em> in your program—for example, to embed multiline error messages, or HTML, XML, JSON, or YAML code in your Python source code files. You can usually embed such blocks directly in your scripts by triple-quoting without resorting to external text files or concatenation and newline characters.</p>
<p>Triple-quoted strings are also <a contenteditable="false" data-type="indexterm" data-primary="docstrings" id="id1951"></a><a contenteditable="false" data-type="indexterm" data-primary="strings" data-secondary="docstrings" id="id1952"></a>commonly used for <em>docstrings</em> (documentation strings), which are string literals that are taken as comments when they appear at specific points in your file (and are covered in full in <a data-type="xref" href="ch15.html#the_documentation_interlude">Chapter 15</a>). These don’t have to be triple-quoted blocks, but they usually are to allow for multiline comments and may need to be triple-quoted raw strings (e.g., <code>r'''</code>) to avoid invalid escape errors in the future (see the 3.12 syntax warnings noted previously).</p>
<p>Finally, triple-quoted strings are also sometimes used as a “horribly hackish” way <em>to temporarily disable</em> lines <a contenteditable="false" data-type="indexterm" data-primary="disabling code, triple-quoted strings" id="id1953"></a>of code during development. Really, it’s not too horrible, and it’s actually a fairly common practice today, but it wasn’t the original intent of the literal. If you wish to turn off a few lines of code and run your script again, simply put three quotes above and below them, like this:</p>
<pre data-type="programlisting">X = 1
"""
import os                            <code><em># Disable this code temporarily</em></code>
print(os.getcwd())
"""
Y = 2</pre>
<p>This was tagged as “hackish” because Python really might make a string out of the lines of code disabled this way, but this is probably not significant in terms of performance. For large sections of code, it’s also easier than manually adding hash marks before each line and later removing them. This is especially true if you are using a <a contenteditable="false" data-type="indexterm" data-primary="strings" data-secondary="triple-quotes" data-startref="strtrp" id="id1954"></a><a contenteditable="false" data-type="indexterm" data-primary="triple-quoted strings" data-startref="trpqg" id="id1955"></a><a contenteditable="false" data-type="indexterm" data-primary="strings" data-secondary="block strings" data-startref="stbkst" id="id1956"></a><a contenteditable="false" data-type="indexterm" data-primary="block strings" data-startref="blksgr" id="id1957"></a><a contenteditable="false" data-type="indexterm" data-primary="strings" data-secondary="multiline" data-startref="stgmtln" id="id1958"></a><a contenteditable="false" data-type="indexterm" data-primary="multiline strings" data-startref="mlttrg" id="id1959"></a>text editor that does not have support for editing Python code specifically. In Python, practicality often beats aesthetics.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Strings in Action"><div class="sect1" id="strings_in_action">
<h1>Strings in Action</h1>
<p>Once you’ve created a string with the literal expressions we just met, you will almost certainly want to do things with it. This section and the next two demonstrate string expressions, methods, and formatting—the first line of text-processing tools in the Python language.</p>
<section data-type="sect2" data-pdf-bookmark="Basic Operations"><div class="sect2" id="basic_operations">
<h2>Basic Operations</h2>
<p>Let’s begin by interacting with <a contenteditable="false" data-type="indexterm" data-primary="strings" data-secondary="operations" id="sgspr"></a><a contenteditable="false" data-type="indexterm" data-primary="operations" data-secondary="strings" id="oprstg"></a>the Python interpreter to illustrate the basic string operations listed earlier in <a data-type="xref" href="#common_string_literals_and_operations">Table 7-1</a>. You can <a contenteditable="false" data-type="indexterm" data-primary="strings" data-secondary="concatenation" id="id1960"></a><a contenteditable="false" data-type="indexterm" data-primary="concatenation" data-secondary="strings" id="id1961"></a>concatenate strings using the <code>+</code> operator and repeat them using the <code>*</code> operator:</p>
<pre class="pagebreak-before" data-type="programlisting">&gt;&gt;&gt; <code><strong>len('abc')</strong></code>            <code><em># Length: number of items
</em></code>3
&gt;&gt;&gt; <code><strong>'abc' + 'def'</strong></code>         <code><em># Concatenation: a new string</em></code>
'abcdef'
&gt;&gt;&gt; <code><strong>'Py!' * 4</strong></code>             <code><em># Repetition: like 'Py!' + 'Py!' + 'Py!' + 'Py!'</em></code>
'Py!Py!Py!Py!'</pre>
<p>The <code>len</code> built-in function here returns the length of a string (or any other object with a length). Formally, adding two string objects with <code>+</code> creates a new string object, with the contents of its operands joined, and repetition with <code>*</code> is like adding a string to itself a given number of times (minus one). In both cases, Python lets you create arbitrarily sized strings; there’s no need to predeclare anything in Python, including the sizes of data structures—you simply build string objects as needed and let Python manage the underlying memory space automatically, as we learned in <a data-type="xref" href="ch06.html#the_dynamic_typing_interlude">Chapter 6</a>.</p>
<p>Repetition may seem a bit obscure at first, but it comes in handy in a surprising number of contexts. For example, to print a line of 80 dashes, you can count up to 80, or let Python count for you:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>print('------</strong></code> …<code><em>more</em></code>… <code><strong>------')</strong></code>        <code><em># 80 dashes, the hard way</em></code>
&gt;&gt;&gt; <code><strong>print('-' * 80)</strong></code>                      <code><em># 80 dashes, the easy way</em></code></pre>
<p>Notice that the <em>operator overloading</em> and <em>polymorphism</em> called out in <a data-type="xref" href="ch05.html#numbers_and_expressions">Chapter 5</a> and earlier is at work <a contenteditable="false" data-type="indexterm" data-primary="strings" data-secondary="polymorphism and" id="id1962"></a><a contenteditable="false" data-type="indexterm" data-primary="strings" data-secondary="operator overload and" id="id1963"></a><a contenteditable="false" data-type="indexterm" data-primary="polymorphism" data-secondary="strings and" id="id1964"></a><a contenteditable="false" data-type="indexterm" data-primary="operator overloading" data-secondary="strings" id="id1965"></a>here already: we’re using the same <code>+</code> and <code>*</code> operators that perform addition and multiplication when using numbers. Python does the correct operation because it knows the types of the objects being added and multiplied. But be careful: the rules aren’t quite as liberal as you might expect. For instance, Python doesn’t allow you to mix numbers and strings in <code>+</code> expressions: <code>'abc'+9</code> raises an error instead of automatically converting <code>9</code> to a string (we’ll fix this ahead).</p>
<p>As shown near the end of <a data-type="xref" href="#common_string_literals_and_operations">Table 7-1</a>, you can also iterate over strings in <a contenteditable="false" data-type="indexterm" data-primary="strings" data-secondary="loops and" id="id1966"></a><a contenteditable="false" data-type="indexterm" data-primary="loops" data-secondary="strings and" id="id1967"></a><a contenteditable="false" data-type="indexterm" data-primary="iteration" data-secondary="strings" id="id1968"></a><a contenteditable="false" data-type="indexterm" data-primary="strings" data-secondary="iteration" id="id1969"></a><a contenteditable="false" data-type="indexterm" data-primary="statements" data-secondary="for" id="id1970"></a>loops using <code>for</code> statements, which repeat actions, and test membership for both characters and substrings with the <code>in</code> expression operator, which is essentially a search. For substrings, <code>in</code> is much like the <code>str.find()</code> method covered later in this chapter, but it returns a Boolean result instead of the substring’s position (don’t be alarmed if the following’s <code>print</code> indents your prompt; its <code>end=' '</code> changes the default newline character at the end of the display to a space):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>myjob = 'hacker'</strong></code>
&gt;&gt;&gt; <code><strong>for c in myjob:</strong> </code>                    <code><em># Step through items, print each + ' '</em></code>                
...     <code><strong>print(c, end=' ')</strong></code>               <code><em># Suppress newlines after each item</em></code>
...
h a c k e r
&gt;&gt;&gt; <code><strong>'k' in myjob</strong></code>                        <code><em># Found</em></code>
True
&gt;&gt;&gt; <code><strong>'z' in myjob</strong></code>                        <code><em># Not found</em></code>
False
&gt;&gt;&gt; <code><strong>'HACK' in 'abcHACKdef'</strong></code>              <code><em># Substring search, no position returned</em></code>
True</pre>
<p>The <code>for</code> loop, previewed in <a data-type="xref" href="ch04.html#introducing_python_objects">Chapter 4</a>, assigns a variable to successive items in a sequence (here, a string) and executes one or more statements (normally indented) for each item. In effect, the variable <code>c</code> becomes a cursor stepping across the string’s characters. Because iteration turns out to be a big idea in Python, we <a contenteditable="false" data-type="indexterm" data-primary="strings" data-secondary="operations" data-startref="sgspr" id="id1971"></a><a contenteditable="false" data-type="indexterm" data-primary="operations" data-secondary="strings" data-startref="oprstg" id="id1972"></a>will discuss iteration tools like these and others listed in <a data-type="xref" href="#common_string_literals_and_operations">Table 7-1</a> in more detail later in this book (see Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch14.html#iterations_and_comprehensions">14</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch20.html#comprehensions_and_generations">20</a>).</p>
</div></section>
<section data-type="sect2" class="pagebreak-before" data-pdf-bookmark="Indexing and Slicing"><div class="sect2" id="indexing_and_slicing-id00066">
<h2 class="less_space">Indexing and Slicing</h2>
<p>Because strings are ordered collections (a.k.a. <em>sequences</em>) of characters, we can access their <a contenteditable="false" data-type="indexterm" data-primary="strings" data-secondary="indexing" id="stdxi"></a><a contenteditable="false" data-type="indexterm" data-primary="strings" data-secondary="slicing" id="strslc"></a><a contenteditable="false" data-type="indexterm" data-primary="slicing" data-secondary="strings" id="slcgrs"></a><a contenteditable="false" data-type="indexterm" data-primary="indexing" data-secondary="strings" id="dxsgrg"></a>components by position. As introduced in <a data-type="xref" href="ch04.html#introducing_python_objects">Chapter 4</a>, characters in a string are fetched by <em>indexing</em>—providing the numeric offset of the desired component in square brackets after the string. You get back the one-character string at the specified position.</p>
<p>As in most C-like languages, Python offsets start at 0 and end at one less than the length of the string (and the “start at 0” part may be a short-lived hurdle if you’re accustomed to counting from 1). Unlike C, however, Python also lets you fetch items from sequences such as strings using <em>negative</em> offsets. Technically, a negative offset is added to the length of a string to derive a positive offset, but you can also think of negative offsets as counting backward from the end. The following interaction demonstrates:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>S = 'code'</strong></code>
&gt;&gt;&gt; <code><strong>S[0], S[-2]</strong></code>                         <code><em># Indexing from front or end</em></code>
('c', 'd')
&gt;&gt;&gt; <code><strong>S[1:3], S[1:], S[:-1]</strong></code>              <code> <em># Slicing: extract a section</em></code>
('od', 'ode', 'cod')</pre>
<p>In this code, the first line defines a four-character string and assigns it to the name <code>S</code>. The next line <em>indexes</em> it in two ways: <code>S[0]</code> fetches the item at offset 0 from the left—the one-character string <code>'c'</code> at the front; and <code>S[−2]</code> gets the item at offset 2 back from the end—or equivalently, at offset (4 + (−2)) from the front.</p>
<p>The last line in the foregoing example demonstrates <em>slicing</em>, a generalized form of indexing that returns an entire <em>section</em>, instead of a single item. It can be used to extract columns of data, chop off prefixes and suffixes, and more. Slicing can <a contenteditable="false" data-type="indexterm" data-primary="slicing" data-secondary="parsing" id="id1973"></a><a contenteditable="false" data-type="indexterm" data-primary="parsing" data-secondary="slicing" id="id1974"></a>also be viewed as a type of <em>parsing</em> (decomposing content), especially when applied to strings, because it’s an easy way to extract substrings. In fact, we’ll explore slicing in the context of text parsing later in this chapter.</p>
<p>Slicing works like this: when you index a sequence object such as a string on a pair of offsets separated by a colon, Python returns a new object containing the contiguous section identified by the offset pair. The left offset is taken to be the lower bound (<em>inclusive</em>), and the right is the upper bound (<em>noninclusive</em>). That is, Python fetches all items from the lower bound up to but not including the upper bound and returns a new object containing the fetched items. If omitted, the left and right bounds default to 0 and the length of the object you are slicing, respectively.</p>
<p>For instance, in the example we just ran, <code>S[1:3]</code> extracts the items at offsets <em>1 and 2</em>—it grabs the second and third items and stops before the fourth item at offset 3. Next, <code>S[1:]</code> gets <em>all items beyond the first</em>—the upper bound, which is not specified, defaults to the length of the string, which is off the end. Finally, <code>S[:−1]</code> fetches <em>all but the last item</em>—the lower bound defaults to 0, and −1 refers to the last item, noninclusive. In more graphic terms, indexes and slices map to cells as shown in <a data-type="xref" href="#indexes_and_slices_positives_start_from">Figure 7-1</a>.</p>
<figure><div id="indexes_and_slices_positives_start_from" class="figure">
<img src="assets/lpy6_0701.png" alt="" width="1055" height="280"/>
<h6><span class="label">Figure 7-1. </span>Indexes and slices: positives start from the left (0) and negatives from the right (–1)</h6>
</div></figure>
<p>All of which may seem confusing at first glance, but indexing and slicing are simple and powerful tools to use once you get the knack. Remember, if you’re unsure about the effects of a slice, try it out interactively. In the next chapter, you’ll see that it’s even possible to change an entire section of another object in one step by <em>assigning</em> to a slice (though not for immutables like the strings we’re studying here). For now, here’s a cheat sheet of the details for reference:</p>
<p><em>Indexing</em>—<code>S[<em>I</em>]</code>—fetches components at offsets in sequences:</p>
<ul>
<li><p>The first item is at offset 0.</p></li>
<li><p>Negative indexes mean counting backward from the end or right.</p></li>
<li><p>Out-of-bounds offsets are an error.</p></li>
<li><p><code>S[0]</code> fetches the first item.</p></li>
<li><p><code>S[−2]</code> fetches the second item from the end (like <code>S[len(S)−2]</code>).</p></li>
</ul>
<p><em>Slicing</em>—<code>S[<em>I</em>:<em>J</em>]</code>—extracts contiguous sections of sequences:</p>
<ul>
<li><p>The upper bound is noninclusive.</p></li>
<li><p>Slice bounds default to 0 and the sequence length, if omitted.</p></li>
<li><p>Out-of-bounds offsets are adjusted to be in bounds.</p></li>
<li><p><code>S[1:3]</code> fetches items at offsets 1 up to but not including 3.</p></li>
<li><p><code>S[1:]</code> fetches items at offset 1 through the end (the sequence length).</p></li>
<li><p><code>S[:3]</code> fetches items at offset 0 up to but not including 3.</p></li>
<li><p><code>S[:−1]</code> fetches items at offset 0 up to but not including the last item.</p></li>
<li><p><code>S[:]</code> fetches items at offsets 0 through the end—making a top-level copy of <code>S</code>.</p></li>
</ul>
<p><em>Extended slicing</em>—<code>S[<em>I</em>:<em>J</em>:<em>K</em>]</code>—accepts a step (or stride) <code>K</code>, which defaults to +1:</p>
<ul>
<li><p>Allows for skipping items and reversing order—see the next section.</p></li>
</ul>
<p>The second-to-last bullet item listed here turns out to be a common technique: <code>S[:]</code> makes a full top-level <em>copy</em> of a sequence object—an object with the same value, but a distinct piece of memory (you’ll find more on copies in <a data-type="xref" href="ch09.html#tuplescomma_filescomma_and_everything_e">Chapter 9</a>). This isn’t very useful for immutable objects like strings, but it comes in handy for objects that may be changed in place, such as lists: making a copy can avoid the side effects of shared references shown in <a data-type="xref" href="ch06.html#the_dynamic_typing_interlude">Chapter 6</a>.</p>
<p>Also per the cheat sheet, slices differ from indexes in their policy on <em>out-of-bounds</em> (off the end) offsets: they’re always <em>errors</em> in indexing, because the offset does not exist, but <em>scaled</em> to be in bounds in slicing, because this can be useful in programs that need to accommodate sizes flexibly:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>S = 'code'</strong></code>
&gt;&gt;&gt; <code><strong>S[99]</strong></code>
IndexError: string index out of range
&gt;&gt;&gt; <code><strong>S[1:99]</strong></code>
'ode'</pre>
<p>Because we’re going to explore this oddity in an end-of-part exercise, though, we’ll cut the story short here.</p>
<section data-type="sect3" class="pagebreak-before" data-pdf-bookmark="Extended slicing: The third limit and slice objects"><div class="sect3" id="extended_slicing_the_third_limit_and_sl">
<h3 class="less_space">Extended slicing: The third limit and slice objects</h3>
<p>Though not commonly used, slice expressions <a contenteditable="false" data-type="indexterm" data-primary="slicing" data-secondary="strings" data-tertiary="extended slicing" id="id1975"></a><a contenteditable="false" data-type="indexterm" data-primary="extended slicing" id="id1976"></a><a contenteditable="false" data-type="indexterm" data-primary="strings" data-secondary="slicing" data-tertiary="extended slicing" id="id1977"></a>also support an optional third index, used as a <em>step</em> (sometimes called a <em>stride</em>). The step is added to the index of each item extracted. With it, the full-blown form of a slice is <code>S[<em>I</em>:<em>J</em>:<em>K</em>]</code>, which means “extract all the items in <code>S</code>, from offset <code><em>I</em></code> through <code><em>J</em></code>−1, by <code><em>K</em></code>.” The third limit, <code>K</code>, defaults to +1, which is why normally all items in a slice are extracted from left to right. If you specify an explicit value, however, you can use the third limit to skip items or to reverse their order.</p>
<p>For instance, <code>S[1:10:2]</code> will fetch <em>every other item</em> in <code>S</code> from offsets 1–9; that is, it will collect the items at offsets 1, 3, 5, 7, and 9. As usual, the first and second limits default to 0 and the length of the sequence, respectively, so <code>X[::2]</code> gets every other item from the beginning to the end of the sequence:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>S = 'abcdefghijklmnop'</strong></code>
&gt;&gt;&gt; <code><strong>S[1:10:2]</strong></code>                          <code><em># Skipping items</em></code>
'bdfhj'
&gt;&gt;&gt; <code><strong>S[::2]</strong></code>
'acegikmo'</pre>
<p>You can also use a negative stride to collect items in the opposite order. For example, in the slicing <a contenteditable="false" data-type="indexterm" data-primary="expressions" data-secondary="slicing expression" id="id1978"></a>expression <code>S[::−1]</code>, the first two bounds default to sequence length–1 and –1 (they really default to <code>None</code> and <code>None</code>, but that’s unimportant here), and a stride of −1 indicates that the slice should go from right to left instead of the usual left to right. In much simpler terms, the effect is to <em>reverse</em> the sequence:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>S = 'hello'</strong></code>
&gt;&gt;&gt; <code><strong>S[::−1]</strong></code>                           <code> <em># Reversing items</em></code>
'olleh'</pre>
<p>With a negative stride, the meanings of the first two bounds are essentially reversed. That is, the slice <code>S[5:1:−1]</code> fetches the items from 2 to 5, in reverse order (the result contains items from offsets 5, 4, 3, and 2):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>S = 'abcedfg'</strong></code>
&gt;&gt;&gt; <code><strong>S[5:1:−1]</strong></code>                          <code><em># Bounds roles differ</em></code>
'fdec'</pre>
<p>Skipping and reversing like this are the most common use cases for three-limit slices, but see Python’s standard-library manual for more details (or run a few experiments interactively). We’ll revisit three-limit slices again later in this book, in conjunction with the <code>for</code> loop statement.</p>
<p>Later in the book, you’ll also learn that slicing is equivalent to indexing with a <em>slice object</em>, a finding of importance to class writers seeking to support both operations:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>'code'[1:3]</strong></code>                       <code><em># Slicing syntax</em></code>
'od'
&gt;&gt;&gt; <code><strong>'code'[slice(1, 3)]</strong></code>               <code><em># Slice objects with index syntax + object</em></code>
'od'
&gt;&gt;&gt; <code><strong>'code'[::-1]</strong></code>
'edoc'
&gt;&gt;&gt; <code><strong>'code'[slice(None, None, -1)]</strong></code>
'edoc'</pre>
<aside data-type="sidebar" epub:type="sidebar" class="pagebreak-before less_space"><div class="sidebar" id="why_you_will_care_slices">
<h1>Why You Will Care: Slices</h1>
<p>Throughout this book, you’ll meet common use-case sidebars such as this one that give you a peek at how some of the language features being discussed are typically used in real programs. Because you won’t be able to make much sense of realistic use cases until you’ve seen more of the Python picture, these sidebars necessarily contain many references to topics not introduced yet; at most, you should consider them previews of ways that you may find these abstract language concepts useful for practical programming tasks.</p>
<p>For instance, you’ll see later that the argument words listed on a system command line used to launch a Python program are made available in the <code>argv</code> attribute of the built-in <code>sys</code> module:</p>
<pre data-type="programlisting"><em># File echo.py</em>
import sys
print(sys.argv)

$ <code><strong>python3 echo.py −a −b −c</strong></code>
['echo.py', '−a', '−b', '−c']</pre>
<p>Usually, you’re interested only in inspecting the arguments that follow the program name. This leads to a typical application of slices: a single slice expression can be used to return all but the first item of a list. Here, <code>sys.argv[1:]</code> returns the desired list, <code>['−a', '−b', '−c']</code>. You can then process this list without having to accommodate the program name at the front.</p>
<p>Slices are also often used to clean up lines read from input files, of the sort we’ll study in <a data-type="xref" href="ch09.html#tuplescomma_filescomma_and_everything_e">Chapter 9</a>. If you know that a line will have a <a contenteditable="false" data-type="indexterm" data-primary="slices" data-secondary="cleanup and" id="id1979"></a>newline character at the end (a <code>\n</code>), you can get rid of it with a single expression such as <code>line[:−1]</code>, which extracts all but the last character in the line. In both cases, slices do the job of logic that must be explicit in a lower-level language.</p>
<p>Having said that, calling the <code>line.rstrip</code> method is often preferred for stripping newline characters because this call leaves the line intact if it has no newline character <a contenteditable="false" data-type="indexterm" data-primary="strings" data-secondary="indexing" data-startref="stdxi" id="id1980"></a><a contenteditable="false" data-type="indexterm" data-primary="strings" data-secondary="slicing" data-startref="strslc" id="id1981"></a><a contenteditable="false" data-type="indexterm" data-primary="slicing" data-secondary="strings" data-startref="slcgrs" id="id1982"></a><a contenteditable="false" data-type="indexterm" data-primary="indexing" data-secondary="strings" data-startref="dxsgrg" id="id1983"></a>at the end—a common case for files created with some text-editing tools. Slicing works only if you’re sure the line is properly terminated.</p>
</div></aside>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="String Conversion Tools"><div class="sect2" id="string_conversion_tools">
<h2>String Conversion Tools</h2>
<p>One of Python’s design <a contenteditable="false" data-type="indexterm" data-primary="strings" data-secondary="conversion" id="id1984"></a>mottos is that it refuses the temptation to guess. As a prime example, you cannot add a number and a string together in Python, even if the string looks like a number (i.e., is all digits):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>'62' + 1</strong></code>
TypeError: can only concatenate str (not "int") to str</pre>
<p>This is by design: because <code>+</code> can mean both addition and concatenation, the choice of conversion would be ambiguous—do you want <code>'621'</code> or <code>63</code>? Instead, Python treats this as an error. In Python, magic is generally omitted if it will make your coding life more complex.</p>
<p>What to do, then, if your <a contenteditable="false" data-type="indexterm" data-primary="strings" data-secondary="conversion" data-tertiary="strings to numbers" id="id1985"></a>script obtains a number as a text string from a file or user interface? The trick is that you must simply employ conversion tools before you can treat a string like a number, or vice versa. For instance:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>int('62'), str(62)</strong></code>          <code><em># Convert from/to string</em></code>
(62, '62')</pre>
<p>The <code>int</code> function converts a string to a number, and the <code>str</code> function converts a number to its string representation (essentially, what it looks like when printed). Now, although you can’t mix strings and number types around operators such as <code>+</code>, you can manually convert operands before that operation if needed:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>S = '62'</strong></code>
&gt;&gt;&gt; <code><strong>I = 1</strong></code>
&gt;&gt;&gt; <code><strong>S + I</strong></code>
TypeError: can only concatenate str (not "int") to str

&gt;&gt;&gt; <code><strong>int(S) + I</strong></code>            <code><em># Force addition</em></code>
63

&gt;&gt;&gt; <code><strong>S + str(I)</strong></code>            <code><em># Force concatenation
</em></code>'621'</pre>
<p>Similar built-in functions <a contenteditable="false" data-type="indexterm" data-primary="strings" data-secondary="conversion" data-tertiary="floating-point numbers" id="id1986"></a><a contenteditable="false" data-type="indexterm" data-primary="floating point numbers" data-secondary="conversion" id="id1987"></a>handle floating-point-number conversions to and from strings, if you need to mix the two in expressions:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>float('1.5') + 2.8</strong></code>
4.3
&gt;&gt;&gt; <code><strong>'1.5' + str(2.8)</strong></code>
'1.52.8'</pre>
<p>The built-in <code>eval</code> function introduced in <a data-type="xref" href="ch05.html#numbers_and_expressions">Chapter 5</a> runs a string containing Python expression code, and so can also convert a string to any kind of object. The <a contenteditable="false" data-type="indexterm" data-primary="eval function" id="id1988"></a><a contenteditable="false" data-type="indexterm" data-primary="functions" data-secondary="eval" id="id1989"></a>functions <code>int</code> and <code>float</code> convert only to numbers, but this restriction means they are usually faster (and more secure, because they do not accept arbitrary expression code). As we also  saw briefly in <a data-type="xref" href="ch05.html#numbers_and_expressions">Chapter 5</a>, string formatting provides other ways to convert numbers to strings; more on it ahead.</p>
<section data-type="sect3" data-pdf-bookmark="Character-code conversions"><div class="sect3" id="character_code_conversions">
<h3>Character-code conversions</h3>
<p>On the subject <a contenteditable="false" data-type="indexterm" data-primary="strings" data-secondary="conversion" data-tertiary="character-code" id="id1990"></a><a contenteditable="false" data-type="indexterm" data-primary="character code conversion" id="id1991"></a>of conversions, it is also possible to convert a single character to its underlying integer code by passing it to the built-in <code>ord</code> function—this returns the numeric “ordinal” value used to represent the corresponding character in memory (technically, its Unicode <em>code point</em>, as you’ll learn in <a data-type="xref" href="ch37.html#unicode_and_byte_strings">Chapter 37</a>, but this isn’t crucial yet). The <code>chr</code> function performs the inverse operation, taking an integer code and converting it to the corresponding character:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>ord('h')</strong></code>               <code><em># Character =&gt; ID (code point)</em></code>
104
&gt;&gt;&gt; <code><strong>chr(104)</strong></code>               <code><em># ID =&gt; character (string)</em></code>
'h'

&gt;&gt;&gt; <code><strong>for c in 'hack':</strong>  </code>     <code><em># All code points in a string</em></code>
...     <code><strong>print(c, ord(c))</strong></code>
... 
h 104
a 97
c 99
k 107</pre>
<p>You can use a loop to apply <code>ord</code> to all characters in a string as shown, but these tools can also be used to perform a simple sort of string-based math. To advance to the next character, for example, convert and do the math in integer:</p>
<pre class="pagebreak-before" data-type="programlisting">&gt;&gt;&gt; <code><strong>S = '5'</strong></code>
&gt;&gt;&gt; <code><strong>S = chr(ord(S) + 1)</strong></code>
&gt;&gt;&gt; <code><strong>S</strong></code>
'6'
&gt;&gt;&gt; <code><strong>S = chr(ord(S) + 1)</strong></code>
&gt;&gt;&gt; <code><strong>S</strong></code>
'7'</pre>
<p>At least for single-character strings, this provides an alternative to using the built-in <code>int</code> function to convert from string to integer (though this only makes sense if character ordinals are ordered as your code expects!):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>int('5')</strong></code>
5
&gt;&gt;&gt; <code><strong>ord('5') - ord('0')</strong></code>
5</pre>
</div></section>
<section data-type="sect3" data-pdf-bookmark="String comparisons"><div class="sect3" id="string_comparisons">
<h3>String comparisons</h3>
<p>Another reason for introducing <a contenteditable="false" data-type="indexterm" data-primary="strings" data-secondary="comparisons" id="id1992"></a><a contenteditable="false" data-type="indexterm" data-primary="ordinals" id="id1993"></a>ordinals here is that it helps us understand <em>string comparisons</em>: when we compare two text strings, Python automatically compares them left to right, character by character, and lexicographically—that is, by the same character code-point values returned by <code>ord</code>—until the first mismatch or end of either string. In the following, for example, the code point of <code>t</code> is greater than that of <code>k</code>, and the longer string at the end wins:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>'hack' == 'hack', 'hact' &gt; 'hack', 'hacker' &gt; 'hack'</strong></code>
(True, True, True)</pre>
<p>The same holds true for the byte strings you’ll meet in <a data-type="xref" href="ch37.html#unicode_and_byte_strings">Chapter 37</a> (they are compared byte for byte until a result is known), and the next chapter’s richer collections like lists do similar (Python compares all their parts for you).</p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="“Changing” Strings Part 1: Sequence Operations"><div class="sect2" id="quotation_markchangingquotation-id00071">
<h2>“Changing” Strings Part 1: Sequence Operations</h2>
<p>Remember the term <em>immutable sequence</em>? As we’ve seen, being a <em>sequence</em> means that strings <a contenteditable="false" data-type="indexterm" data-primary="strings" data-secondary="sequence operations" id="sgsqpt"></a><a contenteditable="false" data-type="indexterm" data-primary="sequence operations" id="id1994"></a>support operations like concatenation, repetition, indexing, and slicing. The <em>immutable</em> part means that you cannot change a string in place—for instance, by assigning to an index:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>S = 'text'</strong></code>
&gt;&gt;&gt; <code><strong>S[0] = 'n'</strong></code>
TypeError: 'str' object does not support item assignment</pre>
<p>How to modify textual information in Python, then? To change a string, you generally need to build a <em>new</em> string using tools such as concatenation and slicing, and assign the result back to the string’s original name if desired:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>S = 'text'</strong></code>
&gt;&gt;&gt; <code><strong>S = S + 'ual!'</strong></code>           <code><em># To change a string, make a new one</em></code>
&gt;&gt;&gt; <code><strong>S</strong></code>
'textual!'
&gt;&gt;&gt; <code><strong>S = S[:4] + ' processing' + S[-1]</strong></code>
&gt;&gt;&gt; <code><strong>S</strong></code>
'text processing!'</pre>
<p>The first example adds a substring at the end of <code>S</code>, by concatenation. Really, it makes a <em>new string</em> and assigns it back to <code>S</code> to save it, but you can think of this as “changing” the original string. The second example replaces three characters with many by slicing, indexing, and concatenating. As you’ll see in the next section, you can achieve similar effects with string methods like <code>replace</code>:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>S = 'text'</strong></code>
&gt;&gt;&gt; <code><strong>S = S.replace('ex', 'hough')</strong></code>
&gt;&gt;&gt; <code><strong>S</strong></code>
'thought'</pre>
<p>Like every operation that yields a new string value, string methods generate new string objects. If you want to retain those objects, you can assign them to variable names. Whether by sequence operations or methods, generating a new string object for each string change is not as inefficient as it may sound—remember, as discussed in the preceding chapter, Python automatically garbage-collects (reclaims the space of) old unused string objects as you go, so newer objects reuse the space held by prior values. Python is usually more efficient than you might expect.</p>
<p>But string methods can do much more, as the next section will explain.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><em>Except for bytearray</em>: As previewed in <a data-type="xref" href="ch04.html#introducing_python_objects">Chapter 4</a> and to be covered in <a data-type="xref" href="ch37.html#unicode_and_byte_strings">Chapter 37</a>, Python has a string type known as <code>bytearray</code>, which <em>is</em> mutable and so may be changed in place. <code>bytearray</code> objects aren’t really text strings; they’re sequences of small, 8-bit integers. However, they support most of the same operations as normal strings and print as ASCII characters when displayed. Accordingly, they provide another option for large <a contenteditable="false" data-type="indexterm" data-primary="strings" data-secondary="sequence operations" data-startref="sgsqpt" id="id1995"></a><a contenteditable="false" data-type="indexterm" data-primary="sequence operations" id="id1996"></a>amounts of simple 8-bit text that must be changed frequently. Richer Unicode text and <em>str</em> strings in general, though, require techniques shown here.</p>
</div>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="String Methods"><div class="sect1" id="string_methods">
<h1>String Methods</h1>
<p>In addition to all the string <a contenteditable="false" data-type="indexterm" data-primary="string methods" id="id1997"></a><a contenteditable="false" data-type="indexterm" data-primary="methods" data-secondary="string methods" id="id1998"></a>operations already introduced, strings provide a set of <em>methods</em> that support more sophisticated text-processing goals. In Python, expressions and built-in functions may work across a range of types, but methods are generally <em>specific to object types</em>—string methods, for example, work only on string objects. Some method names are used by multiple objects in Python for consistency (e.g., many have <code>count</code> and <code>copy</code> methods, and most mutables have a <code>pop</code>), but they are still more type specific than other tools.</p>
<section data-type="sect2" data-pdf-bookmark="Method Call Syntax"><div class="sect2" id="method_call_syntax">
<h2>Method Call Syntax</h2>
<p>As introduced in <a data-type="xref" href="ch04.html#introducing_python_objects">Chapter 4</a>, methods are simply functions that are associated with and act upon <a contenteditable="false" data-type="indexterm" data-primary="string methods" data-secondary="method calls, syntax" id="id1999"></a><a contenteditable="false" data-type="indexterm" data-primary="methods" data-secondary="string methods" data-tertiary="syntax" id="id2000"></a><a contenteditable="false" data-type="indexterm" data-primary="syntax" data-secondary="method calls" id="id2001"></a><a contenteditable="false" data-type="indexterm" data-primary="method calls" data-secondary="syntax" id="id2002"></a>particular objects. Technically, they are attributes attached to objects that happen to reference callable functions which always have an <em>implied subject</em>. In finer-grained detail, functions are packages of code, and method calls combine two operations at once—an attribute fetch and a call:</p>
<dl>
<dt>Attribute fetches</dt>
<dd>An expression of the <a contenteditable="false" data-type="indexterm" data-primary="methods" data-secondary="attribute fetches" id="id2003"></a><a contenteditable="false" data-type="indexterm" data-primary="attribute fetches" id="id2004"></a>form <code><em>object.attribute</em></code> means “fetch the value of <code><em>attribute</em></code> in <code><em>object</em></code>.”</dd>
<dt>Call expressions</dt>
<dd>An expression of the <a contenteditable="false" data-type="indexterm" data-primary="methods" data-secondary="call expressions" id="id2005"></a><a contenteditable="false" data-type="indexterm" data-primary="call expressions, methods" id="id2006"></a><a contenteditable="false" data-type="indexterm" data-primary="expressions" data-secondary="method call expressions" id="id2007"></a>
form <code><em>function</em>(<em>arguments</em>)</code> means “invoke the code of <code><em>function</em></code>, passing zero or more comma-separated <code><em>argument</em></code> objects to it, and return <code><em>function</em></code>’s result value.”</dd>
</dl>
<p class="pagebreak-before">Putting these two together allows us to call a method of an object. The method call expression:</p>
<pre data-type="programlisting"><code><em>object.method</em></code>(<code><em>arguments</em></code>)</pre>
<p>is evaluated from left to right—Python will first fetch the <code><em>method</em></code> of the <code><em>object</em></code> and then call it, passing in both <code><em>object</em></code> and the <code><em>arguments</em></code>. Or, in plain words, the method call expression means this:</p>
<pre data-type="programlisting">Call <code><em>method</em></code> to process <code><em>object</em></code> with <code><em>arguments</em></code>.</pre>
<p>If the method computes a result, it will also come back as the result of the entire method-call expression. As a more tangible example:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>S = 'hack'</strong></code>
&gt;&gt;&gt; <code><strong>result = S.find('ac')</strong></code>     <code><em># Call the find method to look for 'ac' in string S</em></code></pre>
<p>This mapping holds true for methods of both built-in types, as well as user-defined classes we’ll study later. As you’ll see throughout this part of the book, most objects have callable methods, and all are accessed using this same method-call syntax. To call an object method, as you’ll see in the following sections, you have to go through an existing object; methods cannot be run (and make little sense) without a subject.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="All String Methods (Today)"><div class="sect2" id="all_string_methods_left_parenthesistoda">
<h2>All String Methods (Today)</h2>
<p><a data-type="xref" href="#string_method_calls_in_python_threedoto">Table 7-3</a> summarizes the methods and call patterns for built-in string <a contenteditable="false" data-type="indexterm" data-primary="methods" data-secondary="standard-library manual" id="id2008"></a><a contenteditable="false" data-type="indexterm" data-primary="standard library" data-secondary="methods" id="id2009"></a>objects in Python 3.12. These change over time, so be sure to check Python’s standard-library manual for the most up-to-date list, or run a <code>dir</code> or <code>help</code> call interactively on any string or the <code>str</code> type name, as shown in <a data-type="xref" href="ch04.html#introducing_python_objects">Chapter 4</a>.</p>
<p>In this table, <code>S</code> is a string object; optional arguments are enclosed in <code>[]</code> brackets; nested <code>[]</code> mean optional following an optional; <code>*<em>X</em></code> and <code>**<em>X</em></code> mean any number <code><em>X</em></code>; and the listed methods implement higher-level operations such as splitting and joining, case conversions, content tests, and substring searches and replacements.</p>
<table id="string_method_calls_in_python_threedoto">
<caption><span class="label">Table 7-3. </span>String method calls in Python 3.12</caption>
<tbody>
<tr>
<td><code>S.capitalize()</code></td>
<td><code>S.ljust(<code><em>width</em></code> [, <code><em>fill</em></code>])</code></td>
</tr>
<tr>
<td><code>S.casefold()</code></td>
<td><code>S.lower()</code></td>
</tr>
<tr>
<td><code>S.center(<code><em>width</em></code> [, <code><em>fill</em></code>])</code></td>
<td><code>S.lstrip([<code><em>chars</em></code>])</code></td>
</tr>
<tr>
<td><code>S.count(<code><em>sub</em></code> [, <code><em>start</em></code> [, <code><em>end</em></code>]])</code></td>
<td><code>S.maketrans(<code><em>x</em></code> [, <code><em>y</em></code> [, <code><em>z</em></code>]])</code></td>
</tr>
<tr>
<td><code>S.encode([<code><em>encoding</em></code> [, <code><em>errors</em></code>]])</code></td>
<td><code>S.partition(<code><em>sep</em></code>)</code></td>
</tr>
<tr>
<td><code>S.endswith(<code><em>suffix</em></code> [, <code><em>start</em></code> [, <code><em>end</em></code>]])</code></td>
<td><code>S.removeprefix(<code><em>prefix</em></code>)</code></td>
</tr>
<tr>
<td><code>S.expandtabs([<code><em>tabsize</em></code>])</code></td>
<td><code>S.removesuffix(<code><em>suffix</em></code>)</code></td>
</tr>
<tr>
<td><code>S.find(<code><em>sub</em></code> [, <code><em>start</em></code> [, <code><em>end</em></code>]])</code></td>
<td><code>S.replace(<code><em>old</em></code>, <code><em>new</em></code> [, <code><em>count</em></code>])</code></td>
</tr>
<tr>
<td><code>S.format(<code><em>fmtstr</em></code>, *<code><em>args</em></code>, **<code><em>kwargs</em></code>)</code></td>
<td><code>S.rfind(<code><em>sub</em></code> [, <code><em>start</em></code> [, <code><em>end</em></code>]])</code></td>
</tr>
<tr>
<td><code>S.format_map(<code><em>mapping</em></code>)</code></td>
<td><code>S.rindex(<code><em>sub</em></code> [, <code><em>start</em></code> [, <code><em>end</em></code>]])</code></td>
</tr>
<tr>
<td><code>S.index(<code><em>sub</em></code> [, <code><em>start</em></code> [, <code><em>end</em></code>]])</code></td>
<td><code>S.rjust(<code><em>width</em></code> [, <code><em>fill</em></code>])</code></td>
</tr>
<tr>
<td><code>S.isalnum()</code></td>
<td><code>S.rpartition(<code><em>sep</em></code>)</code></td>
</tr>
<tr>
<td><code>S.isalpha()</code></td>
<td><code>S.rsplit([<code><em>sep</em></code> [, <code><em>maxsplit</em></code>]])</code></td>
</tr>
<tr>
<td><code>S.isascii()</code></td>
<td><code>S.rstrip([<code><em>chars</em></code>])</code></td>
</tr>
<tr>
<td><code>S.isdecimal()</code></td>
<td><code>S.split([<code><em>sep</em></code> [, <code><em>maxsplit</em></code>]])</code></td>
</tr>
<tr>
<td><code>S.isdigit()</code></td>
<td><code>S.splitlines([<code><em>keepends</em></code>])</code></td>
</tr>
<tr>
<td><code>S.isidentifier()</code></td>
<td><code>S.startswith(<code><em>prefix</em></code> [, <code><em>start</em></code> [, <code><em>end</em></code>]])</code></td>
</tr>
<tr>
<td><code>S.islower()</code></td>
<td><code>S.strip([<code><em>chars</em></code>])</code></td>
</tr>
<tr>
<td><code>S.isnumeric()</code></td>
<td><code>S.swapcase()</code></td>
</tr>
<tr>
<td><code>S.isprintable()</code></td>
<td><code>S.title()</code></td>
</tr>
<tr>
<td><code>S.isspace()</code></td>
<td><code>S.translate(<code><em>map</em></code>)</code></td>
</tr>
<tr>
<td><code>S.istitle()</code></td>
<td><code>S.upper()</code></td>
</tr>
<tr>
<td><code>S.isupper()</code></td>
<td><code>S.zfill(<code><em>width</em></code>)</code></td>
</tr>
<tr>
<td><code>S.join(<code><em>iterable</em></code>)</code></td>
<td></td>
</tr>
</tbody>
</table>
<p>As you can see, strings have many methods, and we don’t have space to cover them all here; omissions can be found in other resources when needed. To help you get started, though, let’s work through some code that demonstrates some of the most commonly used methods in action and illustrates Python text-processing basics along the way.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="“Changing” Strings, Part 2: String Methods"><div class="sect2" id="quotation_markchangingquotati-id000105">
<h2>“Changing” Strings, Part 2: String Methods</h2>
<p>As we’ve seen, most strings <a contenteditable="false" data-type="indexterm" data-primary="string methods" id="id2010"></a>cannot be changed in place directly because they are immutable. We explored changing strings with sequence operations in the preceding section, but let’s resume that story here in the context of methods.</p>
<p>By way of review, to make a new text value from an existing string, you can construct a new string with sequence operations such as slicing and concatenation. For example, to replace two characters in the middle of a string, you can use code like this, much as we did in the prior section:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>S = 'textly!'</strong></code>
&gt;&gt;&gt; <code><strong>S[:4] + 'ful' + S[-1]</strong></code>             <code><em># Make a new string with sequence ops</em></code>
'textful!'</pre>
<p>But, if you’re really just out to replace a substring, you can use the string <code>replace</code> method instead:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>S = 'textly!'</strong></code>
&gt;&gt;&gt; <code><strong>S.replace('ly', 'ful')</strong></code>            <code><em># Replace all 'ly' with 'ful' in S</em></code>
'textful!'</pre>
<p>The <code>replace</code> method <a contenteditable="false" data-type="indexterm" data-primary="replace method" id="id2011"></a><a contenteditable="false" data-type="indexterm" data-primary="string methods" data-secondary="replace" id="id2012"></a><a contenteditable="false" data-type="indexterm" data-primary="methods" data-secondary="replace" id="id2013"></a>is more general than this code implies. It takes as arguments the original substring (of any length) and a new substring (of any length) to replace the original, and performs a global search and replace—subject to an optional third argument that limits the number of replacements made:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>'--@--@--@--'.replace('@', 'PY', 2)</strong></code>
'--PY--PY--@--'</pre>
<p>In such a role, <code>replace</code> can be used <a contenteditable="false" data-type="indexterm" data-primary="templates" data-secondary="replacements" id="id2014"></a>as a tool to implement simple <em>template</em> replacements (e.g., in form letters). If you need to replace one fixed-size string that can occur at any offset, you can do a replacement again, or search for the substring with the string <code>find</code> method and then slice:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>S = 'xxxxPYxxxxPYxxxx'</strong></code>
&gt;&gt;&gt; <code><strong>where = S.find('PY')</strong></code>              <code><em># Search for position</em></code>
&gt;&gt;&gt; <code><strong>where</strong></code>                             <code><em># Occurs at offset 4</em></code>
4
&gt;&gt;&gt; <code><strong>S = S[:where] + 'CODE' + S[(where+2):]</strong></code>
&gt;&gt;&gt; <code><strong>S</strong></code>
'xxxxCODExxxxPYxxxx'</pre>
<p class="pagebreak-before">The <code>find</code> method returns <a contenteditable="false" data-type="indexterm" data-primary="find method" id="id2015"></a><a contenteditable="false" data-type="indexterm" data-primary="string methods" data-secondary="find" id="id2016"></a><a contenteditable="false" data-type="indexterm" data-primary="methods" data-secondary="find" id="id2017"></a>the offset where a substring appears, or <code>−1</code> if it is not found (it searches from the front by default, and its cousin <code>rfind</code> searches in reverse). As we saw earlier, this is a <em>substring search</em> operation just like the <code>in</code> expression, but <code>find</code> returns the position of a located substring. In this context, <code>replace</code> does the job easier, and can do more—in the following, replacing both multiple occurrences and multiple targets:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>S = 'xxxxPYxxxxPYxxxx'</strong></code>
&gt;&gt;&gt; <code><strong>S.replace('PY', 'CODE', 1)</strong></code>        <code><em># Replace one</em></code>
'xxxxCODExxxxPYxxxx'

&gt;&gt;&gt; <code><strong>S.replace('PY', 'CODE')</strong></code>           <code><em># Replace all</em></code>
'xxxxCODExxxxCODExxxx'

&gt;&gt;&gt; <code><strong>'xxxxWHATxxxxHOWxxxx'.replace('WHAT', 'CODE').replace('HOW', 'PYTHON')</strong></code>
'xxxxCODExxxxPYTHONxxxx'</pre>
<p>As a reminder, <code>replace</code> returns a new string object each time (which is why two calls can be strung together here). Because strings are immutable, methods, like sequence operations, never really change the subject string in place—even if they are called “replace”! To save the new string object produced by a method call, assign it to a name:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>S = S.replace('PY', 'CODE')</strong></code>
&gt;&gt;&gt; <code><strong>S</strong></code>
'xxxxCODExxxxCODExxxx'</pre>
<p>The fact that concatenation <a contenteditable="false" data-type="indexterm" data-primary="replace method" id="id2018"></a><a contenteditable="false" data-type="indexterm" data-primary="string methods" data-secondary="replace" id="id2019"></a><a contenteditable="false" data-type="indexterm" data-primary="methods" data-secondary="replace" id="id2020"></a>operations and the <code>replace</code> method generate new string objects each time they are run is a potential downside of using them to change strings: each interim result must create a full-fledged object with a fresh copy of its text. If you have to apply many changes to a very large string, you might be able to improve your script’s performance by converting the string to an object that does support in-place changes:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>S = 'text'</strong></code>
&gt;&gt;&gt; <code><strong>L = list(S)</strong>   </code>                    <code><em># Explode string into a list</em></code>
&gt;&gt;&gt; <code><strong>L</strong></code>
['t', 'e', 'x', 't']</pre>
<p>The built-in <code>list</code> function (really, an object construction call) builds a new list out of the items in any sequence (or other iterable)—in this case, “exploding” the characters of a string into a list. Once the string is in this form, you can make multiple changes to it without generating a new copy for each change:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>L[0] = 'h'</strong></code>                        <code><em># Works for lists, not strings</em></code>
&gt;&gt;&gt; <code><strong>L[3] = '!'</strong></code>
&gt;&gt;&gt; <code><strong>L</strong></code>
['h', 'e', 'x', '!']</pre>
<p>After your changes, you can convert back to a string if needed (e.g., to write to a file) by using the string <code>join</code> method to “implode” the list back into a string:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>S = ''.join(L)</strong></code>                    <code><em># Implode back to a string</em></code>
&gt;&gt;&gt; <code><strong>S</strong></code>
'hex!'</pre>
<p>The <code>join</code> method may look <a contenteditable="false" data-type="indexterm" data-primary="join method" id="id2021"></a><a contenteditable="false" data-type="indexterm" data-primary="string methods" data-secondary="join" id="id2022"></a><a contenteditable="false" data-type="indexterm" data-primary="methods" data-secondary="join" id="id2023"></a><a contenteditable="false" data-type="indexterm" data-primary="strings" data-secondary="delimiter" id="id2024"></a><a contenteditable="false" data-type="indexterm" data-primary="delimiter string" id="id2025"></a>a bit backward on first encounter. Because it is a method of strings (not of lists), it is called through the desired <em>delimiter</em> string. <code>join</code> puts the strings in a list (or other iterable) together, with the delimiter between list items; in this case, it uses an empty string delimiter to convert from a list back to a string. More generally, any string delimiter and iterable of strings will do:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>'PY'.join(['which', 'language', 'is', 'best', '?'])</strong></code>
'whichPYlanguagePYisPYbestPY?'</pre>
<p>Though subject to Python implementation, joining substrings all at once might run faster than concatenating them individually. The mutable <code>bytearray</code> string noted earlier may help with efficiency too; because it can be changed in place, it offers an alternative to this <code>list</code>/<code>join</code> combo for simple kinds of byte-sized text like ASCII.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="More String Methods: Parsing Text"><div class="sect2" id="more_string_methods_parsing_text">
<h2>More String Methods: Parsing Text</h2>
<p>Another common role for string methods <a contenteditable="false" data-type="indexterm" data-primary="string methods" data-secondary="parsing text" id="id2026"></a><a contenteditable="false" data-type="indexterm" data-primary="parsing" data-secondary="text, string methods" id="id2027"></a>is as a simple form of text <em>parsing</em>—that is, analyzing structure and extracting substrings. To extract substrings at fixed offsets, we can employ <em>slicing</em> techniques:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>line = 'aaa bbb ccc'</strong></code>

&gt;&gt;&gt; <code><strong>col1 = line[:3]</strong></code>
&gt;&gt;&gt; <code><strong>col2 = line[4:8]</strong></code>
&gt;&gt;&gt; <code><strong>col3 = line[-3:]</strong></code>

&gt;&gt;&gt; <code><strong>col1, col2, col3</strong></code>
('aaa', 'bbb ', 'ccc')</pre>
<p>Here, the columns of data appear at fixed offsets and so may be sliced out of the original string. This technique passes for parsing, as long as the components of your data have known positions. If instead some sort of delimiter separates the data, you can pull out its components by <em>splitting</em>. This will work even if the data may show up at arbitrary positions within the string:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>line = 'aaa bbb     ccc'</strong></code>
&gt;&gt;&gt; <code><strong>cols = line.split()</strong></code>
&gt;&gt;&gt; <code><strong>cols</strong></code>
['aaa', 'bbb', 'ccc']</pre>
<p>The string <code>split</code> method<a contenteditable="false" data-type="indexterm" data-primary="string methods" data-secondary="split" id="id2028"></a><a contenteditable="false" data-type="indexterm" data-primary="split method" id="id2029"></a><a contenteditable="false" data-type="indexterm" data-primary="methods" data-secondary="split" id="id2030"></a> chops up a string into a list of substrings, around a delimiter string. We didn’t pass a delimiter in the prior example, so it defaults to whitespace—the string is split at groups of one or more spaces, tabs, and newlines, and we get back a list of the resulting substrings. In other applications, more tangible delimiters may separate the data. To demo, the next example splits (and hence parses) the string at commas, a separator common in some database roles (string conversion tools covered earlier can change substrings here into numbers):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>line = 'Python,3.12,scripting,33'</strong></code>
&gt;&gt;&gt; <code><strong>line.split(',')</strong></code>
['Python', '3.12', 'scripting', '33']</pre>
<p>Delimiters can be longer than a single character, too:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>line = 'youPYarePYaPYstringPYcoder'</strong></code>
&gt;&gt;&gt; <code><strong>line.split('PY')</strong></code>
['you', 'are', 'a', 'string', 'coder']</pre>
<p>Although there are limits to the parsing potential of slicing and splitting, both run fast and can handle basic text-extraction chores. Comma-separated text data is also part of the CSV file format; for a more advanced tool on this front, see also the <code>csv</code> module in Python’s standard library.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Other Common String Methods"><div class="sect2" id="other_common_string_methods">
<h2>Other Common String Methods</h2>
<p>Other string methods have more <a contenteditable="false" data-type="indexterm" data-primary="string methods" data-secondary="whitespace" id="id2031"></a><a contenteditable="false" data-type="indexterm" data-primary="whitespace" id="id2032"></a>focused purposes—for example, to strip off whitespace at the end of a line of text, perform case conversions, test content, and test for a substring at the end or front:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>line = "Python's strings are awesome!\n"</strong></code>

&gt;&gt;&gt; <code><strong>line.rstrip()</strong>   </code>                    <code><em># Drop whitespace (or other)</em></code>
"Python's strings are awesome!"
&gt;&gt;&gt; <code><strong>line.upper()</strong></code>                        <code><em># Case conversions</em></code>
"PYTHON'S STRINGS ARE AWESOME!\n"
&gt;&gt;&gt; <code><strong>line.isalpha()</strong>  </code>                    <code><em># Content tests</em></code>
False
&gt;&gt;&gt; <code><strong>line.endswith('awesome!\n')</strong></code>         <code><em># Suffix and prefix tests</em></code>
True
&gt;&gt;&gt; <code><strong>line.startswith('Python')</strong></code>
True<strong></strong></pre>
<p>Alternative techniques can also <a contenteditable="false" data-type="indexterm" data-primary="string methods" data-secondary="substring test" id="id2033"></a><a contenteditable="false" data-type="indexterm" data-primary="strings" data-secondary="substrings, testing for" id="id2034"></a><a contenteditable="false" data-type="indexterm" data-primary="substrings, testing for" id="id2035"></a>sometimes be used to achieve the same results as string methods—the <code>in</code> membership operator can be used to test for the presence of a substring, for instance, and length and slicing operations can be used to mimic <code>endswith</code>:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>line.find('awesome') != -1</strong></code>          <code><em># Search via method call or expression
</em></code>True
&gt;&gt;&gt; <code><strong>'awesome' in line</strong></code>
True

&gt;&gt;&gt; <code><strong>sub = 'awesome!\n'</strong></code>
&gt;&gt;&gt; <code><strong>line.endswith(sub)</strong></code>                  <code><em># End test via method call or slice</em></code>
True
&gt;&gt;&gt; <code><strong>line[-len(sub):] == sub</strong></code>
True</pre>
<p>Note that none of the string methods accepts <em>patterns</em>—for pattern-based text processing, you must use the Python <code>re</code> standard-library module, an advanced tool that will be introduced briefly in <a data-type="xref" href="ch37.html#unicode_and_byte_strings">Chapter 37</a> but is mostly outside the scope of this text. Because of their limitations, though, string methods may run more quickly than the <code>re</code> module’s tools.</p>
<p>Again, because there are so many methods available for strings, we won’t look at every one here. You’ll see some additional string examples later in this book, but for more details you can also turn to the Python library manual and other reference resources, or simply experiment interactively on your own. As noted in <a data-type="xref" href="ch04.html#introducing_python_objects">Chapter 4</a>, <code>help(S.<em>method</em>)</code> gives info for a <code><em>method</em></code> of any string object <code>S</code>; use <code>help(str.<em>method</em>)</code> if you have no <code>S</code>.</p>
<p>All that being said, one method is noticeably absent from this section’s coverage: <code>format</code> performs string formatting, which combines many operations in a single step. It’s also part of a larger topic in Python, which we turn to next.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="String Formatting: The Triathlon"><div class="sect1" id="string_formatting_the_triathlon">
<h1>String Formatting: The Triathlon</h1>
<p>Although you can get a lot done with the string methods and sequence operations you’ve already met, Python <a contenteditable="false" data-type="indexterm" data-primary="string formatting" id="id2036"></a>also provides a more advanced way to combine string processing tasks: <em>string formatting</em> allows us to perform multiple type-specific substitutions on a string in a single step. It’s never strictly required, but it can be convenient, especially when laying out text to be displayed to a program’s users.</p>
<p>We’ve used string formatting informally in this book already, but it’s finally time to dig into its details. As suggested in earlier examples, this story is regrettably convoluted by Python’s history: there are today <em>three different string-formatting tools</em> that broadly overlap in functionality. This curious state of affairs reflects a common pattern in software development—new tools arise that boldly promise to be radical improvements over the past, only to be supplanted by even newer tools that boldly make the exact same claims.</p>
<p>The net effect handicaps languages with redundancy, and users with unnecessarily steep learning curves. While learning resources could present just one of many options, that would both impose authors’ opinions and do a vast disservice to readers: even if you’re able to pick just one of the formatting tools for your own work, the fact that the others have been available for decades and have been used by millions of programmers virtually guarantees that you’ll be seeing them in the wild when you begin reusing other people’s code. Try as it may, the new cannot erase the old.</p>
<p>Hence, this chapter presents all three formatting tools for the sake of inclusiveness. If you’re new to Python or programming in general, you probably should focus on the current latest-and-greatest <span class="keep-together"><em>f-string</em></span> option—not because it’s necessarily “better,” but because it’s more likely to garner development attention and less likely to be deprecated in a backward-incompatible future (its predecessors have been spared this fate to date, but Python has a history here).</p>
<p>But that’s not to say that the others are out of the race: the expression and method alternatives may feel more comfortable to readers with backgrounds in some other tools, and both are pervasive in the vast reams of Python code written over the last thirty-some years. Learning all three options hedges your bets best.</p>
<section data-type="sect2" data-pdf-bookmark="String-Formatting Options"><div class="sect2" id="string_formatting_options">
<h2>String-Formatting Options</h2>
<p>As a preview of what we’re going to explore in this section, here are today’s entries in the string-formatting race:</p>
<dl>
<dt>Formatting expression: <code>'…%s…%s…' % (<em>value</em>, <em>value</em>)</code></dt>
<dd>The original <a contenteditable="false" data-type="indexterm" data-primary="string formatting" data-secondary="expressions" id="id2037"></a><a contenteditable="false" data-type="indexterm" data-primary="expressions" data-secondary="string formatting" id="expstrgtt"></a>technique available since Python’s inception, this form is loosely based upon the C language’s <code>printf</code> model and sees widespread use in much existing code. Values on the right replace targets on the left.</dd>
<dt>Formatting method: <code>'…{}…{}…'.format(<em>value</em>, <em>value</em>)</code></dt>
<dd>A newer technique added in <a contenteditable="false" data-type="indexterm" data-primary="string formatting" data-secondary="format method" id="id2038"></a><a contenteditable="false" data-type="indexterm" data-primary="methods" data-secondary="string formatting" id="id2039"></a>Python 3.0, this form is derived in part from a same-named tool in C#/.NET. It largely overlaps with the expression’s functionality but aims to address usage modes subjectively deemed subpar.</dd>
<dt>Formatting literal: <code>f'…{<em>value</em>}…{<em>value</em>}…'</code></dt>
<dd>The very latest (so far) added in Python 3.6, this form is known as <em>f-strings</em>. It shares much with the method <a contenteditable="false" data-type="indexterm" data-primary="string formatting" data-secondary="literals" id="id2040"></a><a contenteditable="false" data-type="indexterm" data-primary="literals" data-secondary="string formatting" id="id2041"></a>but apes a host of languages that support <em>string interpolation</em>—substituting inline expressions with their results.</dd>
</dl>
<p>You can also format strings <a contenteditable="false" data-type="indexterm" data-primary="string formatting" data-secondary="manual" id="id2042"></a>manually with string methods, though it’s too cumbersome to count. And technically, an additional tool, <code>string.Template</code>, predates the method—and drives the formatting set’s length up to a whopping <em>four</em>—but it’s so scantly used that it gets less billing than the three primary options above and is relegated to a brief sidebar here (and you’d be excused for pretending it doesn’t exist at all, given the heft of the formatting toolbox!).</p>
<p>The following sections present all three formatting options above in turn. While it may be tempting to jump straight to whatever the blogosphere may be recommending as you read these words, these <span class="keep-together">sections</span> partly build on each other (e.g., f-strings use the method’s format specifier and assume its earlier coverage), so a linear read is suggested.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="The String-Formatting Expression"><div class="sect2" id="the_string_formatting_expression">
<h2>The String-Formatting Expression</h2>
<p>Since string-formatting <em>expressions</em> are the original in this department, we’ll start with them. Python defines the <code>%</code> binary operator to work on strings. You may recall that this is also the remainder of division, or modulus, operator for numbers. When applied to strings, the <code>%</code> operator provides a simple way to format values as strings according to a format definition. It’s a much more concise way to code multiple substitutions than processing parts individually.</p>
<section data-type="sect3" data-pdf-bookmark="Formatting expression basics"><div class="sect3" id="formatting_expression_basics">
<h3>Formatting expression basics</h3>
<p>To format strings with an expression:</p>
<ol>
<li><p>On the <em>left</em> of the <code>%</code> operator, provide a format string containing one or more embedded conversion targets, each of which starts with a <code>%</code> (e.g., <code>%d</code>).</p></li>
<li><p>On the <em>right</em> of the <code>%</code> operator, provide the object that you want Python to insert into the format string on the left in place of the conversion target; for multiple targets, provide multiple objects in a tuple.</p></li>
</ol>
<p>For instance, in the following formatting example, the integer <code>3</code> replaces the <code>%d</code> in the format string on the left, and the string <code>'format'</code> replaces the <code>%s</code>. The result is a new string that reflects these two substitutions, which may be printed or saved for use in other roles:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>'There are %d ways to %s!' % (3, 'format')</strong></code>      <code><em># Formatting expression</em></code>
'There are 3 ways to format!'</pre>
<p>Technically speaking, string formatting in any flavor is usually optional—you can generally do similar work with multiple concatenations and conversions. However, formatting allows us to combine many steps into a single operation. It’s powerful enough to warrant a few more introductory examples:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>option = 'expression'</strong></code>
&gt;&gt;&gt; <code><strong>'Meet the formatting %s!' % option</strong></code>              <code><em># String substitution</em></code>
'Meet the formatting expression!'

&gt;&gt;&gt; <code><strong>'%d %s %g you' % (1, 'formatter', 4.0)</strong></code>          <code><em># Type-specific substitutions</em></code>
'1 formatter 4 you'
 
&gt;&gt;&gt; <code><strong>'%s -- %s -- %s' % (42, 3.14159, [1, 2, 3])</strong></code>     <code><em># All types match a %s target</em></code>
'42 -- 3.14159 -- [1, 2, 3]'</pre>
<p>The first example here plugs a string into the target on the left, replacing the <code>%s</code> marker. In the second example, three values are inserted into the target string.</p>
<p>Notice that when you’re inserting more than one value, you need to group the values on the right in parentheses—that is, put them in a <em>tuple</em>. The <code>%</code> operator’s right side generally expects a tuple of one or more items (or a dictionary of items for key references, covered ahead), but allows a single nontuple item if there is just one substitution target. You’ll know which form to use when coding the expression, of course, but this difference was nevertheless deemed a quirk sufficient to justify other formatting options over time.</p>
<p>The third example again inserts three values—an integer, a floating-point number, and a list—but notice that all of the targets on the left are <code>%s</code>, which stands for conversion to string. As every type of object can be converted to a string (the one used when printing), every object type works with the <code>%s</code> conversion code. Because of this, unless you need to do special formatting, <code>%s</code> is often the only code you need to remember for the formatting expression.</p>
<p>Again, keep in mind that formatting always makes a new string, rather than changing the string on the left; because strings are immutable, it must work this way. As before, assign the result <a contenteditable="false" data-type="indexterm" data-primary="expressions" data-secondary="string formatting" data-startref="expstrgtt" id="id2043"></a>to a variable name if you need to retain it.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Formatting expression custom formats"><div class="sect3" id="formatting_expression_custom_formats">
<h3>Formatting expression custom formats</h3>
<p>For more advanced type-specific <a contenteditable="false" data-type="indexterm" data-primary="string formatting" data-secondary="expressions" data-tertiary="custom formats" id="stfxfm"></a>formatting, you can use any of the conversion type codes listed in <a data-type="xref" href="#formatting_expression_type_codes">Table 7-4</a> in formatting expressions; they appear after the <code>%</code> character in substitution targets. C programmers will recognize most of these because Python string formatting supports all the usual C <code>printf</code> format codes (but returns the result, instead of displaying it like <code>printf</code>). Some of the format codes in the table provide alternative ways to format the same type; for instance, <code>%e</code>, <code>%f</code>, and <code>%g</code> provide alternative ways to format floating-point numbers.</p>
<table class="border" id="formatting_expression_type_codes">
<caption><span class="label">Table 7-4. </span>Formatting-expression type codes</caption>
<thead>
<tr>
<th>Code</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>s</code></td>
<td>String (or any object’s <code>str(X)</code> string)</td>
</tr>
<tr>
<td><code>r</code></td>
<td>Same as <code>s</code>, but uses <code>repr</code>, not <code>str</code></td>
</tr>
<tr>
<td><code>a</code></td>
<td>Same as <code>s</code>, but uses <code>ascii</code>, not <code>str</code></td>
</tr>
<tr>
<td><code>c</code></td>
<td>Character (integer code or string)</td>
</tr>
<tr>
<td><code>d</code></td>
<td>Decimal (signed base-10 integer)</td>
</tr>
<tr>
<td><code>i</code></td>
<td>Integer (see <code>d</code>)</td>
</tr>
<tr>
<td><code>u</code></td>
<td>Same as <code>d</code> (obsolete: no longer unsigned)</td>
</tr>
<tr>
<td><code>o</code></td>
<td>Octal integer (base 8)</td>
</tr>
<tr>
<td><code>x</code></td>
<td>Hex integer (base 16)</td>
</tr>
<tr>
<td><code>X</code></td>
<td>Same as <code>x</code>, but with uppercase letters</td>
</tr>
<tr>
<td><code>e</code></td>
<td>Floating point with exponent, lowercase</td>
</tr>
<tr>
<td><code>E</code></td>
<td>Same as <code>e</code>, but uses uppercase letters</td>
</tr>
<tr>
<td><code>f</code></td>
<td>Floating-point decimal</td>
</tr>
<tr>
<td><code>F</code></td>
<td>Same as <code>f</code>, but uses uppercase letters</td>
</tr>
<tr>
<td><code>g</code></td>
<td>Floating-point <code>e</code> or <code>f</code></td>
</tr>
<tr>
<td><code>G</code></td>
<td>Floating-point <code>E</code> or <code>F</code></td>
</tr>
<tr>
<td><code>%</code></td>
<td>Literal <code>%</code> (coded as <code>%%</code>)</td>
</tr>
</tbody>
</table>
<p>All told, conversion targets in the format string on the expression’s left side support a variety of <a contenteditable="false" data-type="indexterm" data-primary="expressions" data-secondary="string formatting" data-tertiary="type codes" id="id2044"></a>conversion operations with a fairly sophisticated syntax all their own. In formal terms, the general structure of conversion targets looks like the following, where <code>[…]</code> denotes an optional part (its two square-bracket characters are not included in the expression’s code), and no spaces are allowed between parts (though some parts may contain spaces):</p>
<pre data-type="programlisting">%[(<code><em>keyname</em></code>)][<code><em>flags</em></code>][<code><em>width</em></code>][.<code><em>precision</em></code>]<code><em>typecode</em></code></pre>
<p>One of the <em>type code</em> characters in the first column of <a data-type="xref" href="#formatting_expression_type_codes">Table 7-4</a> shows up at the end of this target string’s format, at <code><em>typecode</em></code>. Between the <code>%</code> and this type code character, you can do any (or none) of the <span class="keep-together">following</span>:</p>
<ul>
<li><p>Provide a <em>key name</em> for indexing the dictionary used on the right side of the expression.</p></li>
<li><p>List <em>flags</em> that specify zero padding (<code>0</code>), left justification (<code>−</code>), numeric sign (<code>+</code>), or a blank before positive numbers and a <code>–</code> for negatives (a space), where <code>−</code> overrides <code>0</code>, and <code>+</code> overrides a space.</p></li>
<li><p>Give a total but minimum field <em>width</em> for the substituted text.</p></li>
<li><p>Set the number of digits (<em>precision</em>) to display after a decimal point for floating-point numbers.</p></li>
</ul>
<p>Both the <code><em>width</em></code> and <code><em>precision</em></code> parts can also be coded as a <code>*</code> to specify that they should take their values dynamically from the next item in the input values on the expression’s right side (useful when this isn’t known until your code is run, but unavailable when <code><em>keyname</em></code>s are used). And if you don’t need any of these extra tools, a simple <code>%s</code> in the format string will be replaced by the corresponding <a contenteditable="false" data-type="indexterm" data-primary="string formatting" data-secondary="expressions" data-tertiary="custom formats" data-startref="stfxfm" id="id2045"></a>value’s default print string, regardless of its type.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Advanced formatting expression examples"><div class="sect3" id="advanced_formatting_expression_examples">
<h3>Advanced formatting expression examples</h3>
<p>Formatting target syntax <a contenteditable="false" data-type="indexterm" data-primary="string formatting" data-secondary="expressions" data-tertiary="advanced" id="id2046"></a><a contenteditable="false" data-type="indexterm" data-primary="expressions" data-secondary="string formatting" data-tertiary="advanced" id="xpfttv"></a>is documented in full in the Python standard manuals and other reference resources, but to demonstrate common usage, let’s explore a few examples. The first formats integers using the default, and then in a six-character field with left justification and zero padding:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>x = 1234</strong></code>
&gt;&gt;&gt; <code><strong>res = 'integers: ...%d...%-6d...%06d' % (x, x, x)</strong></code>
&gt;&gt;&gt; <code><strong>res</strong></code>
'integers: ...1234...1234  ...001234'</pre>
<p>The <code>%e</code>, <code>%f</code>, and <code>%g</code> formats display floating-point numbers in different ways, as the following interaction demonstrates—<code>%E</code> is the same as <code>%e</code> but the exponent is uppercase, and <code>g</code> chooses formats by number content (it’s formally defined to use exponential format <code>e</code> if the exponent is less than −4 or not less than precision, and decimal format <code>f</code> otherwise, with a default minimum total-digits precision of 6; no, really!):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>x = 1.23456789</strong></code>
&gt;&gt;&gt; <code><strong>x</strong></code>                                   <code><em># Default REPL display</em></code>
1.23456789

&gt;&gt;&gt; <code><strong>'%e | %f | %g' % (x, x, x)</strong></code>
'1.234568e+00 | 1.234568 | 1.23457'

&gt;&gt;&gt; <code><strong>'%E' % x</strong></code>
'1.234568E+00'</pre>
<p>For floating-point numbers, you can achieve a variety of additional formatting effects by specifying left justification, zero padding, numeric signs, total field width, and digits after the decimal point. For simpler tasks, you might get by with simply converting to strings with a <code>%s</code> type code or the <code>str</code> built-in function we used earlier:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>'%-6.2f | %05.2f | %+06.1f' % (x, x, x)</strong></code>
'1.23   | 01.23 | +001.2'

&gt;&gt;&gt; <code><strong>'%s' % x, str(x)</strong></code>
('1.23456789', '1.23456789')</pre>
<p>When sizes are not known until runtime, you can use a <em>dynamically</em> computed width and precision by specifying them with a <code>*</code> in the format string to force their values to be taken from the next item in the inputs to the right of the <code>%</code> operator—the 4 in the tuple here gives precision:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>'%f, %.2f, %.*f' % (1/3.0, 1/3.0, 4, 1/3.0)</strong></code>
'0.333333, 0.33, 0.3333'</pre>
<p>As usual, experiment with some of these examples <a contenteditable="false" data-type="indexterm" data-primary="expressions" data-secondary="string formatting" data-tertiary="advanced" data-startref="xpfttv" id="id2047"></a>and operations on your own for more insight.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Dictionary-based formatting expressions"><div class="sect3" id="dictionary_based_formatting_expressions">
<h3>Dictionary-based formatting expressions</h3>
<p>As a more advanced extension, <code>%</code> string formatting also allows conversion targets on the left to <a contenteditable="false" data-type="indexterm" data-primary="string formatting" data-secondary="expressions" data-tertiary="dictionary-based" id="sgfxdb"></a><a contenteditable="false" data-type="indexterm" data-primary="expressions" data-secondary="string formatting" data-tertiary="dictionary-based" id="xpfdbs"></a><a contenteditable="false" data-type="indexterm" data-primary="dictionary-based formatting expressions" id="dcbsfx"></a>refer to the keys in a <em>dictionary</em> coded on the right and use the corresponding values. Syntactically, this form requires <code>()</code> key references on the left of <code>%</code>, and a single dictionary (or other mapping) on the right. Functionally, it allows formatting to be used as a basic <em>template</em> tool. You’ve met dictionaries only briefly thus far in <a data-type="xref" href="ch04.html#introducing_python_objects">Chapter 4</a>, but the following demos the idea:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>'%(qty)s more %(tool)s' % {'qty': 1, 'tool': 'formatter'}</strong></code>
'1 more formatter'</pre>
<p>Here, the <code>(qty)</code> and <code>(tool)</code> in the format string on the left refer to <em>keys</em> in the dictionary literal on the right and fetch their associated values. Programs that generate text such as HTML or XML often use this form: they build up a dictionary of values and substitute them all at once with a single formatting expression, using key references and a template string either loaded from a file or coded in the script. The following demos the idea (notice that its first comment is above the triple quote to keep it out of the string, and “…” prompts may not appear in your REPL):</p>
<pre data-type="programlisting">&gt;&gt;&gt;                                           <code><em># Template with substitution targets
</em></code>&gt;&gt;&gt; <code><strong>reply = """</strong></code>
... <code><strong>Hello %(name)s!</strong></code>
... <code><strong>Welcome to %(year)s</strong></code>
... <code><strong>"""</strong></code>
 
&gt;&gt;&gt; <code><strong>values = {'name': 'Pat', 'year': 2024}</strong></code>    <code><em># Build up values to substitute</em></code>
&gt;&gt;&gt; <code><strong>print(reply % values)</strong></code>                     <code><em># Perform substitutions</em></code>

Hello Pat!
Welcome to 2024</pre>
<p>This trick is also sometimes used in conjunction with the <code>vars</code> built-in function, which returns a dictionary containing all the variables that exist in the place it is called:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>name = 'Pat'</strong></code>
&gt;&gt;&gt; <code><strong>year = 2024</strong></code>
&gt;&gt;&gt; <code><strong>vars()</strong></code>
{'name: 'Pat', 'year': 2024, …<code><em>plus built-in names set by Python</em></code>…}</pre>
<p>When used on the right side of a format operation, this allows the format string to refer to variables <em>by name</em>—using dictionary-key syntax:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>'%(name)s from %(year)s' % vars()</strong></code>         <code><em># Variables are keys in vars()</em></code>
'Pat from 2024'</pre>
<p>Although formatting expressions are positional by nature, dictionaries also allow them to <em>reuse values</em> more than once (see <a data-type="xref" href="ch05.html#numbers_and_expressions">Chapter 5</a> for another demo of this in action):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>'%(value)f, %(value).2f, %(value).f' % ({'value': 1 / 3.0})</strong></code>
'0.333333, 0.33, 0'</pre>
<p>We’ll study dictionaries in more depth in <a data-type="xref" href="ch08.html#lists_and_dictionaries">Chapter 8</a>. See also <a data-type="xref" href="ch05.html#hexcomma_octalcomma_and_binary">“Hex, Octal, and Binary”</a> for examples that convert to hexadecimal and octal number strings with the <code>%x</code> and <code>%o</code> formatting expression target codes, which we won’t repeat here. Additional formatting expression examples also appear ahead as <a contenteditable="false" data-type="indexterm" data-primary="string formatting" data-secondary="expressions" data-tertiary="dictionary-based" data-startref="sgfxdb" id="id2048"></a><a contenteditable="false" data-type="indexterm" data-primary="expressions" data-secondary="string formatting" data-tertiary="dictionary-based" data-startref="xpfdbs" id="id2049"></a><a contenteditable="false" data-type="indexterm" data-primary="dictionary-based formatting expressions" data-startref="dcbsfx" id="id2050"></a>comparisons to the formatting method and f-string—the first of which is this chapter’s next topic.</p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="The String-Formatting Method"><div class="sect2" id="the_string_formatting_method">
<h2>The String-Formatting Method</h2>
<p>As noted, Python 3.0 added a second way <a contenteditable="false" data-type="indexterm" data-primary="string formatting" data-secondary="format method" id="id2051"></a><a contenteditable="false" data-type="indexterm" data-primary="methods" data-secondary="string formatting" data-tertiary="format method" id="mstdffr"></a>to format strings that some see as more Python specific. Unlike formatting expressions, the formatting method is not as closely based upon the C language’s “printf” model; is sometimes more explicit in intent; and avoids the value-or-tuple quirk of <code>%</code>: substituted values are just arguments, whether one or many.</p>
<p>On the other hand, the new technique still relies on “printf” concepts like type codes and formatting specifications. Moreover, it largely overlaps with formatting expressions; often yields more verbose code; and in practice can be just as complex in most roles. And if we’re all being honest, the value-or-tuple quirk of the <code>%</code> expression is much more of a concern in theory than practice. Luckily, the two are similar enough that many core concepts overlap.</p>
<section data-type="sect3" data-pdf-bookmark="Formatting method basics"><div class="sect3" id="formatting_method_basics">
<h3>Formatting method basics</h3>
<p>The string object’s <code>format</code> method at the heart of this option is based on function call syntax, instead of an expression. Specifically, it uses the call’s subject string as a template and takes any number of arguments that represent values to be substituted according to the template.</p>
<p>This option requires knowledge of functions and calls but is mostly straightforward. Within the subject string, curly braces designate substitution targets and arguments to be inserted—either by <em>relative</em> position (<code>{}</code>), <em>absolute</em> position (e.g., <code>{1}</code>), or <em>keyword</em> (e.g., <code>{<em>name</em>}</code>). As you’ll learn when we explore argument passing in depth in <a data-type="xref" href="ch18.html#arguments">Chapter 18</a>, arguments to functions and methods may be passed by position (e.g., <code><em>value</em></code>) or keyword (e.g., <code><em>name</em>=<em>value</em></code>), and Python’s ability to collect arbitrarily many arguments allows for general method-call patterns. As initial examples:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>template = '{}, {}, and {}'</strong></code>                               <code><em># Relative position
</em></code>&gt;&gt;&gt; <code><strong>template.format('expr', 'method', 'fstring')</strong></code>
'expr, method, and fstring'

&gt;&gt;&gt; <code><strong>template = '{0}, {1}, and {2}'</strong></code>                            <code><em># Absolute position</em></code>
&gt;&gt;&gt; <code><strong>template.format('expr', 'method', 'fstring')</strong></code>
'expr, method, and fstring'

&gt;&gt;&gt; <code><strong>template = '{first}, {second}, and {third}'</strong></code>               <code><em># Keyword name</em></code>
&gt;&gt;&gt; <code><strong>template.format(first='expr', second='method', third='fstring')</strong></code>
'expr, method, and fstring'

&gt;&gt;&gt; <code><strong>template = '{first}, {0}, and {third}'</strong></code>                    <code><em># Combos ({0} or {})</em></code>
&gt;&gt;&gt; <code><strong>template.format('method', first='expr', third='fstring')</strong></code>
'expr, method, and fstring'</pre>
<p>By comparison, the last section’s formatting <em>expression</em> can be a bit more concise, but uses dictionaries instead of keyword arguments for named references, and as you’ll see in a moment doesn’t allow quite as much flexibility for value sources in the template string itself (which may be an asset or liability, depending on your perspective):</p>
<pre class="pagebreak-before" data-type="programlisting">&gt;&gt;&gt;<code> <strong>template = '%s, %s, and %s'</strong></code>                               <code><em># Equivalent %s 
</em></code>&gt;&gt;&gt; <code><strong>template % ('expr', 'method', 'fstring')</strong> </code>
'expr, method, and fstring'

&gt;&gt;&gt; <code><strong>template = '%(first)s, %(second)s, and %(third)s'</strong></code>
&gt;&gt;&gt; <code><strong>template % dict(first='expr', second='method', third='fstring')</strong> </code>
'expr, method, and fstring'</pre>
<p>Note the use of <code>dict()</code> to make a dictionary from keyword arguments here, introduced in <a data-type="xref" href="ch04.html#introducing_python_objects">Chapter 4</a> and covered in full in <a data-type="xref" href="ch08.html#lists_and_dictionaries">Chapter 8</a>; it’s an often less cluttered alternative to the <code>{…}</code> literal. Naturally, the subject string in the <code>format</code> method call can also be a literal that creates a temporary string, and arbitrary object types can be substituted at targets much like the expression’s <code>%s</code> code:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>'{pi}, {} and {years}'.format(62, pi=3.14, years=[1995, 2024])</strong></code>
'3.14, 62 and [1995, 2024]'</pre>
<p>Just as with the <code>%</code> expression and other string methods, <code>format</code> creates and returns a new string object, which can be printed immediately or saved for further work (as another reminder, strings are immutable, so <code>format</code> really <em>must</em> make a new object). String formatting in any of its forms is not just for <span class="keep-together">display</span>:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>X = '{pi}, {} and {years}'.format(62, pi=3.14, years=[1995, 2024])</strong></code>
&gt;&gt;&gt; <code><strong>X</strong></code>
'3.14, 62 and [1995, 2024]'

&gt;&gt;&gt; <code><strong>X.split(' and ')</strong></code>
['3.14, 62', '[1995, 2024]'] 

&gt;&gt;&gt; <code><strong>Y = X.replace('and', 'but under no circumstances')</strong></code>
&gt;&gt;&gt; <code><strong>Y</strong></code>
'3.14, 62 but under no circumstances [1995, 2024]'</pre>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Adding keys, attributes, and offsets"><div class="sect3" id="adding_keyscomma_attributescomma_and_of">
<h3>Adding keys, attributes, and offsets</h3>
<p>Like <code>%</code> formatting expressions, <code>format</code> calls can become more complex to support <a contenteditable="false" data-type="indexterm" data-primary="string formatting" data-secondary="format method" data-tertiary="keys" id="id2052"></a><a contenteditable="false" data-type="indexterm" data-primary="string formatting" data-secondary="format method" data-tertiary="attributes" id="id2053"></a><a contenteditable="false" data-type="indexterm" data-primary="string formatting" data-secondary="format method" data-tertiary="offsets" id="id2054"></a>more advanced usage. For instance, format strings can name object attributes and dictionary keys—as in normal Python syntax, square brackets name dictionary keys and dots denote object attributes of an item referenced by position or keyword. The first of the following examples indexes a dictionary on the key <code>kind</code> and then fetches the attribute <code>platform</code> from the already imported <code>sys</code> module object. The second does the same, but names the objects by keyword instead of position:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>import sys</strong></code>    <code><em># Standard-library module</em></code>

&gt;&gt;&gt; <code><strong>'This {1[kind]} runs {0.platform}'.format(sys, {'kind': 'laptop'})</strong></code>
'This laptop runs darwin'

&gt;&gt;&gt; <code><strong>'This {map[kind]} runs {sys.platform}'.format(sys=sys, map={'kind': 'phone'})</strong></code>
'This phone runs linux'</pre>
<p>Square brackets in format strings can also name offsets to index lists (and other sequences), but only a single positive offset works syntactically within each <code>[]</code>, so this feature is not as general as you might think. To reference negative offsets or slices, or to use arbitrary expression results in general, you must run expressions outside the format string itself, just as you would for <code>%</code> expressions (note the use of <code>*parts</code> here to unpack a tuple’s items into individual function arguments; you’ll learn more about this form when we study function arguments in <a data-type="xref" href="ch18.html#arguments">Chapter 18</a>):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>somelist = list('HACK')</strong></code>
&gt;&gt;&gt; <code><strong>somelist</strong></code>
['H', 'A', 'C', 'K'] 

&gt;&gt;&gt; <code><strong>'zero={0[0]}, two={0[2]}'.format(somelist)</strong></code>
'zero=H, two=C'

&gt;&gt;&gt; <code><strong>'first={}, last={}'.format(somelist[0], somelist[-1])</strong></code>    <code><em># [-1] fails in fmt</em></code>
'first=H, last=K'

&gt;&gt;&gt; <code><strong>parts = (somelist[0], somelist[-1], somelist[1:3])</strong></code>       <code><em># [1:3] fails in fmt</em></code>
&gt;&gt;&gt; <code><strong>'first={}, last={}, middle={}'.format(*parts)</strong></code>            <code><em># Or {0}, {1}, {2}</em></code>
"first=H, last=K, middle=['A', 'C']"</pre>
<p>If you simply cannot do without full generality inside format strings, stay tuned for the <em>f-string</em> and its arbitrary nested expressions (albeit in a code literal instead of a method object, and at the cost of more redundancy and less utility).</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Formatting method custom formats"><div class="sect3" id="formatting_method_custom_formats">
<h3>Formatting method custom formats</h3>
<p>Another similarity with <code>%</code> expressions is that <code>format</code> lets you can achieve more <a contenteditable="false" data-type="indexterm" data-primary="string formatting" data-secondary="format method" data-tertiary="custom formats" id="strgfffr"></a>specific layouts with extra format-string syntax. For the formatting method, we use a colon after the possibly empty substitution target’s identification, followed by a format specifier that can name the field size, justification, and a specific type code. Here’s the formal structure of what can appear as a substitution target in a format string—its four parts are all optional (denoted by surrounding <code>[]</code> here, which aren’t coded in the format string) and must appear without intervening spaces:</p>
<pre data-type="programlisting">{[<code><em>fieldname</em></code>][<code><em>component</em></code>][!<code><em>conversionflag</em></code>][:<code><em>formatspec</em></code>]}</pre>
<p>Text outside a <code>{}</code> substitution <a contenteditable="false" data-type="indexterm" data-primary="string formatting" data-secondary="format method" data-tertiary="substitution targets" id="id2055"></a>target is taken literally and may use doubled <code>{{</code> and <code>}}</code> to escape braces (each is replaced with a single brace). Within a <code>{}</code> substitution target:</p>
<dl>
<dt><code><em>fieldname</em></code></dt>
<dd>Is an optional number or keyword identifying an argument, which may be omitted to reference arguments by   relative position</dd>
<dt><code><em>component</em></code> </dt>
<dd>Is a string of zero or more <code>.<em>name</em></code> or <code>[<em>index</em>]</code> (brackets required!) references, which are used to fetch attributes and indexed values of an argument, and may be omitted to use the whole argument value</dd>
<dt><code><em>conversionflag</em></code> </dt>
<dd>Starts with a <code>!</code> if present, which is followed by <code>s</code>, <code>r</code>, or <code>a</code> to call <code>str</code>, <code>repr</code>, or <code>ascii</code> built-in functions on the value, respectively (this may bypass the value’s normal formatting)</dd>
<dt><code><em>formatspec</em></code></dt>
<dd>Starts with a <code>:</code> if present, followed by text that specifies how the value should be presented, including details such as field width, alignment, padding, decimal precision, and so on, and ends with an optional type code</dd>
</dl>
<p>The <code><em>formatspec</em></code> component after the colon character has a rich format all its own and <a contenteditable="false" data-type="indexterm" data-primary="string formatting" data-secondary="format method" data-tertiary="formatspec component" id="sgffsp"></a>is formally described as follows. As you’ll see later, this part is reused by <em>f-strings</em> (again, <code>[…]</code> in this denotes an optional component whose square brackets are not coded literally, and spaces aren’t allowed between parts but may appear within some):</p>
<pre data-type="programlisting">[[<code><em>fill</em></code>]<code><em>align</em></code>][<code><em>sign</em></code>][z][#][0][<code><em>width</em></code>][<code><em>grouping</em></code>][.<code><em>precision</em></code>][<code><em>typecode</em></code>]</pre>
<p>Within this <code><em>formatspec</em></code> part of the <code>{}</code> substitution target, the salient parts are these:</p>
<dl>
<dt><code><em>fill</em></code></dt>
<dd>Can be any fill character other than <code>{</code> or <code>}</code></dd>
<dt><code><em>align</em></code></dt>
<dd>May be <code>&lt;</code>, <code>&gt;</code>, <code>=</code>, or <code>^</code>, for left alignment, right alignment, padding after a sign character, or centered alignment</dd>
<dt><code><em>sign</em></code> </dt>
<dd>Can be <code>+</code> (to sign all numbers), <code>−</code> (to sign only negatives), or a space (to use a space for positives)</dd>
<dt><code><em>grouping</em></code></dt>
<dd>May be <code>,</code> or <code>_</code> to request a comma or underscore separator, added for thousands in decimal number type codes, and four-digit groups in nondecimal number type codes (which support only <code>_</code>)</dd>
<dt><code><em>width</em></code> and <code><em>precision</em></code></dt>
<dd>Similar to those in the <code>%</code> expression of the preceding section, as shown by examples ahead</dd>
<dt><code><em>typecode</em></code></dt>
<dd>Similar to those in the <code>%</code> expression, with the exceptions described below this list</dd>
<dt>Others</dt>
<dd>For numbers, a <code>0</code> before <code><em>width</em></code> enables sign-aware zero-padding (redundantly with some <code><em>fill</em></code> usage), and <code>#</code> invokes an alternate form (e.g., adding <code>0b</code> and <code>0X</code> prefixes for binary and hex type codes <code>b</code> and <code>X</code>).</dd>
</dl>
<p>The <code><em>formatspec</em></code> may also contain <em>nested</em> <code>{}</code> substitution targets for any of its parts, to use argument-list values dynamically (much like the <code>*</code> in formatting expressions). These nested <code>{}</code> use <code><em>fieldname</em></code> to identify arguments from which values are pulled, and their formatted results are used in place of the nested <code>{}</code>. Nesting may be only one level deep, and <em>f-strings</em> (ahead) use an arbitrary expression instead of <code><em>fieldname</em></code> in a nested <code>{}</code>.</p>
<p>The method’s <code><em>typecode</em></code> options largely overlap with those used in <code>%</code> expressions and listed earlier in <a data-type="xref" href="#formatting_expression_type_codes">Table 7-4</a>, but the formatting method adds a <code>b</code> to display integers in <em>binary</em> format (much like using the <code>bin</code> built-in), adds a <code>%</code> to display <em>percentages</em>, uses only <code>d</code> for base-10 integers (<code>i</code> and <code>u</code> are unused), uses <code>!</code> conversion flags for some cases, and requires a string object for <code>s</code> (to flexibly allow any type like the expression’s <code>%s</code>, either <em>omit</em> the type code or <code><em>formatspec</em></code> in full, or use a <code>!s</code> conversion flag as described earlier).</p>
<p>See Python’s library manual for more on substitution syntax that we’ll omit here. In addition to the string’s <code>format</code> method, a single object may also be formatted with the <code>format(<em>object</em>, <em>formatspec</em>)</code> built-in function (which the method uses internally), and may be customized in user-defined classes with the <code>__format__</code> operator-overloading method (see <a data-type="xref" href="part06.html#classes_and_oop">Part VI</a>). Different objects may <a contenteditable="false" data-type="indexterm" data-primary="string formatting" data-secondary="format method" data-tertiary="custom formats" data-startref="strgfffr" id="id2056"></a><a contenteditable="false" data-type="indexterm" data-primary="string formatting" data-secondary="format method" data-tertiary="formatspec component" data-startref="sgffsp" id="id2057"></a>use different format specifiers, but most follow norms.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Advanced formatting method examples"><div class="sect3" id="advanced_formatting_method_examples">
<h3>Advanced formatting method examples</h3>
<p>As you can tell, the syntax in formatting methods can be complex. Because your best ally in such cases is <a contenteditable="false" data-type="indexterm" data-primary="string formatting" data-secondary="format method" data-tertiary="advanced" id="gffmdv"></a>often the interactive prompt, let’s turn to some examples. In the following, <code>{0:10}</code> means the first positional argument in a field 10 characters <em>wide</em>; <code>{1:&lt;10}</code> means the second positional argument left-<em>justified</em> in a 10-character-wide field; <code>^10</code> center <em>aligns</em> in 10; and <code>{0.platform:&gt;10}</code> means the <span class="keep-together"><code>platform</code></span> attribute of the first argument, right-justified in a 10-character-wide field (notice again the use of <code>dict()</code> to make a dictionary from keyword arguments):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>'{0:10} = {1:10}'.format('text', 123.4567)</strong></code>
'text       =   123.4567'

&gt;&gt;&gt; <code><strong>'{0:&gt;10} = {1:&lt;10}'.format('text', 123.4567)</strong></code>
'      text = 123.4567  '

&gt;&gt;&gt; <code><strong>'{1[kind]:^10} = {0.platform:^10}'.format(sys, dict(kind='laptop'))</strong></code>
'  laptop   =   darwin  '</pre>
<p>As demoed earlier, you can <em>omit</em> the argument number if you’re selecting them from left to right—though this may make your code less explicit, thereby negating one of the purported pluses of <code>format</code> versus <code>%</code>. Code readers must count to match <code>{}</code>s to arguments off to the right (something the f-string’s inline expressions wholly avoid):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>'{:10} = {:10}'.format('text', 123.4567)</strong></code>
'text       =   123.4567'</pre>
<p>Floating-point numbers support <a contenteditable="false" data-type="indexterm" data-primary="string formatting" data-secondary="format method" data-tertiary="floating-point numbers" id="id2058"></a>the same <em>type codes</em> and formatting specificity in formatting method calls as in <code>%</code> expressions. For instance, in the following <code>{2:g}</code> means the third argument formatted by default according to the “g” floating-point representation, <code>{:.2f}</code> designates the “f” floating-point format with just two decimal digits (and rounding), and <code>{:06.2f}</code> denotes a field with a width of six characters and zero padding on the left:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>'{0:e}, {1:.3e}, {2:g}'.format(3.14159, 3.14159, 3.14159)</strong></code>
'3.141590e+00, 3.142e+00, 3.14159'

&gt;&gt;&gt; <code><strong>'{:f}, {:.2f}, {:06.2f}'.format(3.14159, 3.14159, 3.14159)</strong></code>
'3.141590, 3.14, 003.14'</pre>
<p><em>Hex, octal, and binary</em> formats <a contenteditable="false" data-type="indexterm" data-primary="string formatting" data-secondary="format method" data-tertiary="hex formats" id="id2059"></a><a contenteditable="false" data-type="indexterm" data-primary="string formatting" data-secondary="format method" data-tertiary="octal formats" id="id2060"></a><a contenteditable="false" data-type="indexterm" data-primary="string formatting" data-secondary="format method" data-tertiary="binary formats" id="id2061"></a>are supported by the formatting method as well (<code>%</code> has all these <em>except</em> binary). In fact, string formatting is an alternative to some of the built-in functions that format integers to a given base:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>'{:X}, {:o}, {:b}'.format(255, 255, 255)</strong></code>         <code><em># Hex, octal, binary</em></code>
'FF, 377, 11111111'

&gt;&gt;&gt; <code><strong>hex(255), int('FF', 16), 0xFF</strong></code>                    <code><em># Other to/from hex</em></code>
('0xff', 255, 255)

&gt;&gt;&gt; <code><strong>oct(255), int('377', 8), 0o377</strong></code>                  <code> <em># Other to/from octal</em></code>
('0o377', 255, 255)

&gt;&gt;&gt; <code><strong>bin(255), int('11111111', 2), 0b11111111</strong></code>         <code><em># Other to/from binary</em></code>
('0b11111111', 255, 255)</pre>
<p>The formatting method also supports <em>separator</em> insertions (but <code>%</code> currently does <em>not</em>): you can add commas and underscores between thousands groups in numbers, and underscores between four-digit groups in hex, octal, and binary formats, and absolute argument numbers let you <em>reuse values</em> passed in (<code>%</code> uses dictionaries to do the same):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>'{:,.2f}'.format(12345.678)</strong></code>
'12,345.68'

&gt;&gt;&gt; <code><strong>'{0:,}  {0:_}  {1:_x}  {1:_b}'.format(2 ** 32, 0x1FFFF)</strong></code>
'4,294,967,296  4_294_967_296  1_ffff  1_1111_1111_1111_1111'</pre>
<p>Formatting parameters can either be hardcoded in format strings or taken from the arguments list <em>dynamically</em> by nested format syntax—much like the <code>*</code> syntax in formatting expressions’ width and <span class="keep-together">precision</span>:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>'{:.4f}'.format(1 / 3.0)</strong></code>                         <code><em># Parameters hardcoded</em></code>
'0.3333'
&gt;&gt;&gt; <code><strong>'%.4f' % (1 / 3.0)</strong></code>                               <code><em># Ditto for expression</em></code>
'0.3333'

&gt;&gt;&gt; <code><strong>'{0:.{1}f}'.format(1 / 3.0, 4)</strong></code>                  <code> <em># Take value from arguments</em></code>
'0.3333'
&gt;&gt;&gt; <code><strong>'%.*f' % (4, 1 / 3.0)</strong></code>                            <code><em># Ditto for expression</em></code>
'0.3333'</pre>
<p>In fact, <code>format</code> allows <em>any</em> component of a <code><em>formatspec</em></code> string to be taken from arguments at runtime, rather than hardcoded at programming time (this is more general than <code>%</code>). In the following, a number is zero filled, left-justified, signed, twelve wide, comma separated, with two decimal digits—both statically and dynamically (and with and without argument numbering that nearly breaches this page’s width limits!):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>'{0:0&lt;+12,.2f}!'.format(1234.564)</strong></code>
'+1,234.56000!'

&gt;&gt;&gt; <code><strong>'{0:{1}{2}{3}{4}{5}.{6}{7}}!'.format(1234.564, 0, '&lt;', '+', 12, ',', 2, 'f')</strong></code>
'+1,234.56000!'

&gt;&gt;&gt; <code><strong>'{:{}{}{}{}{}{}{}{}}!'.format(1234.564, 0, '&lt;', '+', 12, ',', '.', 2, 'f')</strong></code>
'+1,234.56000!'</pre>
<p>Finally, Python’s built-in <code>format</code> function noted earlier can also be used to format a <em>single</em> item. It may be simpler than using the <code>format</code> method in this case, and is roughly similar to formatting one item with the <code>%</code> expression:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>'{:.2f}'.format(1.2345)</strong></code>                          <code><em># String method</em></code>
'1.23'
&gt;&gt;&gt; <code><strong>format(1.2345, '.2f')</strong></code>                            <code><em># Built-in function</em></code>
'1.23'
&gt;&gt;&gt; <code><strong>'%.2f' % 1.2345</strong></code>                                  <code><em># Expression</em></code>
'1.23'
&gt;&gt;&gt; <code><strong>f'{1.2345:.2f}'       </strong>  </code>                         <code><em># Preview: f-string</em></code>
'1.23'</pre>
<p>Technically, the <code>format</code> built-in runs the subject object’s <code>__format__</code> method, which the <code>str.format</code> method does internally for each formatted item. It’s still more verbose than the original <code>%</code> expression’s equivalent here, though, and the f-string alternative may best both when the <a contenteditable="false" data-type="indexterm" data-primary="methods" data-secondary="string formatting" data-tertiary="format method" data-startref="mstdffr" id="id2062"></a><a contenteditable="false" data-type="indexterm" data-primary="string formatting" data-secondary="format method" data-tertiary="advanced" data-startref="gffmdv" id="id2063"></a>value is a variable’s name—which leads us to the next section.</p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="The F-String Formatting Literal"><div class="sect2" id="the_f_string_formatting_literal">
<h2>The F-String Formatting Literal</h2>
<p>If you’ve survived the formatting story this far, there’s some good news: the third and last variant is mostly<a contenteditable="false" data-type="indexterm" data-primary="string formatting" data-secondary="format method" data-tertiary="f-string literal" id="sgfflt"></a><a contenteditable="false" data-type="indexterm" data-primary="f-strings" data-secondary="literals" id="id2064"></a><a contenteditable="false" data-type="indexterm" data-primary="literals" data-secondary="f-string formatting" id="id2065"></a> just a takeoff on the second. The <em>f-string</em> is a text-string literal that <em>embeds</em> substitution values in the format string itself, rather than listing them separately. The code it uses to specify custom formatting, though, is the same as that used for the formatting method. Hence, much of what you just learned for the method applies here in full.</p>
<p class="pagebreak-before">F-strings, added in Python 3.6, perform what’s <a contenteditable="false" data-type="indexterm" data-primary="string interpolation" id="id2066"></a>generally called <em>string interpolation</em>—replacing the text of an expression with the result of running it live, when the f-string itself is run. These expressions are coded inside the f-string and can be arbitrary Python expression code. The effect isn’t functionally different from listing replacement values after a <code>%</code> in the expression, or as arguments in the <code>format</code> method. Because they embed values where they are to be substituted, though, f-strings are often shorter and may seem easier to read to some observers.</p>
<p>Syntactically, f-strings begin with the letter <code>f</code> (uppercase or lowercase, but usually the latter) before any string-literal form (single, double, or triple quotes). The <code>f</code> prefix may be combined with <code>r</code> in any order to code formatted raw strings that ignore backslashes (e.g., <code>rf</code>), and f-strings concatenate implicitly with an adjacent text-string literal of any kind (but use the <code>f</code> prefix on other concatenated literals if you want them to be f-strings too—even on continuation lines).</p>
<p>As a preview of <a data-type="xref" href="ch37.html#unicode_and_byte_strings">Chapter 37</a>, the <code>f</code> cannot be combined with byte-string prefix <code>b</code> (which means that the f-string, like the <code>format</code> method but unlike the <code>%</code> expression, works only for text, not bytes); and cannot be mixed with the backward-compatible and seldom-used <code>u</code> (which would yield prefixes inappropriate for this family-oriented text).</p>
<section data-type="sect3" data-pdf-bookmark="F-string formatting basics"><div class="sect3" id="f_string_formatting_basics">
<h3>F-string formatting basics</h3>
<p>Within the f-string literal, curly braces are <a contenteditable="false" data-type="indexterm" data-primary="f-strings" data-secondary="literals" data-tertiary="substitutions" id="id2067"></a><a contenteditable="false" data-type="indexterm" data-primary="literals" data-secondary="f-string formatting" data-tertiary="substitutions" id="id2068"></a>used to denote substitutions just like the formatting method. Unlike the method, though, <code>{}</code>s contain inline Python <em>expressions</em> whose formatted runtime results replace the bracketed parts:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>what = 'coding'</strong></code>
&gt;&gt;&gt; <code><strong>tool = 'Python'</strong></code>

&gt;&gt;&gt; <code><strong>f'Learning {what} in {tool}'</strong></code>
'Learning coding in Python'</pre>
<p>As usual, the f-string result is a new string that we’re letting the REPL display, but it can also be assigned to a name to be used elsewhere in our code. F-strings also frequently <a contenteditable="false" data-type="indexterm" data-primary="f-strings" data-secondary="literals" data-tertiary="REPL" id="id2069"></a><a contenteditable="false" data-type="indexterm" data-primary="literals" data-secondary="f-string formatting" data-tertiary="REPL" id="id2070"></a><a contenteditable="false" data-type="indexterm" data-primary="REPLs (real-eval-print loops)" data-secondary="f-string literal" id="id2071"></a>appear in <code>print</code> calls to display formatted text, though sometimes more often than they should: there’s no reason to use an f-string for simple space-separated prints.</p>
<p>In its simplest form like this, an f-string’s expressions enclosed in <code>{}</code> are evaluated and then formatted per their print-string defaults. This isn’t much different from the equivalent expression or method, but is slightly easier on your keyboard and may be slightly easier on your eyes:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>'Learning %s in %s' % (what, tool)</strong> </code>          <code><em># Expression equivalent</em></code>
'Learning coding in Python'

&gt;&gt;&gt; <code><strong>'Learning {} in {}'.format(what, tool)</strong>  </code>     <code><em># Method equivalent</em></code>
'Learning coding in Python'</pre>
<p>Importantly, <em>any</em> expression can be used in the curly braces and works as it would outside the f-string:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>task = f'Learning {what.upper() + '!'} in {tool + str(3.12)}'</strong></code>
&gt;&gt;&gt; <code><strong>task</strong></code>
'Learning CODING! in Python3.12'</pre>
<p>Moreover, <code>{}</code> expressions are evaluated both <em>where</em> they appear (subject to the name-scoping details you’ll meet later in this book) and <em>when</em> the f-string is run to make a string (not when your code is first read by Python). Like the formatting expression and method, it’s a runtime operation that uses the <em>current</em> values of any variables it names:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>what = 'f-strings'</strong></code>
&gt;&gt;&gt; <code><strong>task      </strong>  </code>                         <code><em># F-strings built when run (only)</em></code>
'Learning CODING! in Python3.12'

&gt;&gt;&gt; <code><strong>task = f'Learning {what.upper() + '!'} in {tool + str(3.12)}'</strong></code>
&gt;&gt;&gt; <code><strong>task</strong></code>
'Learning F-STRINGS! in Python3.12'</pre>
<p>As a preview, this runtime nature also means that f-strings, unlike all other text-string literals, don’t work as <a data-type="xref" href="ch15.html#the_documentation_interlude">Chapter 15</a>’s <em>docstrings</em>. This makes sense if you keep in mind that f-strings are runtime code, more like the <code>%</code> expression and <code>format</code> method calls. When coded in a function, for example, an f-string won’t be run until that function is called.</p>
<p>One syntax quirk here: as this <a contenteditable="false" data-type="indexterm" data-primary="f-strings" data-secondary="literals" data-tertiary="quotes" id="id2072"></a><a contenteditable="false" data-type="indexterm" data-primary="literals" data-secondary="f-string formatting" data-tertiary="quotes" id="id2073"></a>example demos, you can embed <em>quotes</em> within an f-string’s <code>{}</code> even if they are the same as the quotes used for the f-string at large—but this is new as of Python 3.12. In earlier Pythons, backslash escapes didn’t help for nested quotes, though other enclosing-quote tricks did, and none of this applies outside a <code>{}</code>:</p>
<pre data-type="programlisting"><code><strong>f'Learning {what + '!'}'</strong></code>         <code><em># OK as of Python 3.12</em></code>

<code><strong>f'Learning {what + '!'}'</strong></code>         <code><em># An error before Python 3.12</em></code>
<code><strong>f'Learning {what + \'!\'}'</strong>  </code>     <code><em># And this doesn't make it work</em></code>

<code><strong>f"Learning {what + '!'}"</strong></code>         <code><em># OK before (and after) Python 3.12</em></code>
<code><strong>f'''Learning {what + '!'}'''</strong></code>     <code><em># Ditto</em></code>

<code><strong>f'Learning '{what + '!'}''</strong>  </code>     <code><em># An error in 3.12+</em></code>
<code><strong>f'Learning \'{what + '!'}\''</strong></code>     <code><em># OK if escape quotes outside {}</em></code></pre>
<p>Also new as of Python 3.12, a <em>backslash</em> can be used in an f-string’s <code>{}</code> part and works <a contenteditable="false" data-type="indexterm" data-primary="f-strings" data-secondary="literals" data-tertiary="backslash" id="id2074"></a><a contenteditable="false" data-type="indexterm" data-primary="literals" data-secondary="f-string formatting" data-tertiary="backslash" id="id2075"></a><a contenteditable="false" data-type="indexterm" data-primary="backslash escape sequences" data-secondary="f-string literal" id="id2076"></a>just like it does outside the <code>{}</code>, as do both <em>comments</em> and <em>newlines</em> (the following may stretch the limits of f-strings, but prove these points):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>f'{'\n'.join([what] * 3) + '\x21'}'</strong></code>
'f-strings\nf-strings\nf-strings!'

&gt;&gt;&gt;<code> <strong>f'Learning {                 # Your comment here</strong></code>
...<code> <strong>     what.upper() + '!'</strong></code>
...<code> <strong>     } in {tool + str(3.12)}'</strong></code>
<code><strong>'Learning F-STRINGS! in Python3.12'</strong></code></pre>
<p>In other words, if you like f-strings, you’ll like them best in Python 3.12+. As this book is based on 3.12 (and 3.13 is right around the corner), it will generally use 3.12’s f-string rules; mod examples’ quotes for older Pythons if needed.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="F-string custom formats"><div class="sect3" id="f_string_custom_formats">
<h3>F-string custom formats</h3>
<p>As noted, f-strings use <a contenteditable="false" data-type="indexterm" data-primary="f-strings" data-secondary="literals" data-tertiary="custom formats" id="id2077"></a><a contenteditable="false" data-type="indexterm" data-primary="literals" data-secondary="f-string formatting" data-tertiary="custom formats" id="id2078"></a>the same custom-format syntax as string methods, so there’s not much new to learn here. In the abstract, f-strings are coded with a format like this (as usual, <code>[…]</code> means an optional part here and its square brackets are not part of the f-string’s code, but spaces are generally allowed between the parts here):</p>
<pre data-type="programlisting">f'…<code><em>literaltext</em></code>… {<code><em>expression</em></code> [=] [!s, !r, or !a] [:<code><em>formatspec</em></code>]} …<code><em>literaltext</em></code>…'</pre>
<p class="pagebreak-before">As in the method, text outside a <code>{}</code> is taken literally and uses <code>{{</code> and <code>}}</code> to escape braces, and the <code>{}</code> part can be repeated to embed multiple values. In each, the <code><em>expression</em></code> part is any Python expression code (including nested f-strings) and is run to produce the substitution value before formatting it. As in the formatting method, the optional <code>!s</code>, <code>!r</code>, or <code>!a</code> render the expression in user-friendly, as-code, or ASCII-with-escapes form—which is the same as calling <code>str</code>, <code>repr</code>, or <code>ascii</code> for the entire expression enclosed by <code>{}</code>.</p>
<p>Within a <code>{}</code>, the <code><em>formatspec</em></code> that is coded after a <code>:</code> is (nearly) <em>identical</em> to that used in the string method and presented earlier, so we won’t repeat its syntax here; see <a data-type="xref" href="#formatting_method_custom_formats">“Formatting method custom formats”</a> for the options that f-strings share with the method. As a minor convenience for developers, f-strings also allow an <code>=</code> character after <code><em>expression</em></code> to add the expression’s text and an “=” as a label before its value formatted with a <code>repr</code> default.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Advanced f-string examples"><div class="sect3" id="advanced_f_string_examples">
<h3>Advanced f-string examples</h3>
<p>All of which is easier to explain by example than narrative, so let’s get back to running code. Numbers can be formatted in a variety of ways spelled out for the formatting method earlier—including defaults, fixed decimal digits, comma and underscore separators, exponents, signs, and leading zeroes:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>a = 3.14156</strong></code>
&gt;&gt;&gt; <code><strong>b = 1_234_567</strong></code>

&gt;&gt;&gt; <code><strong>f'{a} and {b}'</strong>  </code>                         <code><em># Defaults</em></code>
'3.14156 and 1234567'

&gt;&gt;&gt; <code><strong>f'{a:.2f} and {b:09}'</strong></code>                    <code><em># Decimals, padding</em></code>        
'3.14 and 001234567'
 
&gt;&gt;&gt; <code><strong>f'{a * 1000:,.2f} and {b:,} and {b:_}'</strong></code>   <code><em># Comma and underscore separators</em></code>
'3,141.56 and 1,234,567 and 1_234_567'

&gt;&gt;&gt; <code><strong>f'{a * 1000:e} and {b:+012,}'</strong>  </code>          <code><em># Exponents, signs, and padding</em></code>
'3.141560e+03 and +001,234,567'

&gt;&gt;&gt; <code><strong>f'{b:_X} and {b:_o} and {b // 64:_b}'</strong></code>    <code><em># Hex, octal, binary, underscores</em></code>
'12_D687 and 455_3207 and 100_1011_0101_1010'</pre>
<p>Adding an <code>=</code> after the expression may be useful when you’re debugging code, as it <em>labels</em> data automatically (though this may be more readable for simple variable names than larger expressions):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>f'{a=:e} and {b=:+012,}'</strong>  </code>               <code><em># Labeled</em></code>
'a=3.141560e+00 and b=+001,234,567'
 
&gt;&gt;&gt; <code><strong>f'{a + 1=:e} and {b * 2=:+012,}'</strong></code>
'a + 1=4.141560e+00 and b * 2=+002,469,134'</pre>
<p>String formats can vary according to the <code>s</code>/<code>r</code>/<code>a</code> <em>flag</em> also coded before the format specifier (but after <span class="keep-together">an <code>=</code></span>). To demo, the following uses a non-ASCII character (an “A” with either an umlaut mark or <span class="keep-together">diaeresis</span>):</p>
<pre class="pagebreak-before" data-type="programlisting">&gt;&gt;&gt; <code><strong>c = 'h\xc4ck' </strong>  </code>                         <code><em># \xc4 (a.k.a \u00c4) is non-ASCII Ä</em></code>

&gt;&gt;&gt; <code><strong>f'{c} and {c} and {c}'</strong></code>                   <code><em># Defaults</em></code>
'hÄck and hÄck and hÄck'
 
&gt;&gt;&gt; <code><strong>f'{c!s} and {c!r} and {c!a}'</strong>   </code>          <code><em># Display mode, two ways</em></code>
"hÄck and 'hÄck' and 'h\\xc4ck'"
 
&gt;&gt;&gt; <code><strong>f'{str(c)} and {repr(c)} and {ascii(c)}'</strong></code>
"hÄck and 'hÄck' and 'h\\xc4ck'"
 
&gt;&gt;&gt; <code><strong>f'{c=!s} and {c=!r} and {c=!a}'</strong></code>          <code><em># Labeled</em></code>
"c=hÄck and c='hÄck' and c='h\\xc4ck'"
 
&gt;&gt;&gt; <code><strong>f'{c=!s:8} and {repr(c)} and {c:0&gt;8}'</strong></code>    <code><em># Width, fill, alignment</em></code>
"c=hÄck     and 'hÄck' and 0000hÄck"</pre>
<p><em>Advanced tip</em>: as in the formatting method, parts of the format specifier can be fetched <em>dynamically</em> at runtime instead of being hardcoded, by using nested <code>{}</code> expressions. The nested expression’s formatted result is used where it appears:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>width = 8</strong></code>

&gt;&gt;&gt; <code><strong>f'{a:.8f} and {c:0&gt;8}'</strong></code>                   <code><em># Hardcoded parameters</em></code>
'3.14156000 and 0000hÄck'

&gt;&gt;&gt; <code><strong>f'{a:.{width}f} and {c:0&gt;{width}}'</strong>  </code>     <code><em># Dynamic parameters</em></code>
'3.14156000 and 0000hÄck'

&gt;&gt;&gt; <code><strong>f'{a=:.{width}f} and {c * 2:0&gt;{width * 3}}'</strong></code>
'a=3.14156000 and 0000000000000000hÄckhÄck'</pre>
<p>Like the <code>format</code> method, <em>any</em> part of a <code><em>formatspec</em></code> in a <code>{}</code> can be a nested <code>{}</code>—though they contain <em>expressions</em> in the f-string, not argument identifiers. This is why f-string formats are just “(nearly)” identical. Other parts of f-strings don’t allow <code>{}</code>s (forward reference: for economy, the following assigns many names positionally with sequence-assignment syntax covered formally in <a data-type="xref" href="ch11.html#assignmentscomma_expressionscomma_and_p">Chapter 11</a>—it’s like <code>a=0</code>, <code>b='&lt;'</code>, and so on):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>what = 1_234.564</strong></code>
&gt;&gt;&gt; <code><strong>a, b, c, d, e, f, g, h = 0, '&lt;', '+', 12, ',', '.', 2, 'f'</strong></code>

&gt;&gt;&gt; <code><strong>f'{what:0&lt;+12,.2f}!'</strong></code>
'+1,234.56000!'

&gt;&gt;&gt; <code><strong>f'{what:{a}{b}{c}{d}{e}{f}{g}{h}}!'</strong> </code>     <code><em># But don't try this at home?</em></code>
'+1,234.56000!'</pre>
<p><em>Usage tip</em>: because f-strings run expressions that reference variables, they may not be easy to use as <em>templates</em> when substitution values are collected in a <em>container</em> at runtime—as they often would be. In the following, a <code>**</code> converts dictionary keys to keyword arguments, as you’ll learn later in this book:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>values = dict(tool='Python', role='scripting')</strong></code>     <code><em># Collected values</em></code>

&gt;&gt;&gt; <code><strong>'Use %(tool)s for %(role)s.' % values</strong> </code>             <code><em># Expression: keys</em></code>
'Use Python for scripting.'

&gt;&gt;&gt; <code><strong>'Use {tool} for {role}.'.format(**values)</strong> </code>         <code><em># Method: keywords</em></code>
'Use Python for scripting.'

&gt;&gt;&gt; <code><strong>'Use {0[tool]} for {0[role]}.'.format(values)</strong></code>      <code><em># Method: reused-arg keys</em></code>
'Use Python for scripting.'

&gt;&gt;&gt; <code><strong>f'Use {values['tool']} for {values['role']}.'</strong> </code>     <code><em># F-string: expressions</em></code>
'Use Python for scripting.'</pre>
<p>For more impressive f-string results, assign substitution values to same-scope variables when possible:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>tool = 'Python'</strong></code>
&gt;&gt;&gt; <code><strong>role = 'scripting'</strong></code>
&gt;&gt;&gt; <code><strong>f'Use {tool} for {role}.'</strong></code>
'Use Python for scripting.'</pre>
<p>But also bear in mind that f-strings may not be easy to use when templates are loaded from <em>external files</em> at runtime—as they often would be. While the format expression and method can treat such templates as simple text data, f-strings are Python <em>program code</em>, and hence may have to be run post load with the <code>eval</code> function of <a data-type="xref" href="ch05.html#numbers_and_expressions">Chapter 5</a>—and trusted to not contain code that will do damage (e.g., erasing files is fairly easy in a Python expression):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>fs = """f'Use {tool} for {role}.'"""</strong></code>               <code><em># As if loaded from a file</em></code>
&gt;&gt;&gt; <code><strong>eval(fs)                </strong>  </code>                         <code><em># Run as code – and trust!</em></code>
'Use Python for scripting.'</pre>
<p>F-strings are a powerful tool, but their nested expressions make them geared more toward <em>in-program</em> formatting than data-based roles. For more details on the f-string, see <a contenteditable="false" data-type="indexterm" data-primary="string formatting" data-secondary="format method" data-tertiary="f-string literal" data-startref="sgfflt" id="id2079"></a>its full disclosure in Python’s language reference manual.</p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="And the Winner Is…"><div class="sect2" id="and_the_winner_ishasheighttwothreezero">
<h2>And the Winner Is…</h2>
<p>The previous edition of this book went to considerable lengths (about seven pages) to show how the formatting method, newest at the time, was functionally redundant with the expression, in order to underscore the downsides of feature bloat in programming languages. Given that the number of primary formatting tools in Python has <em>climbed from two to three</em> since then, that message may not have entirely hit its mark. Consequently, this edition has dropped most of the rhetoric, and opted to leave this race’s call up to you.</p>
<p>But if you’re looking for a <em>guideline</em>, there is no killer argument for dismissing any formatting option out of hand for all use cases. As stated at the start of this section, <em>f-strings</em> may be best in most new code, on logistical grounds alone: newer is less likely to be culled by Python sooner. In fact, we’ll be using them regularly in the rest of this book where warranted, so expect more examples ahead. Even so, you will also see the expression and method often in existing code and may <em>have</em> to use them in roles that f-strings don’t address (e.g., for substitutions in text loaded from files).</p>
<p>More fundamentally, this book is not in the business of telling you what to do, and you are welcome to use <em>any</em> formatting option you prefer. Imposing new tools on programmers is exclusive, divisive, and probably rude. Despite norms in the software field today, the choice of development options should be yours—and yours alone—to make.</p>
<p>As for the <em>bloat</em>: change is not always bad, but it can be when it creates redundancy or incompatibility. In fact, you’ve just had a front-row seat to one of its worst consequences: <code><em>N</em></code> functionally equivalent options can multiply newcomers’ learning requirements by <code><em>N</em></code>. We’ll return to this and other perils of ego-fueled churn and convolution in software development at the end of this book. For now, we’ll close by simply noting that this stuff still matters. With any luck, a future edition won’t have yet another formatting tool to doc, and future learners won’t have yet another one to grok.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="plus_one_more_stringdottemplate">
<h1>Plus One More: string.Template</h1>
<p>Technically speaking, there are <em>four</em> (not three) formatting tools built into Python today, if we include the obscure <code>string</code> module’s <code>Template</code> tool mentioned earlier. Now that you’ve seen the other three, you can tell how it compares. The expression, method, and f-string can all be used as templating tools, referring to substitution values by name using dictionary keys, keyword arguments, or variables (the “;” in the following separates multiple statements needed to give the <span class="keep-together">f-string</span> variables to reference):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>'The %(num)s %(tool)ss' % dict(num=4, tool='formatter')</strong></code>
'The 4 formatters'
&gt;&gt;&gt; <code><strong>'The {num} {tool}s'.format(num=4, tool='formatter')</strong></code>
'The 4 formatters'
&gt;&gt;&gt; <code><strong>num=4; tool='formatter'; f'The {num} {tool}s'</strong></code>
'The 4 formatters'</pre>
<p>The module’s templating system allows values to be referenced by name too, prefixed by a <code>$</code>, as either dictionary keys or keywords, but does not support all the utilities of the other two <span class="keep-together">methods—a</span> limitation that yields simplicity, the prime motivation for this tool:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>import string</strong></code>
&gt;&gt;&gt; <code><strong>t = string.Template('The $num ${tool}s')</strong></code>
&gt;&gt;&gt; <code><strong>t.substitute(num=4, tool='formatter')</strong></code>
'The 4 formatters'
&gt;&gt;&gt; <code><strong>t.substitute(dict(num=4, tool='formatter'))</strong></code>
'The 4 formatters'</pre>
<p>See Python’s manuals for more details. It’s possible that you may see this alternative (as well as additional tools in the third-party domain) in Python code too; thankfully this technique is simple and is used rarely enough to warrant its limited coverage here.</p>
</div></aside>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="General Type Categories"><div class="sect1" id="general_type_categories">
<h1>General Type Categories</h1>
<p>Now that we’ve explored the first of Python’s collection objects, the string, let’s close this chapter by defining a few general type concepts that will apply to most of the types we’ll look at from here on. With regard to built-in types, it turns out that operations work the same for all the types in the same category, so we’ll only need to define most of these ideas once. We’ve examined only numbers and strings so far, but because they are representative of two of the three major type categories in Python, you already know more about several other types than you might think.</p>
<section data-type="sect2" data-pdf-bookmark="Types Share Operation Sets by Categories"><div class="sect2" id="types_share_operation_sets_by_categorie">
<h2>Types Share Operation Sets by Categories</h2>
<p>As you’ve learned, strings are <a contenteditable="false" data-type="indexterm" data-primary="immutability" data-secondary="strings" id="id2080"></a>immutable sequences: they cannot be changed in place (the <em>immutable</em> part), and they are positionally ordered collections that are accessed by offset (the <em>sequence</em> part). It so happens that all the sequences we’ll study in this part of the book respond to the same sequence operations shown in this chapter at work on strings—concatenation, indexing, iteration, and so on. More formally, there <a contenteditable="false" data-type="indexterm" data-primary="types" data-secondary="numbers" id="id2081"></a><a contenteditable="false" data-type="indexterm" data-primary="types" data-secondary="sequences" id="id2082"></a><a contenteditable="false" data-type="indexterm" data-primary="types" data-secondary="mappings" id="id2083"></a><a contenteditable="false" data-type="indexterm" data-primary="numbers" data-secondary="integers" id="id2084"></a><a contenteditable="false" data-type="indexterm" data-primary="numbers" data-secondary="floating-point numbers" id="id2085"></a><a contenteditable="false" data-type="indexterm" data-primary="numbers" data-secondary="decimals" id="id2086"></a><a contenteditable="false" data-type="indexterm" data-primary="numbers" data-secondary="fractions" id="id2087"></a><a contenteditable="false" data-type="indexterm" data-primary="integers" id="id2088"></a><a contenteditable="false" data-type="indexterm" data-primary="floating point numbers" id="id2089"></a><a contenteditable="false" data-type="indexterm" data-primary="decimals" id="id2090"></a><a contenteditable="false" data-type="indexterm" data-primary="fractions" id="id2091"></a><a contenteditable="false" data-type="indexterm" data-primary="sequences" data-secondary="strings" id="id2092"></a><a contenteditable="false" data-type="indexterm" data-primary="sequences" data-secondary="lists" id="id2093"></a><a contenteditable="false" data-type="indexterm" data-primary="sequences" data-secondary="tuples" id="id2094"></a><a contenteditable="false" data-type="indexterm" data-primary="strings" id="id2095"></a><a contenteditable="false" data-type="indexterm" data-primary="lists" id="id2096"></a><a contenteditable="false" data-type="indexterm" data-primary="tuples" id="id2097"></a><a contenteditable="false" data-type="indexterm" data-primary="mappings" id="id2098"></a><a contenteditable="false" data-type="indexterm" data-primary="dictionaries" id="id2099"></a>are three major type (and hence operation) categories in Python that have this generic nature:</p>
<dl class="pagebreak-before">
<dt>Numbers (integer, floating-point, decimal, fraction, others)</dt>
<dd>Support addition, multiplication, etc.</dd>
<dt>Sequences (strings, lists, tuples)</dt>
<dd>Support indexing, slicing, concatenation, etc.</dd>
<dt>Mappings (dictionaries)</dt>
<dd>Support indexing by key, etc.</dd>
</dl>
<p>Python’s byte strings mentioned at the start of this chapter fall under the general “strings” label here; sets are something of a category unto themselves (they don’t map keys to values and are not positionally ordered sequences); and we haven’t yet explored mappings on our in-depth tour (we will in the next chapter). However, many of the other types we will encounter will be similar to numbers and strings. For example, for any sequence objects <code><em>X</em></code> and <code><em>Y</em></code>:</p>
<ul>
<li><p><code><em>X</em> + <em>Y</em></code> makes a new sequence object with the contents of both operands joined.</p></li>
<li><p><code><em>X</em> * <em>N</em></code> makes a new sequence object with <code><em>N</em></code> copies of the sequence operand <code><em>X</em></code>.</p></li>
</ul>
<p>In other words, these operations work the same way on any kind of sequence, including strings, lists, tuples, and some user-defined object types. The only difference is that the new result object you get back is of the same type as the operands <code><em>X</em></code> and <code><em>Y</em></code>—if you concatenate lists, you get back a new list, not a string. Indexing, slicing, and other sequence operations work the same on all sequences, too; the type of the objects being processed tells Python which flavor of the task to perform (and if that sounds like <em>polymorphism</em> again, it should).</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Mutable Types Can Be Changed in Place"><div class="sect2" id="mutable_types_can_be_changed_in_place">
<h2>Mutable Types Can Be Changed in Place</h2>
<p>The string’s immutable classification is an important constraint to be aware of, yet it tends to trip up new users. If an object type is immutable, you cannot change its value in place; Python raises an error if you try. Instead, you must run code to make a new object containing the new value. The major core types in Python break down as follows:</p>
<dl>
<dt>Immutables (numbers, strings, tuples, frozensets)</dt>
<dd>None of the object types <a contenteditable="false" data-type="indexterm" data-primary="immutable types" id="id2100"></a><a contenteditable="false" data-type="indexterm" data-primary="types" data-secondary="immutable" id="id2101"></a>in the immutable category support in-place changes, though we can always run expressions to make new objects and assign their results to variables as needed.</dd>
<dt>Mutables (lists, dictionaries, sets, bytearray)</dt>
<dd>Conversely, the mutable <a contenteditable="false" data-type="indexterm" data-primary="mutable types" id="id2102"></a><a contenteditable="false" data-type="indexterm" data-primary="types" data-secondary="mutable" id="id2103"></a>object types can always be changed in place with operations that do not create new objects. Although such objects can be copied manually, in-place changes support direct modification.</dd>
</dl>
<p>Generally, immutable types give some degree of integrity by guaranteeing that an object won’t be changed by another part of a program. For a refresher on why this matters, see the discussion of shared object references in <a data-type="xref" href="ch06.html#the_dynamic_typing_interlude">Chapter 6</a>. To see how lists, dictionaries, and tuples participate in type categories, we need to move ahead to the next chapter.</p>
</div></section>
</div></section>
<section data-type="sect1" class="pagebreak-before" data-pdf-bookmark="Chapter Summary"><div class="sect1" id="chapter_summary-id00017">
<h1 class="less_space">Chapter Summary</h1>
<p>In this chapter, we took an in-depth, second-pass tour of the string object type. We learned about coding string literals, and we explored string operations, including sequence expressions, string method calls, and string formatting in its expression, method, and literal flavors. Along the way, we studied a variety of concepts in depth, such as slicing, method call syntax, and triple-quoted block strings. We also defined some core ideas common to a variety of types: sequences, for example, share an entire set of operations demoed here for strings.</p>
<p>In the next chapter, we’ll continue our types tour with a look at the most general object collections in Python—lists and dictionaries. As you’ll find, much of what you’ve learned here will apply to those types as well. And as mentioned earlier, in the final part of this book we’ll return to Python’s string model to flesh out the details of Unicode text and binary data, which are of interest to some, but not all, Python programmers, and depend on tools we haven’t yet studied in full. Before moving on, though, here’s another chapter quiz to review the material covered here.</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Test Your Knowledge: Quiz"><div class="sect1" id="test_your_knowledge_quiz-id000136">
<h1>Test Your Knowledge: Quiz</h1>
<ol>
<li><p>Can the string <code>find</code> method be used to search a list?</p></li>
<li><p>Can a string slice expression be used on a list?</p></li>
<li><p>How would you convert a character to its ASCII integer code? How would you convert the other way, from an integer code to a character?</p></li>
<li><p>How might you go about changing a string in Python?</p></li>
<li><p>Given a string <code>S</code> with the value <code>'c,od,e'</code>, name two ways to extract the two characters in the <span class="keep-together">middle</span>.</p></li>
<li><p>How many characters are there in the string <code>"a\nb\x1f\000d"</code>?</p></li>
<li><p>Write an expression, method call, and f-string to format <code>'Python'</code> and <code>3.12</code> at a string’s beginning and end.</p></li>
</ol>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Test Your Knowledge: Answers"><div class="sect1" id="test_your_knowledge_answers-id000135">
<h1>Test Your Knowledge: Answers</h1>
<ol>
<li><p>No, because methods are always <a contenteditable="false" data-type="indexterm" data-primary="lists" data-secondary="searching" id="id2104"></a><a contenteditable="false" data-type="indexterm" data-primary="searches" data-secondary="lists" id="id2105"></a>type specific; that is, they only work on a single object type. Expressions like <code><em>X</em>+<em>Y</em></code> and built-in functions like <code>len(<em>X</em>)</code> are generic, though, and may work on a variety of types. In this case, for instance, the <code>in</code> membership expression has a similar effect as the string <code>find</code>, but it can be used to search both strings and lists. Python makes some attempt to name similar methods consistently (many objects have a <code>copy</code> method, for example, and mutable objects may share method names like <code>pop</code>), but methods are still more type specific than other operation sets.</p></li>
<li><p>Yes. Unlike methods, expressions <a contenteditable="false" data-type="indexterm" data-primary="sequence operations" id="id2106"></a><a contenteditable="false" data-type="indexterm" data-primary="slice assignments" id="id2107"></a>are generic and apply to many types. In this case, the slice expression is really a <em>sequence</em> operation—it works on any type of sequence object, including strings, lists, and tuples. The only difference is that when you slice a list, you get back a new list.</p></li>
<li><p>The built-in <code>ord(<em>S</em>)</code> function converts from a one-character string to an integer character code; <code>chr(<em>I</em>)</code> converts from the integer code back to a string. Keep in mind, though, that these integers are only ASCII codes for text whose characters are drawn only from the ASCII character set. In the Unicode model, text strings are really sequences of Unicode code point identifying integers, which may fall outside the 7-bit range of numbers reserved by ASCII (we previewed Unicode in <a data-type="xref" href="ch04.html#introducing_python_objects">Chapter 4</a> and will revisit it in <a data-type="xref" href="ch37.html#unicode_and_byte_strings">Chapter 37</a>).</p></li>
<li><p>Strings cannot be changed; they are immutable. However, you can achieve a similar effect by creating a new string—by concatenating, slicing, using a method call like <code>replace</code>, or running formatting operations—and then assigning the result back to the original variable name.</p></li>
<li><p>You can slice the string using <code>S[2:4]</code> or split on the comma and index the string using <code>S.split(',')[1]</code>. Try these interactively to see for yourself.</p></li>
<li><p>Six. The string <code>"a\nb\x1f\000d"</code> contains the characters <code>a</code>, newline (<code>\n</code>), <code>b</code>, literal value <code>31</code> (as hex escape <code>\x1f</code>, which is a code point that stands for the nonprintable control character US), literal value <code>0</code> (an octal escape <code>\000</code>), and <code>d</code>. Pass the string to the built-in <code>len</code> function to verify this and print each of its characters’ <code>ord</code> results to see the actual code point (identifying number) values. See <a data-type="xref" href="#string_backslash_characters">Table 7-2</a> for more details on escapes.</p></li>
<li><p>There’s no right answer for what goes in the middle of the result string, but as examples: <code>'%s is %s' % ('Python', 3.12)</code> works for the expression, and <code>'{} is {}'.format('Python', 3.12)</code> suffices for the method call. There’s almost no reason to use an f-string if all parts are known and formatted per defaults (<code>f'{'Python'} is {3.12}'</code> seems silly), but f-strings are more useful if values are first assigned to variables: <code>x='Python'; y=3.12; f'{x} is {y}'</code> or similar garners full points.</p></li>
</ol>
</div></section>
</div></section></div>
</div>
</body>
</html>