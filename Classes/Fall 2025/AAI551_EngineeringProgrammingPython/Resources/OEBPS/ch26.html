<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xml:lang="en"
lang="en"
xmlns="http://www.w3.org/1999/xhtml"
xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<title>Learning Python, 6th Edition</title>
<link rel="stylesheet" type="text/css" href="override_v1.css"/>
<link rel="stylesheet" type="text/css" href="epub.css"/>
</head>
<body>
<div id="book-content">
<div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 26. OOP: The Big Picture"><div class="chapter" id="oop_the_big_picture">
<h1><span class="label">Chapter 26. </span>OOP: The Big Picture</h1>
<p>So far in this book, we’ve been using the term “object” generically. Really, the code written up to this point has been <em>object-based</em>—we’ve passed objects around our scripts, used <a contenteditable="false" data-type="indexterm" data-primary="object-based code" id="id3673"></a><a contenteditable="false" data-type="indexterm" data-primary="OO (object-oriented) code" id="id3674"></a>them in expressions, called their methods, and so on. For our code to qualify as being truly <em>object-oriented</em> (OO), though, our objects will generally need to also participate in something called an <em>inheritance hierarchy</em>.</p>
<p>This chapter begins our <a contenteditable="false" data-type="indexterm" data-primary="inheritance hierarchy" id="id3675"></a><a contenteditable="false" data-type="indexterm" data-primary="classes" id="id3676"></a>exploration of the Python <em>class</em>—a coding structure and device used to implement new kinds of objects in Python that support inheritance. Classes are Python’s main object-oriented programming (OOP) tool, so we’ll also <a contenteditable="false" data-type="indexterm" data-primary="OOP (object-oriented programming)" id="id3677"></a>study OOP basics along the way in this part of the book. OOP offers a different and often more effective way of programming. Like functions, we can use classes to factor code <a contenteditable="false" data-type="indexterm" data-primary="classes" data-secondary="redundancy" id="id3678"></a><a contenteditable="false" data-type="indexterm" data-primary="redundancy" data-secondary="classes" id="id3679"></a>to minimize <em>redundancy</em>. Unlike functions, classes make it easy to write new programs by <em>customizing</em> existing code instead of changing it in place.</p>
<p>In Python, classes are created with a <a contenteditable="false" data-type="indexterm" data-primary="class statement" id="id3680"></a><a contenteditable="false" data-type="indexterm" data-primary="statements" data-secondary="class" id="id3681"></a>new statement: the <code>class</code>. As you’ll see, the objects defined with classes can look a lot like the built-in object types we employed earlier in the book. In fact, classes really just apply and extend the ideas we’ve already covered; roughly, they are packages of functions that use and process built-in objects. Classes, though, are designed to create and manage new objects, and <a contenteditable="false" data-type="indexterm" data-primary="classes" data-secondary="inheritance" id="id3682"></a><a contenteditable="false" data-type="indexterm" data-primary="inheritance" data-secondary="classes" id="id3683"></a>support <em>inheritance</em>—a mechanism of code customization and reuse above and beyond anything we’ve seen so far.</p>
<p>One note up front: in Python, OOP is entirely optional, and you don’t need to use classes just to get started. You can get plenty of work done with simpler constructs such as functions, or even simple top-level script code. Because using classes well requires some up-front planning, they tend to be of more interest to people who work in <em>strategic</em> mode (doing long-term product development) than to people who work in <em>tactical</em> mode (where time is in very short supply).</p>
<p>Still, as you’ll see in this part of the book, classes turn out to be one of the most useful tools Python provides. When used well, classes can actually cut development time radically. They’re also employed in popular Python libraries, so most Python programmers will usually find at least a working knowledge of class basics helpful.</p>
<section data-type="sect1" data-pdf-bookmark="Why Use Classes?"><div class="sect1" id="why_use_classesquestion_mark">
<h1>Why Use Classes?</h1>
<p>Remember when this book told you that programs “do things with stuff” in Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch04.html#introducing_python_objects">4</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch10.html#introducing_python_statements">10</a>? In simple terms, classes are just a way to define new sorts of <em>stuff</em>, reflecting real objects in a program’s domain. For instance, suppose we decide to implement that hypothetical pizza-making robot we used as an example in <a data-type="xref" href="ch16.html#function_basics">Chapter 16</a>. If we implement it using classes, we can model more of its real-world structure and relationships. Two aspects of OOP could be useful here:</p>
<dl>
<dt>Inheritance</dt>
<dd>Pizza-making robots are kinds of robots, so <a contenteditable="false" data-type="indexterm" data-primary="classes" data-secondary="inheritance" id="id3684"></a><a contenteditable="false" data-type="indexterm" data-primary="inheritance" data-secondary="OOP" id="id3685"></a>they possess the usual robot-y properties. In OOP terms, we say they “inherit” properties from the general category of all robots. These common properties need to be implemented only once for the general case and can be reused in part or in full by all types of robots we may build in the future.</dd>
<dt>Composition</dt>
<dd>Pizza-making robots are really <a contenteditable="false" data-type="indexterm" data-primary="classes" data-secondary="composition" id="id3686"></a><a contenteditable="false" data-type="indexterm" data-primary="OOP (object-oriented programming)" data-secondary="composition" id="id3687"></a>collections of components that work together as a team. For instance, for our robot to be successful, it might need arms to roll dough, motors to maneuver to the oven, and so on. In OOP parlance, our robot is an example of composition; it contains other objects that it activates to do its bidding. Each component might be coded as a class, which defines its own behavior and relationships.</dd>
</dl>
<p>While you may never build pizza-making robots, general OOP ideas like inheritance and composition apply to any application that can be decomposed into a set of objects. For example, in typical <em>GUI</em> systems, interfaces are written as collections of widgets—buttons, labels, and so on—which are all drawn when their container is drawn (<em>composition</em>). Moreover, we may be able to write our own custom widgets—buttons with unique fonts, labels with new color schemes, and the like—which are specialized versions of more general interface devices (<em>inheritance</em>).</p>
<p>From a more concrete programming perspective, classes are Python <em>program units</em>, just like <a contenteditable="false" data-type="indexterm" data-primary="classes" data-secondary="as program units" data-secondary-sortas="program units" id="id3688"></a>functions and modules: they are another compartment for packaging logic and data. In fact, classes also define new namespaces, much like modules. But, compared to other program units we’ve already seen, classes have three critical distinctions that make them more useful when it comes to building new objects:</p>
<dl>
<dt>Multiple instances</dt>
<dd>Classes are essentially <em>factories</em> for generating <a contenteditable="false" data-type="indexterm" data-primary="classes" data-secondary="instances" id="id3689"></a><a contenteditable="false" data-type="indexterm" data-primary="instances" data-secondary="classes" id="id3690"></a><a contenteditable="false" data-type="indexterm" data-primary="OOP (object-oriented programming)" data-secondary="instances" id="id3691"></a>one or more objects. Every time we call a class, we generate a new object with a distinct namespace. Each object generated from a class has access to the class’s attributes <em>and</em> gets a namespace of its own for data that varies per object. This is similar to the per-call state retention of <a data-type="xref" href="ch17.html#scopes">Chapter 17</a>’s <em>closure</em> functions, but is explicit and natural in classes, and is just one of the things that classes do. Classes offer a more complete programming solution.</dd>
<dt>Customization via inheritance</dt>
<dd>Classes also support the OOP notion <a contenteditable="false" data-type="indexterm" data-primary="classes" data-secondary="extending" id="id3692"></a><a contenteditable="false" data-type="indexterm" data-primary="OOP (object-oriented programming)" data-secondary="inheritance" id="id3693"></a>of inheritance: we can <em>extend</em> a class by redefining its attributes outside the class itself in new software components coded <a contenteditable="false" data-type="indexterm" data-primary="classes" data-secondary="namespaces" data-tertiary="hierarchies" id="id3694"></a><a contenteditable="false" data-type="indexterm" data-primary="namespaces" data-secondary="classes" data-tertiary="hierarchies" id="id3695"></a>as subclasses. More generally, classes can build up namespace <em>hierarchies</em>, which define names to be used by objects created from classes in the hierarchy. This supports multiple customizable behaviors more directly than other tools.</dd>
<dt>Operator overloading</dt>
<dd>By providing special <a contenteditable="false" data-type="indexterm" data-primary="OOP (object-oriented programming)" data-secondary="operator overload" id="id3696"></a><a contenteditable="false" data-type="indexterm" data-primary="operator overloading" data-secondary="OOP" id="id3697"></a>protocol methods, classes can define objects that respond to the sorts of <em>operations</em> we saw at work on built-in types. For instance, objects made with classes can be sliced, concatenated, indexed, and so on. Python provides hooks that classes can use to intercept and implement any built-in type operation.</dd>
</dl>
<p>At its base, the mechanism of OOP in Python largely boils down to just two bits of magic: a special first <em>argument</em> in functions (to receive the subject of a call) and <a contenteditable="false" data-type="indexterm" data-primary="OOP (object-oriented programming)" data-secondary="arguments, functions" id="id3698"></a><a contenteditable="false" data-type="indexterm" data-primary="OOP (object-oriented programming)" data-secondary="search attribute" id="id3699"></a><a contenteditable="false" data-type="indexterm" data-primary="OOP (object-oriented programming)" data-secondary="inheritance" data-tertiary="search attribute" id="id3700"></a>inheritance attribute <em>search</em> (to support programming by customization). Other than this, the model is largely just functions that ultimately process built-in types. While not radically new, though, OOP adds an extra layer of structure that supports programming better than flat procedural models. Along with the functional tools we met earlier, it <span class="keep-together">represents</span> a major abstraction step above computer hardware that helps us build more sophisticated programs.</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="OOP from 30,000 Feet"><div class="sect1" id="oop_from_threezerocommazerozerozero_fee">
<h1>OOP from 30,000 Feet</h1>
<p>Before we dig into what this all means in terms of code, let’s get a better handle on the general ideas behind OOP. If you’ve never done anything object-oriented in your life before now, some of the terminology in this chapter may seem a bit perplexing on the first pass. Moreover, the motivation for these terms may be elusive until you’ve had a chance to study the ways that programmers apply them in larger systems. OOP is as much an experience as a technology.</p>
<section data-type="sect2" data-pdf-bookmark="Attribute Inheritance Search"><div class="sect2" id="attribute_inheritance_search">
<h2>Attribute Inheritance Search</h2>
<p>The good news is that OOP is much <a contenteditable="false" data-type="indexterm" data-primary="OOP (object-oriented programming)" data-secondary="attribute fetches" id="pottft"></a><a contenteditable="false" data-type="indexterm" data-primary="OOP (object-oriented programming)" data-secondary="inheritance" data-tertiary="attributes" id="opohtt"></a><a contenteditable="false" data-type="indexterm" data-primary="inheritance" data-secondary="OOP" data-tertiary="attributes" id="ihoptt"></a>simpler to understand and use in Python than in some other languages like C++ or Java. As a dynamically typed scripting language, Python removes much of the syntactic clutter and complexity that clouds OOP in other tools. In fact, much of the OOP story in Python boils down to this expression:</p>
<pre data-type="programlisting"><code><em>object</em></code>.<code><em>attribute</em></code></pre>
<p>We’ve been using this expression throughout the book to access module attributes, call methods of objects, and so on. When we say this to an object that is derived from a <code>class</code> statement, however, the expression kicks off a <em>search</em> in Python—it searches a tree of linked objects, looking for the first appearance of <code><em>attribute</em></code> that it can find. When classes are involved, the preceding Python expression effectively translates to the following in natural language:</p>
<blockquote>
<p>Find the first occurrence of <code><em>attribute</em></code> by looking in <code><em>object</em></code>, then in all classes above it, from bottom to top and left to right.</p>
</blockquote>
<p>In other words, attribute fetches are simply tree searches. The term <em>inheritance</em> is applied to it because objects lower in a tree inherit attributes attached to objects higher in that tree. As the search proceeds from the bottom up, in a sense, the objects linked into a tree are the union of all the attributes defined in all their tree parents, all the way up the tree.</p>
<p>In Python, this is all very literal: we really do build up trees of linked objects with code, and Python really does climb this tree at runtime searching for attributes every time we use the <code><em>object</em>.<em>attribute</em></code> expression. To make this more concrete, <a data-type="xref" href="#a_class_tree_instances_left_parenthesis">Figure 26-1</a> sketches an example of one of these trees.</p>
<figure><div id="a_class_tree_instances_left_parenthesis" class="figure">
<img src="assets/lpy6_2601.png" alt="" width="682" height="460"/>
<h6><span class="label">Figure 26-1. </span>A class tree: instances (I1 and I2), a class (C1), and superclasses (C2 and C3)</h6>
</div></figure>
<p>In this figure, there is a tree of five objects labeled with variables, all of which have attached attributes, ready to be searched. More specifically, this tree links together three <em>class objects</em> (the ovals <code>C1</code>, <code>C2</code>, and <code>C3</code>) and two <em>instance objects</em> (the rectangles <code>I1</code> and <code>I2</code>) into an inheritance-search tree. Notice that in the Python object model, classes and the instances you generate from them are two distinct object types:</p>
<dl>
<dt>Classes</dt>
<dd>Serve as instance factories. Their attributes <a contenteditable="false" data-type="indexterm" data-primary="OOP (object-oriented programming)" data-secondary="classes" id="id3701"></a><a contenteditable="false" data-type="indexterm" data-primary="classes" data-secondary="OOP" id="id3702"></a><a contenteditable="false" data-type="indexterm" data-primary="objects" data-secondary="class objects" id="id3703"></a>provide behavior—data and functions—that is inherited by all the instances generated from them (e.g., a function to compute an employee’s salary from pay and hours).</dd>
<dt>Instances</dt>
<dd>Represent the concrete <a contenteditable="false" data-type="indexterm" data-primary="OOP (object-oriented programming)" data-secondary="instances" id="id3704"></a><a contenteditable="false" data-type="indexterm" data-primary="instances" data-secondary="OOP" id="id3705"></a><a contenteditable="false" data-type="indexterm" data-primary="objects" data-secondary="instance objects" id="id3706"></a>items in a program’s domain. Their attributes record data that varies per specific object (e.g., an employee’s pay rate and hours worked).</dd>
</dl>
<p>In terms of search trees, an instance inherits attributes from its class, and a class inherits attributes from all classes above it in the tree.</p>
<p>In <a data-type="xref" href="#a_class_tree_instances_left_parenthesis">Figure 26-1</a>, we can further categorize the ovals by their relative positions in the tree. We usually <a contenteditable="false" data-type="indexterm" data-primary="classes" data-secondary="OOP" data-tertiary="superclasses" id="id3707"></a><a contenteditable="false" data-type="indexterm" data-primary="OOP (object-oriented programming)" data-secondary="classes" data-tertiary="superclasses" id="id3708"></a><a contenteditable="false" data-type="indexterm" data-primary="superclasses" id="id3709"></a>call classes higher in the tree (like <code>C2</code> and <code>C3</code>) <em>superclasses</em>; classes lower in the tree (like <code>C1</code>) are known as <em>subclasses</em>. These terms refer to both relative tree positions and roles. Superclasses provide behavior shared by all their subclasses, but because the search proceeds from the bottom up, subclasses may override behavior defined in their superclasses by redefining superclass names lower in the tree.<sup><a data-type="noteref" id="ch26fn1-marker" href="ch26.html#ch26fn1">1</a></sup></p>
<p>As these last few words are really the crux of the matter of software <em>customization</em> in OOP, let’s expand on this concept. Suppose we build up the tree in <a data-type="xref" href="#a_class_tree_instances_left_parenthesis">Figure 26-1</a>, and then say this:</p>
<pre data-type="programlisting">I2.w</pre>
<p>Right away, this code invokes inheritance. Because this is an <code><em>object</em>.<em>attribute</em></code> expression, it triggers a search of the tree in <a data-type="xref" href="#a_class_tree_instances_left_parenthesis">Figure 26-1</a>—Python will search for the attribute <code>w</code> by looking in <code>I2</code> and above. Specifically, it will search the linked objects in this order:</p>
<pre data-type="programlisting">I2, C1, C2, C3</pre>
<p>and stop at the first attached <code>w</code> it finds (or raise an error if <code>w</code> isn’t found at all). In this case, <code>w</code> won’t be found until <code>C3</code> is searched because it appears only in that object. In other words, <code>I2.w</code> resolves to <code>C3.w</code> by virtue of the automatic search. In OOP terminology, <code>I2</code> “inherits” the attribute <code>w</code> from <code>C3</code>.</p>
<p>Ultimately, the two instances inherit four attributes from their classes: <code>w</code>, <code>x</code>, <code>y</code>, and <code>z</code>. Other attribute references will wind up following different paths in the tree. For example:</p>
<ul>
<li><p><code>I1.x</code> and <code>I2.x</code> both find <code>x</code> in <code>C1</code> and stop because <code>C1</code> is lower than <code>C2</code>.</p></li>
<li><p><code>I1.y</code> and <code>I2.y</code> both find <code>y</code> in <code>C1</code> because that’s the only place <code>y</code> appears.</p></li>
<li><p><code>I1.z</code> and <code>I2.z</code> both find <code>z</code> in <code>C2</code> because <code>C2</code> is further to the left than <code>C3</code>.</p></li>
<li><p><code>I2.name</code> finds <code>name</code> in <code>I2</code> without climbing the tree at all.</p></li>
</ul>
<p>Trace these searches through the tree in <a data-type="xref" href="#a_class_tree_instances_left_parenthesis">Figure 26-1</a> to get a feel for how inheritance searches work in Python.</p>
<p>The first item in the preceding list is perhaps the most important to notice—because <code>C1</code> redefines the attribute <code>x</code> lower in the tree, it effectively <em>replaces</em> the version above it in <code>C2</code>. As you’ll see in a moment, such <a contenteditable="false" data-type="indexterm" data-primary="OOP (object-oriented programming)" data-secondary="attribute fetches" data-startref="pottft" id="id3710"></a><a contenteditable="false" data-type="indexterm" data-primary="OOP (object-oriented programming)" data-secondary="inheritance" data-tertiary="attributes" data-startref="opohtt" id="id3711"></a><a contenteditable="false" data-type="indexterm" data-primary="inheritance" data-secondary="OOP" data-tertiary="attributes" data-startref="ihoptt" id="id3712"></a>redefinitions are at the heart of software customization in OOP—by redefining and replacing the attribute, <code>C1</code> effectively customizes what it inherits from its superclasses.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Classes and Instances"><div class="sect2" id="classes_and_instances">
<h2>Classes and Instances</h2>
<p>Although they are technically two <a contenteditable="false" data-type="indexterm" data-primary="classes" data-secondary="OOP" data-tertiary="namespaces" id="id3713"></a><a contenteditable="false" data-type="indexterm" data-primary="instances" data-secondary="OOP" data-tertiary="namespaces" id="id3714"></a><a contenteditable="false" data-type="indexterm" data-primary="namespaces" data-secondary="OOP" id="id3715"></a><a contenteditable="false" data-type="indexterm" data-primary="OOP (object-oriented programming)" data-secondary="namespaces" id="id3716"></a>separate object types in the Python model, the classes and instances we put in these trees are almost identical—each type’s main purpose is to serve as another kind of <em>namespace</em>—a package of variables, and a place where we can attach attributes. If classes and instances therefore sound like modules, they should; however, the objects in class trees also have automatically searched links to other namespace objects, and classes and instances correspond to statements and calls, respectively, not entire files.</p>
<p>The primary difference between classes and instances is that classes are a kind of <em>factory</em> for generating instances. For example, in a realistic application, we might have an <code>Employee</code> class that defines what it means to be an employee; from that class, we generate actual <code>Employee</code> instances. This is another difference between classes and modules—we only ever have one instance of a given module in memory (that’s why we have to reload a module to get its new code), but with classes, we can make as many unique instances as we need.</p>
<p>Operationally, classes will usually have functions attached to them (e.g., <code>computeSalary</code>), and the instances will have more basic data items used by the class’s functions (e.g., <code>hoursWorked</code>). In fact, the object-oriented model is not that different from the classic data-processing model of <em>programs</em> plus <em>records</em>—in OOP, instances are like records with “data,” and classes are the “programs” for processing those records. In OOP, though, we also have the notion of an inheritance hierarchy, which supports software customization better than earlier models.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Method Calls"><div class="sect2" id="method_calls">
<h2>Method Calls</h2>
<p>In the prior section, we saw how the <a contenteditable="false" data-type="indexterm" data-primary="OOP (object-oriented programming)" data-secondary="method calls" id="opomthc"></a><a contenteditable="false" data-type="indexterm" data-primary="method calls (OOP)" id="mthclp"></a>attribute reference <code>I2.w</code> in our example class tree was translated to <code>C3.w</code> by the inheritance search procedure in Python. Perhaps just as important to understand as the inheritance of attributes, though, is what happens when we try to call <em>methods</em>—functions attached to classes as attributes.</p>
<p>If this <code>I2.w</code> reference is a <em>function</em> call, what it really means is “call the <code>C3.w</code> function to process <code>I2</code>.” That is, Python will automatically map the call <code>I2.w()</code> into the call <code>C3.w(I2)</code>, passing in the instance as the first argument to the inherited function as the implied <em>subject</em> of the call.</p>
<p>In fact, whenever we call a function attached to a class in this fashion, an instance of the class is always implied. This implied subject is part of the reason we refer to this as an <em>object-oriented</em> model—there is always a subject object when an operation is run. In a more realistic example, we might invoke a method called <code>giveRaise</code> attached as an attribute to an <code>Employee</code> class; such a call has no meaning unless qualified with the employee to whom the raise should be given.</p>
<p>As you’ll see in more detail later, Python passes in the implied instance to a special first argument in the method, called <code>self</code> by strong convention. Methods go through this argument to process the subject of the call. As you’ll also learn later, methods can be called either through an instance—<code>pat.giveRaise()</code>—or through a class—<code>Employee.giveRaise(pat)</code>—and both forms serve purposes in our scripts. In fact, these calls illustrate both of the key ideas in OOP; to run a <code>pat.giveRaise()</code> method call, Python:</p>
<ol class="pagebreak-before">
<li><p>First looks up <code>giveRaise</code> from <code>pat</code>, by <em>inheritance</em>.</p></li>
<li><p>Then passes <code>pat</code> to the located <code>giveRaise</code> function, in the special <code>self</code> function <em>argument</em>.</p></li>
</ol>
<p>When you run the call <code>Employee.giveRaise(pat)</code>, you’re just performing both steps yourself.</p>
<p>This description is technically just the default case (Python has additional method types you’ll meet later, called static and class methods), but it applies to the vast majority of the OOP code written in the language. To see how methods receive their subjects, though, we <a contenteditable="false" data-type="indexterm" data-primary="OOP (object-oriented programming)" data-secondary="method calls" data-startref="opomthc" id="id3717"></a><a contenteditable="false" data-type="indexterm" data-primary="method calls (OOP)" data-startref="mthclp" id="id3718"></a>need to move on to some code.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Coding Class Trees"><div class="sect2" id="coding_class_trees">
<h2>Coding Class Trees</h2>
<p>Although we are speaking in the abstract <a contenteditable="false" data-type="indexterm" data-primary="class trees" data-secondary="OOP" id="ctpoo"></a><a contenteditable="false" data-type="indexterm" data-primary="OOP (object-oriented programming)" data-secondary="class trees" id="oopoogclt"></a>here, there is tangible code behind all these ideas, of course. We construct trees and their objects with <code>class</code> statements and class calls, which we’ll explore in more detail later. In short, though:</p>
<ul>
<li><p>Each <code>class</code> statement generates a new class object.</p></li>
<li><p>Each time a class is called, it generates a new instance object.</p></li>
<li><p>Instances are automatically linked to the classes from which they are created.</p></li>
<li><p>Classes are automatically linked to their superclasses according to the way we list them in parentheses in a <code>class</code> header line; the left-to-right order there gives the order in the tree.</p></li>
</ul>
<p>To build the tree in <a data-type="xref" href="#a_class_tree_instances_left_parenthesis">Figure 26-1</a>, for example, we would run Python code of the sort in <a data-type="xref" href="#example_twosix_onedot_classtreeonedotpy">Example 26-1</a>. Like function definition, classes are normally coded in module files and are run during an import (the guts of the following <code>class</code> statements are omitted here for brevity, though <code>...</code> qualifies as a no-op statement per <a data-type="xref" href="ch13.html#while_and_for_loops">Chapter 13</a> if run live).</p>
<div data-type="example" id="example_twosix_onedot_classtreeonedotpy">
<h5><span class="label">Example 26-1. </span>classtree1.py</h5>
<pre data-type="programlisting">class C2: ...                 <code><em># Make class objects (ovals)</em></code>
class C3: ...
class C1(C2, C3): ...         <code><em># Linked to superclasses - in this order</em></code>

I1 = C1()                     <code><em># Make instance objects (rectangles)</em></code>
I2 = C1()                     <code><em># Linked to their class</em></code></pre>
</div>
<p>Here, we build the three class objects by running three <code>class</code> statements, and make the two instance objects by calling the class <code>C1</code> twice—as though it were a function (Python lumps classes and functions together as “callable” objects invoked with parentheses, though <code>def</code> requires header parentheses and <code>class</code> does not). The instances remember the class they were made from, and the class <code>C1</code> remembers its listed superclasses.</p>
<p>Technically, this example uses something <a contenteditable="false" data-type="indexterm" data-primary="OOP (object-oriented programming)" data-secondary="inheritance" data-tertiary="multiple inheritance" id="id3719"></a><a contenteditable="false" data-type="indexterm" data-primary="inheritance" data-secondary="OOP" data-tertiary="multiple inheritance" id="id3720"></a>called <em>multiple inheritance</em>, which simply means that a class has more than one superclass above it in the class tree—a useful technique when you wish to combine multiple tools. In Python, if there is more than one superclass listed in parentheses in a <code>class</code> statement (like <code>C1</code>’s here), their left-to-right order gives the order in which those superclasses will be searched for attributes by inheritance. The leftmost version of a name is used by default, though you can always choose a name by asking for it from the class it lives in (e.g., <code>C3.z</code>). The search also picks names to the right over higher duplicates, but we can safely ignore that for now.</p>
<p>Because of the way inheritance searches proceed, the object to which you attach an attribute turns out to be crucial—it determines the name’s <em>scope</em>. Attributes attached to instances pertain only to those single instances, but attributes attached to classes are shared by all their subclasses and instances. Later, we’ll study the code that hangs attributes on these objects in depth. As you’ll find, it’s all about where an <em>assignment</em> is run:</p>
<ul>
<li><p>Attributes are usually attached to classes by assignments made at the top level in <code>class</code> statement blocks, and not nested inside function <code>def</code> statements there.</p></li>
<li><p>Attributes are usually attached to instances by assignments to the special argument passed to functions coded inside classes, called <code>self</code>.</p></li>
</ul>
<p>For example, classes provide behavior for their instances with functions we create by coding <code>def</code> statements inside <code>class</code> statements. Because such nested <code>def</code> statements assign function names within the class, they wind up attaching attributes to the class object that will be inherited by all instances and subclasses—as is <a data-type="xref" href="#example_twosix_twodot_classtreetwodotpy">Example 26-2</a>, which lists changed parts in bold.</p>
<div data-type="example" id="example_twosix_twodot_classtreetwodotpy">
<h5><span class="label">Example 26-2. </span>classtree2.py</h5>
<pre data-type="programlisting">class C2: ...                    <code><em># Make superclass objects</em></code>
class C3: ...

class C1(C2, C3):                <code><em># Make and link class C1</em></code>
<code> <strong>   def setname(self, who):</strong> </code>     <code><em># Assign name: C1.setname
</em> <strong>       self.name = who</strong></code>          <code><em># Self is either I1 or I2</em></code>

I1 = C1()                        <code><em># Make two instances</em></code>
I2 = C1()
<code><strong>I1.setname('sue')</strong> </code>               <code><em># Sets I1.name to 'sue'</em></code>
<code><strong>I2.setname('bob')</strong> </code>               <code><em># Sets I2.name to 'bob'</em></code>
<code><strong>print(I1.name)</strong></code>                   <code><em># Prints 'sue'</em></code></pre>
</div>
<p>There’s nothing syntactically unique about <code>def</code> in this context. Operationally, though, when a <code>def</code> appears inside a <code>class</code> like this, it is usually <a contenteditable="false" data-type="indexterm" data-primary="OOP (object-oriented programming)" data-secondary="methods" id="id3721"></a><a contenteditable="false" data-type="indexterm" data-primary="methods" data-secondary="OOP" id="id3722"></a>known as a <em>method</em>, and it automatically receives a special first argument—called <code>self</code> by very strong convention—that provides a handle back to the instance to be processed. Any values you pass to the method yourself go to arguments after <code>self</code> (here, to <code>who</code>).<sup><a data-type="noteref" id="ch26fn2-marker" href="ch26.html#ch26fn2">2</a></sup></p>
<p>Because classes are factories for multiple instances, their methods usually go through this automatically passed-in <code>self</code> argument whenever they need to fetch or set attributes of the particular instance being processed by a method call. In the preceding code, <code>self</code> is used to store a name in one of two instances.</p>
<p>Like simple variables, <em>attributes</em> of classes and instances are not declared ahead of time, but spring into existence the first time they are assigned values. When a method assigns to a <code>self</code> attribute, it creates or changes an attribute in an instance at the bottom of the class tree (i.e., one of the rectangles in <a data-type="xref" href="#a_class_tree_instances_left_parenthesis">Figure 26-1</a>) because <code>self</code> automatically refers to the instance being processed—the subject of the call.</p>
<p>In fact, because all the objects in class <a contenteditable="false" data-type="indexterm" data-primary="class trees" data-secondary="(OOP)" data-startref="ctpoo" id="id3723"></a><a contenteditable="false" data-type="indexterm" data-primary="OOP (object-oriented programming)" data-secondary="class trees" data-startref="oopoogclt" id="id3724"></a>trees are just namespace objects, we can fetch or set any of their attributes by going through the appropriate names. Saying <code>C1.setname</code> is as valid as saying <code>I1.setname</code>, as long as the names <code>C1</code> and <code>I1</code> are in your code’s scopes.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Operator Overloading"><div class="sect2" id="operator_overloading-id00069">
<h2>Operator Overloading</h2>
<p>As currently coded, our <code>C1</code> class doesn’t attach a <code>name</code> attribute to an instance <a contenteditable="false" data-type="indexterm" data-primary="OOP (object-oriented programming)" data-secondary="operator overload" id="id3725"></a><a contenteditable="false" data-type="indexterm" data-primary="operator overloading" data-secondary="OOP" id="id3726"></a>until the <code>setname</code> method is called. Indeed, referencing <code>I1.name</code> before calling <code>I1.setname</code> would produce an undefined name error. If a class wants to guarantee that an attribute like <code>name</code> is always set in its instances, it more typically will fill out the attribute at construction time, as demoed by <a data-type="xref" href="#example_twosix_threedot_classtreethreed">Example 26-3</a>.</p>
<div data-type="example" id="example_twosix_threedot_classtreethreed">
<h5><span class="label">Example 26-3. </span>classtree3.py</h5>
<pre data-type="programlisting">class C2: ...                    <code><em># Make superclass objects</em></code>
class C3: ...

class C1(C2, C3):
<code> <strong>   def __init__(self, who):</strong></code>     <code><em># Set name when constructed</em></code>
<code> <strong>       self.name = who</strong></code>          <code><em># Self is either I1 or I2</em><strong>
</strong></code>
<code><strong>I1 = C1('sue')</strong></code>                   <code><em># Sets I1.name to 'sue'</em><strong>
I2 = C1('bob')</strong></code>                   <code><em># Sets I2.name to 'bob'</em><strong>
</strong></code>print(I1.name)                   <code><em># Prints 'sue'</em></code></pre>
</div>
<p>If it’s either coded or inherited, Python automatically calls a method named <code>__init__</code> each time an instance is generated from a class. The new instance is passed in to the <code>self</code> argument of <code>__init__</code> as usual, and any values listed in parentheses in the class call go to arguments two and beyond. The effect here is to initialize instances when they are made, without requiring extra method calls.</p>
<p>The <code>__init__</code> method is known as the <em>constructor</em> because of when it is run. It’s the <a contenteditable="false" data-type="indexterm" data-primary="__init__ method" data-secondary="constructors" data-primary-sortas="init method" id="id3727"></a><a contenteditable="false" data-type="indexterm" data-primary="constructors" data-secondary="__init__ method" data-secondary-sortas="init method" id="id3728"></a>most commonly used representative of a larger category called <em>operator-overloading</em> methods, which we’ll explore in later chapters. Such methods are inherited in class trees as usual and have double underscores at the start and end of their names to make them distinct. Python runs them automatically when instances that support them appear in the corresponding operations, and they are mostly an alternative to using simple method calls. They’re also optional: if omitted, the operations are not supported. If no <code>__init__</code> is present, class calls return an empty instance, without initializing it.</p>
<p>For example, a custom set intersection might be coded as a method named <code>intersect</code> called explicitly, or as a method named <code>__and__</code> that is called automatically by the <code>&amp;</code> expression operator. Because the operator scheme makes instances look and feel more like built-in types, it allows some classes to provide a consistent and natural interface, and be compatible with code that expects a built-in type. Still, apart from the <code>__init__</code> constructor—which appears in most realistic classes—many programs may be better off with simpler named methods unless their objects are similar to built-ins. A <code>giveRaise</code> may make sense for an <code>Employee</code>, but an <code>&amp;</code> might not.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="OOP Is About Code Reuse"><div class="sect2" id="oop_is_about_code_reuse">
<h2>OOP Is About Code Reuse</h2>
<p>And that, along with a few syntax details, is most of the OOP story in Python. Of course, there’s a bit more to <a contenteditable="false" data-type="indexterm" data-primary="OOP (object-oriented programming)" data-secondary="code reuse" id="poocdrs"></a><a contenteditable="false" data-type="indexterm" data-primary="code reuse" data-secondary="OOP" id="cdruppo"></a>it than just inheritance. For example, operator overloading is much more general than described so far—classes may also provide their own implementations of operations such as indexing, fetching attributes, printing, and more. By and large, though, OOP is about looking up attributes in trees with a special first argument in functions.</p>
<p>So why would we be interested in building and searching trees of objects? Although it takes some experience to see how, when used well, classes support code <em>reuse</em> in ways that other Python program components cannot. In fact, this is, by most accounts, their highest purpose. With classes, we code by customizing existing software, instead of either changing existing code in place or starting from scratch for each new project. This turns out to be a powerful paradigm in realistic programming.</p>
<p>At a fundamental level, classes are really just packages of functions and other names, much like modules. However, the automatic attribute inheritance search that we get with classes supports customization of software above and beyond what we can do with modules and functions. Moreover, classes provide a natural <em>structure</em> for code that packages and localizes both logic and names, and so aids in debugging.</p>
<p>To be fair, because methods are simply functions with a special first argument, we can mimic some of their behavior by manually passing subject objects to simple functions. The participation of methods in class inheritance, though, allows us to naturally extend and customize software by coding subclasses with new methods, rather than modifying code that already works. There is really no such concept with modules and functions.</p>
<section data-type="sect3" data-pdf-bookmark="Polymorphism and classes"><div class="sect3" id="polymorphism_and_classes">
<h3>Polymorphism and classes</h3>
<p>As an abstract example, suppose you’re <a contenteditable="false" data-type="indexterm" data-primary="OOP (object-oriented programming)" data-secondary="polymorphism" id="ojopym"></a><a contenteditable="false" data-type="indexterm" data-primary="polymorphism" id="pyphsm"></a><a contenteditable="false" data-type="indexterm" data-primary="classes" data-secondary="polymorphism" id="clspyph"></a>assigned the task of implementing an employee database application. As a Python OOP programmer, you might begin by coding a general superclass that defines default behaviors common to all the kinds of employees in your organization (code in this section is hypothetical and partial):</p>
<pre data-type="programlisting">class Employee:                      <code><em># General superclass</em></code>
    def computeSalary(self): …       <code><em># Common or default behaviors</em></code>
    def giveRaise(self): …
    def promote(self): …
    def retire(self): …</pre>
<p>Once you’ve coded this general behavior, you can specialize it for each specific kind of employee to reflect how the various types differ from the norm. That is, you can code subclasses that customize just the bits of behavior that vary per employee type; the rest of the employee types’ behavior will be inherited from the more general class. For instance, if engineers have a unique salary computation rule (perhaps it’s not hours times rate), you can replace just that one method in a subclass:</p>
<pre data-type="programlisting">class Engineer(Employee):            <code><em># Specialized subclass</em></code>
     def computeSalary(self): …      <code><em># Something custom here</em></code></pre>
<p>Because the <code>computeSalary</code> version here appears lower in the class tree, it will replace (override) the general version in <code>Employee</code>. All other methods, though, are inherited from the superclass verbatim. You then create instances of the kinds of employee classes that the real employees belong to, to get the correct behavior:</p>
<pre data-type="programlisting">sue = Employee()                     <code><em># Default behavior</em></code>
bob = Employee()                     <code><em># Default behavior</em></code>
pat = Engineer()                     <code><em># Custom salary calculator</em></code></pre>
<p>Notice that you can make instances of any class in a tree, not just the ones at the bottom—the class you make an instance from determines the level at which the attribute search will begin, and thus which versions of the methods it will employ (pun accidental).</p>
<p>Ultimately, these three instance objects might wind up embedded in a larger container object—for instance, a list, dictionary, or an instance of another class—that represents a department or company using the composition idea mentioned at the start of this chapter. When you later ask for these <span class="keep-together">employees’</span> salaries, they will be computed according to the classes from which the objects were made, due to the principles of the inheritance search:</p>
<pre data-type="programlisting">company = [sue, bob, pat]            <code><em># A composite object</em></code>
for emp in company:
    print(emp.<code><strong>computeSalary</strong></code>())       <code><em># Run this emp's version: default or custom</em></code></pre>
<p>This is yet another instance of the idea of <em>polymorphism</em> introduced in <a data-type="xref" href="ch04.html#introducing_python_objects">Chapter 4</a> and expanded in <a data-type="xref" href="ch16.html#function_basics">Chapter 16</a>. Recall that polymorphism means that the meaning of an operation depends on the object being operated on. That is, code shouldn’t care about what an object <em>is</em>, only about what it <em>does</em>. Here, the method <code>computeSalary</code> is located by inheritance search in each object before it is called, per the object’s class. The net effect is that we automatically run the correct version for the object being processed—default or custom. Trace the code to see why.</p>
<p>In other applications, polymorphism might also be used to <em>encapsulate</em> (i.e., abstract away) interface differences. For example, a program that processes data streams might be coded to expect objects with input and output methods, without caring what those methods actually do:</p>
<pre data-type="programlisting">def processor(reader, converter, writer):
    while True:
        data = reader.<code><strong>read</strong></code>()
        if not data: break
        data = converter(data)
        writer.<code><strong>write</strong></code>(data)</pre>
<p>By passing in instances of subclasses that specialize the required <code>read</code> and <code>write</code> method interfaces for various data sources, we can reuse the <code>processor</code> function for any data source we need to use, both now and in the future:</p>
<pre data-type="programlisting">class Reader:
    def other(self): …               <code><em># Default behavior and tools</em></code>

class FileReader(Reader):
    def read(self): …                <code><em># Read from a local file</em></code>

class SocketReader(Reader):
    def read(self): …                <code><em># Read from a network socket</em></code>
    
…<code><em>and others</em></code>…

processor(FileReader(…),   converter,  FileWriter(…))
processor(SocketReader(…), converter,  FileWriter(…))
processor(FtpReader(…),    converter,  JsonWriter(…))</pre>
<p>Moreover, because the internal implementations of those <code>read</code> and <code>write</code> methods have been factored into single locations, they can be changed without impacting code that uses them. The <code>processor</code> function might even be a class itself to allow the conversion logic of <code>converter</code> to be filled in <a contenteditable="false" data-type="indexterm" data-primary="OOP (object-oriented programming)" data-secondary="polymorphism" data-startref="ojopym" id="id3729"></a><a contenteditable="false" data-type="indexterm" data-primary="polymorphism" data-startref="pyphsm" id="id3730"></a><a contenteditable="false" data-type="indexterm" data-primary="classes" data-secondary="polymorphism" data-startref="clspyph" id="id3731"></a>by inheritance, and to allow readers and writers to be embedded by composition (you’ll see how this works later in this part of the book).</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Programming by customization"><div class="sect3" id="programming_by_customization">
<h3>Programming by customization</h3>
<p>Once you get used to programming this way (by software customization), you’ll find that when it’s time to write a new program, much of your work may already be done—your task largely becomes one of mixing together existing superclasses that already implement the behavior required by your program. For example, someone else might have written the <code>Employee</code> and <code>Reader</code> classes in this section’s examples for use in completely different programs. If so, you get all of that person’s code “for free.”</p>
<p>In fact, in many application domains, you <a contenteditable="false" data-type="indexterm" data-primary="frameworks" id="id3732"></a>can fetch or purchase collections of superclasses, known as <em>frameworks</em>, that implement common programming tasks as classes, ready to be mixed into your <span class="keep-together">applications</span>. These frameworks might provide database interfaces, testing protocols, GUI toolkits, and so on. With frameworks, you often simply code a subclass that fills in a handful of expected methods; the framework classes higher in the tree do most of the work for you. Programming in such an OOP world is just a matter of combining and specializing already debugged code by writing subclasses of your own.</p>
<p>Of course, it takes a while to learn how to leverage classes to achieve such OOP utopia. In practice, object-oriented work also entails substantial design work to fully realize the code reuse benefits of classes. To this end, programmers catalog common <a contenteditable="false" data-type="indexterm" data-primary="OOP (object-oriented programming)" data-secondary="frameworks" id="id3733"></a>OOP structures, known as <em>design patterns</em>, to help with design choices. The actual <a contenteditable="false" data-type="indexterm" data-primary="OOP (object-oriented programming)" data-secondary="code reuse" data-startref="poocdrs" id="id3734"></a><a contenteditable="false" data-type="indexterm" data-primary="code reuse" data-secondary="OOP" data-startref="cdruppo" id="id3735"></a>code you write to do OOP in Python, though, is so simple that it will not in <em>itself</em> pose an additional obstacle to your OOP quest. To see why, you’ll have to move on to <span class="keep-together"><a data-type="xref" href="ch27.html#class_coding_basics">Chapter 27</a></span>.</p>
</div></section>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Chapter Summary"><div class="sect1" id="chapter_summary-id00037">
<h1>Chapter Summary</h1>
<p>We made an initial, abstract pass over classes and OOP in this chapter, taking in the big picture before we dive into syntax details. As we’ve seen, OOP is mostly about an argument named <code>self</code>, and a search for attributes in trees of linked objects called inheritance. Objects at the bottom of the tree inherit attributes from objects higher up in the tree—a feature that enables us to program by customizing code, rather than changing it or starting from scratch. When used well, this model of programming can cut development time radically.</p>
<p>The next chapter will begin to fill in the coding details behind the picture painted here. As we get deeper into Python classes, though, keep in mind that the OOP model in Python is very simple; as we’ve seen here, it’s really just about looking up names in object trees and a special function argument. Before we move on, here’s a quick quiz to review what we’ve covered here.</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Test Your Knowledge: Quiz"><div class="sect1" id="test_your_knowledge_quiz-id000173">
<h1>Test Your Knowledge: Quiz</h1>
<ol>
<li><p>What is the main point of OOP in Python?</p></li>
<li><p>Where does an inheritance search look for an attribute?</p></li>
<li><p>What is the difference between a class object and an instance object?</p></li>
<li><p>Why is the first argument in a class’s method function special?</p></li>
<li><p>What is the <code>__init__</code> method used for?</p></li>
<li><p>How do you create a class instance?</p></li>
<li><p>How do you create a class?</p></li>
<li><p>How do you specify a class’s superclasses?</p></li>
</ol>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Test Your Knowledge: Answers"><div class="sect1" id="test_your_knowledge_answers-id000172">
<h1>Test Your Knowledge: Answers</h1>
<ol>
<li><p>OOP is about code <em>reuse</em>—you factor code to minimize redundancy, and program by customizing what already exists instead of changing code in place or starting from scratch.</p></li>
<li><p>An inheritance search looks for an attribute first in the instance object, then in the class the instance was created from, then in all higher superclasses, progressing from the bottom to the top of the object tree, and from left to right (normally). The search stops at the first place the attribute is found. Because the lowest version of a name found along the way wins, class hierarchies naturally support customization by extension in new subclasses.</p></li>
<li><p>Both class and instance objects are namespaces—packages of variables that appear as attributes. The main difference between them is that classes are a kind of factory for creating multiple instances. Classes also support operator-overloading methods, which instances inherit, and treat any functions nested in the class as methods for processing instances.</p></li>
<li><p>The first argument in a class’s method function is special because it always receives the instance object that is the implied subject of the method call. It’s usually called <code>self</code> by convention. Because method functions always have this implied subject—and object context—by default, we say they are “object-oriented” (i.e., designed to process or change objects).</p></li>
<li><p>If the <code>__init__</code> method is coded or inherited in a class, Python calls it automatically each time an instance of that class is created. It’s known as the <em>constructor</em> method; it is passed the new instance implicitly, as well as any arguments passed explicitly to the class name. It’s also the most commonly used operator-overloading method. If no <code>__init__</code> method is present, instances simply begin life as empty namespaces.</p></li>
<li><p>You create a class instance by calling the class name as though it were a function; any arguments passed into the class name show up as arguments two and beyond in the <code>__init__</code> constructor method (if there is one). The new instance remembers the class it was created from for inheritance purposes.</p></li>
<li><p>You create a class by running a <code>class</code> statement; like function definitions, these statements normally run when the enclosing module file is imported (more on this in the next chapter).</p></li>
<li><p>You specify a class’s superclasses by listing them in parentheses in the <code>class</code> statement, after the new class’s name. The left-to-right order in which the classes are listed in the parentheses gives the left-to-right inheritance search order in the class tree.</p></li>
</ol>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="ch26fn1"><sup><a href="ch26.html#ch26fn1-marker">1</a></sup> In other literature and circles, you may also occasionally see the terms <em>base classes</em> and <em>derived classes</em> used to describe superclasses and subclasses, respectively. Most Python people and this book tend to use the latter terms.</p><p data-type="footnote" id="ch26fn2"><sup><a href="ch26.html#ch26fn2-marker">2</a></sup> If you’ve ever used C++ or Java, you’ll recognize that Python’s <code>self</code> is much like these languages’ <code>this</code> pointer/reference, but <code>self</code> is always explicit in both headers and bodies of Python methods to make attribute accesses more obvious: a name has fewer possible meanings to consider, if it cannot be magically associated with a hidden object. Explicit is generally better.</p></div></div></section></div>
</div>
</body>
</html>