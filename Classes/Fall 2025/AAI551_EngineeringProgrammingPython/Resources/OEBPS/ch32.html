<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xml:lang="en"
lang="en"
xmlns="http://www.w3.org/1999/xhtml"
xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<title>Learning Python, 6th Edition</title>
<link rel="stylesheet" type="text/css" href="override_v1.css"/>
<link rel="stylesheet" type="text/css" href="epub.css"/>
</head>
<body>
<div id="book-content">
<div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 32. Class Odds and Ends"><div class="chapter" id="class_odds_and_ends">
<h1><span class="label">Chapter 32. </span>Class Odds and Ends</h1>
<p>This chapter concludes our look at OOP in Python by presenting a collage of more advanced class topics. We will survey customizing built-in types, the relationship of classes and types, attribute tools like slots and properties, the special-case static and class methods, decorators and metaclasses, and the <code>super</code> call’s complete story. Some of these are introduced here but resumed by focused chapters in this book’s <a data-type="xref" data-xrefstyle="chap-num-title" href="part08.html#advanced_topics">Part VIII, “Advanced Topics”</a>.</p>
<p>As we’ve seen, Python’s OOP model is, at its core, relatively simple, and some of the topics presented in this chapter are so advanced and optional that you may not encounter them very often in your Python applications-programming career. In the interest of completeness, though—and because you never know when an “advanced” topic may crop up in code you use—we’ll round out our discussion of classes with a brief look at these advanced tools for OOP work.</p>
<p>As usual, because this is the last chapter in this part of the book, it ends with a section on class-related “gotchas” and a set of lab exercises for this part to help cement the ideas we’ve studied here. Beyond these exercises, studying larger OOP Python projects or starting some of your own is heartily recommended as a supplement to this book. As with much in life and computing, the benefits of OOP tend to become more apparent with practice.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><em>Blast from the past</em>: Python 3.X launched with a mandatory “<em>new-style</em>” class model that could be enabled in 2.X as an option; 2.X’s own model was dubbed “<em>classic</em>.” At least in terms of its OOP support, new-style classes transformed Python into a different language altogether—one that borrows much more from, and is often as complex as, other languages in this domain. The last chapter’s MRO and most topics in this chapter were part of this package. Because this book is now focused on 3.X only, the term “new style” is moot and unused <span class="keep-together">here—all</span> its classes qualify.</p>
</div>
<section data-type="sect1" data-pdf-bookmark="Extending Built-in Object Types"><div class="sect1" id="extending_built_in_object_types">
<h1>Extending Built-in Object Types</h1>
<p>Besides implementing new kinds of objects, classes are sometimes used to extend the functionality <a contenteditable="false" data-type="indexterm" data-primary="built-in types" id="id4174"></a><a contenteditable="false" data-type="indexterm" data-primary="object types" data-secondary="built-ins" data-tertiary="extending" id="objbuxt"></a>of Python’s built-in object types to support more exotic data structures. For instance, to add <em>queue</em> insert and delete methods to lists, you can code classes that wrap (embed) a list object and augment it with insert and delete methods that process the list specially, using the delegation technique we studied in <a data-type="xref" href="ch31.html#designing_with_classes">Chapter 31</a>. You can also use simple inheritance to customize built-in types for such custom roles. The next two sections show both techniques in action.</p>
<section data-type="sect2" data-pdf-bookmark="Extending Types by Embedding"><div class="sect2" id="extending_types_by_embedding">
<h2>Extending Types by Embedding</h2>
<p>Do you remember those set functions we wrote in Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch16.html#function_basics">16</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch18.html#arguments">18</a>? Here’s what they look like brought back to life as a Python class. <a data-type="xref" href="#example_threetwo_onedot_setwrapperdotpy">Example 32-1</a> (file <em>setwrapper.py</em>) implements a new set object type by moving set functions to methods and adding some basic <a contenteditable="false" data-type="indexterm" data-primary="built-in types" data-secondary="extending" data-tertiary="embedding" id="bltxmb"></a><a contenteditable="false" data-type="indexterm" data-primary="embedding" data-secondary="built-in object types" id="bddbjxt"></a><a contenteditable="false" data-type="indexterm" data-primary="types" data-secondary="built-ins, extending" id="id4175"></a>operator overloading. For the most part, this class just wraps a Python list with extra set operations. But because it’s a class, it also supports multiple instances and customization by inheritance in subclasses. Unlike our earlier functions, using classes here allows us to make multiple self-contained set objects with preset data and behavior rather than passing lists into functions manually.</p>
<div data-type="example" id="example_threetwo_onedot_setwrapperdotpy">
<h5><span class="label">Example 32-1. </span>setwrapper.py</h5>
<pre data-type="programlisting">class Set:
   def __init__(self, value = []):    <code><em># Constructor</em></code>
       self.data = []                 <code><em># Manages a list</em></code>
       self.concat(value)             <code><em># Removes duplicates</em></code>

   def intersect(self, other):        <code><em># other is any iterable
</em></code>       res = []                       <code><em># self is the subject</em></code>
       for x in self.data:
           if x in other:             <code><em># Pick common items</em></code>
               res.append(x)
       return Set(res)                <code><em># Return a new Set</em></code>

   def union(self, other):            <code><em># other is any iterable</em></code>
       res = self.data[:]             <code><em># Copy of my list</em></code>
       for x in other:                <code><em># Add items in other</em></code>
           if not x in res:
               res.append(x)
       return Set(res)

   def concat(self, value):           <code><em># value: list, Set...</em></code>
       for x in value:                <code><em># Removes duplicates</em></code>
          if not x in self.data:
               self.data.append(x)

   def __len__(self):          return len(self.data)            <code><em># len(self), if self</em></code>
   def __getitem__(self, key): return self.data[key]            <code><em># self[i], self[i:j]</em></code>
   def __and__(self, other):   return self.intersect(other)     <code><em># self &amp; other</em></code>
   def __or__(self, other):    return self.union(other)         <code><em># self | other
</em></code>   def __repr__(self):         return f'Set({self.data!r})'     <code><em># print(self),...</em></code>
   def __iter__(self):         return iter(self.data)           <code><em># for x in self,...</em></code></pre>
</div>
<p>To use this class, we make instances, call methods, and run defined operators as usual:</p>
<pre data-type="programlisting">$ <code><strong>python3</strong></code>
&gt;&gt;&gt; <code><strong>from setwrapper import Set</strong></code>
&gt;&gt;&gt; <code><strong>x = Set([1, 3, 5, 7, 3])</strong></code>
&gt;&gt;&gt; <code><strong>x.union(Set([1, 4, 7]))</strong></code>
Set([1, 3, 5, 7, 4])
&gt;&gt;&gt; <code><strong>x | Set([1, 4, 6, 4])</strong></code>
Set([1, 3, 5, 7, 4, 6])</pre>
<p>Overloading operations such as indexing and iteration also enables instances of our <code>Set</code> class to often masquerade as real lists. Because you will interact with and extend this class in an exercise at the end of this chapter, we’ll put this code on the back burner <a contenteditable="false" data-type="indexterm" data-primary="built-in types" data-secondary="extending" data-tertiary="embedding" data-startref="bltxmb" id="id4176"></a><a contenteditable="false" data-type="indexterm" data-primary="embedding" data-secondary="built-in objects" data-startref="bddbjxt" id="id4177"></a>until its solution in <a data-type="xref" href="app02.html#appendix_b_solutions_to_end_of_part_exe">Appendix B</a>.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Extending Types by Subclassing"><div class="sect2" id="extending_types_by_subclassing">
<h2>Extending Types by Subclassing</h2>
<p>While the prior section’s embedding works, Python’s <a contenteditable="false" data-type="indexterm" data-primary="built-in types" data-secondary="extending" data-tertiary="subclassing" id="bltjxbc"></a><a contenteditable="false" data-type="indexterm" data-primary="subclassing" data-secondary="built-in types extension" id="subbjxt"></a>built-in types can also be subclassed directly. In fact, type-conversion functions such as <code>list</code>, <code>str</code>, <code>dict</code>, and <code>tuple</code> are really built-in type names; although transparent to your script, a type-conversion call (e.g., <code>list('text')</code>) is really an invocation of a type’s constructor.</p>
<p>This allows you to customize or extend the behavior of built-in types with user-defined <code>class</code> statements: simply subclass the type names to customize them. Instances of your type subclasses can generally be used anywhere that the original built-in type can appear. For example, suppose you have trouble getting used to the fact that Python list offsets begin at 0 instead of 1. Not to worry—you can always code your own subclass that customizes this core behavior of lists, and <a data-type="xref" href="#example_threetwo_twodot_typesubclassdot">Example 32-2</a> shows how.</p>
<div data-type="example" id="example_threetwo_twodot_typesubclassdot">
<h5><span class="label">Example 32-2. </span>typesubclass.py</h5>
<pre data-type="programlisting">"""
Subclass built-in list type/class.
Map 1..N to 0..N-1, call back to built-in version.
"""

class MyList(list):
    def __getitem__(self, offset):
        print(f'&lt;indexing {self} at {offset}&gt;')
        return list.__getitem__(self, offset - 1)

if __name__ == '__main__':
    print(list('abc'))
    x = MyList('abc')               <code><em># __init__ inherited from list</em></code>
    print(x)                        <code><em># __str__/__repr__ inherited from list</em></code>

    print(x[1])                     <code><em># MyList.__getitem__</em></code>
    print(x[3])                     <code><em># Customizes list superclass method
</em></code>
    x.append('hack!'); print(x)     <code><em># Attributes from list superclass</em></code>
    x.reverse();       print(x)</pre>
</div>
<p>In this file, the <code>MyList</code> subclass extends the built-in list’s <code>__getitem__</code> indexing method only, to map indexes 1 to N back to the required 0 to N−1. Really, all it does is decrement the submitted index and call back to the superclass’s version of indexing, but it’s enough to do the trick:</p>
<pre data-type="programlisting">$ <code><strong>python3 typesubclass.py</strong></code>
['a', 'b', 'c']
['a', 'b', 'c']
&lt;indexing ['a', 'b', 'c'] at 1&gt;
a
&lt;indexing ['a', 'b', 'c'] at 3&gt;
c
['a', 'b', 'c', 'hack!']
['hack!', 'c', 'b', 'a']</pre>
<p>This output also includes tracing text the class prints on indexing. Of course, whether changing indexing this way is a good idea, in general, is <em>another issue</em>—users of your <code>MyList</code> class may very well be confused by such a core departure from Python sequence behavior. The ability to customize built-in types this way can be a powerful asset, though.</p>
<p>For instance, this coding pattern gives rise to an alternative way to code a set—as a subclass of the built-in list type rather than a standalone class that manages an embedded list object, as shown in the prior section. As discussed in <a data-type="xref" href="ch05.html#numbers_and_expressions">Chapter 5</a>, Python today comes with a powerful built-in set object, along with literal and comprehension syntax for making new sets. Coding one yourself, though, is still a great way to learn about type subclassing in general.</p>
<p>The code in <a data-type="xref" href="#example_threetwo_threedot_setsubclassdo">Example 32-3</a>, file <em>setsubclass.py</em>, customizes lists to add just methods and operators related to set processing. Because all other behavior is inherited from the built-in <code>list</code> superclass, this makes for a shorter and simpler alternative—everything not defined here is routed to <code>list</code> directly.</p>
<div data-type="example" id="example_threetwo_threedot_setsubclassdo">
<h5><span class="label">Example 32-3. </span>setsubclass.py</h5>
<pre data-type="programlisting">class Set(list):
    def __init__(self, value = []):      <code><em># Constructor</em></code>
        list.__init__(self)              <code><em># Customizes list</em></code>
        self.concat(value)               <code><em># Copies mutable defaults</em></code>

    def intersect(self, other):          <code><em># other is any iterable</em></code>
        res = []                         <code><em># self is the subject</em></code>
        for x in self:
            if x in other:               <code><em># Pick common items</em></code>
                res.append(x)
        return Set(res)                  <code><em># Return a new Set</em></code>

    def union(self, other):              <code><em># other is any iterable</em></code>
        res = Set(self)                  <code><em># Copy me and my list</em></code>
        res.concat(other)
        return res

    def concat(self, value):             <code><em># value: list, Set, etc.</em></code>
        for x in value:                  <code><em># Removes duplicates</em></code>
            if not x in self:
                self.append(x)

    def __and__(self, other): return self.intersect(other)
    def __or__(self, other):  return self.union(other)
    def __repr__(self):       return f'Set({list.__repr__(self)})'

if __name__ == '__main__':
    x = Set([1, 3, 5, 7])
    y = Set([2, 1, 4, 5, 6])
    print(x, y, len(x))
    print(x.intersect(y), y.union(x))
    print(x &amp; y, x | y)
    x.reverse(); print(x)</pre>
</div>
<p>Here is the output of the self-test code at the end of this file. Because subclassing core types is a somewhat advanced feature with a limited audience, we’ll end this topic here, but you’re invited to trace through these results in the code to study its behavior:</p>
<pre data-type="programlisting">$ <code><strong>python3 setsubclass.py</strong></code>
Set([1, 3, 5, 7]) Set([2, 1, 4, 5, 6]) 4
Set([1, 5]) Set([2, 1, 4, 5, 6, 3, 7])
Set([1, 5]) Set([1, 3, 5, 7, 2, 4, 6])
Set([7, 5, 3, 1])</pre>
<p>Subtleties: some inherited list operations may introduce duplicates to our <code>Set</code>, and there are more efficient ways to implement sets with dictionaries in Python, which replace the nested linear search scans in the set implementations shown here with more direct dictionary index operations (hashing) and so run much quicker. If you’re interested in sets, also take another look at the <code>set</code> object type we explored in <a data-type="xref" href="ch05.html#numbers_and_expressions">Chapter 5</a>; this type provides extensive set operations as built-in tools. Set implementations are fun to experiment with but not strictly required in Python today.</p>
<p>More important here is the question of why we can subclass built-in types like <code>list</code> at all. The next section <a contenteditable="false" data-type="indexterm" data-primary="object types" data-secondary="built-in" data-tertiary="extending" data-startref="objbuxt" id="id4178"></a><a contenteditable="false" data-type="indexterm" data-primary="built-in types" data-secondary="extending" data-tertiary="subclassing" data-startref="bltjxbc" id="id4179"></a><a contenteditable="false" data-type="indexterm" data-primary="subclassing" data-secondary="built-in type extension" data-startref="subbjxt" id="id4180"></a>solves the mystery—at least as much as this chapter can.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="The Python Object Model"><div class="sect1" id="the_python_object_model">
<h1>The Python Object Model</h1>
<p>The reason we could subclass built-in types in the prior section is that types and classes are largely one and the same—a unification that came with the “new-style” model alluded to at the start of this chapter. For built-ins, some instances can uniquely be coded <a contenteditable="false" data-type="indexterm" data-primary="types" data-secondary="classes and" id="id4181"></a><a contenteditable="false" data-type="indexterm" data-primary="classes" data-secondary="types and" id="id4182"></a>with literal syntax like <code>[]</code>, <code>'lp6e'</code>, and <code>3.12</code> instead of class calls like <code>list()</code>, <code>str()</code>, and <code>float()</code>, but they are instances of a class, nonetheless.</p>
<p>In fact, built-in types and <a contenteditable="false" data-type="indexterm" data-primary="built-in types" data-secondary="classes" id="id4183"></a><a contenteditable="false" data-type="indexterm" data-primary="classes" data-secondary="built-in types" id="id4184"></a>user-defined classes are both classes and are both themselves instances of the built-in <code>type</code> class. The <code>type</code> object generates classes as its instances, classes generate instances of themselves, and classes are really just user-defined types. And on top of all this, the built-in <code>object</code> class provides defaults for every object.</p>
<section data-type="sect2" data-pdf-bookmark="Classes Are Types Are Classes"><div class="sect2" id="classes_are_types_are_classes">
<h2>Classes Are Types Are Classes</h2>
<p>While you probably shouldn’t ponder the <a contenteditable="false" data-type="indexterm" data-primary="object model" data-secondary="classes, user-defined" id="obmdcus"></a><a contenteditable="false" data-type="indexterm" data-primary="user-defined classes" id="usdfcl"></a><a contenteditable="false" data-type="indexterm" data-primary="classes" data-secondary="user-defined" id="clsssdf"></a>preceding definitions before operating heavy machinery, it’s easy to see all this in code. The <code>type</code> built-in with one argument returns any object’s type, which is normally the same as the object’s <code>__class__</code>,<a contenteditable="false" data-type="indexterm" data-primary="__class__ attribute" data-primary-sortas="class attribute" id="id4185"></a><a contenteditable="false" data-type="indexterm" data-primary="classes" data-secondary="__class__ attribute" data-secondary-sortas="class attribute" id="id4186"></a> and <code>isinstance</code> checks whether an object inherits from another. Here’s the story for user-defined <em>classes</em> (a.k.a. types):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>class Hack: pass</strong></code>         <code><em># A humble user-defined class</em></code>
&gt;&gt;&gt; <code><strong>I = Hack()</strong></code>               <code><em># Make an instance by calling the class</em></code>

&gt;&gt;&gt; <code><strong>type(I)</strong>   </code>               <code><em># Type is the user-defined class of origin</em></code>
&lt;class '__main__.Hack'&gt;

&gt;&gt;&gt; <code><strong>type(Hack)</strong></code>               <code><em># User-defined classes are instances of type</em></code>
&lt;class 'type'&gt;

&gt;&gt;&gt; <code><strong>I.__class__, Hack.__class__</strong></code>
(&lt;class '__main__.Hack'&gt;, &lt;class 'type'&gt;)

&gt;&gt;&gt; <code><strong>isinstance(I, object), isinstance(Hack, object)</strong></code>
(True, True)</pre>
<p>This works the same <a contenteditable="false" data-type="indexterm" data-primary="instances" data-secondary="literal syntax" id="id4187"></a><a contenteditable="false" data-type="indexterm" data-primary="syntax" data-secondary="instance generation" id="id4188"></a>for built-in <em>types</em> (a.k.a. classes), but there is also literal syntax for generating instances:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>I = 'hack'</strong></code>               <code><em># Make an instance by literal syntax, or str()</em></code>

&gt;&gt;&gt; <code><strong>type(I)</strong>   </code>               <code><em># Built-in objects are instances of classes</em></code>
&lt;class 'str'&gt;

&gt;&gt;&gt; <code><strong>type(str)</strong> </code>               <code><em># Built-in classes are instances of type</em></code>
&lt;class 'type'&gt;

&gt;&gt;&gt; <code><strong>I.__class__, str.__class__</strong></code>
(&lt;class 'str'&gt;, &lt;class 'type'&gt;)

&gt;&gt;&gt; <code><strong>isinstance(I, object), isinstance(str, object)</strong></code>
(True, True)</pre>
<p>In fact, <code>type</code> itself reports in as a class, though it has no type but itself—circularly capping the chain:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>type(type)</strong></code>                 <code><em># The type class ends the chain</em></code>
&lt;class 'type'&gt;
&gt;&gt;&gt; <code><strong>type(type(type))</strong> </code>          <code><em># Hmm...the top of the chain</em></code>
&lt;class 'type'&gt;</pre>
<p>This model may seem academic (and to some extent is), but it allows us to specialize built-in types with normal user-defined classes and bears on type-testing code: you must know what a type <a contenteditable="false" data-type="indexterm" data-primary="object model" data-secondary="classes, user-defined" data-startref="obmdcus" id="id4189"></a><a contenteditable="false" data-type="indexterm" data-primary="user-defined classes" data-startref="usdfcl" id="id4190"></a><a contenteditable="false" data-type="indexterm" data-primary="classes" data-secondary="user-defined" data-startref="clsssdf" id="id4191"></a>is to test it accurately.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Some Instances Are More Equal Than Others"><div class="sect2" id="some_instances_are_more_equal_than_othe">
<h2>Some Instances Are More Equal Than Others</h2>
<p>It’s tempting to simply take away from the foregoing that classes and types are the same, but this story is richer than that may imply: the instances we make from these objects diverge in both functionality and inheritance.</p>
<p>To truly understand how, we have <a contenteditable="false" data-type="indexterm" data-primary="object model" data-secondary="instances, metaclasses" id="id4192"></a><a contenteditable="false" data-type="indexterm" data-primary="instances" data-secondary="metaclasses" id="id4193"></a><a contenteditable="false" data-type="indexterm" data-primary="metaclasses" id="id4194"></a><a contenteditable="false" data-type="indexterm" data-primary="classes" data-secondary="metaclasses" data-see="metaclasses" id="id4195"></a>to briefly factor in <em>metaclasses</em>—classes that generate other classes. The <code>type</code> built-in itself <em>is</em> a metaclass and may be <em>customized</em> with user-defined subclasses. These subclasses are coded with normal <code>class</code> statements, selected with special syntax in <code>class</code> headers, and designed to play metaclass roles, but they won’t be covered in full until <a data-type="xref" href="ch40.html#metaclasses_and_inheritance">Chapter 40</a>.</p>
<p>In brief, though, the complete relationship between instances, classes, and types is as follows:</p>
<ul>
<li><p><em>Instances</em> are created <a contenteditable="false" data-type="indexterm" data-primary="classes" data-secondary="instances" data-tertiary="creating" id="id4196"></a><a contenteditable="false" data-type="indexterm" data-primary="instances" data-secondary="creation" id="id4197"></a>from classes—both built-in and user-defined.</p></li>
<li><p><em>Classes</em> themselves are created <a contenteditable="false" data-type="indexterm" data-primary="built-in types" data-secondary="class creation" id="id4198"></a>from the built-in <code>type</code> class or one of its subclasses.</p></li>
<li><p>The <code>object</code> built-in class <a contenteditable="false" data-type="indexterm" data-primary="object class" data-secondary="as superclass" id="id4199"></a>is a superclass to every object—instance, class, or both.</p></li>
</ul>
<p>Although everything is ultimately an “instance” in Python, there are two fundamentally different <em>kinds</em> of instances, and conflating these only serves to mask the true complexity of the model. It doesn’t help to distinguish these as instances of <em>user-defined</em> classes or not: metaclasses may be user-defined classes too. Nor is this about being a <em>subclass</em> of a type: the real fork in this model is that classes are <em>created</em> from a type class specially.</p>
<p>As you’ll learn in full later, classes define their types with optional <code>metaclass</code> syntax that defaults to <code>type</code> if omitted, but other instances define their types by the class calls or literal syntax we’ve used so far:</p>
<pre data-type="programlisting">class C(metaclass=<code><em>Meta</em></code>): …     <code><em># Class creation: metaclass defaults to "type"</em></code>

I = C(…)                       <code><em># Instance creation: user-defined classes</em></code>
X = [1, 2]                     <code><em># Instance creation: built-in classes</em></code></pre>
<p>While both produce instances in some sense, these different syntaxes create very different kinds of instances—<em>class</em> and <em>nonclass</em>—with fundamentally different behaviors:</p>
<dl>
<dt>Nonclass instances do not make instances</dt>
<dd>Classes are created from <code>type</code> (or another metaclass), similar to the way instances <a contenteditable="false" data-type="indexterm" data-primary="instances" data-secondary="nonclass instances" id="id4200"></a><a contenteditable="false" data-type="indexterm" data-primary="nonclass instances" id="id4201"></a>are created from classes. Once created, though, the analogy fails: <em>classes</em> create instances of their own, but <em>nonclass</em> instances do not.</dd>
<dt>Classes have an extra inheritance search</dt>
<dd>There are <a contenteditable="false" data-type="indexterm" data-primary="classes" data-secondary="inheritance" id="id4202"></a><a contenteditable="false" data-type="indexterm" data-primary="inheritance" data-secondary="classes" data-tertiary="inheritance search" id="id4203"></a>really <em>two</em> inheritance trees and searches in Python, which are distinct but not entirely disjoint. The secondary tree is formed by <code>type</code> and its subclasses and is searched only for <em>classes</em>, not <em>nonclass</em> instances.</dd>
</dl>
<p>In other words, nonclass instances seal off the instantiation chain, and inheritance differs for nonclass instances and classes themselves—even though the latter are also instances of <code>type</code>. All of this boils down to different creation syntax that makes different kinds of objects, which are often confusingly lumped together as “instances”:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>class C: pass     </strong>  </code>                         <code><em># A type instance</em></code>
&gt;&gt;&gt; <code><strong>I = C()</strong> </code>                                     <code><em># A nonclass instance</em></code>
&gt;&gt;&gt; <code><strong>isinstance(I, type), isinstance(C, type)</strong></code>     <code><em># Only classes are types</em></code>
(False, True)</pre>
<p>While types and classes may be synonymous, the instances we create from them vary per creation code.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="The Inheritance Bifurcation"><div class="sect2" id="the_inheritance_bifurcation">
<h2>The Inheritance Bifurcation</h2>
<p>Though we can’t get into full details here, the inheritance search used for <em>classes</em> (a.k.a. types) differs from what we’ve seen so far and may be their most profound distinction. In short, inheritance <a contenteditable="false" data-type="indexterm" data-primary="MRO (method resolution order)" data-secondary="inheritance" id="id4204"></a><a contenteditable="false" data-type="indexterm" data-primary="inheritance" data-secondary="MRO (method resolution order)" id="id4205"></a>is always based on the <em>MRO</em> (method resolution order) we studied in <a data-type="xref" href="ch31.html#multiple_inheritance_and_the_mro">“Multiple Inheritance and the MRO”</a>, but varies as follows:</p>
<dl>
<dt>Nonclass inheritance</dt>
<dd>As we’ve seen, inheritance run <a contenteditable="false" data-type="indexterm" data-primary="inheritance" data-secondary="nonclass instances" id="id4206"></a><a contenteditable="false" data-type="indexterm" data-primary="instances" data-secondary="nonclass instances" data-tertiary="inheritance" id="id4207"></a><a contenteditable="false" data-type="indexterm" data-primary="nonclass instances" data-secondary="inheritance" id="id4208"></a>on a <em>nonclass</em> instance searches the <code>__dict__</code> attributes of instance, class, and superclasses, per the MRO order we studied in the prior chapter. This works by first checking the instance, then following the instance’s <code>__class__</code> to its class, and finally following each class’s <code>__bases__</code><a contenteditable="false" data-type="indexterm" data-primary="__bases__ attribute" data-primary-sortas="bases attribute" id="id4209"></a><a contenteditable="false" data-type="indexterm" data-primary="classes" data-secondary="__bases__ attribute" data-secondary-sortas="bases attribute" id="id4210"></a> to superclasses. Technically, <code>__bases__</code> are used to make an <code>__mro__</code> at <code>__class__</code>, which inheritance scans.<a contenteditable="false" data-type="indexterm" data-primary="__mro__ attribute" data-primary-sortas="mro attribute" id="id4211"></a><a contenteditable="false" data-type="indexterm" data-primary="classes" data-secondary="__mro__ attribute" data-secondary-sortas="mro attribute" id="id4212"></a></dd>
<dt>Class inheritance</dt>
<dd>Inheritance run on a <em>class</em> directly, <a contenteditable="false" data-type="indexterm" data-primary="classes" data-secondary="inheritance" data-tertiary="metaclass subclasses and" id="id4213"></a><a contenteditable="false" data-type="indexterm" data-primary="inheritance" data-secondary="classes" data-tertiary="metaclass subclasses and" id="id4214"></a><a contenteditable="false" data-type="indexterm" data-primary="metaclasses" data-secondary="inheritance" id="id4215"></a><a contenteditable="false" data-type="indexterm" data-primary="subclassing" data-secondary="inheritance" id="id4216"></a>though, first searches the <code>__dict__</code> of the class and all its supers available from <code>__bases__</code> as usual, but then <em>also</em> searches the separate class tree formed by the <code>type</code> class and its <em>metaclass</em> subclasses. The second part of this works by following the class’s own <code>__class__</code> to its <code>type</code> class tree and using <code>__bases__</code> and MROs there, too—but only as a last resort and only for inheritance run on classes.</dd>
</dl>
<p>In fact, if you know where to look, you can inspect the inheritance sources that differ for nonclass instances like <code>I</code> and classes like <code>C</code> in the prior example—though the underscores and displays aren’t pretty:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>isinstance(I, C), type(I)</strong></code>
(True, &lt;class '__main__.C'&gt;)

&gt;&gt;&gt; <code><strong>I, I.__class__, I.__class__.__bases__</strong></code>
(&lt;__main__.C object at 0x101265d60&gt;, &lt;class '__main__.C'&gt;, (&lt;class 'object'&gt;,))

&gt;&gt;&gt; <code><strong>C, C.__bases__, C.__class__, C.__class__.__bases__</strong></code>
(&lt;class '__main__.C'&gt;, (&lt;class 'object'&gt;,), &lt;class 'type'&gt;, (&lt;class 'object'&gt;,))</pre>
<p>But due to the way MROs are computed from <code>__bases__</code> and scanned, it’s more accurate to think of inheritance’s different search orders for nonclass instances and classes as <a contenteditable="false" data-type="indexterm" data-primary="MRO (method resolution order)" data-secondary="as flattened tree" data-secondary-sortas="flattened tree" id="id4217"></a>follows—where each <code>__mro__</code> is a <em>flattened tree</em>:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>I, I.__class__.__mro__</strong></code>
(&lt;__main__.C object at 0x101265d60&gt;, (&lt;class '__main__.C'&gt;, &lt;class 'object'&gt;))

&gt;&gt;&gt; <code><strong>C.__mro__, C.__class__.__mro__</strong></code>
((&lt;class '__main__.C'&gt;, &lt;class 'object'&gt;), (&lt;class 'type'&gt;, &lt;class 'object'&gt;))</pre>
<p>And because each item’s <code>__dict__</code> is checked, the ordered set of candidates searched by inheritance for nonclass instances <code>I</code> and classes <code>C</code> is ultimately and respectively as follows—with <em>two</em> MRO scans of flattened trees for classes only, and ignoring the fact that some kinds of <em>descriptors</em>, introduced ahead, take precedence in both trees as you’ll learn in <a data-type="xref" href="ch40.html#metaclasses_and_inheritance">Chapter 40</a>:</p>
<pre data-type="programlisting">[I.__dict__] + [x.__dict__ for x in I.__class__.__mro__]

[x.__dict__ for x in C.__mro__] + [x.__dict__ for x in C.__class__.__mro__]</pre>
<p>Wait—there’s a <em>second</em> tree in inheritance? Well, yes, though it doesn’t come into play in the vast <a contenteditable="false" data-type="indexterm" data-primary="inheritance" data-secondary="secondary trees" id="id4218"></a>majority of application code. The type/metaclass tree is used in advanced class-management roles and, even then, is often limited to class customization at class creation time.</p>
<p>Still, this secondary tree, along with the descriptors’ special cases omitted here, bifurcates and convolutes the inheritance story, especially compared to its prior forms. It also explains why some class attributes like <code>__bases__</code> are not inherited by nonclass instances—they’re located in the secondary tree (i.e., MRO) searched only for classes:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>'__bases__' in I.__dict__</strong> </code>               <code><em># Not in instance</em></code>
False
&gt;&gt;&gt; <code><strong>'__bases__' in C.__dict__</strong> </code>               <code><em># Not in instance's class</em></code>
False
&gt;&gt;&gt; <code><strong>'__bases__' in C.__class__.__dict__</strong> </code>     <code><em># In instance's class's class</em></code>
True</pre>
<p>Because of the two-tree inheritance model, such names inherited by classes are not inherited by their instances:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>C.__bases__   </strong>  </code>                         <code><em># Instance does not inherit!</em></code>
(&lt;class 'object'&gt;,)
&gt;&gt;&gt; <code><strong>I.__bases__</strong></code>
AttributeError: 'C' object has no attribute '__bases__'. Did you mean: '__class__'?</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="The Metaclass/Class Dichotomy"><div class="sect2" id="the_metaclasssolidusclass_dichotomy">
<h2>The Metaclass/Class Dichotomy</h2>
<p>So, where does this odd tale of type/class unification leave us? Types indeed behave as classes, and this <a contenteditable="false" data-type="indexterm" data-primary="types" data-secondary="metaclass/class dichotomy" id="typmccd"></a><a contenteditable="false" data-type="indexterm" data-primary="metaclass/class dichotomy" id="mtcldchtm"></a>allows us to extend them with normal class syntax in both the primary and metaclass trees. But it also comes with noticeable <em>seams</em>, including special-case syntax for class instantiation, an extra type-tree search for classes only, two very different kinds of instances, and unique semantics for metaclasses that customize types (a.k.a. classes), which we’ll uncover later.</p>
<p>In fact, a reasonable argument can be made that the <em>type</em>/<em>class</em> dichotomy of earlier Pythons may simply have morphed into one of <em>metaclass</em>/<em>class</em>—which trades a straightforward distinction for all the seams just enumerated and muddles inheritance and the fundamental meaning of <em>names</em> in Python everywhere to support what in the end is a very rare use case. As usual, the net merit of the morph is yours to weigh.</p>
<p>To be fair, some of the widespread confusion this model has spawned may stem from <code>type</code> itself: it’s overloaded to either <em>return</em> a sole argument’s type, or <em>generate</em> a new instance of itself for multiple arguments—just like other constructors and equivalent to what a <code>class</code> statement does to make a class object:</p>
<pre data-type="programlisting">type(<code><em>object</em></code>)                                     <code><em># Fetch object type</em></code>
type(<code><em>classname</em></code>, <code><em>superclasses</em></code>, <code><em>attributedict</em></code>)     <code><em># Make a class/type</em></code></pre>
<p>The first of these roles might have been better named “typeof,” but the second will have to await the metaclass <a contenteditable="false" data-type="indexterm" data-primary="types" data-secondary="metaclass/class dichotomy" data-startref="typmccd" id="id4219"></a><a contenteditable="false" data-type="indexterm" data-primary="metaclass/class dichotomy" data-startref="mtcldchtm" id="id4220"></a>preview later in this chapter and the extended coverage in <a data-type="xref" href="ch40.html#metaclasses_and_inheritance">Chapter 40</a>.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="And One “object” to Rule Them All "><div class="sect2" id="and_one_quotation_markobjectquotation_m">
<h2>And One “object” to Rule Them All </h2>
<p>To round out this topic, keep in mind that <a contenteditable="false" data-type="indexterm" data-primary="object class " data-secondary="inheritance type class" id="id4221"></a>because topmost classes inherit from the built-in class <code>object</code>, every object <em>derives</em> (i.e., inherits) from it, whether directly or through a superclass—and whether you code <code>object</code> or not:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>class C: pass</strong></code>
&gt;&gt;&gt; <code><strong>class D(object): pass</strong></code>

&gt;&gt;&gt; <code><strong>dir(C) == dir(D)</strong></code>
True
&gt;&gt;&gt; <code><strong>C.__bases__, D.__bases__</strong></code>
((&lt;class 'object'&gt;,), (&lt;class 'object'&gt;,))</pre>
<p>In fact, the <code>type</code> class inherits from the <code>object</code> class, and <code>object</code> inherits from <code>type</code>, even though the two are different objects—a circular relationship that crowns the object model and may make your cranium catch fire (to avoid combustion, keep in mind that <code>isinstance</code> is true for <em>either</em> a subclass relationship or creation source, though this is based on inheritance through the secondary type-class tree for classes):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>type is object</strong></code>
False
&gt;&gt;&gt; <code><strong>type(type), type(object)</strong></code>
(&lt;class 'type'&gt;, &lt;class 'type'&gt;)
&gt;&gt;&gt; <code><strong>isinstance(type, object), isinstance(object, type)</strong></code>
(True, True)
&gt;&gt;&gt; <code><strong>type.__bases__, object.__bases__</strong></code>
((&lt;class 'object'&gt;,), ())</pre>
<p>Strange though it may seem, this has a number of practical consequences. For one thing, it means that we sometimes must be aware of the method defaults that come with the implicit (or explicit) <code>object</code> root class. As we noted in earlier chapters, for instance, the <code>object</code> class comes with a <code>__repr__</code> for display:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>class C: pass</strong></code>                     <code><em># All classes inherit object defaults</em></code>
&gt;&gt;&gt; <code><strong>X = C()
</strong></code>&gt;&gt;&gt; <code><strong>X.__repr__</strong></code>
&lt;method-wrapper '__repr__' of C object at 0x1091a7920&gt;</pre>
<p>For another, this also allows us to write code that can safely assume and use an <code>object</code> superclass. As an example, we can rely on it to be a call-chain “anchor” in some <code>super</code> built-in roles described ahead and can reroute method calls to it from attribute-interceptor methods to invoke higher default behavior. Per <a data-type="xref" href="ch30.html#operator_overloading-id000103">Chapter 30</a>:</p>
<pre data-type="programlisting">object.__setattr__(self, <code><em>attr</em></code>, <code><em>value</em></code>)</pre>
<p>We’ll code examples of such rerouting later in the book; for now, let’s move on to something a bit more tangible and our next topic in this OOP jamboree.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Advanced Attribute Tools"><div class="sect1" id="advanced_attribute_tools">
<h1>Advanced Attribute Tools</h1>
<p>Along with the normal class and instance attributes we’ve been using so far, Python’s OOP support includes attribute tools of narrower scope—<em>slots</em>, <em>properties</em>, <em>descriptors</em>, and more. Slots, for example, are an optimization option, and properties and descriptors allow classes to augment access. None of these tools are required, but as for most topics in this chapter, all are fair game in Python code you may someday use. Most of these tools get extended coverage in <a data-type="xref" href="ch38.html#managed_attributes">Chapter 38</a>, but slots get full coverage here, and others are presented in abbreviated form. </p>
<section data-type="sect2" data-pdf-bookmark="Slots: Attribute Declarations"><div class="sect2" id="slots_attribute_declarations">
<h2>Slots: Attribute Declarations</h2>
<p>First off, we’ve noted the <a contenteditable="false" data-type="indexterm" data-primary="attributes" data-secondary="slots" id="id4222"></a><a contenteditable="false" data-type="indexterm" data-primary="slots" id="id4223"></a>implications of <em>slots</em> several times in this part of the book. In short, by assigning an iterable of attribute name strings to a special <code>__slots__</code> class attribute, we can enable a class to both limit the set of legal attributes that instances of the class will have and optimize memory usage and possibly program speed. As you’ll find, though, slots should be used only in applications that clearly warrant the added complexity. They will complicate your code, may complicate or break code you may use, and rigidly require universal deployment to be effective.</p>
<section data-type="sect3" data-pdf-bookmark="Slot basics"><div class="sect3" id="slot_basics">
<h3>Slot basics</h3>
<p>To declare slots, assign an iterable (e.g., list) of string names to the special <code>__slots__</code> variable <a contenteditable="false" data-type="indexterm" data-primary="slots" data-secondary="declaring" id="id4224"></a>and attribute at the top level of a <code>class</code> statement: only those names in <code>__slots__</code> can be assigned as instance attributes. This doesn’t change the way these attributes work in general, though; like all names in Python, instance attribute names must always be assigned before they can be referenced, even if they’re listed in <code>__slots__</code>. Here are the basics:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>class Limiter(object):
        __slots__ = ['age', 'name', 'job']</strong> </code>               <code><em># Slots "declaration"</em></code>

&gt;&gt;&gt; <code><strong>I = Limiter()
</strong></code>&gt;&gt;&gt; <code><strong>I.age</strong></code>                                                 <code><em># Must assign before use</em></code>
AttributeError: 'Limiter' object has no attribute 'age' 

&gt;&gt;&gt; <code><strong>I.age = 40</strong></code>                                            <code><em># Looks like instance data
</em></code>&gt;&gt;&gt; <code><strong>I.age</strong></code>
40
&gt;&gt;&gt; <code><strong>I.ape = 1000</strong></code>                                          <code><em># Fails: not in __slots__
</em></code>AttributeError: 'Limiter' object has no attribute 'ape'</pre>
<p>This feature is advertised as both a way to catch typo errors like this (assignments to illegal attribute names not in <code>__slots__</code> are detected instead of silently assigned), as well as an optimization mechanism that saves memory.</p>
<p>Allocating a namespace dictionary for every <a contenteditable="false" data-type="indexterm" data-primary="slots" data-secondary="namespaces dictionaries and" id="slnmpd"></a><a contenteditable="false" data-type="indexterm" data-primary="namespaces" data-secondary="dictionaries" data-tertiary="slots and" id="nmpdcslt"></a><a contenteditable="false" data-type="indexterm" data-primary="dictionaries" data-secondary="namespaces" data-tertiary="slots" id="id4225"></a>instance object can be expensive in terms of <em>memory</em> if many instances are created and only a few attributes are required. To save space, instead of allocating a dictionary for each instance, Python reserves just enough space in each <em>instance</em> to hold a value for each slot attribute, along with inherited attributes in the common <em>class</em> to manage slot access. This might additionally <em>speed</em> execution, though this benefit may vary per program, platform, and Python version (spoiler: the speedup is trivial today, as we’ll prove ahead).</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="You shouldn’t normally use slots"><div class="sect3" id="you_shouldnapostrophet_normally_use_slo">
<h3>You shouldn’t normally use slots</h3>
<p>Slots are a fairly major break with Python’s core dynamic nature, which dictates that any name may be created by assignment (and frankly, tend to appeal most to people with backgrounds in draconian languages). In fact, they partly imitate C++ for efficiency at the expense of flexibility and even have the potential to <em>break</em> some programs.</p>
<p>As you’ll see, slots also come with <a contenteditable="false" data-type="indexterm" data-primary="slots" data-secondary="usage rules" id="id4226"></a>a plethora of special-case usage <em>rules</em>. Per Python’s own manual, they should <em>not</em> be used except in clearly warranted cases—they are difficult to deploy correctly, complicate your code badly, and are best limited to very rare memory-critical programs that produce an extremely large numbers of instances.</p>
<p>In other words, this is yet another feature that should be used only if clearly justified. Unfortunately, slots seem to be showing up in Python code much more often than they should; their obscurity seems to be a draw in itself. Slots are actually used by Python, unlike <em>type hinting</em>, their declaration cousin of <a data-type="xref" href="ch06.html#the_dynamic_typing_interlude">Chapter 6</a>, but they are similarly paradoxical and restrictive. As usual, knowledge is your best ally in such things, so let’s take a deeper look here.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Slots and namespace dictionaries"><div class="sect3" id="slots_and_namespace_dictionaries">
<h3>Slots and namespace dictionaries</h3>
<p>Potential benefits aside, slots can complicate a class model—and code that relies on it—substantially. In fact, some <a contenteditable="false" data-type="indexterm" data-primary="dictionaries" data-secondary="namespaces" data-tertiary="slots" id="dctnmpcl"></a>instances with slots may not have a <code>__dict__</code> attribute namespace dictionary at all, and others will have data attributes that this dictionary does not include. To be clear, this is a <em>major incompatibility</em> with the traditional class model—one that can impact any code that accesses attributes generically and may even cause some to fail altogether.</p>
<p>For instance, programs that list or access instance attributes by name string may need to use more storage-neutral interfaces than <code>__dict__</code> if slots may be used. Because an instance’s data may include class-level names such as slots—either in <em>addition</em> to or <em>instead</em> of namespace dictionary storage—both attribute sources may need to be queried for completeness, and some roles may be rendered impossible.</p>
<p>Let’s see what this means in terms of code and explore more about slots along the way. First off, when slots are used, instances do not normally have an attribute dictionary—instead, Python uses the class <em>descriptors</em> feature introduced ahead to allocate and manage space reserved for slot attributes in the instance:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>class C:</strong></code>
        <code><strong>__slots__ = ['a', 'b']</strong></code>           <code><em># __slots__ means no __dict__ by default</em></code>

&gt;&gt;&gt; <code><strong>I = C()
</strong></code>&gt;&gt;&gt; <code><strong>I.a = 1
</strong></code>&gt;&gt;&gt; <code><strong>I.a</strong></code>
1
&gt;&gt;&gt; <code><strong>I.__dict__</strong></code>
AttributeError: 'C' object has no attribute '__dict__'. Did you mean: '__dir__'?</pre>
<p>However, we can still fetch and set slot-based attributes by name string using storage-neutral tools such as <code>getattr</code> and <code>setattr</code> (which look beyond the instance <code>__dict__</code> and thus include class-level names like slots) and list them with <code>dir</code> (which collects all inherited names of any kind throughout a class tree):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>getattr(I, 'a')</strong></code>
1
&gt;&gt;&gt; <code><strong>setattr(I, 'b', 2)</strong></code>                   <code><em># But getattr() and setattr() still work</em></code>
&gt;&gt;&gt; <code><strong>I.b</strong></code>
2
&gt;&gt;&gt; <code><strong>'a' in dir(I)</strong></code>                        <code><em># And dir() finds slot attributes too</em></code>
True
&gt;&gt;&gt; <code><strong>'b' in dir(I)</strong></code>                        <code><em># Though __dict__ access will fail</em></code>
True
&gt;&gt;&gt; <code><strong>I.__dict__</strong></code>
AttributeError: 'C' object has no attribute '__dict__'. Did you mean: '__dir__'?</pre>
<p>Also keep in mind that without an attribute namespace dictionary, it’s not possible to assign <em>new</em> names to instances that are not names in the slots list:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>class D:</strong></code>                             
        <code><strong>__slots__ = ['a', 'b']
        def __init__(self):
            self.d = 4</strong></code>                   <code><em># Cannot add new names if no __dict__
</em></code>
&gt;&gt;&gt; <code><strong>I = D()</strong></code>
AttributeError: 'D' object has no attribute 'd'</pre>
<p>We can still accommodate extra attributes, though, by including <code>__dict__</code> explicitly in <code>__slots__</code> in order to create an attribute namespace dictionary in <em>addition</em> to slots:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>class D:
        __slots__ = ['a', 'b', '__dict__']</strong></code>    <code><em># Name __dict__ to include one too
</em></code>        <code><strong>c = 3</strong></code>                                 <code><em># Class attrs work normally
</em></code>        <code><strong>def __init__(self):
            self.d = 4</strong></code>                        <code><em># d stored in __dict__, a is a slot</em></code>

&gt;&gt;&gt; <code><strong>I = D()
</strong></code>&gt;&gt;&gt; <code><strong>I.d</strong></code>
4
&gt;&gt;&gt; <code><strong>I.c</strong></code>
3
&gt;&gt;&gt; <code><strong>I.a</strong></code>                          <code><em># All instance attrs undefined until assigned</em></code>
AttributeError: 'D' object has no attribute 'a' 
&gt;&gt;&gt; <code><strong>I.a = 1
</strong></code>&gt;&gt;&gt; <code><strong>I.b = 2</strong></code></pre>
<p>In this case, <em>both</em> storage mechanisms are used. This renders <code>__dict__</code> too limited for code that wishes to treat slots as instance data, but generic tools such as <code>getattr</code> still allow us to process both storage forms as a single set of attributes:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>I.__dict__</strong></code>                   <code><em># Some objects have both __dict__ and slot names</em></code>
{'d': 4}                         <code><em># getattr() can fetch either type of attr
</em></code>&gt;&gt;&gt; <code><strong>I.__slots__</strong></code>
['a', 'b', '__dict__']
&gt;&gt;&gt; <code><strong>getattr(I, 'a'), getattr(I, 'c'), getattr(I, 'd')</strong></code>    <code><em># Fetches all 3 forms</em></code>
(1, 3, 4)</pre>
<p>Because <code>dir</code> also returns all <em>inherited</em> attributes, though, it might be too broad in some contexts; it also includes class-level methods and even all <code>object</code> defaults. Code that wishes to list <em>just</em> instance attributes may, in principle, still need to allow for both storage forms explicitly. We might at first naively code this as follows:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>for attr in list(I.__dict__) + I.__slots__:</strong></code>          <code><em># Wrong...</em></code>
        <code><strong>print(attr, '=&gt;', getattr(I, attr))</strong></code></pre>
<p>Since either can be omitted, we may more <a contenteditable="false" data-type="indexterm" data-primary="slots" data-secondary="namespaces dictionaries and" data-startref="slnmpd" id="id4227"></a><a contenteditable="false" data-type="indexterm" data-primary="namespaces" data-secondary="dictionaries" data-tertiary="slots and" data-startref="nmpdcslt" id="id4228"></a><a contenteditable="false" data-type="indexterm" data-primary="dictionaries" data-secondary="namespaces" data-tertiary="slots" data-startref="dctnmpcl" id="id4229"></a>correctly code this as follows, using <code>getattr</code> to allow for defaults—a noble but nonetheless inaccurate approach, as the next section will explain:</p>
<pre data-type="programlisting" class="pagebreak-before">&gt;&gt;&gt; <code><strong>for attr in list(getattr(I, '__dict__', [])) + getattr(I, '__slots__', []):
        print(attr, '=&gt;', getattr(I, attr))</strong></code>

d =&gt; 4
a =&gt; 1                                                   <code><em># Less wrong...</em></code>
b =&gt; 2
__dict__ =&gt; {'d': 4}</pre>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Multiple __slot__ lists in superclasses"><div class="sect3" id="multiple_slot_lists_in_superclasses">
<h3>Multiple __slot__ lists in superclasses</h3>
<p>The preceding code works in this <a contenteditable="false" data-type="indexterm" data-primary="__slots__ attribute" data-primary-sortas="slots attribute" id="id4230"></a><a contenteditable="false" data-type="indexterm" data-primary="attributes" data-secondary="__slots__" data-secondary-sortas="slots" id="id4231"></a><a contenteditable="false" data-type="indexterm" data-primary="superclasses" data-secondary="__slots__ attribute" data-secondary-sortas="slots attribute" id="id4232"></a>specific case, but in general, it’s not entirely accurate. Specifically, this code addresses only slot names in the <em>lowest</em> <code>__slots__</code> attribute inherited by an instance, but slot lists may appear more than once in a class tree. That is, a name’s absence in the lowest <code>__slots__</code> list does not preclude its existence in a higher <code>__slots__</code>. Because slot names become class-level attributes, instances acquire the <em>union</em> of all slot names anywhere in the tree by the normal inheritance rule:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>class E:
        __slots__ = ['c', 'd']</strong></code>            <code><em># Superclass has slots</em></code>

&gt;&gt;&gt; <code><strong>class D(E):
        __slots__ = ['a', '__dict__']</strong></code>     <code><em># But so does its subclass</em></code>

&gt;&gt;&gt; <code><strong>I = D()    </strong>  </code>                         <code><em># The instance gets the union of each</em></code>
&gt;&gt;&gt; <code><strong>dir(I)</strong></code>
[…<code><em>names omitted</em></code>…, 'a', 'c', 'd']<code><strong>
</strong></code>&gt;&gt;&gt; <code><strong>I.a = 1; I.b = 2; I.c = 3</strong></code>             <code><em># slots: a, c, __dict__: b</em></code>
&gt;&gt;&gt; <code><strong>I.a, I.c</strong></code>
(1, 3)</pre>
<p>But inspecting just the inherited slots list won’t pick up slots defined <em>higher</em> in a class tree:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>E.__slots__</strong></code>                           <code><em># But __slots__ not concatenated</em><strong>
</strong></code>['c', 'd']
&gt;&gt;&gt; <code><strong>D.__slots__</strong></code>
['a', '__dict__']
&gt;&gt;&gt; <code><strong>I.__slots__</strong></code>                           <code><em># Instance inherits *lowest* __slots__</em></code>
['a', '__dict__']
&gt;&gt;&gt; <code><strong>I.__dict__</strong></code>                            <code><em># And has its own attr dict</em></code>
{'b': 2}

&gt;&gt;&gt; <code><strong>for attr in list(getattr(I, '__dict__', [])) + getattr(I, '__slots__', []):
        print(attr, '=&gt;', getattr(I, attr))</strong></code>

b =&gt; 2                                    <code><em># Other superclass slots missed!</em></code>
a =&gt; 1
__dict__ =&gt; {'b': 2}

&gt;&gt;&gt; <code><strong>dir(I)</strong></code>                                <code><em># But dir() includes all slot names
</em></code>[…<code><em>names omitted</em></code>…, 'a', 'b', 'c', 'd']</pre>
<p>In other words, in terms of listing instance attributes generically, one <code>__slots__</code> isn’t always enough—they are potentially subject to the full inheritance search procedure. If multiple classes in a class tree may have their own <code>__slots__</code> attributes, tools must develop other policies for listing attributes—as the next section explains.</p>
</div></section>
<section data-type="sect3" class="pagebreak-before" data-pdf-bookmark="Handling slots and other “virtual” attributes generically"><div class="sect3" id="handling_slots_and_other_quotation_mark">
<h3 class="less_space">Handling slots and other “virtual” attributes generically</h3>
<p>The prior chapter concluded with a brief summary of the slots policies of its attribute lister tools—a prime example of why <a contenteditable="false" data-type="indexterm" data-primary="slots" data-secondary="generic programs" id="id4233"></a>generic programs may need to care about slots. Such tools that attempt to list instance data attributes generically must account for slots and perhaps other such “virtual” instance attributes like <em>properties</em> and <em>descriptors</em> introduced ahead—names that similarly reside in classes but may provide attribute values for instances on request. Slots are the most data-centric of these but are representative of a larger category.</p>
<p>Such attributes require inclusive approaches, special handling, or general avoidance—the latter of which becomes unsatisfactory as soon as any programmer uses slots in subject code. Really, class-level instance attributes like slots probably necessitate a redefinition of the term <em>instance data</em>—as locally stored attributes, the union of all inherited attributes, or some subset thereof.</p>
<p>For example, some programs might classify slot names as attributes of <em>classes</em> instead of instances; these attributes do not exist in instance namespace dictionaries, after all. Alternatively, as shown earlier, programs can be more inclusive by relying on <code>dir</code> to fetch all inherited attribute names and <code>getattr</code> to fetch their corresponding values—without regard to their physical location or implementation. If you must support slots as instance data, this may be the most robust way to proceed:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>class Slotful:
        __slots__ = ['a', 'b', '__dict__']
        def __init__(self, data):
            self.c = data

</strong></code>&gt;&gt;&gt; <code><strong>I = Slotful(3)
</strong></code>&gt;&gt;&gt; <code><strong>I.a, I.b = 1, 2</strong></code>
&gt;&gt;&gt; <code><strong>I.a, I.b, I.c</strong></code>                            <code><em># Normal attribute fetch</em></code>
(1, 2, 3)

&gt;&gt;&gt; <code><strong>I.__dict__</strong></code>                               <code><em># Both __dict__ and slots storage</em></code>
{'c': 3}
&gt;&gt;&gt; <code><strong>[x for x in dir(I) if not x.startswith('__')]</strong></code>
['a', 'b', 'c']

&gt;&gt;&gt; <code><strong>I.__dict__['c']</strong></code>                          <code><em># __dict__ is only one attr source</em></code>
3
&gt;&gt;&gt; <code><strong>getattr(I, 'c'), getattr(I, 'a')</strong></code>         <code><em># dir+getattr is broader than __dict__</em></code>
(3, 1)                                       <code><em># applies to slots, properties, descrip</em></code>

&gt;&gt;&gt; <code><strong>for a in (x for x in dir(I) if not x.startswith('__')):
        print(a, '=&gt;', getattr(I, a))</strong></code>

a 1
b 2
c 3</pre>
<p>Under this <code>dir</code>/<code>getattr</code> model, you can still map attributes to their inheritance sources and filter them more selectively by source or type, if needed, by scanning the <em>MRO</em>—as we did in the prior chapter’s <em>mapattrs.py</em> (<a data-type="xref" href="ch31.html#example_threeone_onefourdot_mapattrsdot">Example 31-14</a>). As a bonus, such tools and policies for handling slots will potentially apply automatically to properties and descriptors too, though these attributes are more explicitly computed values, and less obviously instance-related data than slots.</p>
<p>Also keep in mind that this is not just a tools issue. Class-based instance attributes like slots also impact the traditional coding of the <code>__setattr__</code> operator-overloading method we met in <a data-type="xref" href="ch30.html#operator_overloading-id000103">Chapter 30</a>. Because slots and some other attributes are not stored in the instance <code>__dict__</code>, and may even imply its <em>absence</em>, classes must instead generally run attribute assignments by rerouting them to the <code>object</code> superclass.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Slot usage rules"><div class="sect3" id="slot_usage_rules">
<h3>Slot usage rules</h3>
<p>Slot declarations can appear in multiple classes in a class tree, but when they do, they are subject to a number of constraints that are somewhat difficult to rationalize unless you understand the implementation of slots as class-level <em>descriptors</em> for each slot name that are inherited by the instances in which the managed space is reserved (again, you’ll meet descriptors briefly ahead). Here are the main constraints that slots impose:</p>
<ul>
<li><p><strong>Slots in subs are <a contenteditable="false" data-type="indexterm" data-primary="slots" data-secondary="subclasses" id="id4234"></a><a contenteditable="false" data-type="indexterm" data-primary="subclasses" data-secondary="slots" id="id4235"></a>pointless when absent in supers</strong>. If a subclass inherits from a superclass without a <code>__slots__</code>, the instance <code>__dict__</code> attribute created for the superclass will always be accessible, making a <code>__slots__</code> in the subclass largely pointless. The subclass still manages its slots but doesn’t compute their values in any way and doesn’t avoid a dictionary—the main reason to use slots.</p></li>
<li><p><strong>Slots in supers are pointless <a contenteditable="false" data-type="indexterm" data-primary="slots" data-secondary="superclasses" id="id4236"></a><a contenteditable="false" data-type="indexterm" data-primary="superclasses" data-secondary="slots" id="id4237"></a>when absent in subs</strong>. Similarly, because the meaning of a <code>__slots__</code> declaration is limited to the class in which it appears, subclasses will produce an instance <code>__dict__</code> if they do not define a <code>__slots__</code>, rendering a <code>__slots__</code> in a superclass largely pointless.</p></li>
<li><p><strong>Redefinition renders super slots pointless</strong>. If a class defines the same slot name as a superclass, its redefinition hides the slot in the superclass per normal inheritance. You can access the version of the name defined by the superclass slot only by fetching its descriptor directly from the superclass.</p></li>
<li><p><strong>Slots prevent class-level defaults</strong>. Because slots are implemented as class-level <a contenteditable="false" data-type="indexterm" data-primary="slots" data-secondary="class-level defaults" id="id4238"></a>descriptors (along with per-instance space), you cannot use class attributes of the same name to provide defaults as you can for normal instance attributes: assigning the same name in the class overwrites the slot descriptor.</p></li>
<li><p><strong>Slots cannot be combined in multiple inheritance</strong>. Multiple inheritance cannot be used if <a contenteditable="false" data-type="indexterm" data-primary="slots" data-secondary="multiple inheritance" id="id4239"></a><a contenteditable="false" data-type="indexterm" data-primary="multiple inheritance" data-secondary="slots" id="id4240"></a><a contenteditable="false" data-type="indexterm" data-primary="inheritance" data-secondary="multiple" data-tertiary="slots" id="id4241"></a>more than one of the classes mixed together have nonempty slots lists—even if their slots define the same names. You’ll get an error when running the class that does the mixing. Empty slots lists allow the mixer to define slots or not, as desired.</p></li>
<li><p><strong>Slots can impact <code>__dict__</code></strong>. As shown earlier, <code>__slots__</code> preclude both an instance <code>__dict__</code> and assigning names not listed, unless <code>__dict__</code> is listed explicitly too. Slots similarly preclude a <code>__weakref__</code> attribute used to support instance “weak references” covered briefly in <a data-type="xref" href="ch06.html#the_dynamic_typing_interlude">Chapter 6</a>, but these are rare enough to soft-pedal here.</p></li>
</ul>
<p>We’ve already seen the last of these in action. It’s easy to demonstrate how the new rules here translate to actual code—most crucially, a namespace dictionary is created when any class in a tree omits slots, thereby negating the memory optimization benefit but also supporting classes that require a <code>__dict__</code> when mixed in with others:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>class C: pass</strong></code>                        <code><strong># Bullet 1: slots in sub but not super</strong></code>
&gt;&gt;&gt; <code><strong>class D(C): __slots__ = ['a']</strong></code>        <code><em># Makes instance dict for nonslots</em></code>
&gt;&gt;&gt; <code><strong>I = D()   </strong>  </code>                         <code><em># But slot name still managed in class</em><strong>
</strong></code>&gt;&gt;&gt; <code><strong>I.a = 1; I.b = 2
</strong></code>&gt;&gt;&gt; <code><strong>I.__dict__</strong></code>
{'b': 2}
&gt;&gt;&gt; <code><strong>D.__dict__.keys()</strong></code>
dict_keys([… '__slots__', 'a', …])

&gt;&gt;&gt; <code><strong>class C: __slots__ = ['a']</strong></code>           <code><strong># Bullet 2: slots in super but not sub</strong></code>
&gt;&gt;&gt; <code><strong>class D(C): pass</strong></code>                     <code><em># Makes instance dict for nonslots</em></code>
&gt;&gt;&gt; <code><strong>I = D()</strong></code>                              <code><em># But slot name still managed in class</em></code>
&gt;&gt;&gt; <code><strong>I.a = 1; I.b = 2
</strong></code>&gt;&gt;&gt; <code><strong>I.__dict__</strong></code>
{'b': 2}
&gt;&gt;&gt; <code><strong>C.__dict__.keys()</strong></code>
dict_keys([… '__slots__', 'a', …])

&gt;&gt;&gt; <code><strong>class C: __slots__ = ['a']</strong></code>           <code><strong># Bullet 3: only lowest slot accessible</strong></code>
&gt;&gt;&gt; <code><strong>class D(C): __slots__ = ['a']</strong>   </code>     <code><em># Superclass slot 'a' is pointless</em></code>

&gt;&gt;&gt; <code><strong>class C: __slots__ = ['a']; a = 99</strong></code>   <code><strong># Bullet 4: no class-level defaults</strong></code>
ValueError: 'a' in __slots__ conflicts with class variable

&gt;&gt;&gt; <code><strong>class C: __slots__ = ['a']</strong></code>           <code><strong># Bullet 5: only one nonempty in mixins</strong></code>
&gt;&gt;&gt; <code><strong>class D: __slots__ = ['a']</strong></code>           <code><em># Use empty slots or omit in all but one</em></code>
&gt;&gt;&gt; <code><strong>class E(C, D): pass</strong></code>
TypeError: multiple bases have instance lay-out conflict</pre>
<p>In other words, besides their program-breaking potential, slots essentially require both <em>universal</em> and <em>careful</em> deployment to be effective—because slots do not compute values dynamically like properties (coming up in the next section), they are largely pointless unless each class in a tree uses them and is cautious to define only new slot names not defined by other classes. It’s an <em>all-or-nothing</em> feature—an unfortunate property shared by the <code>super</code> call discussed ahead:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>class C: __slots__ = ['a']</strong></code>           <code><em># Assumes universal use, differing names</em></code>
&gt;&gt;&gt; <code><strong>class D(C): __slots__ = ['b']
</strong></code>&gt;&gt;&gt; <code><strong>I = D()   </strong>  </code>                         <code><em># And may break code and tools you use</em><strong>
</strong></code>&gt;&gt;&gt; <code><strong>I.a = 1; I.b = 2
</strong></code>&gt;&gt;&gt; <code><strong>I.__dict__</strong></code>
AttributeError: 'D' object has no attribute '__dict__'. Did you mean: '__dir__'?
&gt;&gt;&gt; <code><strong>C.__dict__.keys(), D.__dict__.keys()</strong></code>
(dict_keys([… '__slots__', 'a', …]), dict_keys([… '__slots__', 'b', …]))</pre>
<p>Such rules—and others omitted here for space—are part of the reason slots are not widely used and are not generally recommended except in pathological cases where their space reduction is significant. Even then, their potential to complicate or break code should be ample cause to carefully consider the trade-offs. Not only must they be spread almost <em>neurotically</em> throughout a framework, but they may also break tools you rely on.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Example impacts of slots: ListTree and mapattrs"><div class="sect3" id="example_impacts_of_slots_listtree_and_m">
<h3>Example impacts of slots: ListTree and mapattrs</h3>
<p>As a more realistic example of slots’ effects, due to the first bullet in the prior section, <a data-type="xref" href="ch31.html#designing_with_classes">Chapter 31</a>’s <code>ListTree</code> class (<a data-type="xref" href="ch31.html#example_threeone_onethreedot_listtreedo">Example 31-13</a>) does <em>not fail</em> when mixed into a class that defines <code>__slots__</code>, even <a contenteditable="false" data-type="indexterm" data-primary="slots" data-secondary="ListTree class" id="sltlstc"></a>though it scans instance namespace dictionaries without verifying their presence. This lister class’s own lack of slots is enough to ensure that the instance will still have a <code>__dict__</code> and hence not trigger an exception when fetched or indexed.</p>
<p>For example, both of the following <em>single</em>-inheritance trees display without error—the second <a contenteditable="false" data-type="indexterm" data-primary="slots" data-secondary="single-inheritance trees" id="id4242"></a><a contenteditable="false" data-type="indexterm" data-primary="inheritance" data-secondary="single-inheritance, slots" id="id4243"></a>also allows names not in the slots list to be assigned as instances attributes, including any required by the superclass:</p>
<pre data-type="programlisting">class C(ListTree): pass
I = C()                                        <code><em># OK: no __slots__ used</em></code>
print(I)

class C(ListTree): __slots__ = ['a', 'b']      <code><em># OK: superclass produces __dict__
</em></code>I = C()
I.c = 3
print(I)                                       <code><em># Displays c at I, a and b at C</em></code></pre>
<p>The following <em>multiple</em>-inheritance <a contenteditable="false" data-type="indexterm" data-primary="inheritance" data-secondary="multiple" data-tertiary="slots" id="id4244"></a><a contenteditable="false" data-type="indexterm" data-primary="slots" data-secondary="multiple inheritance classes" id="id4245"></a>classes display correctly as well—<em>any</em> nonslot class like <code>ListTree</code> generates an instance <code>__dict__</code> and can thus safely assume its presence. Although it renders subclass slots pointless, this is a positive side effect for tool classes like <code>ListTree</code> and its <a data-type="xref" href="ch28.html#a_more_realistic_example">Chapter 28</a> predecessor:</p>
<pre data-type="programlisting">class A: __slots__ = ['a']                     <code><em># Both OK by bullet 1 above</em></code>
class B(A, ListTree): pass
print(B())

class A: __slots__ = ['a']
class B(A, ListTree): __slots__ = ['b']        <code><em># Displays b at B, a at A</em></code>
print(B())</pre>
<p>In general, though, tools may need to catch exceptions when <code>__dict__</code> is absent or use a <code>hasattr</code> or <code>getattr</code> to test or provide defaults if slot usage may preclude an instance namespace dictionary. For instance, <a data-type="xref" href="ch31.html#designing_with_classes">Chapter 31</a>’s <em>mapattrs.py</em> module (<a data-type="xref" href="ch31.html#example_threeone_onefourdot_mapattrsdot">Example 31-14</a>) must check for <code>__dict__</code> presence explicitly because it is not a class mixed into others, and so cannot assume this attribute. Like <code>ListTree</code>, this example also associates slots with their classes.</p>
<p>Run these examples on your own for more info. Slots’ impacts may <a contenteditable="false" data-type="indexterm" data-primary="slots" data-secondary="ListTree class" data-startref="sltlstc" id="id4246"></a>be onerous, but knowledge is your best defense.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="What about slots speed?"><div class="sect3" id="what_about_slots_speedquestion_mark">
<h3>What about slots speed?</h3>
<p>Finally, while slots primarily optimize <a contenteditable="false" data-type="indexterm" data-primary="slots" data-secondary="speed" id="id4247"></a>memory use, their speed impact is less clear-cut. <a data-type="xref" href="#example_threetwo_fourdot_slots_testdotp">Example 32-4</a> codes a simple test script using the <code>timeit</code> techniques we studied in <a data-type="xref" href="ch21.html#the_benchmarking_interlude">Chapter 21</a>. For both the slots and nonslots (instance dictionary) storage models, it makes 1,000 instances, assigns and fetches 4 attributes on each, and repeats 1,000 times—for both models taking the best of 5 runs that each exercise a total of 8M attribute operations.</p>
<div data-type="example" id="example_threetwo_fourdot_slots_testdotp">
<h5><span class="label">Example 32-4. </span>slots-test.py</h5>
<pre data-type="programlisting">import timeit
base = """
Is = []
for i in range(1000):
    I = C()
    I.a = 1; I.b = 2; I.c = 3; I.d = 4
    t = I.a + I.b + I.c + I.d
    Is.append(I)
"""

stmt = """
class C:
    __slots__ = ['a', 'b', 'c', 'd']
""" + base
print('Slots   =&gt;', end=' ')
print(min(timeit.repeat(stmt, number=1000, repeat=5)))

stmt = """
class C:
    pass
""" + base
print('Nonslots=&gt;', end=' ')
print(min(timeit.repeat(stmt, number=1000, repeat=5)))</pre>
</div>
<p class="pagebreak-before">At least for this code, on the macOS test host, and using CPython 3.12, the best times imply that slots are only slightly quicker, though this says little about memory space and is prone to change arbitrarily in the future (PyPy 7.3 struggled on this test with times 10x slower than CPython, presumably due to dynamic class creation, but relatively similar):</p>
<pre data-type="programlisting">$ <code><strong>python3 slots-test.py</strong></code>
Slots   =&gt; 0.17895982996560633
Nonslots=&gt; 0.18887511501088738</pre>
<p>For more on slots in general, see the Python standard manual set. Also, watch for the <code>Private</code> decorator case study of <a data-type="xref" href="ch39.html#decorators">Chapter 39</a>—an example that naturally allows for attributes based on both <code>__slots__</code> and <code>__dict__</code> storage, by using delegation and storage-neutral accessor tools like <code>getattr</code>.</p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Properties: Attribute Accessors"><div class="sect2" id="properties_attribute_accessors">
<h2>Properties: Attribute Accessors</h2>
<p>Our next attribute-related topic <a contenteditable="false" data-type="indexterm" data-primary="properties" id="id4248"></a><a contenteditable="false" data-type="indexterm" data-primary="attributes" data-secondary="properties" id="id4249"></a>is <em>properties</em>—a mechanism that provides another way for classes to define methods called automatically for access or assignment to instance attributes. This feature is similar to “getters” and “setters” in languages like Java and C#, but in Python is generally best used sparingly as a way to add accessors to attributes <em>after the fact</em> as needs evolve and warrant. Where needed, though, properties allow attribute values to be computed dynamically without requiring method calls at the point of access.</p>
<p>Though properties cannot support generic attribute routing goals, at least for specific attributes, they are an alternative to some traditional uses of the <code>__getattr__</code> and <code>__setattr__</code> overloading methods we first studied in <a data-type="xref" href="ch30.html#operator_overloading-id000103">Chapter 30</a>. Properties can have a similar effect to these two methods but, by contrast, incur an extra method call only for accesses to names that require dynamic computation—other nonproperty names are accessed normally with no extra calls. Although <code>__getattr__</code> is invoked only for <em>undefined</em> names, the <code>__setattr__</code> method is instead called for assignment to <em>every</em> attribute.</p>
<p>Properties and slots are related, too, but serve different goals. Both implement instance attributes that are not physically stored in instance namespace dictionaries—a sort of “virtual” attribute—and both are based on the notion of class-level attribute <em>descriptors</em>. In contrast, slots manage instance storage, while properties intercept access and compute values arbitrarily. Because their underlying descriptor implementation tool is too advanced for us to cover here, properties and descriptors both get full treatment in <a data-type="xref" href="ch38.html#managed_attributes">Chapter 38</a>.</p>
<section data-type="sect3" data-pdf-bookmark="Property basics"><div class="sect3" id="property_basics">
<h3>Property basics</h3>
<p>As a brief introduction, though, a property is a type of object assigned to a class attribute name. You can generate a <a contenteditable="false" data-type="indexterm" data-primary="properties" data-secondary="objects, class statement" id="id4250"></a><a contenteditable="false" data-type="indexterm" data-primary="objects" data-secondary="properties, class statement" id="id4251"></a>property by calling the <code>property</code> built-in function, passing in up to three accessor methods—handlers for get, set, and delete operations—as well as an optional docstring for the property. If any argument is passed as <code>None</code> or omitted, that operation is not supported.</p>
<p>The resulting property object is typically assigned to a name at the top level of a <code>class</code> statement as a class attribute (e.g., <code><em>name</em>=property(…)</code>), and a special <code>@</code> decorator syntax you’ll meet later is available to automate this step. When thus assigned, later accesses to the class property name itself as an object attribute (e.g., <code>obj.<em>name</em></code>) are automatically routed to one of the accessor methods passed into the <span class="keep-together"><code>property</code></span> call.</p>
<p>For example, we’ve seen how the <code>__getattr__</code> operator-overloading method allows classes to intercept <em>undefined</em> attribute references:</p>
<pre class="pagebreak-before" data-type="programlisting">&gt;&gt;&gt; <code><strong>class WithOperators:
        def __getattr__(self, name):</strong>   <em># On undefined attr</em><strong>
            if name == 'age':
                return 40
            else:
                raise AttributeError(name)

</strong></code>&gt;&gt;&gt; <code><strong>x = WithOperators()
</strong></code>&gt;&gt;&gt; <code><strong>x.age</strong></code>                         <code><em># Runs __getattr__</em></code>
40
&gt;&gt;&gt; <code><strong>x.name</strong></code>                        <code><em># Runs __getattr__</em></code>
AttributeError: name</pre>
<p>Here is the same example, coded with <em>properties</em> instead:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>class WithProperties:</strong></code>
        <code><strong>def getage(self):
            return 40
        age = property(getage)</strong></code>    <code><em># (get?, set?, del?, docs?), or @</em></code>

&gt;&gt;&gt; <code><strong>x = WithProperties()
</strong></code>&gt;&gt;&gt; <code><strong>x.age</strong></code>                         <code><em># Runs getage</em></code>
40
&gt;&gt;&gt; <code><strong>x.name</strong></code>                        <code><em># Normal fetch</em></code>
AttributeError: 'WithProperties' object has no attribute 'name'</pre>
<p>For some coding tasks, properties can be <a contenteditable="false" data-type="indexterm" data-primary="properties" data-secondary="attributes" id="id4252"></a><a contenteditable="false" data-type="indexterm" data-primary="attributes" data-secondary="properties" data-tertiary="assignment support" id="id4253"></a>less complex and quicker to run than the traditional techniques. For example, when we add attribute <em>assignment</em> support, properties become more attractive—there’s less code to type, and no extra method calls are incurred for assignments to attributes we don’t wish to manage or compute dynamically:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>class WithProperties:</strong></code>    
        <code><strong>def getage(self):</strong></code>
<code> <strong>           print('get age')</strong></code>            <code><strong>
            return 40
        def setage(self, value):
            print('set age:', value)
            self._age = value
        age = property(getage, setage)
</strong></code>
&gt;&gt;&gt; <code><strong>x = WithProperties()
</strong></code>&gt;&gt;&gt; <code><strong>x.age</strong></code>                         <code><em># Runs getage</em></code>
get age
40
&gt;&gt;&gt; <code><strong>x.age = 42</strong></code>                    <code><em># Runs setage</em></code>
set age: 42
&gt;&gt;&gt; <code><strong>x._age</strong></code>                        <code><em># Normal fetch:  no getage call</em></code>
42
&gt;&gt;&gt; <code><strong>x.job = 'hacker'</strong></code>              <code><em># Normal assign: no setage call</em></code>
&gt;&gt;&gt; <code><strong>x.job</strong></code>                         <code><em># Normal fetch:  no getage call</em></code>
'hacker'</pre>
<p>The equivalent class based on operator overloading incurs extra method calls for assignments to attributes not being managed and needs to route attribute assignments through the attribute dictionary to avoid loops (or to the <code>object</code> superclass’s <code>__setattr__</code> to better support “virtual” attributes such as slots and properties coded in other classes):</p>
<pre class="pagebreak-before" data-type="programlisting">&gt;&gt;&gt; <code><strong>class WithOperators:
        def __getattr__(self, name):</strong></code>            <code><em># On undefined attr
</em></code>            <code><strong>if name == 'age':</strong></code>
                <code><strong>print('get age')
                return 40
            else:
                raise AttributeError(name)
        def __setattr__(self, name, value):</strong></code>     <code><em># On all assignments</em></code>
            <code><strong>print('set:', name, value)
            if name == 'age':
                self.__dict__['_age'] = value</strong>   <em># Or object.__setattr__(self, ...)</em></code>
            <code><strong>else:
                self.__dict__[name] = value

</strong></code>&gt;&gt;&gt; <code><strong>x = WithOperators()
</strong></code>&gt;&gt;&gt; <code><strong>x.age</strong></code>                         <code><em># Runs __getattr__</em></code>
get age<code><em>
</em></code>40
&gt;&gt;&gt; <code><strong>x.age = 41</strong></code>                    <code><em># Runs __setattr__
</em></code>set: age 41
&gt;&gt;&gt; <code><strong>x._age</strong></code>                        <code><em># Defined: no __getattr__ call
</em></code>41
&gt;&gt;&gt; <code><strong>x.job = 'coder'</strong></code>               <code><em># Runs __setattr__ again
</em></code>set: job coder
&gt;&gt;&gt; <code><strong>x.job</strong></code>                         <code><em># Defined: no __getattr__ call</em></code>
'coder'</pre>
<p>Properties seem like a win for this simple example. However, some applications of <code>__getattr__</code> and <code>__setattr__</code> still require more dynamic or generic interfaces than properties directly provide.</p>
<p>For example, the set of attributes to be managed might be unknown when a class is coded and may not even exist in a tangible form (e.g., when <em>delegating</em> arbitrary attribute references to a wrapped and embedded object generically). In such contexts, a generic attribute handler like <code>__getattr__</code> with a passed-in attribute name may be preferable. Because such generic handlers can also support simpler cases, properties may be a redundant extension—albeit one that may avoid extra calls on assignments and one that some programmers may prefer when applicable.</p>
<p>For more details on both options, tune in to <a data-type="xref" href="ch38.html#managed_attributes">Chapter 38</a>. As you’ll see there, it’s also possible to code properties <a contenteditable="false" data-type="indexterm" data-primary="function decorators" data-secondary="syntax" id="id4254"></a><a contenteditable="false" data-type="indexterm" data-primary="syntax" data-secondary="function decorator" id="id4255"></a>using the <code>@</code> symbol <em>function decorator</em> syntax—a topic introduced in brief later in this chapter and an equivalent and automatic alternative to manual assignment in the class scope:</p>
<pre data-type="programlisting">class WithProperties:
    @property                     <code><em># Coding properties with decorators: ahead
</em></code>    def age(self):                <code><em># On instance.age</em></code>
        …
    @age.setter
    def age(self, value):         <code><em># On instance.age = value</em></code>
        …</pre>
<p>To make sense of this decorator syntax, though, we must move ahead.</p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="__getattribute__ and Descriptors: Attribute Implementations"><div class="sect2" id="getattribute_and_descriptors_attrib">
<h2>__getattribute__ and Descriptors: Attribute Implementations</h2>
<p>To complete our attribute-tools collection, the <code>__getattribute__</code> operator-overloading method <a contenteditable="false" data-type="indexterm" data-primary="attributes" data-secondary="__getattribute__ method" data-secondary-sortas="getattribute method" id="id4256"></a><a contenteditable="false" data-type="indexterm" data-primary="__getattribute__ method" data-primary-sortas="getattribute method" id="id4257"></a>intercepts <em>all</em> attribute references, not just undefined references. This makes it more potent than its <span class="keep-together"><code>__getattr__</code></span> cousin we used in the prior section, but also trickier to use—it’s prone to loops much like <code>__setattr__</code>, but in different ways.</p>
<p>For more specialized attribute interception <a contenteditable="false" data-type="indexterm" data-primary="attribute interception" data-secondary="descriptors" id="id4258"></a>goals, in addition to properties and operator-overloading methods, Python provides attribute <em>descriptors</em>—classes with <code>__get__</code> and <code>__set__</code> methods, assigned to class attributes and inherited by instances, that intercept read and write accesses to specific attributes. As a preview, here’s one of the<code><strong></strong> </code>simplest descriptors you’re likely to encounter:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>class AgeDesc:
        def __get__(self, instance, owner): return 40
        def __set__(self, instance, value): instance._age = value

</strong></code>&gt;&gt;&gt; <code><strong>class WithDescriptors:
        age = AgeDesc()</strong> </code>          <code><em># Assign descriptor instance</em><strong>

</strong></code>&gt;&gt;&gt; <code><strong>x = WithDescriptors()
</strong></code>&gt;&gt;&gt; <code><strong>x.age</strong></code>                         <code><em># Runs AgeDesc.__get__</em></code>
40
&gt;&gt;&gt; <code><strong>x.age = 42</strong></code>                    <code><em># Runs AgeDesc.__set__</em></code>
&gt;&gt;&gt; <code><strong>x._age</strong></code>                        <code><em># Normal fetch: no AgeDesc call</em></code>
42</pre>
<p>Descriptors have access to state-information <a contenteditable="false" data-type="indexterm" data-primary="attributes" data-secondary="descriptors" id="id4259"></a><a contenteditable="false" data-type="indexterm" data-primary="descriptors" id="id4260"></a>attributes in instances of themselves as well as their client class and are, in a sense, a more general form of properties. In fact, <em>properties</em> are a simplified way to define a specific type of descriptor—one that runs functions on access. Descriptors are also used to implement the <em>slots</em> feature we met earlier, among other Python tools, and are afforded special cases in attribute <em>inheritance</em> alluded to earlier in this chapter.</p>
<p>Because <code>__getattribute__</code> and descriptors are too substantial to present here, we’ll defer the rest of their coverage, as well as much more on properties, to <a data-type="xref" href="ch38.html#managed_attributes">Chapter 38</a>. We’ll also employ them in examples in <a data-type="xref" href="ch39.html#decorators">Chapter 39</a> and study how they factor into inheritance in <a data-type="xref" href="ch40.html#metaclasses_and_inheritance">Chapter 40</a>. Here, the topics tour is moving on.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Static and Class Methods"><div class="sect1" id="static_and_class_methods">
<h1>Static and Class Methods</h1>
<p>Beyond the usual methods we’ve been using so far, classes can define two kinds of methods called without an <a contenteditable="false" data-type="indexterm" data-primary="static methods" id="id4261"></a><a contenteditable="false" data-type="indexterm" data-primary="methods" data-secondary="static" id="mthstt"></a><a contenteditable="false" data-type="indexterm" data-primary="methods" data-secondary="classes" id="id4262"></a><a contenteditable="false" data-type="indexterm" data-primary="classes" data-secondary="methods" id="id4263"></a><a contenteditable="false" data-type="indexterm" data-primary="special methods" data-seealso="static methods" id="id4264"></a>instance: <em>static</em> methods work roughly like simple instance-less functions inside a class no matter how they’re called, and <em>class</em> methods are passed a class instead of an instance. Both are similar to tools in other languages (e.g., C++ static methods). The prior chapter’s bound method coverage noted these briefly, but we’ll finish the story here.</p>
<p>To enable these special method modes, you call built-in functions named <code>staticmethod</code> and <code>classmethod</code> within the class or invoke them with the special <code>@<em>name</em></code> decoration syntax you’ll meet later in this chapter. The <code>classmethod</code> call is required to enable its mode; <code>staticmethod</code> is not required for instance-less methods called only through a class name but is required if such methods are called through instances.</p>
<section data-type="sect2" data-pdf-bookmark="Why the Special Methods?"><div class="sect2" id="why_the_special_methodsquestion_mark">
<h2>Why the Special Methods?</h2>
<p>As we’ve seen, a class’s method is normally passed an instance object in its first argument to serve as the implied subject of the method call—that’s the “object” in “object-oriented programming.” Though much less common, there are two formal ways to temper this model. Before we get to the syntax, let’s clarify why this might matter to you.</p>
<p>Sometimes, programs need to process data associated with <em>classes</em> instead of instances. Consider keeping track of the number of instances created from a class or maintaining a list of all of a class’s instances that are currently in use. This type of information and its processing are associated with the class rather than its instances. That is, the information is usually stored on the class itself and processed apart from any instance.</p>
<p>For such tasks, simple functions coded outside a class might suffice—because they can access class attributes through the class name, they have access to class data, and never require access to an instance. However, to better associate such code with a class and to allow such processing to be customized with inheritance as usual, it would be better to code these types of functions <em>inside</em> the class itself. To make this work, we need methods in a class that are not passed, and do not expect, a <code>self</code> instance argument.</p>
<p>Per the prior chapter, methods accessed <a contenteditable="false" data-type="indexterm" data-primary="plain functions" id="id4265"></a><a contenteditable="false" data-type="indexterm" data-primary="functions" data-secondary="plain functions" id="id4266"></a><a contenteditable="false" data-type="indexterm" data-primary="bound methods" id="id4267"></a><a contenteditable="false" data-type="indexterm" data-primary="methods" data-secondary="bound methods" id="id4268"></a><a contenteditable="false" data-type="indexterm" data-primary="static methods" id="id4269"></a>through the class are <em>plain functions</em> that meet some of this need but fail if accessed through an instance: the resulting <em>bound method</em> passes an instance in calls, even if the plain function doesn’t expect one. To address, Python provides <em>static methods</em>—plain functions that are nested in a class and never expect nor receive an automatic <code>self</code> argument, regardless of how they are called. They’re optional for methods only ever accessed through classes but needed for access through instances.</p>
<p>Although less commonly used, Python <a contenteditable="false" data-type="indexterm" data-primary="methods" data-secondary="class methods" id="id4270"></a><a contenteditable="false" data-type="indexterm" data-primary="instance methods" id="id4271"></a><a contenteditable="false" data-type="indexterm" data-primary="methods" data-secondary="instance" id="id4272"></a>also supports <em>class methods</em>—methods of a class that are passed a class object in their first argument instead of an instance, regardless of whether they are called through an instance or a class. Such methods can access class data through their class argument—what we’ve called <code>self</code> thus far—even if called through an instance. Normal methods, sometimes called <em>instance methods</em>, still receive a subject instance when called; static and class methods do not.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Plain-Function Methods"><div class="sect2" id="plain_function_methods">
<h2>Plain-Function Methods</h2>
<p>To demo the preceding ideas, let’s suppose <a contenteditable="false" data-type="indexterm" data-primary="methods" data-secondary="plain-function" id="mthplf"></a><a contenteditable="false" data-type="indexterm" data-primary="plain-function methods" id="plfcmthd"></a>that we want to use class attributes to count how many instances are generated from a class. <a data-type="xref" href="#example_threetwo_fivedot_hackonedotpy">Example 32-5</a>, <em>hack1.py</em>, makes a first attempt—its class has a counter stored as a class attribute, a constructor that bumps up the counter by one each time a new instance is created, and a method that displays the counter’s value. Remember, class attributes are stored just once on a class and shared by all instances; storing the counter this way ensures that it effectively spans all instances.</p>
<div data-type="example" id="example_threetwo_fivedot_hackonedotpy">
<h5><span class="label">Example 32-5. </span>hack1.py</h5>
<pre data-type="programlisting">class Hack:
    numInstances = 0
    def __init__(self):
        Hack.numInstances += 1
    def printNumInstances():
        print('Number of instances created:', Hack.numInstances)</pre>
</div>
<p>The <code>printNumInstances</code> method is designed to process class data, not instance data—it’s about <em>all</em> the instances, not any one in particular. Because of that, we want to be able to call it without having to pass an instance. Indeed, we don’t want to <em>make</em> an instance to fetch the number of instances because this would <em>change</em> the number of instances we’re trying to fetch! In other words, we want a <code>self</code>-less “static” method.</p>
<p>Whether this code’s <code>printNumInstances</code> works or not, though, depends on which way you call the method—through the class or through an instance. Calls to <code>self</code>-less methods made through classes work because they produce plain functions, but calls from instances produce bound methods and fail:</p>
<pre class="pagebreak-before" data-type="programlisting">$ <code><strong>python3
</strong></code>&gt;&gt;&gt; <code><strong>from hack1 import Hack
</strong></code>&gt;&gt;&gt; <code><strong>a, b, c = Hack(), Hack(), Hack()</strong></code>     <code><em># Make three instances</em><strong>

</strong></code>&gt;&gt;&gt; <code><strong>Hack.printNumInstances()</strong></code>             <code><em># Okay to call from instance – only!</em></code>
Number of instances created: 3
&gt;&gt;&gt; <code><strong>a.printNumInstances()</strong></code>
TypeError: Hack.printNumInstances() takes 0 positional arguments but 1 was given</pre>
<p>Calls to instance-less methods like <code>printNumInstances</code> made through the <em>class</em> work, but calls made through an <em>instance</em> fail because an instance is automatically passed to a method that does not have an argument to receive it. If you’re able to stick with calling <code>self</code>-less methods through classes only, you already have a static method. However, to allow <code>self</code>-less methods to be called through instances, you need to either adopt <a contenteditable="false" data-type="indexterm" data-primary="methods" data-secondary="plain-function" data-startref="mthplf" id="id4273"></a><a contenteditable="false" data-type="indexterm" data-primary="plain-function methods" data-startref="plfcmthd" id="id4274"></a>other designs or mark such methods as special. Let’s look at both options in turn.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Static Method Alternatives"><div class="sect2" id="static_method_alternatives">
<h2>Static Method Alternatives</h2>
<p>Short of marking a <code>self</code>-less <a contenteditable="false" data-type="indexterm" data-primary="static methods" data-secondary="alternatives" id="id4275"></a>method as special, you can sometimes achieve similar results with different coding structures. For example, if you just want to call functions that access class members without an instance, perhaps the simplest idea is to use normal functions outside the class, not class methods. This way, an instance isn’t expected in the call. The mutation in <a data-type="xref" href="#example_threetwo_sixdot_hacktwodotpy">Example 32-6</a> illustrates.</p>
<div data-type="example" id="example_threetwo_sixdot_hacktwodotpy">
<h5><span class="label">Example 32-6. </span>hack2.py</h5>
<pre data-type="programlisting">def printNumInstances():
    print('Number of instances created:', Hack.numInstances)

class Hack:
    numInstances = 0
    def __init__(self):
        Hack.numInstances += 1</pre>
</div>
<p>Because the class name is accessible to the simple function as a global variable, this works fine. Also, note that the name of the function becomes global, but only to this single module; it will not clash with names in other files:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>import hack2 as hack
</strong></code>&gt;&gt;&gt; <code><strong>a = hack.Hack()
</strong></code>&gt;&gt;&gt; <code><strong>b = hack.Hack()
</strong></code>&gt;&gt;&gt; <code><strong>c = hack.Hack()
</strong></code>&gt;&gt;&gt; <code><strong>hack.printNumInstances()</strong></code>           <code><em># But function may be too far removed</em></code>
Number of instances created: 3         <code><em># And cannot be changed via inheritance</em></code>
&gt;&gt;&gt; <code><strong>hack.Hack.numInstances</strong></code>
3</pre>
<p>Prior to static methods in Python, this structure was the general prescription. Because Python already provides modules as a namespace-partitioning tool, one could argue that there’s not typically any need to package functions in classes unless they implement object behavior. Simple functions within modules like the one here do much of what instance-less class methods could and are already associated with the class because they live in the same module.</p>
<p>This approach, though, may be subpar. For one thing, it adds to this file’s scope an extra name that is used only for processing a single class. For another, the function is not directly associated with the class by structure; in fact, its <code>def</code> could be hundreds of lines away. Worse, simple functions like this cannot be customized by inheritance since they live outside a class’s namespace: subclasses cannot directly replace or extend such a function by redefining it.</p>
<p>We might also try to make this example work by simply using a normal method and always calling it through an instance, as usual. Unfortunately, such an approach is completely unworkable if we don’t have an instance available, and making an instance changes the class <a contenteditable="false" data-type="indexterm" data-primary="static methods" data-secondary="alternatives" data-startref="sttmtnv" id="id4276"></a>data, as noted earlier. A better solution would be to somehow mark a method inside a class as never requiring an instance. The next section shows how.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Using Static and Class Methods"><div class="sect2" id="using_static_and_class_methods">
<h2>Using Static and Class Methods</h2>
<p>To designate a <code>self</code>-less method that may be called through <em>either</em> the class or its instances, classes <a contenteditable="false" data-type="indexterm" data-primary="staticmethod function" id="id4277"></a><a contenteditable="false" data-type="indexterm" data-primary="classmethod function" id="id4278"></a><a contenteditable="false" data-type="indexterm" data-primary="functions" data-secondary="classmethod" id="id4279"></a><a contenteditable="false" data-type="indexterm" data-primary="functions" data-secondary="staticmethod" id="id4280"></a>can simply call the built-in functions <code>staticmethod</code> and <code>classmethod</code>. Both mark a function object as special—requiring no instance for the former and requiring a class argument for the latter. <a data-type="xref" href="#example_threetwo_sevendot_allmethodsdot">Example 32-7</a> shows how.</p>
<div data-type="example" id="example_threetwo_sevendot_allmethodsdot">
<h5><span class="label">Example 32-7. </span>allmethods.py</h5>
<pre data-type="programlisting">class Methods:
    def imeth(self, x):            <code><em># Instance method: passed a self</em></code>
        print([self, x])           <code><em># Always expects a self instance</em></code>

    def smeth(x):                  <code><em># Static method: no instance passed</em></code>
        print([x])                 <code><em># Also a plain function from the class</em></code>

    def cmeth(cls, x):             <code><em># Class method: gets class, not instance</em></code>
        print([cls, x])            <code><em># Always expects a class, not instance</em></code>

    smeth = staticmethod(smeth)    <code><em># Make smeth a static method (or use @: ahead)</em></code>
    cmeth = classmethod(cmeth)     <code><em># Make cmeth a class method (or use @: ahead)</em></code></pre>
</div>
<p>Notice how the last two assignments in this code simply <em>reassign</em> (a.k.a. rebind) the method names <code>smeth</code> and <code>cmeth</code>. Attributes are created and changed by any assignment in a <code>class</code> statement, so these final assignments simply overwrite the assignments made earlier by the <code>def</code>s. As you’ll see in a few moments, the special <code>@</code> decorator syntax works here as an alternative to this just as it does for properties—but makes little sense unless you first understand the assignment form here that it automates.</p>
<p>Technically, Python supports three kinds of class-related methods with differing argument protocols:</p>
<ul>
<li><p><em>Instance methods</em>, passed <a contenteditable="false" data-type="indexterm" data-primary="instance methods" id="id4281"></a><a contenteditable="false" data-type="indexterm" data-primary="methods" data-secondary="instance methods" id="id4282"></a>a <code>self</code> instance object (the default)</p></li>
<li><p><em>Static methods</em>, passed <a contenteditable="false" data-type="indexterm" data-primary="static methods" id="id4283"></a><a contenteditable="false" data-type="indexterm" data-primary="methods" data-secondary="static" data-startref="mthstt" id="id4284"></a>no extra instance object (via <code>staticmethod</code>)</p></li>
<li><p><em>Class methods</em>, passed a class <a contenteditable="false" data-type="indexterm" data-primary="methods" data-secondary="class methods" id="id4285"></a>object (via <code>classmethod</code>, and inherent in metaclasses)</p></li>
</ul>
<p>Moreover, simple functions in a class also serve the role of static methods without requiring any extra protocol when called through a class object only. The <em>allmethods.py</em> module illustrates all three method types, so let’s expand on these in turn.</p>
<p><em>Instance methods</em> are the normal and default case that we’ve used in this book so far. An instance method must always be called with an instance object. When you call it through an <em>instance</em>, Python passes the instance to the first (leftmost) argument automatically; when you call it through a <em>class</em>, you must pass along the instance manually:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>from allmethods import Methods</strong></code>     <code><em># Normal instance methods</em></code>
&gt;&gt;&gt; <code><strong>obj = Methods()</strong></code>                    <code><em># Callable through instance or class</em></code>
&gt;&gt;&gt; <code><strong>obj.imeth(1)</strong>   </code>                    <code><em># Becomes imeth(obj, 1)</em></code>
[&lt;allmethods.Methods object at 0x1015a79b0&gt;, 1] 
&gt;&gt;&gt; <code><strong>Methods.imeth(obj, 2)</strong></code>
[&lt;allmethods.Methods object at 0x1015a79b0&gt;, 2]</pre>
<p><em>Static methods</em>, by contrast, are called without an instance argument. Unlike simple functions outside a class, their names are local to the scopes of the classes in which they are defined, and they may be looked up by inheritance. Instance-less functions can be called through a class normally, but using the <code>staticmethod</code> built-in allows such methods to also be called through an instance. That is, the first of the following works without the <code>staticmethod</code> in the class but the second does not:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>Methods.smeth(3)</strong></code>                   <code><em># Static method: call through class</em></code>
[3]                                    <code><em># No instance passed or expected</em></code>
&gt;&gt;&gt; <code><strong>obj.smeth(4)</strong></code>                       <code><em># Static method: call through instance</em></code>
[4]                                    <code><em># Instance not passed – requires staticmethod</em></code></pre>
<p><em>Class methods</em> are similar, but <a contenteditable="false" data-type="indexterm" data-primary="classes" data-secondary="methods" id="id4286"></a><a contenteditable="false" data-type="indexterm" data-primary="methods" data-secondary="class methods" id="id4287"></a>Python automatically passes the class (not an instance) to a class method’s first (leftmost) argument, whether it is called through a class or an instance:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>Methods.cmeth(5)</strong></code>                   <code><em># Class method: call through class
</em></code>[&lt;class 'allmethods.Methods'&gt;, 5]      <code><em># Becomes cmeth(Methods, 5)</em></code>
&gt;&gt;&gt; <code><strong>obj.cmeth(6)</strong></code>                       <code><em># Class method: call through instance</em></code>
[&lt;class 'allmethods.Methods'&gt;, 6]      <code><em># Becomes cmeth(Methods, 6)</em></code></pre>
<p>In <a data-type="xref" href="ch40.html#metaclasses_and_inheritance">Chapter 40</a>, you’ll also find that <em>metaclass methods</em>—an advanced and technically distinct method type used in the secondary class trees of types—behave similarly to the explicitly declared class methods we’re exploring here.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Counting Instances with Static Methods"><div class="sect2" id="counting_instances_with_static_methods">
<h2>Counting Instances with Static Methods</h2>
<p>Now, given these built-ins, <a data-type="xref" href="#example_threetwo_eightdot_hack_staticdo">Example 32-8</a> codes the static method equivalent of this section’s <a contenteditable="false" data-type="indexterm" data-primary="instances" data-secondary="counting" id="istcntg"></a><a contenteditable="false" data-type="indexterm" data-primary="static methods" data-secondary="instance counting" id="stcmstcc"></a>instance-counting example—it marks the method as special, so it will never be passed an instance automatically.</p>
<div data-type="example" id="example_threetwo_eightdot_hack_staticdo">
<h5><span class="label">Example 32-8. </span>hack_static.py</h5>
<pre data-type="programlisting">class Hack:
    numInstances = 0                         <code><em># Use static method for class data</em></code>
    def __init__(self):
        Hack.numInstances += 1
    def printNumInstances():
        print('Number of instances:', Hack.numInstances)
    printNumInstances = staticmethod(printNumInstances)</pre>
</div>
<p>Using the static method built-in, our code now allows the <code>self</code>-less method to be called through the class or any instance of it:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>from hack_static import Hack
</strong></code>&gt;&gt;&gt; <code><strong>a, b, c = Hack(), Hack(), Hack()
</strong></code>&gt;&gt;&gt; <code><strong>Hack.printNumInstances()</strong></code>                 <code><em># Call as simple function</em></code>
Number of instances: 3
&gt;&gt;&gt; <code><strong>a.printNumInstances()</strong></code>                    <code><em># Instance argument not passed</em></code>
Number of instances: 3</pre>
<p>Compared to simply moving <code>printNumInstances</code> outside the class, as prescribed earlier, this version requires an extra <code>staticmethod</code> call (or an <code>@</code> line you’ll meet ahead). However, it also localizes the function name in the class scope (so it won’t clash with other names in the module); moves the function code closer to where it is used (inside the <code>class</code> statement); and allows subclasses to <em>customize</em> the static method with inheritance—a more convenient and powerful approach than importing functions from the files in which superclasses are coded. The following subclass illustrates (this continues the prior session, so the count is already 3 at the start):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>class Sub(Hack):</strong></code>
        <code><strong>def printNumInstances():</strong></code>             <code><em># Override a static method</em></code>
            <code><strong>print('Extra stuff...')</strong></code>          <code><em># But call back to original</em></code>
            <code><strong>Hack.printNumInstances()</strong></code>
        <code><strong>printNumInstances = staticmethod(printNumInstances)</strong></code>
 
&gt;&gt;&gt; <code><strong>a, b = Sub(), Sub()</strong></code>
&gt;&gt;&gt; <code><strong>a.printNumInstances()</strong></code>                    <code><em># Call from subclass instance</em></code>
Extra stuff...
Number of instances: 5
&gt;&gt;&gt; <code><strong>Sub.printNumInstances()</strong></code>                  <code><em># Call from subclass itself</em></code>
Extra stuff...
Number of instances: 5
&gt;&gt;&gt; <code><strong>Hack.printNumInstances()</strong></code>                 <code><em># Call original version</em></code>
Number of instances: 5</pre>
<p>Moreover, classes can inherit the static method without redefining it—it is run without an instance, regardless of where it is defined in a class tree:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>class Other(Hack): pass</strong></code>                  <code><em># Inherit static method verbatim</em></code>

&gt;&gt;&gt; <code><strong>c = Other()
</strong></code>&gt;&gt;&gt; <code><strong>c.printNumInstances()</strong></code>
Number of instances: 6</pre>
<p>Notice how this also bumps up the <em>superclass</em>’s instance counter because its constructor is inherited <a contenteditable="false" data-type="indexterm" data-primary="instances" data-secondary="counting" data-startref="istcntg" id="id4288"></a><a contenteditable="false" data-type="indexterm" data-primary="static methods" data-secondary="instance counting" data-startref="stcmstcc" id="id4289"></a>and run—a behavior that begins to encroach on the next section’s subject.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Counting Instances with Class Methods"><div class="sect2" id="counting_instances_with_class_methods">
<h2>Counting Instances with Class Methods</h2>
<p>Interestingly, a <em>class method</em> can do similar work here—<a data-type="xref" href="#example_threetwo_ninedot_hack_classdotp">Example 32-9</a> has the <a contenteditable="false" data-type="indexterm" data-primary="instances" data-secondary="counting" data-tertiary="class methods" id="cngstclm"></a><a contenteditable="false" data-type="indexterm" data-primary="classes" data-secondary="methods" data-tertiary="instance counting" id="clmthscc"></a>same behavior as the static method version listed earlier, but it uses a class method that receives the instance’s class in its first argument. Rather than hardcoding the class name, the class method uses the automatically passed class object generically.</p>
<div data-type="example" id="example_threetwo_ninedot_hack_classdotp">
<h5><span class="label">Example 32-9. </span>hack_class.py</h5>
<pre data-type="programlisting">class Hack:
    numInstances = 0                         <code><em># Use class method instead of static</em></code>
    def __init__(self):
        Hack.numInstances += 1
    def printNumInstances(cls):
        print('Number of instances:', cls.numInstances)
    printNumInstances = classmethod(printNumInstances)</pre>
</div>
<p>This class is used in the same way as the prior versions, but its <code>printNumInstances</code> method receives the <code>Hack</code> class, not the instance, when called from either the class or an instance:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>from hack_class import Hack
</strong></code>&gt;&gt;&gt; <code><strong>a, b = Hack(), Hack()
</strong></code>&gt;&gt;&gt; <code><strong>a.printNumInstances()</strong></code>                    <code><em># Passes class to first argument</em></code>
Number of instances: 2
&gt;&gt;&gt; <code><strong>Hack.printNumInstances()</strong></code>                 <code><em># Also passes class to first argument</em></code>
Number of instances: 2</pre>
<p>When using class methods, though, keep in mind that they receive the most specific (i.e., <em>lowest</em>) class of the call’s subject. This has some subtle implications when trying to update class data through the passed-in class. To demo, <a data-type="xref" href="#example_threetwo_onezerodot_hack_classt">Example 32-10</a> subclasses to customize the same way we did for static methods in the prior section, and augments <code>Hack.printNumInstances</code> to also trace its <code>cls</code> argument.</p>
<div data-type="example" id="example_threetwo_onezerodot_hack_classt">
<h5><span class="label">Example 32-10. </span>hack_class2.py</h5>
<pre data-type="programlisting">class Hack:
    numInstances = 0                         <code><em># Trace class passed in</em></code>
    def __init__(self):
        Hack.numInstances += 1
    def printNumInstances(cls):
        print('Number of instances:', cls.numInstances, cls)
    printNumInstances = classmethod(printNumInstances)

class Sub(Hack):
    def printNumInstances(cls):              <code><em># Override a class method</em></code>
        print('Extra stuff...', cls)         <code><em># But call back to original</em></code>
        Hack.printNumInstances()
    printNumInstances = classmethod(printNumInstances)

class Other(Hack): pass                      <code><em># Inherit class method verbatim</em></code></pre>
</div>
<p>Running this in a REPL reveals that the lowest class is passed in whenever a class method is run—even for subclasses that have no class methods of their own:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>from hack_class2 import Hack, Sub, Other
</strong></code>&gt;&gt;&gt; <code><strong>x = Sub()
</strong></code>&gt;&gt;&gt; <code><strong>y = Hack()</strong></code>
<code><strong>
</strong></code>&gt;&gt;&gt; <code><strong>x.printNumInstances()</strong></code>                           <code><em># Call from subclass instance
</em></code>Extra stuff... &lt;class 'hack_class2.Sub'&gt;
Number of instances: 2 &lt;class 'hack_class2.Hack'&gt;

&gt;&gt;&gt; <code><strong>Sub.printNumInstances()</strong></code>                         <code><em># Call from subclass itself</em></code>
Extra stuff... &lt;class 'hack_class2.Sub'&gt;
Number of instances: 2 &lt;class 'hack_class2.Hack'&gt;

&gt;&gt;&gt; <code><strong>y.printNumInstances()</strong></code>                           <code><em># Call from superclass instance</em></code>
Number of instances: 2 &lt;class 'hack_class2.Hack'&gt;</pre>
<p>In the first call here, a class method call is made through an instance of the <code>Sub</code> subclass, and Python passes the lowest class, <code>Sub</code>, to the class method. All is well in this case—since <code>Sub</code>’s redefinition of the method calls the <code>Hack</code> superclass’s version explicitly, the superclass method in <code>Hack</code> receives its own class in its first argument. But watch what happens for an object that inherits the class method <span class="keep-together">verbatim:</span></p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>z = Other()</strong></code>                                     <code><em># Call from lower sub's instance</em></code>
&gt;&gt;&gt; <code><strong>z.printNumInstances()</strong></code>
Number of instances: 3 &lt;class 'hack_class2.Other'&gt;</pre>
<p>This last call here passes <code>Other</code> to <code>Hack</code>’s class method. This works in this example because <em>fetching</em> the counter finds it in <code>Hack</code> by class inheritance. If this method tried to <em>assign</em> to the passed class’s data, though, it would update <code>Other</code>, not <code>Hack</code>! In this specific case, <code>Hack</code> is probably better off hardcoding its own class name to update its data if it means to count instances of all its subclasses, too, rather than relying on the passed-in class argument.</p>
<section data-type="sect3" data-pdf-bookmark="Counting instances per class with class methods"><div class="sect3" id="counting_instances_per_class_with_class">
<h3>Counting instances per class with class methods</h3>
<p>In fact, because class methods always receive the <em>lowest</em> class in an instance’s tree:</p>
<ul>
<li><p><em>Static</em> methods and explicit class names may be a better solution for processing data local to a class.</p></li>
<li><p><em>Class</em> methods may be better suited to processing data that may differ for each class in a hierarchy.</p></li>
</ul>
<p>Code that needs to manage <em>per-class</em> instance counters, for example, might be best off leveraging class methods. To illustrate, the top-level superclass in <a data-type="xref" href="#example_threetwo_oneonedot_hack_classth">Example 32-11</a> uses a class method to manage state information that varies for and is stored on each class in the tree—similar in spirit to the way instance methods manage state information that varies per class instance.</p>
<div data-type="example" id="example_threetwo_oneonedot_hack_classth">
<h5><span class="label">Example 32-11. </span>hack_class3.py</h5>
<pre data-type="programlisting">class Hack:
    numInstances = 0
    def count(cls):                    <code><em># Per-class instance counters</em></code>
        cls.numInstances += 1          <code><em># cls is lowest class above instance</em></code>
    def __init__(self):
        self.count()                   <code><em># Passes self.__class__ to count
</em></code>    count = classmethod(count)

class Sub(Hack):
    numInstances = 0
    def __init__(self):                <code><em># Redefines __init__ (to demo)</em></code>
        Hack.__init__(self)

class Other(Hack):                     <code><em># Inherits __init__</em></code>
    numInstances = 0</pre>
</div>
<p>When run, the <code>Hack</code> class keeps track of each of its subclasses’ instances, using a counter on each <span class="keep-together">subclass:</span></p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>from hack_class3 import Hack, Sub, Other
</strong></code>&gt;&gt;&gt; <code><strong>x = Hack()
</strong></code>&gt;&gt;&gt; <code><strong>y1, y2 = Sub(), Sub()
</strong></code>&gt;&gt;&gt; <code><strong>z1, z2, z3 = Other(), Other(), Other()
</strong></code>&gt;&gt;&gt; <code><strong>x.numInstances, y1.numInstances, z1.numInstances</strong></code>             <code><em># Per-class data!
</em></code>(1, 2, 3)
&gt;&gt;&gt; <code><strong>Hack.numInstances, Sub.numInstances, Other.numInstances</strong></code>
(1, 2, 3)</pre>
<p>Static and class methods have additional advanced roles, which we will skip here; see other resources for more use cases. In later Python versions, though, the static and class method designations became even simpler with the advent of <em>function decoration</em> syntax—a way to apply one function to another that has roles well beyond the static method use case that was one of its initial motivations. This syntax also allows us to augment <em>classes</em>—to initialize data like the <code>numInstances</code> counter in the last example, for instance. The next section explains how.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><em>The methods finale</em>: For a postscript <a contenteditable="false" data-type="indexterm" data-primary="instances" data-secondary="counting" data-tertiary="class methods" data-startref="cngstclm" id="id4290"></a><a contenteditable="false" data-type="indexterm" data-primary="classes" data-secondary="methods" data-tertiary="instance counting" data-startref="clmthscc" id="id4291"></a>on Python’s method types, be sure to watch for coverage of metaclass methods in <a data-type="xref" href="ch40.html#metaclasses_and_inheritance">Chapter 40</a>—because these are designed to process a <em>class</em> that is an instance of a metaclass, they turn out to be very similar to the class methods defined here but require no <code>classmethod</code> declaration, and apply only to the shadowy metaclass realm previewed next.</p>
</div>
</div></section>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Decorators and Metaclasses"><div class="sect1" id="decorators_and_metaclasses">
<h1>Decorators and Metaclasses</h1>
<p>Because the <code>staticmethod</code> and <code>classmethod</code> call technique described in the prior section initially seemed obscure to some observers, a device was eventually added to make the operation simpler. Python <em>decorators</em>—similar to the notion and syntax of annotations in Java—both address this specific need and provide a general tool for adding logic that manages functions and classes or later calls to them.</p>
<p>This is called a “decoration,” but in more concrete terms is really just a way to run extra processing steps at function and class definition time with explicit syntax. It comes in two flavors:</p>
<ul>
<li><p><em>Function decorators</em>: The initial entry, augment function definitions at <code>def</code> statements. They <a contenteditable="false" data-type="indexterm" data-primary="function decorators" id="fcdcrt"></a>specify operation modes for both simple functions and classes’ methods by wrapping them in an extra layer of logic implemented as another function. That function is often called a <em>metafunction</em>, though this is just terminology.</p></li>
<li><p><em>Class decorators</em>: A later <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="class decorators" id="id4292"></a><a contenteditable="false" data-type="indexterm" data-primary="class decorators" id="id4293"></a>extension, augment class definitions at <code>class</code> statements. They wrap classes in a similar way, adding support for management of whole objects and their interfaces instead of a single function. </p></li>
</ul>
<p>We met decorators very briefly in <a data-type="xref" href="ch19.html#function_odds_and_ends">Chapter 19</a> in relation to simple functions, but they are more general than earlier implied: they can also be used for class methods and classes and can add nearly arbitrary logic to functions and classes that go well beyond that the static- and class-method roles used as a segue here.</p>
<p>For instance, <em>function decorators</em> may be used to augment functions with code that logs calls made to them, checks argument types during debugging, times calls, and so on, and can be used to manage either functions themselves or later calls to them. In the latter mode, function decorators are similar to the <em>delegation</em> design pattern we explored in <a data-type="xref" href="ch31.html#designing_with_classes">Chapter 31</a>, but they are designed to augment a specific function or method call, not an entire object interface.</p>
<p>Python provides a few built-in function decorators for operations, such as marking static and class methods and defining properties (as sketched earlier, the <code>property</code> built-in works as a decorator automatically), but programmers can also code arbitrary decorators of their own. Although they are not strictly tied to classes, user-defined function decorators are often coded as classes to save the original functions for later dispatch, along with other data as state information.</p>
<p>This proved such a useful hook that it was eventually extended—<em>class decorators</em> bring augmentation to classes, too, and are more directly tied to the class model. Like their function cohorts, class decorators may manage classes themselves or later instance-creation calls and often employ <em>delegation</em> of entire interfaces in the latter mode. As you’ll find, their roles also often overlap with <em>metaclasses</em> but are a more lightweight way to achieve some goals.</p>
<section data-type="sect2" data-pdf-bookmark="Function Decorator Basics"><div class="sect2" id="function_decorator_basics-id00062">
<h2>Function Decorator Basics</h2>
<p>Syntactically, a function decorator is a <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="function decorators" id="dcrfcdc"></a>sort of runtime declaration about the function that follows it. A function decorator is coded on a line by itself just before the <code>def</code> statement that defines a function or method. It <a contenteditable="false" data-type="indexterm" data-primary="functions" data-secondary="metafunctions" id="id4294"></a><a contenteditable="false" data-type="indexterm" data-primary="metafunctions" id="id4295"></a>consists of the <code>@</code> symbol, followed by a <em>metafunction</em>—a plain function (or other callable object) of one argument, which is passed and manages another function. The code following the <code>@</code> is usually the name of a metafunction with an optional arguments list, but as of Python 3.9, it can be any expression returning a one-argument function. Listing multiple decorators on consecutive lines allows them to nest, as you’ll see later in this book.</p>
<p>For example, the prior section’s methods may be coded with decorator syntax like this:</p>
<pre data-type="programlisting">class C:
   @staticmethod                    <code><em># Function decoration syntax</em></code>
   def meth():
       …</pre>
<p>Internally, this syntax has the same effect as the following—passing the function through the decorator and assigning the result back to the original name:</p>
<pre data-type="programlisting">class C:
   def meth():
       …
   meth = staticmethod(meth)        <code><em># Name rebinding equivalent</em></code></pre>
<p>Decoration <em>rebinds</em> the method name to the decorator’s result. The net effect is that calling the method function’s name later actually triggers the result of its <code>staticmethod</code> decorator first. Because a decorator can return any sort of object, this allows the decorator to insert a layer of logic to be run on every later call. The decorator function is free to return either the original function itself or a new <em>proxy</em> object that saves the original function passed to the decorator to be invoked indirectly after the extra logic layer runs.</p>
<p>With this addition, <a data-type="xref" href="#example_threetwo_onetwodot_hack_static">Example 32-12</a> is a better way to code our static method code of <a data-type="xref" href="#example_threetwo_eightdot_hack_staticdo">Example 32-8</a>.</p>
<div data-type="example" id="example_threetwo_onetwodot_hack_static">
<h5><span class="label">Example 32-12. </span>hack_static_deco.py</h5>
<pre data-type="programlisting">class Hack:
    numInstances = 0
    def __init__(self):
        Hack.numInstances += 1

    @staticmethod
    def printNumInstances():
        print('Number of instances:', Hack.numInstances)</pre>
</div>
<p>Here is this example in action as before:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>from hack_static_deco import Hack
</strong></code>&gt;&gt;&gt; <code><strong>a, b, c = Hack(), Hack(), Hack()
</strong></code>&gt;&gt;&gt; <code><strong>Hack.printNumInstances()</strong></code>              <code><em># Calls from classes and instances work</em></code>
Number of instances: 3
&gt;&gt;&gt; <code><strong>a.printNumInstances()</strong></code>
Number of instances: 3</pre>
<p>Because they also accept and return functions, the <code>classmethod</code> and <code>property</code> built-in functions may be used as decorators in the same way—as in <a data-type="xref" href="#example_threetwo_onethreedot_alldecorat">Example 32-13</a>, which demos all three built-in decorators previewed earlier.</p>
<div data-type="example" id="example_threetwo_onethreedot_alldecorat">
<h5><span class="label">Example 32-13. </span>alldecorators.py</h5>
<pre data-type="programlisting">class Methods:
    def imeth(self, x):            <code><em># Normal instance method: passed a self
</em></code>        print([self, x])

    @staticmethod
    def smeth(x):                  <code><em># Static: no instance passed
</em></code>        print([x])

    @classmethod
    def cmeth(cls, x):             <code><em># Class: gets class, not instance</em></code>
        print([cls, x])

    @property                      <code><em># Property: computed on fetch</em></code>
    def name(self):
        return 'Pat ' + self.__class__.__name__</pre>
</div>
<p>Running this live in a REPL proves the point:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>from alldecorators import Methods
</strong></code>&gt;&gt;&gt; <code><strong>obj = Methods()
</strong></code>&gt;&gt;&gt; <code><strong>obj.imeth(1)</strong></code>
[&lt;alldecorators.Methods object at 0x10d2839b0&gt;, 1]
&gt;&gt;&gt; <code><strong>obj.smeth(2)</strong></code>
[2]
&gt;&gt;&gt; <code><strong>obj.cmeth(3)</strong></code>
[&lt;class 'alldecorators.Methods'&gt;, 3]
&gt;&gt;&gt; <code><strong>obj.name</strong></code>
'Pat Methods'</pre>
<p>Bear in mind that <code>staticmethod</code> and its kin here are still built-in functions; they may be used in decoration syntax just because they take a function as an argument and return a callable to which the original function name can be rebound. In fact, any such function can be used in this way—even user-defined functions we <a contenteditable="false" data-type="indexterm" data-primary="function decorators" data-startref="fcdcrt" id="id4296"></a><a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="function decorators" data-startref="dcrfcdc" id="id4297"></a>code ourselves, as the next section explains.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="A First Look at User-Defined Function Decorators"><div class="sect2" id="a_first_look_at_user_defined_function_d">
<h2>A First Look at User-Defined Function Decorators</h2>
<p>Although Python provides a handful of built-in functions that can be used as decorators, we can also write custom <a contenteditable="false" data-type="indexterm" data-primary="function decorators" data-secondary="user-defined" id="fcdcurd"></a><a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="function decorators" data-tertiary="user-defined" id="dcruddf"></a><a contenteditable="false" data-type="indexterm" data-primary="user-defined function decorators" id="usrdffccr"></a>decorators of our own. Because of their wide utility, we’re going to devote an entire chapter to coding decorators in the final part of this book. As a quick example, though, let’s look at a simple user-defined decorator at work.</p>
<p>Recall from <a data-type="xref" href="ch30.html#operator_overloading-id000103">Chapter 30</a> that the <code>__call__</code> operator-overloading method implements a function-call interface for class instances. <a data-type="xref" href="#example_threetwo_onefourdot_traceronedo">Example 32-14</a> uses this to code a call <em>proxy</em> class that saves the decorated function in the instance and catches calls to the original name. Because this is a class, it also has state information—a counter of calls made.</p>
<div data-type="example" id="example_threetwo_onefourdot_traceronedo">
<h5><span class="label">Example 32-14. </span>tracer1.py</h5>
<pre data-type="programlisting">class tracer:
    def __init__(self, func):          <code><em># Remember original, init counter</em></code>
        self.calls = 0
        self.func  = func
    def __call__(self, *args):         <code><em># On later calls: add logic, run original</em></code>
        self.calls += 1
        print(f'call {self.calls} to {self.func.__name__}')
        return self.func(*args)

@tracer                                <code><em># Same as hack = tracer(hack)</em></code>
def hack(a, b, c):                     <code><em># Wrap hack in a decorator object</em></code>
    return a + b + c

if __name__ == '__main__':
    print(hack(1, 2, 3))               <code><em># Really calls the tracer wrapper object</em></code>
    print(hack('a', 'b', 'c'))         <code><em># Invokes __call__ in class</em></code></pre>
</div>
<p>Because the <code>hack</code> function is run through the <code>tracer</code> decorator, when the original <code>hack</code> name is called, it actually triggers the <code>__call__</code> method in the class. This method counts and logs the call and then dispatches it to the original wrapped function. Note how the <code>*<em>name</em></code> argument syntax is used to pack and unpack the passed-in arguments; because of this, this decorator can be used to wrap any function with any number of positional arguments.</p>
<p>The net effect, again, is to add a layer of logic to the original <code>hack</code> function. When run, the first output line comes from the <code>tracer</code> class, and the second gives the return value of the <code>hack</code> function itself:</p>
<pre data-type="programlisting">$ <code><strong>python3 tracer1.py</strong></code>
call 1 to hack
6
call 2 to hack
abc</pre>
<p>Trace through this example’s code for more insight. As it is, this decorator works for any function that takes positional arguments, but it does not handle <em>keyword</em> arguments and cannot decorate class-level <em>method</em> functions (in short, for methods, its <code>__call__</code> would be passed a <code>tracer</code> instance only). As you’ll learn in <a data-type="xref" href="part08.html#advanced_topics">Part VIII</a>, there are a variety of ways to code function decorators, including nested <code>def</code> statements, and some of the alternatives are better suited to methods than the version shown here.</p>
<p>For example, by using <em>nested functions</em> with enclosing scopes for state instead of callable class instances with attributes, function decorators often become more broadly applicable to class-level <em>methods</em> too. We’ll postpone the full details on this, but <a data-type="xref" href="#example_threetwo_onefivedot_tracertwodo">Example 32-15</a> provides a brief look at this <em>closure</em>-based coding model; it uses function attributes for counter state for portability but could also leverage variables and <code>nonlocal</code> instead.</p>
<div data-type="example" id="example_threetwo_onefivedot_tracertwodo">
<h5><span class="label">Example 32-15. </span>tracer2.py</h5>
<pre data-type="programlisting">def tracer(func):                      <code><em># Remember original</em></code>
    def oncall(*args):                 <code><em># On later calls
</em></code>        oncall.calls += 1
        print(f'call {oncall.calls} to {func.__name__}')
        return func(*args)
    oncall.calls = 0
    return oncall

class C:
    @tracer
    def hack(self, a, b, c): return a + b + c

if __name__ == '__main__':
    x = C()
    print(x.hack(1, 2, 3))
    print(x.hack('a', 'b', 'c'))</pre>
</div>
<p>The example’s output is the same as its predecessor <a contenteditable="false" data-type="indexterm" data-primary="function decorators" data-secondary="user-defined" data-startref="fcdcurd" id="id4298"></a><a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="function decorators" data-tertiary="user-defined" data-startref="dcruddf" id="id4299"></a><a contenteditable="false" data-type="indexterm" data-primary="user-defined function decorators" data-startref="usrdffccr" id="id4300"></a>but reflects a decorated class method; more on this later.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="A First Look at Class Decorators and Metaclasses"><div class="sect2" id="a_first_look_at_class_decorators_and_me">
<h2>A First Look at Class Decorators and Metaclasses</h2>
<p>Python later generalized decorators, allowing <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="class decorators" id="dccldrt"></a><a contenteditable="false" data-type="indexterm" data-primary="class decorators" id="cldcrtr"></a><a contenteditable="false" data-type="indexterm" data-primary="metaclasses" data-startref="mtclss" id="id4301"></a>them to be applied to classes as well as functions. In short, <em>class decorators</em> are similar to function decorators, but they are run at the end of a <code>class</code> statement to rebind a class name to a callable. As such, they can be used to either manage classes just after they are created or insert a layer of wrapper logic to manage instances when they are later created. Symbolically, the code structure:</p>
<pre data-type="programlisting">def decorator(aClass): …

@decorator                       <code><em># Class decoration syntax</em></code>
class C: …</pre>
<p>is mapped to the following equivalent:</p>
<pre data-type="programlisting">def decorator(aClass): …

class C: …                       <code><em># Name rebinding equivalent
</em></code>C = decorator(C)</pre>
<p>The class decorator is free to augment the class itself or return a <em>proxy</em> object that intercepts later instance construction calls. For example, in the code of <a data-type="xref" href="#counting_instances_per_class_with_class">“Counting instances per class with class methods”</a>, we could use this hook to automatically augment the classes with instance counters and any other data required:</p>
<pre data-type="programlisting">def count(aClass):
    aClass.numInstances = 0
    return aClass                <code><em># Return class itself instead of a wrapper
</em></code>
@count
class Hack: …                    <code><em># Same as Hack = count(Hack)</em></code>

@count
class Sub(Hack): …               <code><em># numInstances = 0 not needed here</em></code></pre>
<p>In fact, as coded, this decorator can be applied to classes <em>or</em> functions—it happily returns the object being defined in either context after initializing the object’s attribute:</p>
<pre data-type="programlisting">@count
def hack(): pass                 <code><em># Like hack = count(hack)
</em></code>
@count
class Hack: pass                 <code><em># Like Hack = count(Hack)</em></code>

hack.numInstances                <code><em># Both are set to zero</em></code>
Hack.numInstances</pre>
<p>Though this decorator manages a function or class itself, as detailed later in this book, class decorators can also manage an object’s entire <em>interface</em> by intercepting construction calls and wrapping the new instance object in a <em>proxy</em> that deploys attribute accessor tools to intercept later requests—a multilevel coding technique we’ll use to implement class attribute privacy in <a data-type="xref" href="ch39.html#decorators">Chapter 39</a>. Here’s a preview of the model:</p>
<pre data-type="programlisting">def decorator(cls):                             <code><em># On @ decoration</em></code>
    class Proxy:
        def __init__(self, *args):              <code><em># On instance creation: make a cls</em></code>
            self.wrapped = cls(*args)
        def __getattr__(self, name):            <code><em># On attribute fetch: extra ops here</em></code>
            return getattr(self.wrapped, name)
    return Proxy

@decorator
class C: …          <code><em># Like C = decorator(C)</em></code>
X = C()             <code><em># Makes a Proxy that wraps a C, and catches later X.attr</em></code></pre>
<p>Finally, <em><em>metaclasses</em></em>, mentioned briefly earlier in this chapter, are a similarly advanced class-based tool whose roles often intersect with those of class decorators. They provide an alternate model, which routes the creation of a class object to a subclass of the top-level <code>type</code> class (normally), at the conclusion of a <code>class</code> statement:</p>
<pre data-type="programlisting">class Meta(type):
    def __new__(meta, classname, supers, classdict):
        …<code><em>extra logic + class creation via type call</em></code>…

class C(metaclass=Meta):
    …<code><em>my creation routed to Meta</em></code>…            <code><em># Like C = Meta('C', (), {…})</em></code></pre>
<p>Python calls a class’s metaclass to create the new class object, passing in the data defined during the <code>class</code> statement’s run; if omitted, the <code>metaclass</code> simply defaults to the <code>type</code> class we explored earlier. Abstractly speaking, here’s what happens at the end of <code>class</code> statements having explicit metaclasses like the preceding:</p>
<pre data-type="programlisting"> <code><em>classname</em></code> = Meta(<code><em>classname</em></code>, <code><em>superclasses</em></code>, <code><em>attributedict</em></code>)</pre>
<p>To manage the creation or initialization of a new class object, a metaclass generally redefines the <code>__new__</code> or <code>__init__</code> method of the <code>type</code> class that intercepts this call by default. The net effect, as with class decorators, is to define code to be run automatically at class creation time. Here, this binds the class name to the result of a call to a user-defined metaclass. In fact, a metaclass need not be a class at all—a possibility we’ll explore later that blurs some of the distinction between this tool and decorators and even qualifies the two as functionally equivalent in some roles.</p>
<p>Both schemes, class decorators and metaclasses, are free to augment a class or return an arbitrary object to replace it—a hook with almost limitless class-based customization possibilities. As you’ll learn later, metaclasses may also define <em>methods</em> that process their instance classes rather than normal instances of them—a technique that’s similar (if not redundant) to class methods and might be emulated by methods and data in class decorator proxies, or even a class decorator that returns <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="class decorators" data-startref="dccldrt" id="id4302"></a><a contenteditable="false" data-type="indexterm" data-primary="class decorators" data-startref="cldcrtr" id="id4303"></a><a contenteditable="false" data-type="indexterm" data-primary="metaclasses" data-startref="mtclss" id="id4304"></a>a metaclass instance.</p>
<p>Such mind-bending concepts, however, require <a data-type="xref" href="ch40.html#metaclasses_and_inheritance">Chapter 40</a>’s conceptual groundwork (and quite possibly sedation).</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="For More Details"><div class="sect2" id="for_more_details">
<h2>For More Details</h2>
<p>Naturally, there’s more to the decorator and metaclass stories than shown here. Although they are a general mechanism whose usage may be required by some packages, coding <em>new</em> user-defined decorators and metaclasses is an advanced topic of interest primarily to tool writers, not application programmers. Because of this, this book defers additional coverage until its final and optional part:</p>
<ul>
<li><p><a data-type="xref" href="ch38.html#managed_attributes">Chapter 38</a> shows how to code properties using function decorator syntax in more depth.</p></li>
<li><p><a data-type="xref" href="ch39.html#decorators">Chapter 39</a> focuses on decorators, and includes more comprehensive examples.</p></li>
<li><p><a data-type="xref" href="ch40.html#metaclasses_and_inheritance">Chapter 40</a> covers metaclasses, and more on the class and instance management story.</p></li>
</ul>
<p>Although these chapters cover advanced topics, they’ll also provide us with a chance to see Python at work in substantial examples. For now, let’s move on to our final class-related topic.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="The super Function"><div class="sect1" id="the_super_function">
<h1>The super Function</h1>
<p>To close out this chapter, we turn to <code>super</code>: a built-in function that can be used to both <a contenteditable="false" data-type="indexterm" data-primary="super function" id="id4305"></a><a contenteditable="false" data-type="indexterm" data-primary="functions" data-secondary="super function" id="id4306"></a>reference superclass attributes implicitly without naming a superclass explicitly and route method calls coherently in multiple-inheritance trees.</p>
<p>So far, <code>super</code> has been called out in the sidebar <a data-type="xref" href="ch28.html#the_super_alternative">“The super Alternative”</a>, as well as multiple notes along the way, but has not appeared in code. This was by design: <code>super</code> comes with substantial complexities and downsides that make it difficult to recommend to learners. In short, it’s an all-or-nothing tool with several arduous coding requirements and relies on special-case and wildly implicit semantics that run counter to Python norms.</p>
<p>The <code>super</code> call also tends to be abused for “Java-fication” of Python code. Newcomers with backgrounds in Java often rush to use Python’s <code>super</code> simply because of its similarity to a Java tool but are unaware of its much more subtle implications in Python’s multiple inheritance—until adding superclasses breaks their programs.</p>
<p>Nevertheless, this call has grown pervasive in Python code and merits further elaboration, especially for those opting to use it naively. Hence, this section both covers <code>super</code> usage and notes its pitfalls along the way. Ultimately, though, the merit of this call, like everything else presented in this chapter and book, is ultimately yours to decide.</p>
<section data-type="sect2" data-pdf-bookmark="The super Basics"><div class="sect2" id="the_super_basics">
<h2>The super Basics</h2>
<p>First off, let’s review the explicit alternative that’s more closely in step with Python’s own idioms. As we’ve seen in this book so far, it’s always possible to reference a superclass’s attributes—whether method or data—by naming their desired source class explicitly:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>class C:</strong></code>
        <code><strong>def act(self):
            print('hack')

</strong></code>&gt;&gt;&gt; <code><strong>class D(C):
        def act(self):</strong></code>
            <code><strong>C.act(self)</strong></code>         <code><em># Name superclass explicitly, pass self</em></code>
            <code><strong>print('code')

</strong></code>&gt;&gt;&gt; <code><strong>I = D()
</strong></code>&gt;&gt;&gt; <code><strong>I.act()</strong></code>
hack
code</pre>
<p>In <em>single-inheritance</em> trees like this one, the <code>super</code> alternative seems relatively straightforward at first glance: its most common form in the following automatically selects the calling class’s superclass generically and implicitly when an attribute is later fetched. An explicit call like <code><em>class</em>.<em>method</em>(self)</code>, for example, becomes an implicit <code>super().<em>method</em>()</code>, as in our example:</p>
<pre class="pagebreak-before" data-type="programlisting">&gt;&gt;&gt; <code><strong>class C:</strong></code> 
        <code><strong>def act(self):
            print('hack')

</strong></code>&gt;&gt;&gt; <code><strong>class D(C):
        def act(self):
            super().act()</strong></code>       <code><em># Reference superclass implicitly, omit self</em></code>
            <code><strong>print('code')</strong></code>

&gt;&gt;&gt; <code><strong>I = D()
</strong></code>&gt;&gt;&gt; <code><strong>I.act()</strong></code>
hack
code</pre>
<p>This works as advertised and may minimize work—you don’t need to list <code>self</code> in the call, don’t need to update the call if <code>D</code>’s superclass changes in the future, and don’t need to code long superclass names or package-import paths.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="The super Details"><div class="sect2" id="the_super_details">
<h2>The super Details</h2>
<p>If you study the preceding code closely, though, you’ll realize that there’s something odd going on here. The <code>super</code> call somehow knows about the class, its superclass, and the <code>self</code> instance, even though none are present in its call. The backstory involves MROs, a proxy, and an algorithm that are required reading for <code>super</code> aspirants of all kinds.</p>
<section data-type="sect3" data-pdf-bookmark="A “magic” proxy"><div class="sect3" id="a_quotation_markmagicquotation_mark_pro">
<h3>A “magic” proxy</h3>
<p>To understand how <code>super</code> works, you <a contenteditable="false" data-type="indexterm" data-primary="super function" data-secondary="MRO algorithm" id="spfmrgr"></a><a contenteditable="false" data-type="indexterm" data-primary="functions" data-secondary="super function" data-tertiary="MRO algorithm" id="fcspfmrg"></a><a contenteditable="false" data-type="indexterm" data-primary="MRO (method resolution order)" data-secondary="super function" id="MROspfc"></a>first need to be fluent in the <em>MRO algorithm</em> covered in <a data-type="xref" href="ch31.html#multiple_inheritance_and_the_mro">“Multiple Inheritance and the MRO”</a>—and you should review that now if you gave it a pass. The MRO is both a firm prerequisite and nested component of <code>super</code>. Given the complexity and artificial nature of the MRO, some may rule this a first strike against <code>super</code>.</p>
<p>Once you’ve mastered the MRO, the simplest description of <code>super</code> is this: when used in a class method, <code>super</code> returns a <em>proxy</em> object that will locate an attribute in a class <em>following</em> that of the containing class in the MRO of the <code>self</code> instance’s class. The net effect finds an attribute in a superclass or other relative of the class containing the call.</p>
<p>This works as expected in single-inheritance trees because the superclass naturally follows the containing class on <code>self</code>’s MRO. Really, though, this relies on deep magic. Apart from the MRO itself, <code>super</code> works by inspecting:</p>
<ul>
<li><p>The runtime <em>call stack</em> info for the calling method’s arguments</p></li>
<li><p>The <code>__class__</code> variable internally added to the <code>__closure__</code> of methods that call <code>super</code><a contenteditable="false" data-type="indexterm" data-primary="__class__ attribute" data-primary-sortas="class attribute" id="id4307"></a><a contenteditable="false" data-type="indexterm" data-primary="classes" data-secondary="__class__ attribute" data-secondary-sortas="class attribute" id="id4308"></a></p></li>
</ul>
<p>The combo automatically locates both the <code>self</code> argument and the class containing the <code>super</code> call and then pairs the two in a special <em>proxy</em> object that routes later attribute fetches to a superclass’s version of a name.</p>
<p>In fact, the common no-argument <code>super</code> form is equivalent to manually passing in the class containing the <code>super</code> call, along with the <code>self</code> instance. That is, within a class’s method function, the following forms work the same, though the second can be used outside a method, too, and its first argument can be <code>__class__</code> inside a method:</p>
<pre data-type="programlisting">super()
super(<code><em>class-containing-the-super-call</em></code>, <code><em>method-self-argument</em></code>)</pre>
<p>Both forms can be used in your code, and manual arguments may be handy in some roles. Because the second may be <em>harder</em> to code and maintain than explicit class-name references, though, Python roots out the class and instance for you behind the scenes. Here’s the equivalent manual version in our <span class="keep-together">example:</span></p>
<pre data-type="programlisting">class D(C):
    def act(self):
        <code><strong>super(D, self).act()</strong></code>    <code><em># Works the same as super().act()</em><strong></strong></code>
        print('code')           <code><em># And D is available as __class__</em></code></pre>
<p>If that all sounds complicated and strange, it’s because it is. Due to its unusual semantics, the no-argument <code>super</code> call form doesn’t work at all outside the context of a class’s method:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>super</strong></code>                       <code><em># A "magic" proxy object that routes later calls</em></code>
&lt;class 'super'&gt;
&gt;&gt;&gt; <code><strong>super()</strong> </code>                    <code><em># This form has no meaning outside a method</em></code>
RuntimeError: super(): no arguments</pre>
<p>And where it does work, its implicit pairing of class and instance is nowhere to be found in your code:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>class E(C):</strong></code>
        <code><strong>def method(self):</strong></code>
            <code><strong>proxy = super()</strong></code>     <code><em># self is implicit in super - only!</em></code>
            <code><strong>return proxy</strong></code>
 
&gt;&gt;&gt; <code><strong>prx = E().method()</strong></code>          <code><em># The normally hidden proxy object</em></code>
&gt;&gt;&gt; <code><strong>prx</strong></code>
&lt;super: &lt;class 'E'&gt;, &lt;E object&gt;&gt;

&gt;&gt;&gt; <code><strong>prx.act()</strong></code>    <code><em># Find act on MRO past hidden E, bind with hidden self, call (!)</em></code>
Hack</pre>
<p>To be sure, this call’s semantics resemble nothing else in Python—it’s neither a bound nor nonbound method and fills in a class and <code>self</code> even though you omit both in the call. This deviates from Python’s explicit <code>self</code> policy, which holds true everywhere else. As we’ve seen, class methods list and use <code>self</code> explicitly to make instance references apparent. Operator overloading, including constructors, implies a <code>self</code>, but this is trivial by comparison.</p>
<p>By hiding the instance, <code>super</code> violates this fundamental Python idiom for a single role. While that <a contenteditable="false" data-type="indexterm" data-primary="super function" data-secondary="MRO algorithm" data-startref="spfmrgr" id="id4309"></a><a contenteditable="false" data-type="indexterm" data-primary="functions" data-secondary="super function" data-tertiary="MRO algorithm" data-startref="fcspfmrg" id="id4310"></a><a contenteditable="false" data-type="indexterm" data-primary="MRO (method resolution order)" data-secondary="super function" data-startref="MROspfc" id="id4311"></a>may be comfortable to those accustomed to other OOP languages, it may also qualify as a strike two to <span class="keep-together">others.</span></p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Attribute-fetch algorithm"><div class="sect3" id="attribute_fetch_algorithm">
<h3>Attribute-fetch algorithm</h3>
<p>In a <em>single-inheritance</em> tree like <a contenteditable="false" data-type="indexterm" data-primary="super function" data-secondary="attribute-fetch algorithm" id="id4312"></a><a contenteditable="false" data-type="indexterm" data-primary="functions" data-secondary="super function" data-tertiary="attribute-fetch algorithm" id="id4313"></a><a contenteditable="false" data-type="indexterm" data-primary="attribute fetches" id="id4314"></a><a contenteditable="false" data-type="indexterm" data-primary="MRO (method resolution order)" data-secondary="attribute fetch" id="id4315"></a>the preceding example, <code>super</code> is straightforward because there’s just one obvious follower on the MRO—the superclass of the class containing the <code>super</code> call. In fact, in this simple case, the immediate superclass can be had from an instance at <code>__class__.__bases__</code> without applying MROs at all:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>E.__mro__</strong></code>
(&lt;class '__main__.E'&gt;, &lt;class '__main__.C'&gt;, &lt;class 'object'&gt;)
&gt;&gt;&gt; <code><strong>E().__class__.__bases__[0]</strong></code>
&lt;class '__main__.C'&gt;</pre>
<p>In the more complex class trees of <em>multiple inheritance</em>, though, you must understand <code>super</code>’s full algorithm to know what it will choose in a given tree.</p>
<p>Here’s how this works. The proxy object that <code>super</code> returns—created “magically” from runtime info as described in the prior section—uses its saved instance and class containing the call to resolve attribute references as follows:</p>
<ol>
<li><p>Fetch the MRO of the saved <code>self</code> instance’s class, available at <code>self.__class__.__mro__</code>.<a contenteditable="false" data-type="indexterm" data-primary="__mro__ attribute" data-primary-sortas="mro attribute" id="id4316"></a><a contenteditable="false" data-type="indexterm" data-primary="classes" data-secondary="__mro__ attribute" data-secondary-sortas="mro attribute" id="id4317"></a></p></li>
<li><p>Scan this MRO from left to right to find the saved containing class, and skip it.</p></li>
<li><p>Search the namespace dictionaries of each remaining class in the MRO from left to right until the requested attribute is found.</p></li>
<li><p>If the attribute was found and is a method, bind it with the saved <code>self</code> instance.</p></li>
</ol>
<p>This procedure is run for each attribute fetch and is wholly based on MRO ordering. It must start with <code>self</code>’s MRO because the containing class’s own MRO won’t apply if it has been mixed with other classes; class-tree shape and hence MRO may be arbitrary for instances made from lower classes (and may even change dynamically in rare cases).</p>
<p>You can’t ignore these underlying mechanics except in very simple class trees. Unlike in Java, the utility of <em>mix-in</em> classes in Python makes multiple inheritance from disjoint and independent superclasses a common occurrence in realistic code. And once you add multiple superclasses, you’ve kicked <code>super</code> up to a whole new level.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Universal deployment"><div class="sect3" id="universal_deployment">
<h3>Universal deployment</h3>
<p>Let’s illustrate with code. Suppose you’ve <a contenteditable="false" data-type="indexterm" data-primary="super function" data-secondary="deployment" id="id4318"></a><a contenteditable="false" data-type="indexterm" data-primary="functions" data-secondary="super function" data-tertiary="deployment" id="id4319"></a><a contenteditable="false" data-type="indexterm" data-primary="MRO (method resolution order)" data-secondary="deployment" id="id4320"></a>written the following classes that happily deploy <code>super</code> in simple single-inheritance mode to implicitly invoke a method one level up from <code>C</code>:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>class A:</strong></code>
        <code><strong>def act(self): print('A')</strong></code>
<code><strong>
</strong></code>&gt;&gt;&gt; <code><strong>class B:
        def act(self): print('B')

</strong></code>&gt;&gt;&gt; <code><strong>class C(B):
        def act(self):
            super().act()</strong></code>         <code><em># super applied to a single-inheritance tree</em><strong></strong></code>

&gt;&gt;&gt; <code><strong>C().act()</strong> </code>                    <code><em># Make an instance and call its method</em></code>
B</pre>
<p>If such classes later grow to use more than one superclass, though, <code>super</code>’s effects might be surprising—it does not raise an exception when the same name appears in more than one superclass of a multiple inheritance tree but will naively pick just the <em>leftmost</em> superclass having the method being run (really, the <em>first</em> per the class tree’s flattened MRO). This may or may not be the class that you want, and is completely wrong if you want both:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>class C(B, A):</strong></code>                <code><em># Add an A mix-in class with the same method</em></code>
        <code><strong>def act(self):
            super().act()</strong></code>         <code><em># Doesn't fail on conflicts - picks just one</em></code>

&gt;&gt;&gt; <code><strong>C().act()</strong></code>
B

&gt;&gt;&gt; <code><strong>class C(A, B):
        def act(self):
            super().act()</strong></code>         <code><em># If A is listed first, B.act() is no longer run</em></code>

&gt;&gt;&gt; <code><strong>C().act()</strong></code>
A</pre>
<p>This silently masks a source of OOP errors so common that it shows up again in this part’s “Gotchas” ahead. <em>Explicit</em> calls are one way to solve this dilemma. With explicit class names, you can choose either the left class, the right class, or both, and with substantially less drama. If you might need to be explicit later, why not use this form earlier too?</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>class C(A, B):</strong></code>                <code><em># Explicit form</em></code>
        <code><strong>def act(self):</strong></code>            <code><em># You probably want to be more explicit here</em></code>
            <code><strong>A.act(self)</strong></code>           <code><em># This handles both single and multiple inheritance</em></code>
            <code><strong>B.act(self)</strong></code>           <code><em># So why use the super special case at all?</em></code>

&gt;&gt;&gt; <code><strong>C().act()</strong></code>
A
B</pre>
<p>Technically speaking, <a contenteditable="false" data-type="indexterm" data-primary="MRO (method resolution order)" data-secondary="class inheritance" id="id4321"></a><a contenteditable="false" data-type="indexterm" data-primary="classes" data-secondary="inheritance" data-tertiary="MRO (method resolution order)" id="id4322"></a>this example’s explicit <em>class inheritance</em> also searches the metaclass type tree for names not defined in superclasses, per <a data-type="xref" href="#the_inheritance_bifurcation">“The Inheritance Bifurcation”</a>. This secondary-tree search differs from <code>super</code>, which always searches just a tail portion of the <em>instance</em>’s MRO (and hence just the superclass tree), but is completely moot for defined names and unlikely to matter for undefined names.</p>
<p>The real underlying issue with <code>super</code> here, though, is that it requires itself to be called in <em>every</em> class’s method in order to propagate the call chain. Without this <em>universal deployment</em>, the call dies in the first class that doesn’t call <code>super</code>—as in our <code>A</code> and <code>B</code>. While we can add <code>super</code> to these classes, too, this is the first of that handful of arduous <code>super</code> coding requirements and quickly leads to another issue, as the next section explains.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Call-chain anchors"><div class="sect3" id="call_chain_anchors">
<h3>Call-chain anchors</h3>
<p>Since both <code>A</code> and <code>B</code> of the prior section’s example are somewhere on <code>C</code>’s MRO, we might be <a contenteditable="false" data-type="indexterm" data-primary="super function" data-secondary="call-chain anchors" id="spfccch"></a><a contenteditable="false" data-type="indexterm" data-primary="functions" data-secondary="super function" data-tertiary="call-chain anchors" id="fpfccchr"></a><a contenteditable="false" data-type="indexterm" data-primary="cooperative method dispatch" id="cprvmdpt"></a><a contenteditable="false" data-type="indexterm" data-primary="super function" data-secondary="cooperator method dispatch" id="spfucoom"></a>tempted to make both classes’ methods run by propagating the call with added <code>super</code> calls in both.</p>
<p>This scheme is called <em>cooperative method dispatch</em>: each class in a tree runs <code>super</code> to hand the call off to the next class on the MRO that cares about it. This automatically routes calls through each calling class just once and avoids running a method in a diamond’s common superclass more than once (it appears just once in an MRO). It assumes that the MRO’s order makes sense for your method calls, but explicit class-name calls are a fallback if not.</p>
<p>Armed with that info, here’s the mod in our example:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>class A:</strong></code>
        <code><strong>def act(self):</strong></code>
<code> <strong>           print('A')</strong></code>
            <code><strong>super().act()</strong></code>         <code><em># Add a super here too</em></code>

&gt;&gt;&gt; <code><strong>class B:</strong></code>
<code> <strong>       def act(self):</strong></code>
<code> <strong>           print('B')</strong></code>
            <code><strong>super().act()</strong></code>         <code><em># Add a super here too</em></code>
 
&gt;&gt;&gt; <code><strong>class C(B, A):</strong></code>
<code> <strong>       def act(self):</strong></code>
            <code><strong>super().act()</strong></code>         <code><em># Hope this winds up running all methods</em></code> 
 
&gt;&gt;&gt; <code><strong>C().act()</strong></code>
B
A
AttributeError: 'super' object has no attribute 'act'</pre>
<p>Immediately, though, we’re in trouble here, and the reason requires inspecting the MRO of an instance’s class:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>I = C()</strong></code>
&gt;&gt;&gt; <code><strong>I.__class__.__mro__</strong></code>
(&lt;class '__main__.C'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;)</pre>
<p>Here’s the subtle problem. The <code>super</code> in <code>C</code> will select <code>act</code> in <code>B</code>, the next on this MRO; the <code>super</code> in <code>B</code> will then select <code>act</code> in <code>A</code>, its follower on <code>self</code>’s MRO; but then there are no more <code>act</code> definitions to be had: the <code>super</code> in <code>A</code> looks for <code>act</code> in <code>object</code> and beyond, and of course fails. We say that there is no <em>call-chain anchor</em>—no end point for the call propagation. Hence, the last <code>super</code> call in <code>A</code> dies with an exception.</p>
<p>In fact, you’ve just met a possible strike three for this call. While this code works if you omit the <code>super</code> in <code>A</code>, this policy won’t help in general: classes like <code>A</code> and <code>B</code> are probably designed to be mixed into other classes, too, and it wouldn’t make sense to specialize their code just for the <code>C</code> class’s use case. To propagate <code>super</code> method calls, <em>all</em> classes must define <code>super</code>, too, and there must be an anchor to catch and end the chain somewhere.</p>
<p>Although we can add an anchor in a pointless superclass that defines the method but does not call <code>super</code> again, this is another of those arduous coding requirements—and substantially more effort than simply running the explicit class-name calls alternative shown earlier:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>class X:</strong></code>                          <code><em># Code a bogus class, just to appease super</em></code>
        <code><strong>def act(self):</strong></code>
            <code><strong>print('anchor')</strong></code>

&gt;&gt;&gt; <code><strong>class A:</strong></code> …<code><em>same</em></code>…
 
&gt;&gt;&gt; <code><strong>class B:</strong></code> …<code><em>same</em></code>…

&gt;&gt;&gt; <code><strong>class C(B, A, X):</strong></code>                 <code><em># Add a final anchor, just to appease super</em></code>
         <code><strong>def act(self):</strong></code>
             <code><strong>super().act()</strong></code>

&gt;&gt;&gt; <code><strong>C().act()</strong></code>
B
A
anchor

&gt;&gt;&gt; <code><strong>[c.__name__ for c in C().__class__.__mro__]</strong></code>
['C', 'B', 'A', 'X', 'object']</pre>
<p>This works because <code>X</code> precedes <code>object</code> on the MRO as shown, and hence stops the <code>act</code> call chain. Adding the anchor class <code>X</code> as a common superclass to both <code>A</code> and <code>B</code> in a diamond would work, too, because the resulting MRO is the same (remember, the MRO removes all but the last [rightmost] appearance of a class from the DFLR order):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>class X:</strong></code> …<code><em>same</em></code>…
         
&gt;&gt;&gt; <code><strong>class A(X):</strong></code> …<code><em>same</em></code>…
 
&gt;&gt;&gt; <code><strong>class B(X):</strong></code> …<code><em>same</em></code>…

&gt;&gt;&gt; <code><strong>class C(B, A):</strong></code> …<code><em>same</em></code>…

&gt;&gt;&gt; <code><strong>C().act()</strong></code>
B
A
anchor

&gt;&gt;&gt; <code><strong>[c.__name__ for c in C().__class__.__mro__]</strong></code>
['C', 'B', 'A', 'X', 'object']</pre>
<p>Again, though, if you have to code a special class just to appease <code>super</code>, why not just use explicit class names? Similarity to other languages isn’t a very good reason, especially in contexts that other languages don’t support.</p>
<p>Also, keep in mind that the class selected by <code>super</code> for an attribute reference may not be a superclass at all and may vary per tree that a class is mixed into. For instance, the <code>super</code> in <code>B</code> in our example dispatches to <code>A</code>—the next on the MRO, but a <em>sibling</em>, not a superclass. This may be moot <a contenteditable="false" data-type="indexterm" data-primary="super function" data-secondary="call-chain anchors" data-startref="spfccch" id="id4323"></a><a contenteditable="false" data-type="indexterm" data-primary="functions" data-secondary="super function" data-tertiary="call-chain anchors" data-startref="fpfccchr" id="id4324"></a><a contenteditable="false" data-type="indexterm" data-primary="cooperative method dispatch" data-startref="cprvmdpt" id="id4325"></a><a contenteditable="false" data-type="indexterm" data-primary="super function" data-secondary="cooperator method dispatch" data-startref="spfucoom" id="id4326"></a>in most programs, but if you must be sure that an immediate superclass’s method is run, you again must use explicit class names instead of <code>super</code>.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Same argument lists"><div class="sect3" id="same_argument_lists">
<h3>Same argument lists</h3>
<p>While <code>super</code> always demands <a contenteditable="false" data-type="indexterm" data-primary="super function" data-secondary="argument lists" id="sufugul"></a><a contenteditable="false" data-type="indexterm" data-primary="functions" data-secondary="super function" data-tertiary="argument lists" id="fcpfg"></a><a contenteditable="false" data-type="indexterm" data-primary="arguments" data-secondary="super function" id="arguupu"></a>a call-chain anchor, you may occasionally get one for free. As a special case, <code>object</code> defines a <em>constructor</em> that can be relied on to anchor some chains (recall that the <code>__init__</code> constructor method is a class attribute like any other, despite its odd name and automatic invocation):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>class A:</strong></code>
<code> <strong>       def __init__(self):</strong></code>
<code> <strong>           print('A')</strong></code>
            <code><strong>super().__init__()</strong></code>       <code><em># Propagate constructor calls</em></code>
 
&gt;&gt;&gt; <code><strong>class B:</strong></code>
<code> <strong>       def __init__(self):</strong></code>
<code> <strong>           print('B')</strong></code>
            <code><strong>super().__init__()</strong></code>       <code><em># Propagate constructor calls</em></code>
 
&gt;&gt;&gt; <code><strong>class C(B, A):</strong></code>
<code> <strong>       def __init__(self):</strong></code>
            <code><strong>super().__init__()</strong></code>       <code><em># Assume object anchors constructor chain</em></code>

&gt;&gt;&gt; <code><strong>I = C()</strong></code>
B
A</pre>
<p>This propagates the constructor call through <code>C</code>, <code>B</code>, <code>A</code>, and <code>object</code> per the <code>I</code> instance’s MRO via cooperative method dispatch as before. This also fails, however, for constructors that take any arguments because that of <code>object</code> takes none except <code>self</code>:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>class A:</strong></code>
<code> <strong>       def __init__(self, name):</strong></code>         <code><em># Add an argument to the method</em><strong></strong></code>
<code> <strong>           print('A')</strong></code>
<code> <strong>           super().__init__(name)</strong></code>
 
&gt;&gt;&gt; <code><strong>class B:</strong></code>
<code> <strong>       def __init__(self, name):</strong></code>
<code> <strong>           print('B')</strong></code>
<code> <strong>           super().__init__(name)</strong></code>
<code><strong></strong> </code>
&gt;&gt;&gt; <code><strong>class C(B, A):</strong></code>
<code> <strong>       def __init__(self, name):</strong></code>
<code> <strong>           super().__init__(name)</strong>   </code>     <code><em># But object's arguments list differs</em><strong></strong></code>
 
&gt;&gt;&gt; <code><strong>I = C('Pat')</strong></code>
B
A
TypeError: object.__init__() takes exactly one argument (the instance to initialize)</pre>
<p>And now you’ve run into another one of those other arduous coding requirements: <code>super</code> generally assumes that all the methods in a call chain use the <em>same arguments</em> list because the MRO’s ordering of method calls can vary with class-tree shape: an arbitrary change in inheritance may change call order arbitrarily.</p>
<p>This limits flexibility inherently. While you may be able to ensure same arguments for classes used only in a single program <a contenteditable="false" data-type="indexterm" data-primary="super function" data-secondary="argument lists" data-startref="sufugul" id="id4327"></a><a contenteditable="false" data-type="indexterm" data-primary="functions" data-secondary="super function" data-tertiary="argument lists" data-startref="fcpfg" id="id4328"></a><a contenteditable="false" data-type="indexterm" data-primary="arguments" data-secondary="super function" data-startref="arguupu" id="id4329"></a>and can sometimes fudge it with starred-argument collectors for generality, neither policy will apply to code meant to be reused in multiple contexts—which is really one of the main points behind Python programming.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Noncalls and operator overloading"><div class="sect3" id="noncalls_and_operator_overloading">
<h3>Noncalls and operator overloading</h3>
<p>To close, here are two <a contenteditable="false" data-type="indexterm" data-primary="super function" data-secondary="noncalls" id="sufucll"></a><a contenteditable="false" data-type="indexterm" data-primary="functions" data-secondary="super function" data-tertiary="noncalls" id="fcpnnl"></a><a contenteditable="false" data-type="indexterm" data-primary="super function" data-secondary="operator overloading" id="opvlfc"></a><a contenteditable="false" data-type="indexterm" data-primary="functions" data-secondary="super function" data-tertiary="operator overloading" id="fcpnvpr"></a><a contenteditable="false" data-type="indexterm" data-primary="operator overloading" data-secondary="super function" id="opovlspfc"></a>more <code>super</code> oddities. First, keep in mind that <code>super</code>, like the MRO, is not just about methods, despite their prevalence in its jargon. It can also fetch the class <em>data attributes</em> we met in <a data-type="xref" href="ch29.html#class_coding_details">Chapter 29</a> and the <em>bound methods</em> we met in <a data-type="xref" href="ch31.html#designing_with_classes">Chapter 31</a>:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>class C:</strong></code>
<code> <strong>       attr1 = 'hack'</strong></code>          <code><em># super also fetches data attributes</em></code>
<code> <strong>       def attr2(self):</strong>   </code>     <code><em># And returns bound methods sans calls</em><strong></strong></code>
<code> <strong>           return 'code'</strong></code>
 
&gt;&gt;&gt; <code><strong>class D(C):</strong></code>
<code> <strong>       def act(self):</strong></code>
<code> <strong>           return super().attr1, super().attr2</strong></code>

&gt;&gt;&gt; <code><strong>I = D()</strong></code>
&gt;&gt;&gt; <code><strong>I.act()</strong></code>
('hack', &lt;bound method C.attr2 of &lt;__main__.D object at 0x103993200&gt;&gt;)
&gt;&gt;&gt; <code><strong>I.act()[1]()</strong></code>
'code'</pre>
<p>When you access a method like <code>attr2</code> from a <code>super</code> proxy, the proxy binds it with the saved instance to produce a bound method. Fetching a method as a <em>plain function</em>, however, may require an explicit class name, like <code>C.attr2</code>. This leads down a rabbit hole too deep to plumb here, but it’s another way that <code>super</code> clashes with normal semantics.</p>
<p>Second, <code>super</code> also doesn’t fully work in the presence of <code>__<em>X</em>__</code> operator-overloading methods. If you study the following code, you’ll see that explicit named calls to overloading methods in the superclass work normally, but using the <code>super</code> result in an expression fails to dispatch to the superclass’s method:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>class C:</strong></code>
        <code><strong>def __getitem__(self, ix):</strong></code>      <code><em># Indexing overload method</em></code>
            <code><strong>print('C index')

</strong></code>&gt;&gt;&gt; <code><strong>class D(C):
        def __getitem__(self, ix):</strong></code>      <code><em># Redefine to extend here</em></code>
            <code><strong>print('D index')
            C.__getitem__(self, ix)</strong></code>     <code><em># Explicit call form works</em></code>
            <code><strong>super().__getitem__(ix)</strong></code>     <code><em># Direct name calls work too</em></code>
            <code><strong>super()[ix]</strong></code>                 <code><em># But operators do not! (__getattribute__)</em></code>

&gt;&gt;&gt; <code><strong>I = C()
</strong></code>&gt;&gt;&gt; <code><strong>I[99]</strong></code>
C index
&gt;&gt;&gt; <code><strong>I = D()
</strong></code>&gt;&gt;&gt; <code><strong>I[99]</strong></code>
D index
C index
C index
TypeError: 'super' object is not subscriptable</pre>
<p>This behavior is due to the same limitation described in the sidebar <a data-type="xref" href="ch28.html#delegating_built_insem_dashor_not">“Delegating Built-ins—or Not”</a>—because the proxy object returned by <code>super</code> uses the <code>__getattribute__</code> method we met earlier to catch and dispatch later attribute requests, it fails to intercept the automatic <code>__<em>X</em>__</code> method invocations run by built-in operations including expressions, as these begin their search in the class instead of the instance.</p>
<p>This may seem less severe than the other limitations we’ve met, but operators should generally work the same as the equivalent method call, especially for a built-in like this. Not supporting this adds another exception for <code>super</code> users to confront and remember. Other languages’ mileage may vary, but in Python, <code>self</code> is explicit, multiple-inheritance mix-ins and operator <a contenteditable="false" data-type="indexterm" data-primary="super function" data-secondary="noncalls" data-startref="sufucll" id="id4330"></a><a contenteditable="false" data-type="indexterm" data-primary="functions" data-secondary="super function" data-tertiary="noncalls" data-startref="fcpnnl" id="id4331"></a><a contenteditable="false" data-type="indexterm" data-primary="super function" data-secondary="operator overloading" data-startref="opvlfc" id="id4332"></a><a contenteditable="false" data-type="indexterm" data-primary="functions" data-secondary="super function" data-tertiary="operator overloading" data-startref="fcpnvpr" id="id4333"></a><a contenteditable="false" data-type="indexterm" data-primary="operator overloading" data-secondary="super function" data-startref="opovlspfc" id="id4334"></a>overloading are common, and superclass name changes are rare enough to pass as a red herring.</p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="The super Wrap-Up"><div class="sect2" id="the_super_wrap_up">
<h2>The super Wrap-Up</h2>
<p>So there you have it: a brief tutorial on the <code>super</code> built-in, for which you can find copious supplements in all the standard places, some of which seem as focused on defending <code>super</code> as on documenting it. Hopefully, the coverage here has given you a balanced view of this tool’s trade-offs while introducing its fundamentals.</p>
<p>As we’ve just seen, in single-inheritance class trees, the <code>super</code> call may be used to refer to parent superclasses generically without naming them explicitly. In multiple-inheritance trees, this call can also be used to implement cooperative method dispatch that propagates calls through a tree. The latter role may be especially useful in diamonds, as a conforming method call chain visits each superclass just once.</p>
<p>While these are clear upsides in some contexts, it’s important to know that <code>super</code> can also yield highly implicit behavior, which for some programs may not invoke superclasses as expected or required.</p>
<p>To summarize, the <code>super</code> method-dispatch technique generally imposes three main coding <span class="keep-together">requirements:</span></p>
<ul>
<li><p><em>Anchors</em>: the method called by <code>super</code> must exist—which requires extra code and calls if no call-chain anchor is present, and mix-in classes can’t be specialized for a single tree’s context.</p></li>
<li><p><em>Arguments</em>: the method called by <code>super</code> must have the same argument signature across the entire class tree—which can impair flexibility, especially for implementation-level methods like <span class="keep-together">constructors.</span></p></li>
<li><p><em>Deployment</em>: every appearance of the method called by <code>super</code> but the last must use <code>super</code> itself—which can make it difficult to use existing code, change call ordering, override methods, and code self-contained classes.</p></li>
</ul>
<p>In addition, <code>super</code> builds upon the already complex MRO, can mask problems when single-inheritance trees become multiple-inheritance trees, may select a class other than a superclass in multiple-inheritance trees, and constitutes yet another special case for attribute inheritance, which we’ll revisit in <a data-type="xref" href="ch40.html#metaclasses_and_inheritance">Chapter 40</a>.</p>
<p>In the end, <code>super</code> is easy to use and relatively harmless in single-inheritance roles, but its unusual semantics, rigid requirements, and questionable net reward make it a mixed bag. Python programmers, especially those learning Python anew, might be better served by the more general and transparent coding paradigm of explicit class-name references.</p>
<p>But you should judge all this for yourself in an OOP Python program near you.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Class Gotchas"><div class="sect1" id="class_gotchas">
<h1>Class Gotchas</h1>
<p>We’ve reached the end of the primary OOP coverage in this book. After exceptions up next, we’ll explore additional class-related examples and topics in the last part of the book, but that part mostly just gives expanded coverage to concepts introduced here. As usual, let’s wrap up this part with the standard warnings about pitfalls to avoid.</p>
<p>Most class issues can be boiled down to namespace issues—which makes sense, given that classes are largely just namespaces with a handful of extra tricks. Some of the items in this section are more like class usage pointers than problems, but even experienced class coders have been known to stumble on a few.</p>
<section data-type="sect2" data-pdf-bookmark="Changing Class Attributes Can Have Side Effects"><div class="sect2" id="changing_class_attributes_can_have_side">
<h2>Changing Class Attributes Can Have Side Effects</h2>
<p>Theoretically speaking, classes (and class instances) are <em>mutable</em> objects. As with built-in lists <a contenteditable="false" data-type="indexterm" data-primary="classes" data-secondary="attributes" data-tertiary="changing" id="clttchg"></a><a contenteditable="false" data-type="indexterm" data-primary="attributes" data-secondary="changing" id="atbrchg"></a>and dictionaries, you can change them in place by assigning to their attributes—and as with lists and dictionaries, this means that changing a class or instance object may impact multiple references to it.</p>
<p>That’s usually what we want and is how objects change their state in general, but awareness of this issue becomes especially critical when changing <em>class</em> attributes. Because all instances generated from a class share the class’s namespace, any changes at the class level are reflected in all instances unless they have their own versions of the changed class attributes.</p>
<p>In Python, we can normally change any attribute in any object to which we have a reference. Consider the following class. Inside the class body, the assignment to the name <code>a</code> generates an attribute <code>X.a</code>, which lives in the class object at runtime and will be inherited by all of <code>X</code>’s instances:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>class X:
        a = 1</strong></code>       <code><em># Class attribute</em></code>

&gt;&gt;&gt; <code><strong>I = X()
</strong></code>&gt;&gt;&gt; <code><strong>I.a</strong></code>             <code><em># Inherited by instance</em></code>
1
&gt;&gt;&gt; <code><strong>X.a</strong>   </code>          <code><em># Accessible through class</em></code>
1</pre>
<p>So far, so good—this is the normal case. But notice what happens when we change the class attribute dynamically <em>outside</em> the <code>class</code> statement: it also changes the attribute in every object that inherits from the class. Moreover, new instances created from the class during this session or program run also get the dynamically set value, regardless of what the class’s source code says:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>X.a = 2</strong></code>         <code><em># May change more than X</em></code>
&gt;&gt;&gt; <code><strong>I.a</strong></code>             <code><em># I changes too</em></code>
2
&gt;&gt;&gt; <code><strong>J = X()</strong></code>         <code><em># J inherits from X's runtime values</em></code>
&gt;&gt;&gt; <code><strong>J.a</strong></code>             <code><em># (but assigning to J.a changes a in J, not X or I)</em></code>
2</pre>
<p>Is this a useful feature or a dangerous trap? You be the judge. As discussed in <a data-type="xref" href="ch27.html#class_coding_basics">Chapter 27</a>, you can actually get work done by changing class attributes without ever making a single instance—a technique that can simulate the use of “records” or “structs” in other languages. As a refresher, consider the following unusual but legal Python program:</p>
<pre data-type="programlisting">class X: pass                       <code><em># Make a few attribute namespaces</em></code>
class Y: pass

X.a = 1                             <code><em># Use class attributes as variables</em></code>
X.b = 2                             <code><em># No instances anywhere to be found</em></code>
X.c = 3
Y.a = X.a + X.b + X.c

for X.i in range(Y.a): print(X.i)   <code><em># Prints 0..5</em></code></pre>
<p>Here, the classes <code>X</code> and <code>Y</code> work like “fileless” modules—namespaces for storing variables we don’t want to clash. This is a perfectly legal Python programming trick, but it’s less appropriate when applied to classes written by others; you can’t always be sure that class attributes you change aren’t critical to the class’s internal behavior. If you’re out to simulate a C <code>struct</code>, you <a contenteditable="false" data-type="indexterm" data-primary="classes" data-secondary="attributes" data-tertiary="changing" data-startref="clttchg" id="id4335"></a><a contenteditable="false" data-type="indexterm" data-primary="attributes" data-secondary="changing" data-startref="atbrchg" id="id4336"></a>may be better off changing instances than classes, as that way, only one object is affected:</p>
<pre data-type="programlisting">class Record: pass
X = Record()
X.name = 'pat'
X.job  = 'Pizza maker'</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Changing Mutable Class Attributes Can Have Side Effects, Too"><div class="sect2" id="changing_mutable_class_attributes_can_h">
<h2>Changing Mutable Class Attributes Can Have Side Effects, Too</h2>
<p>This gotcha is really an extension <a contenteditable="false" data-type="indexterm" data-primary="classes" data-secondary="attributes" data-tertiary="mutable" id="clttmut"></a><a contenteditable="false" data-type="indexterm" data-primary="attributes" data-secondary="mutable" id="atbrmut"></a>of the prior. Because class attributes are shared by all instances, if a class attribute references a <em>mutable</em> object, changing that object in place from any instance impacts all instances at once:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>class C:
        shared = []</strong></code>                 <code><em># Class attribute
</em></code>        <code><strong>def __init__(self):
            self.perobj = []</strong></code>        <code><em># Instance attribute</em></code>

&gt;&gt;&gt; <code><strong>x, y = C(), C()</strong></code>                 <code><em># Two instances</em></code>
&gt;&gt;&gt; <code><strong>y.shared, y.perobj</strong></code>              <code><em># Implicitly share class attrs</em></code>
([], [])

&gt;&gt;&gt; <code><strong>x.shared.append('hack')</strong></code>         <code><em># Impacts y's view too!</em></code>
&gt;&gt;&gt; <code><strong>x.perobj.append('code')</strong></code>         <code><em># Impacts x's data only
</em></code>&gt;&gt;&gt; <code><strong>x.shared, x.perobj</strong></code>
(['hack'], ['code']) 

&gt;&gt;&gt; <code><strong>y.shared, y.perobj</strong></code>              <code><em># y sees change made through x</em></code>
(['hack'], [])
&gt;&gt;&gt; <code><strong>C.shared</strong></code>                        <code><em># Stored on class and shared</em></code>
['hack']</pre>
<p>This effect is no different than many we’ve seen in this book already: mutable objects are shared by simple variables, globals are shared by functions, module-level objects are shared by multiple importers, and mutable function arguments are shared by the caller and the callee. All of these are cases of general behavior—multiple references to a mutable object—and all are impacted if the shared object is changed in place from any reference.</p>
<p>Here, this occurs in class attributes shared by all instances via inheritance, but it’s the same phenomenon at work. It may be made more subtle by the different behavior of assignments to instance attributes themselves:</p>
<pre data-type="programlisting">x.shared.append('hack')    <code><em># Changes shared object attached to class - in place</em></code>
x.shared = 'hack'          <code><em># Changed or creates instance attribute attached to x</em></code></pre>
<p>But again, this is not a problem, it’s just <a contenteditable="false" data-type="indexterm" data-primary="classes" data-secondary="attributes" data-tertiary="mutable" data-startref="clttmut" id="id4337"></a><a contenteditable="false" data-type="indexterm" data-primary="attributes" data-secondary="mutable" data-startref="atbrmut" id="id4338"></a>something to be aware of; shared mutable class attributes can have many valid uses in Python programs.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Multiple Inheritance: Order Matters"><div class="sect2" id="multiple_inheritance_order_matters">
<h2>Multiple Inheritance: Order Matters</h2>
<p>This may be obvious by now, but it’s worth underscoring one last time: if you use multiple inheritance, the <a contenteditable="false" data-type="indexterm" data-primary="multiple inheritance" data-secondary="order" id="mulhrd"></a><a contenteditable="false" data-type="indexterm" data-primary="inheritance" data-secondary="multiple" data-tertiary="order" id="ihmplrdr"></a>order in which superclasses are listed in the <code>class</code> statement header can be critical. Python always searches superclasses from left to right, according to their order in the header line.</p>
<p>For instance, in the multiple inheritance example we studied in <a data-type="xref" href="ch31.html#designing_with_classes">Chapter 31</a>, imagine that the <code>Super</code> class implemented a <code>__str__</code> method, too:</p>
<pre data-type="programlisting">class ListTree:
    def __str__(self): …

class Super:
    def __str__(self): …

class Sub(ListTree, Super):    <code><em># Get ListTree's __str__ by listing it first
</em></code>
x = Sub()                      <code><em># Inheritance searches ListTree before Super</em></code></pre>
<p>Which class would we inherit it from—<code>ListTree</code> or <code>Super</code>? As inheritance searches generally proceed from left to right, we would get the method from whichever class is listed first (leftmost) in <code>Sub</code>’s <code>class</code> header. Presumably, we would list <code>ListTree</code> first because its whole purpose is its custom <code>__str__</code>. Indeed, we had to do this in <a data-type="xref" href="ch31.html#designing_with_classes">Chapter 31</a> when mixing this class with a <code>tkinter.Button</code> that had a <code>__str__</code> of its own.</p>
<p>But now, suppose <code>Super</code> and <code>ListTree</code> have their own versions of other same-named attributes, too. If we want one name from <code>Super</code> and another from <code>ListTree</code>, the order in which we list them in the <code>class</code> header won’t help—we will have to override inheritance by manually assigning to the attribute name in the <code>Sub</code> class:</p>
<pre data-type="programlisting">class ListTree:
    def __str__(self): …
    def other(self): …

class Super:
    def __str__(self): …
    def other(self): …

class Sub(ListTree, Super):    <code><em># Get ListTree's __str__ by listing it first
</em></code>    other = Super.other        <code><em># But explicitly pick Super's version of other</em></code>
    def __init__(self):
        …

x = Sub()                      <code><em># Inheritance searches Sub before ListTree/Super</em></code></pre>
<p class="pagebreak-before">Here, the assignment to <code>other</code> within the <code>Sub</code> class creates <code>Sub.other</code>—a reference back to the <code>Super.other</code> object. Because it is lower in the tree, <code>Sub.other</code> effectively hides <code>ListTree.other</code>, the attribute that the inheritance search would normally find. Similarly, if we listed <code>Super</code> first in the <code>class</code> header to pick up its <code>other</code>, we would need to select <code>ListTree</code>’s method explicitly:</p>
<pre data-type="programlisting">class Sub(Super, ListTree):               <code><em># Get Super's other by order</em></code>
    __str__ = ListTree.__str__            <code><em># Explicitly pick ListTree.__str__</em></code></pre>
<p>For another example of the technique shown here in action, see the discussion of explicit conflict resolution in <a data-type="xref" href="ch31.html#attribute_conflict_resolution">“Attribute Conflict Resolution”</a>. Ultimately, multiple inheritance is an advanced tool. Even if you understood the last paragraph, it’s still a good idea to use it sparingly and carefully. Otherwise, the meaning of a name may come to depend on the order in which classes are mixed in an arbitrarily far-removed subclass.</p>
<p>As a rule of thumb, multiple inheritance works best when your mix-in classes are as self-contained as possible—because they may be used in a variety of contexts, they should not make assumptions about names related to other classes in a tree. The pseudoprivate <code>__<em>X</em></code> attributes feature we studied in <a data-type="xref" href="ch31.html#designing_with_classes">Chapter 31</a> can help by localizing names that a class relies on owning and limiting the names that mix-in classes add to the mix. In this example, for instance, if <code>ListTree</code> only means to export its custom <code>__str__</code>, it can name <a contenteditable="false" data-type="indexterm" data-primary="multiple inheritance" data-secondary="order" data-startref="mulhrd" id="id4339"></a><a contenteditable="false" data-type="indexterm" data-primary="inheritance" data-secondary="multiple" data-tertiary="order" data-startref="ihmplrdr" id="id4340"></a>its <code>other</code> method <code>__other</code> to avoid clashing with like-named classes in the tree.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Scopes in Methods and Classes"><div class="sect2" id="scopes_in_methods_and_classes">
<h2>Scopes in Methods and Classes</h2>
<p>When working out the meaning of names in class-based code, it helps to remember that classes introduce local <a contenteditable="false" data-type="indexterm" data-primary="methods" data-secondary="scopes" id="mthdscp"></a><a contenteditable="false" data-type="indexterm" data-primary="classes" data-secondary="scopes" id="clssscps"></a><a contenteditable="false" data-type="indexterm" data-primary="scopes" id="scpos"></a>scopes, just as functions do, and methods are simply further nested functions. In the following example, the <code>generate</code> function returns an instance of the nested <code>Hack</code> class. Within its code, the class name <code>Hack</code> is assigned in the <code>generate</code> function’s local scope and hence is visible to any further nested functions, including code inside <code>method</code>; it’s in the <em>E</em> enclosing-function layer of the LEGB scope lookup rule:</p>
<pre data-type="programlisting">def generate():
    class Hack:                  <code><em># Hack is a name in generate's local scope</em></code>
        count = 1
        def method(self):
            print(Hack.count)    <code><em># Visible in generate's scope, per LEGB rule (E)</em></code>
    return Hack()

generate().method()</pre>
<p>This example works because the local scopes of all enclosing function <code>def</code>s are automatically visible to nested <code>def</code>s—including nested method <code>def</code>s, as in this example.</p>
<p>Even so, keep in mind that method <code>def</code>s cannot see the local scope of the enclosing <em>class</em>; they can see only the local scopes of enclosing <code>def</code>s. That’s why methods must go through the <code>self</code> instance or the class name to reference methods and other attributes defined in the enclosing <code>class</code> statement. For example, code in the method must use <code>self.count</code> or <code>Hack.count</code>, not just <code>count</code>.</p>
<p>To avoid nesting, we could restructure this code such that the class <code>Hack</code> is defined at the top level of the module: the nested <code>method</code> function and the top-level <code>generate</code> will then both find <code>Hack</code> in their global scopes; it’s not localized to a function’s scope, but is still local to a single module:</p>
<pre class="pagebreak-before" data-type="programlisting">def generate():
    return Hack()

class Hack:                    <code><em># Define at top level of module</em></code>
    count = 1
    def method(self):
        print(Hack.count)      <code><em># Found in global scope (enclosing module)</em></code>

generate().method()</pre>
<p>Code tends to be simpler in general if you avoid nesting classes and functions. On the other hand, class nesting is useful in <em>closure</em> contexts, where the enclosing function’s scope retains <em>state</em> used by the class or its methods. In the following, the nested <code>method</code> has access to its own scope, the enclosing function’s scope (for <code>label</code>), the enclosing module’s global scope, anything saved in the <code>self</code> instance by the class, and the class itself via its nonlocal name:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>def generate(label):</strong></code>       <code><em># Returns a class <a contenteditable="false" data-type="indexterm" data-primary="methods" data-secondary="scopes" data-startref="mthdscp" id="id4341"></a><a contenteditable="false" data-type="indexterm" data-primary="classes" data-secondary="scopes" data-startref="clssscps" id="id4342"></a><a contenteditable="false" data-type="indexterm" data-primary="scopes" data-startref="scpos" id="id4343"></a>instead of an instance</em></code>
        <code><strong>class Hack:
            count = 1
            def method(self):
                print(f'{label}={Hack.count}')
        return Hack

</strong></code>&gt;&gt;&gt; <code><strong>aclass = generate('Gotchas')
</strong></code>&gt;&gt;&gt; <code><strong>I = aclass()
</strong></code>&gt;&gt;&gt; <code><strong>I.method()</strong></code>
Gotchas=1</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Miscellaneous Class Gotchas"><div class="sect2" id="miscellaneous_class_gotchas">
<h2>Miscellaneous Class Gotchas</h2>
<p>Here’s a handful of additional class-related warnings, mostly as review:</p>

<ul>
 <li><p><strong>Choose per-instance or class storage wisely.</strong> On a similar note, be careful when you decide <a contenteditable="false" data-type="indexterm" data-primary="storage" data-secondary="per-instance" id="id4344"></a><a contenteditable="false" data-type="indexterm" data-primary="storage" data-secondary="class" id="id4345"></a><a contenteditable="false" data-type="indexterm" data-primary="classes" data-secondary="storage" id="id4346"></a>whether an attribute should be stored on a class or its instances: the former is shared by all instances, and the latter will differ per instance. In a GUI program, for instance, if you want information to be shared by all of the window class objects your application will create (e.g., the last directory used for a Save operation or an already entered password), it might be best stored as class-level data; if stored in the instance as <code>self</code> attributes, it will vary per window or be missing entirely when looked up by inheritance.</p></li>
 <li><p><strong>You usually want to call superclass constructors.</strong> Remember that Python runs only <a contenteditable="false" data-type="indexterm" data-primary="superclasses" data-secondary="constructors" id="id4347"></a><a contenteditable="false" data-type="indexterm" data-primary="classes" data-secondary="superclass constructors" id="id4348"></a><a contenteditable="false" data-type="indexterm" data-primary="constructors" data-secondary="superclasses" id="id4349"></a>one <code>__init__</code> constructor method when an instance is made—the first it finds by inheritance. It does not automatically run the constructors of all superclasses higher up. Because constructors normally perform required startup work, you’ll usually need to run a superclass constructor from a subclass constructor—using either an explicit call through the superclass’s name or <code>super</code>, passing along whatever arguments are required—unless you mean to replace the super’s constructor altogether, or the superclass doesn’t have or inherit a constructor at all.</p></li>
 
 <li><p><strong>Stay tuned for a fix for <code>__getattr__</code> and built-ins.</strong> Another reminder: as noted in <a data-type="xref" href="ch28.html#a_more_realistic_example">Chapter 28</a> and <a contenteditable="false" data-type="indexterm" data-primary="classes" data-secondary="delegation-based" id="id4350"></a><a contenteditable="false" data-type="indexterm" data-primary="__getattr__ method" data-primary-sortas="getattr method" id="id4351"></a>elsewhere, classes that use the <code>__getattr__</code> operator-overloading method to delegate attribute fetches to wrapped objects may fail unless operator-overloading methods are redefined in the wrapper class. The names of operator-overloading methods implicitly fetched by built-in operations are not routed through generic attribute-interception methods. To work around this, you must redefine such methods in wrapper classes, either manually, with tools, or by definition in superclasses; you’ll learn how in <a data-type="xref" href="ch39.html#decorators">Chapter 39</a>.</p></li>
</ul>


</div></section>
<section data-type="sect2" data-pdf-bookmark="“Overwrapping-itis”"><div class="sect2" id="quotation_markoverwrapping_itisquotatio">
<h2>“Overwrapping-itis”</h2>
<p>Finally, when used well, the code <a contenteditable="false" data-type="indexterm" data-primary="wrapping code" id="id4352"></a><a contenteditable="false" data-type="indexterm" data-primary="code wrapping" id="id4353"></a>reuse features of OOP make it excel at cutting development time. Sometimes, though, OOP’s abstraction potential can be abused to the point of making code difficult to understand. If classes are layered too deeply, code can become obscure; you may have to search through many classes to discover what an operation does.</p>
<p>Imagine, for example, a framework with hundreds of classes and a dozen levels of inheritance (this is a true story, but details have been omitted to protect the innocent). Deciphering method calls in such a complex system may be a monumental task: multiple classes might have to be consulted for even the most basic of operations. In fact, the logic of such a system can be so deeply wrapped that understanding a piece of code in some cases may require days of wading through related files. This obviously isn’t ideal for programmer productivity.</p>
<p>The most general rule of thumb of Python programming applies here, too: <em>don’t make things complicated unless they truly must be</em>. Wrapping your code in multiple layers of classes to the point of incomprehensibility is always a bad idea. Abstraction is the basis of polymorphism and encapsulation, and it can be a very effective tool when used well. However, you’ll simplify debugging and aid maintainability if you make your class interfaces intuitive, avoid making your code overly abstract, and keep your class hierarchies short and small unless there is a good reason to do otherwise. Remember: code you write is generally code that others must read.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Chapter Summary"><div class="sect1" id="chapter_summary-id00043">
<h1>Chapter Summary</h1>
<p>This chapter presented an assortment of class-related topics, including subclassing built-in types, the relationship of types and classes, slots, properties, static methods, decorators, and <code>super</code>. Most are optional extensions to the OOP toolbox in Python but may become more useful as you start writing larger object-oriented programs, and all are fair game if they appear in code you must understand. As noted earlier, some of these topics are continued in the final part of this book; be sure to look ahead for more info on properties, descriptors, decorators, and metaclasses.</p>
<p>This is the end of the class part of this book, so you’ll find the usual lab exercises at the end of the chapter: be sure to work through them to get some practice coding real classes. In the next chapter, we’ll begin our look at our last core language topic, <em>exceptions</em>—Python’s mechanism for communicating errors and other conditions to your code. This is a relatively lightweight topic but it was saved for last because new exceptions must be coded as classes. Before we tackle that final core subject, though, take a look at this chapter’s quiz and the lab exercises.</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Test Your Knowledge: Quiz"><div class="sect1" id="test_your_knowledge_quiz-id000185">
<h1>Test Your Knowledge: Quiz</h1>
<ol>
<li><p>Name two ways to extend a built-in object type.</p></li>
<li><p>What are function and class decorators used for?</p></li>
<li><p>How are normal and static methods different?</p></li>
<li><p>Are tools like <code>__slots__</code> and <code>super</code> valid to use in your code?</p></li>
</ol>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Test Your Knowledge: Answers"><div class="sect1" id="test_your_knowledge_answers-id000184">
<h1>Test Your Knowledge: Answers</h1>
<ol>
<li><p>You can embed a built-in object in a wrapper class, or subclass the built-in type directly. The latter approach tends to be simpler, as most original behavior is automatically inherited. This works because types are classes, though the way you create an instance from a type/class determines its functionality.</p></li>
<li><p>Function decorators are generally used to manage a function or method or add to it a layer of logic that is run each time the function or method is called. They can be used to log or count calls to a function, check its argument types, and so on. They are also used to “declare” static methods (simple functions in a class that are not passed an instance, however they are called), as well as class methods and properties. Class decorators are similar but manage whole objects and their interfaces instead of a function call.</p></li>
<li><p>Normal (instance) methods receive a <code>self</code> argument (the implied instance), but static methods do not. Static methods are simple functions nested in class objects. To make a method static, it must either be run through a special built-in function or be decorated with decorator syntax. Python also allows simple functions in a class to be called through the class without this step, but calls through instances still require static-method declaration.</p></li>
<li><p><em>Of course</em>, but you shouldn’t use advanced tools automatically without carefully considering their implications. Slots, for example, can break code; <code>super</code> can mask later problems when used for single inheritance, and in multiple inheritance brings with it substantial complexity for an isolated use case; and both require universal deployment to be most useful. Evaluating new or advanced tools is a primary task of any engineer, and this is why we explored trade-offs in this chapter. This book’s goal is not to tell you which tools to use but to underscore the importance of objectively analyzing them—a task often given too low a priority in the software field. In engineering, as in life in general, we shouldn’t let other people make choices for us.</p></li>
</ol>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Test Your Knowledge: Part VI Exercises"><div class="sect1" id="test_your_knowledge_part_vi_exercises">
<h1>Test Your Knowledge: Part VI Exercises</h1>
<p>These exercises ask you to write a few classes and experiment with some existing code. Of course, the problem with existing code is that it must be existing. To work with the set class in exercise 5, either copy/paste <a data-type="xref" href="#example_threetwo_onedot_setwrapperdotpy">Example 32-1</a> from emedia, find it in this book’s examples package (see the <a href="preface01.html#preface">Preface</a> for pointers), or type it up by hand (mildly tedious but a great way to make syntax more concrete). These programs are growing sophisticated, so be sure to check the solutions at the end of the book for pointers. You’ll find them in <a data-type="xref" href="app02.html#appendix_b_solutions_to_end_of_part_exe">Appendix B</a>, under <a data-type="xref" href="app02.html#part_vicomma_classes_and_oop">“Part VI, Classes and OOP”</a>.</p>
<ol>
<li><p><em>Inheritance</em>: Write a class called <code>Adder</code> that exports a method <code>add(self, x, y)</code>, which prints a “Not Implemented” message. Then, define two subclasses of <code>Adder</code> that implement the <code>add</code> method:</p>
<dl>
<dt><code>ListAdder</code></dt>
<dd>With an <code>add</code> method that returns the concatenation of its two list arguments</dd>
<dt><code>DictAdder</code></dt>
<dd>With an <code>add</code> method that returns a new dictionary containing the items in both its two dictionary arguments (any definition of dictionary addition will do; see dictionary union in <a data-type="xref" href="ch08.html#lists_and_dictionaries">Chapter 8</a> for tips)</dd>
</dl>
<p>Experiment by making instances of all three of your classes interactively and calling their <code>add</code> methods.</p>
<p>Now, extend your <code>Adder</code> superclass to save an object in the instance with a constructor (e.g., assign <code>self.data</code> a list or a dictionary), and overload the <code>+</code> operator with an <code>__add__</code> method to automatically dispatch to your <code>add</code> methods (e.g., <code>X + Y</code> triggers <code>X.add(X.data,Y)</code>). Where is the best place to put the constructors and operator-overloading methods (i.e., in which classes)? What sorts of objects can you add to your class instances?</p>
<p>In practice, you might find it easier to code your <code>add</code> methods to accept just one real argument (e.g., <code>add(self,y)</code>) and add that one argument to the instance’s current data (e.g., <code>self.data + y</code>). Does this make more sense than passing two arguments to <code>add</code>? Would you say this makes your classes more “object-oriented”?</p></li>
<li><p><em>Operator overloading</em>: Write a class called <code>MyList</code> that shadows (“wraps”) a Python list: it should overload most list operators and operations, including <code>+</code>, indexing, iteration, slicing, and list methods such as <code>append</code> and <code>sort</code>. See the Python reference manual or other documentation for a list of all possible methods to support. Also, provide a constructor for your class that takes an existing list (or a <code>MyList</code> instance) and copies its components into an instance attribute. Experiment with your class interactively. Things to explore:</p>
<ul>
<li><p>Why is copying the initial value important here?</p></li>
<li><p>Can you use an empty slice (e.g., <code>start[:]</code>) to copy the initial value if it’s a <code>MyList</code> instance?</p></li>
<li><p>Is there a general way to route list method calls to the wrapped list?</p></li>
<li><p>Can you add a <code>MyList</code> and a regular list? How about a list and a <code>MyList</code> instance?</p></li>
<li><p>What type of object should operations like <code>+</code> and slicing return? What about indexing <span class="keep-together">operations?</span></p></li>
<li><p>You may implement this sort of wrapper class by embedding a real list in a standalone class or by extending the built-in list type with a subclass. Which is easier, and why?</p></li>
</ul></li>
<li><p><em>Subclassing</em>: Make a subclass of <code>MyList</code> from exercise 2 called <code>MyListSub</code>, which extends <code>MyList</code> to print a message to <code>stdout</code> before each call to the <code>+</code> overloaded operation and counts the number of such calls. <code>MyListSub</code> should inherit basic method behavior from <code>MyList</code>. Adding a sequence to a <code>MyListSub</code> should print a message, increment the counter for <code>+</code> calls, and perform the superclass’s method. Also, introduce a new method that prints the operation counters to <code>stdout</code> (i.e., your console window) and experiment with your class interactively. Do your counters count calls per instance or per class (for all instances of the class)? How would you program the other option? (Hint: it depends on which object the count members are assigned to: class members are shared by instances, but <code>self</code> members are per-instance data.)</p></li>
<li><p><em>Attribute methods</em>: Write a class called <code>Attrs</code> with methods that intercept every attribute qualification (both fetches and assignments), and print messages listing their arguments to <code>stdout</code>. Create an <code>Attrs</code> instance and experiment with qualifying it interactively. What happens when you try to use the instance in expressions? Try adding, indexing, and slicing the instance of your class. (Note: a fully generic approach based upon <code>__getattr__</code> requires <a data-type="xref" href="ch39.html#decorators">Chapter 39</a>’s workarounds for reasons noted in <a data-type="xref" href="ch28.html#a_more_realistic_example">Chapter 28</a> and later and summarized in the solution to this exercise.)</p></li>
<li class="pagebreak-before"><p><em>Set objects</em>: Experiment with the set class of <a data-type="xref" href="#example_threetwo_onedot_setwrapperdotpy">Example 32-1</a> and described in <a data-type="xref" href="#extending_types_by_embedding">“Extending Types by Embedding”</a>. Run commands to do the following sorts of operations:</p>
<ul>
<li><p>Create two sets of integers, and compute their intersection and union by using <code>&amp;</code> and <code>|</code> operator expressions.</p></li>
<li><p>Create a set from a string, and experiment with indexing your set. Which methods in the class are called?</p></li>
<li><p>Try iterating through the items in your string set using a <code>for</code> loop. Which methods run this time?</p></li>
<li><p>Try computing the intersection and union of your string set and a simple Python string. Does it work?</p></li>
<li><p>Now, extend your set by subclassing to handle arbitrarily many operands using the <code>*args</code> argument form. (Hint: see the function versions of these algorithms in <a data-type="xref" href="ch18.html#arguments">Chapter 18</a>.) Compute intersections and unions of multiple operands with your set subclass. How can you intersect three or more sets, given that <code>&amp;</code> has only two sides?</p></li>
<li><p>How would you go about emulating other list operations in the set class? (Hint: <code>__add__</code> can catch concatenation, and <code>__getattr__</code> can pass most named list method calls like <code>append</code> to the wrapped list.)</p></li>
</ul></li>
<li><p><em>Class tree links</em>: In<a data-type="xref" href="ch29.html#namespaces_the_conclusion">“Namespaces: The Conclusion”</a> and in <a data-type="xref" href="ch31.html#multiple_inheritance_and_the_mro">“Multiple Inheritance and the MRO”</a>, we learned that classes have a <code>__bases__</code> attribute that returns a tuple of their superclass objects (the ones listed in parentheses in the class header). Use <code>__bases__</code> to extend any or all three of the listing mix-in classes we wrote in <a data-type="xref" href="ch31.html#designing_with_classes">Chapter 31</a> so that they print the names of the immediate superclasses of the instance’s class. Modding <a data-type="xref" href="ch31.html#example_threeone_onezerodot_listinstanc">Example 31-10</a> first may be easiest. When you’re done, the first line of the string representation should look like this (your hex addresses will almost certainly vary):</p>
<pre data-type="programlisting">&lt;Instance of Sub(Super, Lister), address 0x…:</pre></li>
<li><p><em>Composition</em>: Simulate a fast-food ordering scenario by defining four classes:</p>
<dl>
<dt><code>Lunch</code></dt>
<dd>A container and controller class</dd>
<dt><code>Customer</code></dt>
<dd>The actor who buys food</dd>
<dt><code>Employee</code></dt>
<dd>The actor from whom a customer orders</dd>
<dt><code>Food</code></dt>
<dd>What the customer buys</dd>
</dl>
<p>To get you started, here are the classes and methods you’ll be defining:</p>
<pre data-type="programlisting">class Lunch:
    def __init__(self)               <code><em># Make/embed Customer and Employee
</em></code>    def order(self, foodName)        <code><em># Start a Customer order simulation</em></code>
    def result(self)                 <code><em># Ask the Customer what Food it has</em></code>

class Customer:
    def __init__(self)                        <code><em># Initialize my food to None</em></code>
    def placeOrder(self, foodName, employee)  <code><em># Place order with an Employee</em></code>
    def printFood(self)                       <code><em># Print the name of my food</em></code>

class Employee:
    def takeOrder(self, foodName)    <code><em># Return a Food, with requested name</em></code>

class Food:
    def __init__(self, name)         <code><em># Store food name</em></code></pre>
<p>The order simulation should work as follows:</p>
<ul>
<li><p>The <code>Lunch</code> class’s constructor should make and embed an instance of <code>Customer</code> and an instance of <code>Employee</code>, and it should export a method called <code>order</code>. When called, this <code>order</code> method should ask the <code>Customer</code> to place an order by calling its <code>placeOrder</code> method. The <code>Customer</code>’s <code>placeOrder</code> method should, in turn, ask the <code>Employee</code> object for a new <code>Food</code> object by calling <code>Employee</code>’s <code>takeOrder</code> method.</p></li>
<li><p><code>Food</code> objects should store a food name string (e.g., “burritos”), passed down from <code>Lunch.order</code>, to <code>Customer.placeOrder</code>, to <code>Employee.takeOrder</code>, and finally to <code>Food</code>’s constructor. The top-level <code>Lunch</code> class should also export a method called <code>result</code>, which asks the customer to print the name of the food it received from the <code>Employee</code> via the order (this can be used to test your simulation).</p></li>
</ul>
<p>Note that <code>Lunch</code> needs to pass either the <code>Employee</code> or itself to the <code>Customer</code> to allow the <code>Customer</code> to call <code>Employee</code> methods.</p>
<p>Experiment with your classes interactively by importing the <code>Lunch</code> class, calling its <code>order</code> method to run an interaction, and then calling its <code>result</code> method to verify that the <code>Customer</code> got what it ordered. If you prefer, you can also simply code test cases as self-test code in the file where your classes are defined, using the module <code>__name__</code> trick of <a data-type="xref" href="ch25.html#module_odds_and_ends">Chapter 25</a>. In this simulation, the <span class="keep-together"><code>Customer</code></span> is the active agent; how would your classes change if <code>Employee</code> were the object that initiated customer/employee interaction instead?</p></li>
<li><p><em>Zoo animal hierarchy</em>: Consider the class tree shown in <a data-type="xref" href="#a_zoo_hierarchy_composed_of_classes_lin">Figure 32-1</a>.</p>
<figure><div id="a_zoo_hierarchy_composed_of_classes_lin" class="figure">
<img src="assets/lpy6_3201.png" alt="" width="872" height="488"/>
<h6><span class="label">Figure 32-1. </span>A zoo hierarchy composed of classes linked into an inheritance tree</h6>
</div></figure>
<p>Code a set of six <code>class</code> statements to model this taxonomy with Python <em>inheritance</em>. Then, add a <code>speak</code> method to each of your classes that prints a unique message and a <code>reply</code> method in your top-level <code>Animal</code> superclass that simply calls <code>self.speak</code> to invoke the category-specific message printer in a subclass below (this will kick off an independent inheritance search from <code>self</code>). Finally, remove the <code>speak</code> method from your <code>Hacker</code> class so that it picks up the default above it. When you’re finished, your classes should work this way:</p>
<pre data-type="programlisting">$ <code><strong>python3
</strong></code>&gt;&gt;&gt; <code><strong>from zoo import Cat, Hacker
</strong></code>&gt;&gt;&gt; <code><strong>spot = Cat()
</strong></code>&gt;&gt;&gt; <code><strong>spot.reply()</strong></code>                   <code><em># Animal.reply: calls Cat.speak</em></code>
meow
&gt;&gt;&gt; <code><strong>data = Hacker()</strong></code>                <code><em># Animal.reply: calls Primate.speak</em></code>
&gt;&gt;&gt; <code><strong>data.reply()</strong></code>
Hello world!</pre></li>
</ol>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="why_you_will_care_oop_by_the_masters">
<h1>Why You Will Care: OOP by the Masters</h1>
<p>Almost invariably, when teaching live Python classes, about halfway through the OOP section, people who have used OOP in the past are following along intensely, while people who have not are beginning to glaze over (or nod off completely). The point behind the technology just isn’t <span class="keep-together">apparent</span>.</p>
<p>A book like this has the luxury of slowly presenting material like the overview in <a data-type="xref" href="ch26.html#oop_the_big_picture">Chapter 26</a>, and the gradual tutorial of <a data-type="xref" href="ch28.html#a_more_realistic_example">Chapter 28</a>—in fact, you should probably review those sections again if you’re starting to feel like OOP is just some computer science mumbo-jumbo. Though OOP adds more structure than the generators we met earlier, it similarly relies on some magic (inheritance search and a special first argument) that beginners can understandably find difficult to rationalize.</p>
<p>In real classes, however, to help get the newcomers on board (and keep them awake), it often helps to stop and ask the experts in the audience why they use OOP. The answers they’ve given might help shed some light on the purpose of OOP if you’re new to the subject.</p>
<p>Here, then, with only a few embellishments, are the most common reasons to use OOP, as cited by students over the years:</p>
<dl>
<dt>Code reuse</dt>
<dd>This one’s easy and is <a contenteditable="false" data-type="indexterm" data-primary="OOP (object-oriented programming)" data-secondary="code reuse" id="id4354"></a><a contenteditable="false" data-type="indexterm" data-primary="code reuse" id="id4355"></a>the main reason for using OOP. By supporting inheritance, classes make it natural to program by customization instead of starting each project from scratch.</dd>
<dt>Encapsulation</dt>
<dd>Wrapping up <a contenteditable="false" data-type="indexterm" data-primary="OOP (object-oriented programming)" data-secondary="encapsulation" id="id4356"></a><a contenteditable="false" data-type="indexterm" data-primary="encapsulation" id="id4357"></a>implementation details behind object interfaces insulates users of a class from code changes.</dd>
<dt>Structure</dt>
<dd>Classes provide new local <a contenteditable="false" data-type="indexterm" data-primary="OOP (object-oriented programming)" data-secondary="structure" id="id4358"></a>scopes, which minimizes name clashes. They also provide a natural place to write and look for implementation code and to manage object state.</dd>
<dt>Maintenance</dt>
<dd>Classes naturally promote code <a contenteditable="false" data-type="indexterm" data-primary="OOP (object-oriented programming)" data-secondary="maintenance" id="id4359"></a>factoring, which allows us to minimize redundancy. Thanks to both the structure and code reuse support of classes, usually only one copy of the code needs to be changed.</dd>
<dt>Consistency</dt>
<dd>Classes and <a contenteditable="false" data-type="indexterm" data-primary="OOP (object-oriented programming)" data-secondary="consistency" id="id4360"></a>inheritance allow you to implement common interfaces and hence create a common look and feel in your code; this eases debugging, comprehension, and maintenance.</dd>
<dt>Polymorphism</dt>
<dd>This is more a property of OOP than <a contenteditable="false" data-type="indexterm" data-primary="OOP (object-oriented programming)" data-secondary="polymorphism" id="id4361"></a>a reason for using it, but by supporting code generality, polymorphism makes code more flexible and widely applicable and hence more reusable.</dd>
<dt>Other</dt>
<dd>And, of course, the number one reason students gave for using OOP: it looks good on a résumé! (OK, this one was added as a joke, but it is important to be familiar with OOP if you plan to work in the software field today.)</dd>
</dl>
<p>Finally, keep in mind the guidance given multiple times in this part of this book: you won’t fully appreciate OOP until you’ve used it for a while. Pick a project, study larger examples, work through the exercises. Do whatever it takes to get your feet wet with OOP code. It’s optional stuff and may even be overkill in some contexts, but it’s generally worth the effort.</p>
</div></aside>
</div></section>
</div></section></div>
</div>
</body>
</html>