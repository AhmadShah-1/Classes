<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xml:lang="en"
lang="en"
xmlns="http://www.w3.org/1999/xhtml"
xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<title>Learning Python, 6th Edition</title>
<link rel="stylesheet" type="text/css" href="override_v1.css"/>
<link rel="stylesheet" type="text/css" href="epub.css"/>
</head>
<body>
<div id="book-content">
<div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 37. Unicode and Byte Strings"><div class="chapter" id="unicode_and_byte_strings">
<h1><span class="label">Chapter 37. </span>Unicode and Byte Strings</h1>
<p>In <a data-type="xref" href="ch07.html#string_fundamentals">Chapter 7</a>, the Python string story was watered down on purpose to help you get started with the fundamentals. Now that you’ve learned the basics, this chapter moves on to extend them to include the full Unicode-text and binary-data string tales in Python.</p>
<p>This extension was more optional in earlier editions of this book because Unicode was an afterthought in Python 2.X. Python 3.X elevates it to required reading because its normal strings simply <em>are</em> Unicode. Still, how much you need to care about this topic depends in large part upon which of the following categories you fall into:</p>
<ul>
<li><p>If you deal with non-ASCII <em>Unicode text</em>—for instance, in the context of internet content, internationalized <a contenteditable="false" data-type="indexterm" data-primary="Unicode" id="id4556"></a>applications, XML parsers, and some GUIs—you will find direct and seamless support for text encodings in both Python’s all-Unicode <code>str</code> object, as well as its Unicode-aware text files.</p></li>
<li><p>If you deal with <em>binary data</em>—for example, in the form of image or audio files, network transfers, or packed data <a contenteditable="false" data-type="indexterm" data-primary="binary data" id="id4557"></a><a contenteditable="false" data-type="indexterm" data-primary="bytes object" id="id4558"></a><a contenteditable="false" data-type="indexterm" data-primary="objects" data-secondary="bytes" id="id4559"></a>shared with lower-level tools—you will need to understand Python’s <code>bytes</code> object and its sharp distinction between text and binary data and files.</p></li>
<li><p>If you fall into <em>neither</em> of the prior two categories, you may be able to defer this topic and use strings as you did in <a data-type="xref" href="ch07.html#string_fundamentals">Chapter 7</a>: with the general <code>str</code> object, text files, and all the familiar string operations. Your strings will be encoded and decoded using your platform’s default Unicode encoding, but you won’t notice—until, as you’ll see, you encounter content or platforms that use a different default!</p></li>
</ul>
<p>To be sure, if text is always ASCII in your corner of the software world, you might be able to get by with simple string objects and text files and can avoid much of the story that follows. As you’ll learn in a moment, ASCII is a simple kind of Unicode and a subset of other common encodings, so string operations and files “just work” if your programs process ASCII text only and will never deviate from this limitation.</p>
<p>Even if this chapter’s topics seems remote to you today, though, a basic understanding of Python’s string model can both demystify some of the underlying details now and prepare you for Unicode or binary-data issues that may impact you in the future. Given the prominence of the web in most software careers today, that impact may be more a matter of <em>when</em> than <em>if</em>.</p>
<section data-type="sect1" data-pdf-bookmark="Unicode Foundations"><div class="sect1" id="unicode_foundations">
<h1>Unicode Foundations</h1>
<p>Before jumping into code, let’s begin with a general overview of the Unicode model and Python’s support for it. To fully understand both, we have to start with a brief look at how characters are actually represented in computers.</p>
<section data-type="sect2" data-pdf-bookmark="Character Representations"><div class="sect2" id="character_representations">
<h2>Character Representations</h2>
<p>Most programmers think of strings as a <a contenteditable="false" data-type="indexterm" data-primary="Unicode" data-secondary="character representations" id="uncccpr"></a>series of characters (really, their integer codes) used to represent textual data. That’s still true in the brave new world of Unicode, but the way characters are stored in a computer’s memory and files can vary, depending on both what sort of characters are recorded and how programmers choose to record them.</p>
<p>For many programmers in the US, <em>ASCII</em> formed their original notion of text strings. ASCII is a standard <a contenteditable="false" data-type="indexterm" data-primary="ASCII" id="ascii"></a>that defines character codes 0…127 (which always means an inclusive range in this chapter) and thus allows each character to be stored in one 8-bit byte (using 7 bits). For example, the ASCII standard maps character <code>a</code> to the integer value 97 (<code>0x61</code> in hex), which can be stored in a single byte both in computer memory and on files.</p>
<p>To witness this for yourself, Python’s built-in <code>ord</code> function shows the integer code of a given character; <code>chr</code> reveals the character of a given integer code; and <code>hex</code> gives the code’s byte value as two hex digits, each of which fits a 4-bit “nibble.” The first of these, <code>ord</code>, is the value of a character’s representation <span class="keep-together">code—and</span> byte—in ASCII:</p>
<pre data-type="programlisting">$ <code><strong>python3</strong></code>          <code><em># Or py -3 on Windows</em></code>
&gt;&gt;&gt; <code><strong>ord('a')</strong></code>       <code><em># Character =&gt; code</em></code>
97
&gt;&gt;&gt; <code><strong>chr(97)</strong></code>        <code><em># Code =&gt; character</em></code>
'a'
&gt;&gt;&gt; <code><strong>hex(97)</strong></code>        <code><em># Byte value: fits 8 bits</em></code>
'0x61'
&gt;&gt;&gt; <code><strong>0b0111_1111</strong></code>    <code><em># Limit of ASCII's 7-bit range</em></code>
127</pre>
<p>ASCII makes text processing simple, because characters directly correlate to bytes. Sometimes, though, this isn’t enough. Accented characters and special symbols, for example, do not fit into the range of character codes defined by ASCII. To allow for some such extra characters, other standards allow all possible values in an 8-bit byte, 0…255, to be used as codes, and assign values 128…255 to additional characters.</p>
<p>One such standard is known as <em>Latin-1</em> and is widely used in Western Europe. In Latin-1, character codes above 127 are assigned to accented and otherwise special characters. For instance, the character that Latin-1 assigns to code 196 (a.k.a. byte value <code>0xc4</code>) is a specially marked and non-ASCII <span class="keep-together">character, <code>Ä</code></span>. In Python:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>chr(196)</strong></code>         <code><em># Too big for ASCII</em></code>
'Ä'
&gt;&gt;&gt; <code><strong>ord('Ä')</strong></code>         <code><em># Okay for Latin-1</em></code>
196
&gt;&gt;&gt; <code><strong>hex(ord('Ä'))</strong></code>    <code><em># Byte value in Latin-1</em></code>
'0xc4'
&gt;&gt;&gt; <code><strong>bin(ord('Ä'))</strong></code>    <code><em># Latin-1 uses all 8 bits</em></code> 
'0b11000100'</pre>
<p class="pagebreak-before">Still, some alphabets define so many characters that it is impossible to represent them as one byte-sized code per character. The integer codes of the symbols and characters in the following, for example, require more space than a byte—as do those of all the emojis that may not work in some tools but manage to crop up in your emails and texts anyhow:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>ord('<img src="assets/white-right-pointing-index_261e.png" width="108" height="108"/>')</strong></code>
9758
&gt;&gt;&gt; <code><strong>hex(ord('<img src="assets/white-right-pointing-index_261e.png" width="108" height="108"/>'))</strong></code>                     <code><em># Too big for one byte</em></code>
'0x261e'

&gt;&gt;&gt; <code><strong>[hex(ord(c)) for c in '<img src="assets/japanese_character.png" width="160" height="160"/>Л<img src="assets/right-arrow_27a1-fe0f.png" width="160" height="160"/>']</strong></code>     <code><em># Ditto: Unicode required</em></code>
['0x771f', '0x41b', '0x21e8']

&gt;&gt;&gt; <code><strong>[hex(ord(c)) for c in '<img src="assets/slightly-smiling-face_1f642.png" width="160" height="160"/><img src="assets/speak-no-evil-monkey_1f64a.png" width="160" height="160"/><img src="assets/thumbs-up_1f44d.png" width="160" height="160"/>']</strong></code>    <code><em># Emojis: &gt; two bytes (16 bits)</em></code>
['0x1f642', '0x1f64a', '0x1f44d']</pre>
<p><em>Unicode</em> provides the generality <a contenteditable="false" data-type="indexterm" data-primary="code points" data-secondary="Unicode" id="id4560"></a><a contenteditable="false" data-type="indexterm" data-primary="Unicode" data-secondary="code points" id="id4561"></a>we need to deal with text containing non-ASCII characters and symbols like these. In fact, it defines and assigns enough <em>character codes</em> to represent almost every natural language in use, plus a large set of symbols and emojis. In Unicode speak, these codes that stand for characters take the form of numbers (integers), and are usually called <em>code points</em>. The code points that Unicode assigns to characters <code>a</code>, <code>Ä</code>, and <img src="assets/slightly-smiling-face_1f642.png" width="160" height="160"/>, for instance, are<code><strong></strong> </code>97, 196, and 128578 (<code>0x61</code>, <code>0xc4</code>, and <code>0x1f642</code> in hex), respectively:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>[f'{c} is {ord(c)} and {hex(ord(c))}' for c in 'aÄ<img src="assets/slightly-smiling-face_1f642.png" width="160" height="160"/>']</strong></code>
['a is 97 and 0x61', 'Ä is 196 and 0xc4', '<img src="assets/slightly-smiling-face_1f642.png" width="160" height="160"/> is 128578 and 0x1f642']</pre>
<p>Unicode is sometimes referred to <a contenteditable="false" data-type="indexterm" data-primary="wide-character strings" id="id4562"></a>as “wide-character” strings because its range of characters is so broad that multiple bytes may be needed to represent individual character codes. Such text is readily stored in computer memory because each character code can simply span as many bytes as its code-point number requires (the exact way this is done can vary by programming language and isn’t consequential to your Python code).</p>
<p>Once text leaves your computer, though, its storage is more constrained: bytes are a bad thing to waste on your drives and networks, and text used across platforms must follow the same formatting rules. To allow for this, Unicode also defines standard ways to map character codes to and from bytes for storage and transmission that are both platform- and language-neutral—the <em>encodings</em> we’ll explore in the next section.</p>
<p>The takeaway here is that Unicode’s combination of all-encompassing character codes and their predefined encodings make it a portable and flexible model, and the standard way that programs deal with non-English and other text that may have more characters than 8-bit bytes can handle. As an added bonus, earlier schemes like ASCII also fall under <a contenteditable="false" data-type="indexterm" data-primary="Unicode" data-secondary="character representations" data-startref="uncccpr" id="id4563"></a><a contenteditable="false" data-type="indexterm" data-primary="ASCII" data-startref="ascii" id="id4564"></a>the Unicode umbrella unchanged, but we have to move on to the next section to see how.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Character Encodings"><div class="sect2" id="character_encodings">
<h2>Character Encodings</h2>
<p>One of the keys to understanding how Unicode works lies in the way its integer character codes (a.k.a. code points) that <a contenteditable="false" data-type="indexterm" data-primary="Unicode" data-secondary="character encodings" id="ucdcrct"></a>represent characters are mapped to their encoded forms for efficient storage or transfer. Code points in memory are just integers of arbitrary size, but storage and transfer, by nature, impose constraints on time, space, and interoperability that warrant extra formatting steps.</p>
<p class="pagebreak-before">In the Unicode world, we say that characters are translated to and from raw bytes using an <em>encoding</em>—the rules for translating a Unicode-text string into a sequence of bytes and extracting the same string from its sequence of bytes. More procedurally, this translation back and forth between bytes and strings is defined by two terms (the first of which doubles as a noun and verb, confusingly!):</p>
<ul>
<li><p><em>Encoding</em> is the process of <a contenteditable="false" data-type="indexterm" data-primary="encoding" data-secondary="Unicode" id="id4565"></a>translating a string of characters into its raw-bytes form, per any desired encoding that’s broad enough to store the string’s characters.</p></li>
<li><p><em>Decoding</em> is the process of <a contenteditable="false" data-type="indexterm" data-primary="decoding, Unicode" id="id4566"></a>translating a string of raw bytes into its character-string form, per the encoding originally used to create the bytes string.</p></li>
</ul>
<p>As we’ve seen, Unicode defines both character codes and a set of standard encodings. For some of the encodings it defines, the translation process is trivial—ASCII and Latin-1, for instance, map each character to a single byte, so little or no work is required to encode and decode if characters are the same bytes in memory too.</p>
<p>You can view this for yourself with the <code>encode</code> method available on all Python text strings, which simply returns the bytes used to encode the string. The following means that the ASCII character <code>a</code> occupies just one byte when encoded per the ASCII encoding:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>len('a'.encode('ASCII'))</strong></code>      <code><em># ASCII 'a' encodes in 1 byte per ASCII</em></code>
1</pre>
<p>For other encodings, the mapping can be more complex and yield multiple bytes per character. The widely used <em>UTF-8</em> encoding, for example, allows more characters to be <a contenteditable="false" data-type="indexterm" data-primary="UTF-8 encoding" id="id4567"></a><a contenteditable="false" data-type="indexterm" data-primary="encoding" data-secondary="UTF-8" id="id4568"></a>represented by employing a variable-number-of-bytes scheme that’s both general and economical. In fact, because UTF-8 can handle any Unicode code point, it’s become a de facto standard of sorts for text.</p>
<p>In UTF-8, character codes less than 128 are represented as a single byte; codes between 128 and <code>0x7ff</code> (2047) are turned into two bytes, where each byte has a value between 128 and 255; and codes above <code>0x7ff</code> are turned into three- or four-byte sequences having values between 128 and 255. This keeps simple ASCII strings compact, sidesteps byte ordering issues, and avoids null (zero) bytes that can cause problems for C libraries and networking. In Python:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>len('a'.encode('UTF-8'))</strong></code>      <code><em># ASCII: encodes in 1 byte</em></code>
1
&gt;&gt;&gt; <code><strong>len('Ä'.encode('UTF-8'))</strong></code>      <code><em># Non-ASCII: encodes in 2 bytes</em></code>
2
&gt;&gt;&gt; <code><strong>len('<img src="assets/slightly-smiling-face_1f642.png" width="160" height="160"/>'.encode('UTF-8'))</strong></code>     <code><em># Emoji: encodes in 4 bytes</em></code>
4</pre>
<p>Despite such details, it’s important to note that ASCII is a <em>subset</em> of both Latin-1 and UTF-8. This is <a contenteditable="false" data-type="indexterm" data-primary="ASCII" data-secondary="UTF-8 and" id="id4569"></a><a contenteditable="false" data-type="indexterm" data-primary="ASCII" data-secondary="Latin-1 and" id="id4570"></a><a contenteditable="false" data-type="indexterm" data-primary="Latin-1" id="id4571"></a>true because these encodings encode ASCII characters to bytes the same way as ASCII. That, in turn, makes these encodings backward compatible with existing ASCII data: every character string encoded per ASCII is also valid according to the Latin-1 and UTF-8 encodings, and every ASCII file is a valid Latin-1 and UTF-8 file.</p>
<p>Technically, the ASCII encoding is a 7-bit subset of the other two: it’s binary compatible with all character codes less than 128. Latin-1 and UTF-8 simply allow for additional characters: Latin-1 for characters mapped to values 128…255 within a byte, and UTF-8 for characters that may be represented with multiple bytes. The converse is not true, however: UTF-8 and Latin-1 text is not compatible with the ASCII encoding unless its text’s code-point values are all less than 128; otherwise, encoding or decoding per ASCII fails.</p>
<p class="pagebreak-before">In Python again, the mapping is easy to observe. Per the following, an ASCII character encodes to the same single byte in ASCII, UTF-8, and Latin-1 encodings, but non-ASCII characters do not, and require more general encodings than ASCII to encode at all (the <code>b'…'</code> here is the Python <code>bytes</code> object, which will soon play a leading role in this chapter):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>'a'.encode('ASCII')</strong> </code>         <code><em># ASCII encodes to the same byte</em></code> 
b'a'
&gt;&gt;&gt; <code><strong>'a'.encode('UTF-8')</strong></code>
b'a'
&gt;&gt;&gt; <code><strong>'a'.encode('Latin-1')</strong></code>
b'a'

&gt;&gt;&gt; <code><strong>'Ä'.encode('UTF-8')</strong></code>          <code><em># But non-ASCII requires more bytes</em></code>
b'\xc3\x84'
&gt;&gt;&gt; <code><strong>'<img src="assets/slightly-smiling-face_1f642.png" width="160" height="160"/>'.encode('UTF-8')</strong></code>         <code><em># And more inclusive encodings</em></code>
b'\xf0\x9f\x99\x82'

&gt;&gt;&gt; <code><strong>'<img src="assets/slightly-smiling-face_1f642.png" width="160" height="160"/>'.encode('ASCII')</strong></code>
UnicodeEncodeError: 'ascii' codec can't encode character '\U0001f642'…
&gt;&gt;&gt; <code><strong>'<img src="assets/slightly-smiling-face_1f642.png" width="160" height="160"/>'.encode('Latin-1')</strong></code>
UnicodeEncodeError: 'latin-1' codec can't encode character '\U0001f642'…</pre>
<p>Other encodings support richer character sets in other ways. For instance, <em>UTF-16</em> and <em>UTF-32</em> use a fixed and larger 2 and 4 bytes per character, respectively, the former <a contenteditable="false" data-type="indexterm" data-primary="UTF-16 encoding" id="id4572"></a><a contenteditable="false" data-type="indexterm" data-primary="UTF-32 encoding" id="id4573"></a>with a special <em>surrogate-pair</em> protocol for codes too large for 2 bytes. Both of these, along with UTF-8, may also allow or require a <em>BOM</em> (Byte Order Marker) preamble at the <a contenteditable="false" data-type="indexterm" data-primary="BOM (byte order marker)" id="id4574"></a>start of encoded text, which can designate byte order and encoding type, may be present in encoded text stored in files or memory, and is automatically handled for text-mode files.</p>
<p>We’ll skip further details here for space (watch for the BOM to drop at the end of this chapter, along with the thorny topic of Unicode normalization), but keep in mind that all of these—ASCII, Latin-1, UTF-8, and others—are simply alternative Unicode encodings that yield the same Unicode code-point text when decoded. The net effect ensures that text is <em>portable</em> across all the tools that use it in exchange for minor translation costs:</p>
<ul>
<li><p>When <em>decoded</em>, character code points may or may not occupy multiple bytes in memory, depending on programming-language implementation. Some recent Pythons, for example, use a variable-length scheme to store decoded text with 1, 2, or 4 bytes per character, depending on string content. Earlier Pythons instead store each character in a fixed 2 or 4 bytes, depending on compilation settings.</p></li>
<li><p>When <em>encoded</em>, the format of character code points is wholly determined by the standard Unicode encoding applied. This format is the same regardless of which programming language creates or processes the text, making it ideal for storage and transfer—especially in the diverse realm of the internet. This format is often less ideal for programs to use, though, which is why it’s normally decoded when loaded.</p></li>
</ul>
<p>To Python programmers, an encoding is specified as a string containing the encoding’s name. Python comes with roughly 100 different encodings out of the box; see the <code>codecs</code> module in the Python Library Reference for a list. Importing module <code>encodings</code> and asking for <code>help(encodings)</code> shows you many as well. Some encodings are implemented in Python, and some in C, and many have multiple names; for example, <code>latin-1</code>, <code>iso_8859_1</code>, and <code>8859</code> are all synonyms for the same encoding, <code>Latin-1</code>. We’ll revisit encodings later in this chapter when we study Unicode coding techniques.</p>
<p>For another take on the Unicode backstory, see <a contenteditable="false" data-type="indexterm" data-primary="Unicode" data-secondary="character encodings" data-startref="ucdcrct" id="id4575"></a>the Python standard manual at <em>python.org</em>. It includes a <a href="https://docs.python.org/3/howto/unicode.html">Unicode HOWTO section</a>, which provides additional minutiae that we will skip here to focus on the fundamentals.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Introducing Python String Tools"><div class="sect1" id="introducing_python_string_tools">
<h1>Introducing Python String Tools</h1>
<p>At a more concrete level, the Python language provides multiple string data types to represent content in your script: both <em>textual data</em>—integer code-point values of decoded Unicode <a contenteditable="false" data-type="indexterm" data-primary="textual data" id="id4576"></a><a contenteditable="false" data-type="indexterm" data-primary="binary data" id="id4577"></a>characters in <span class="keep-together">memory—as</span> well as <em>binary data</em>—raw byte values, including text that is in encoded form. All told, Python comes with three string object types:</p>
<ul>
<li><p><code>str</code>—for representing Unicode text (decoded code points)</p></li>
<li><p><code>bytes</code>—for representing binary data (including encoded text)</p></li>
<li><p><code>bytearray</code>—a mutable flavor of the <code>bytes</code> type</p></li>
</ul>
<p>All three types support similar operation sets but have very different roles and cannot generally be mixed because of this. Moreover, files and other content tools reflect the text/binary dichotomy, too, and use specific string types in different nodes. The next sections introduce the salient points of this model.</p>
<section data-type="sect2" data-pdf-bookmark="The str Object"><div class="sect2" id="the_str_object">
<h2>The str Object</h2>
<p>First up, the <a contenteditable="false" data-type="indexterm" data-primary="str object" id="id4578"></a><a contenteditable="false" data-type="indexterm" data-primary="objects" data-secondary="str" id="id4579"></a><a contenteditable="false" data-type="indexterm" data-primary="immutable sequence of characters, str type" id="id4580"></a>basic <code>str</code> type (e.g., <code>'text'</code>) is for decoded Unicode text. It’s formally defined as an <em>immutable sequence of characters</em>—which means code points that are not necessarily bytes. Its content may contain both simple text, such as ASCII, whose encoded and decoded forms might yield one byte per character, as well as richer Unicode text, whose encoded and decoded forms may both require multiple bytes per character.</p>
<p>In memory, a <code>str</code> is just an ordered collection of Unicode code-point integers, which <a contenteditable="false" data-type="indexterm" data-primary="glyphs" id="id4581"></a>print as <em>glyph</em>s—visual representations that may vary from host to host—of the characters that the code points represent. When transferred to and from files, a <code>str</code> is automatically encoded to and decoded from a sequence of bytes using either the host platform’s default or a provided encoding name to translate with an explicit scheme. <code>str</code> objects themselves, however, have <em>no notion of an encoding</em>; they are just character code points.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="The bytes Object"><div class="sect2" id="the_bytes_object">
<h2>The bytes Object</h2>
<p>While <code>str</code> is great for Unicode text, many programs need to process raw binary content that is not <a contenteditable="false" data-type="indexterm" data-primary="bytes object" id="id4582"></a><a contenteditable="false" data-type="indexterm" data-primary="objects" data-secondary="bytes" id="id4583"></a>encoded per any Unicode format—as well as the bytes used to store text when it is encoded. Image files and packed data you might process with Python’s <code>struct</code> module fall into this category. To accommodate this, the <code>bytes</code> type supports processing of truly binary data. <code>bytes</code> is just raw bytes, not Unicode-text characters, though its content may include the bytes of still-encoded text, which always has an implied encoding.</p>
<p>The <code>bytes</code> type is formally defined <a contenteditable="false" data-type="indexterm" data-primary="immutable sequence of 8-bit integers, bytes type" id="id4584"></a>as an <em>immutable sequence of 8-bit integers</em>. Its content represents byte values, and it supports almost all the same operations that the <code>str</code> type does; this includes string methods, sequence operations, and even <code>re</code> module pattern matching (formatting works on <code>bytes</code> today, too, but was added later in 3.X’s evolution).</p>
<p>A <code>bytes</code> object really is a sequence of small integers, each of which is in the range 0…255: indexing a <code>bytes</code> returns an <code>int</code>, slicing one returns another <code>bytes</code>, and running <code>list</code> on one returns a list of integers, not characters. However, when processed with operations that assume characters (e.g., the <code>isalpha</code> method), the contents of <code>bytes</code> objects are assumed to be ASCII-encoded bytes. Further, <code>bytes</code> items whose values fall in the range of ASCII character codes are printed as ASCII-character glyphs instead of integers or their hex escapes; this is done for convenience, though it may also confuse the distinction between text and binary data.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="The bytearray Object"><div class="sect2" id="the_bytearray_object-id00079">
<h2>The bytearray Object</h2>
<p>Though less commonly used, Python <a contenteditable="false" data-type="indexterm" data-primary="bytearray object" id="id4585"></a><a contenteditable="false" data-type="indexterm" data-primary="objects" data-secondary="bytearray" id="id4586"></a>also comes with <code>bytearray</code>, a variant of <code>bytes</code> that is <em>mutable</em> and so supports in-place changes. The <code>bytearray</code> type provides the usual string operations that <code>str</code> and <code>bytes</code> do but also has many of the same in-place change operations as lists (e.g., <code>append</code> and <code>extend</code> methods and assignment to indexes). Assuming your strings can be treated as raw bytes, <code>bytearray</code> adds direct in-place mutability for string data—something long prohibited by <code>str</code> and <code>bytes</code>.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Text and Binary Files"><div class="sect2" id="text_and_binary_files">
<h2>Text and Binary Files</h2>
<p>Because file I/O is one of the <a contenteditable="false" data-type="indexterm" data-primary="text files" id="txtfels"></a><a contenteditable="false" data-type="indexterm" data-primary="binary files" id="brflna"></a>main benefactors of encodings, it’s also a core Unicode tool. As we’ve seen, text is really just decoded integer character codes when it is in memory; it’s when text is transferred to and from <em>external interfaces</em> like files that Unicode encodings come into play. By contrast, truly binary data may have nothing at all to do with encodings—or text at all. Because of this, Python makes a sharp platform-independent distinction between text and binary files accessed with the built-in <code>open</code> <span class="keep-together">function</span>:</p>
<ul>
<li><p>When a file is opened in <em>text mode</em>, reading its data automatically decodes its content and returns it as a <code>st</code>r, and writing takes a <code>str</code> and automatically encodes it before transferring it to the file. In both cases, the encoding to use is either a platform default or a provided <code>encoding</code> argument to <code>open</code>. Text mode files also support universal newline (a.k.a. end-of-line) translation, BOMs, and other encoding arguments.</p></li>
<li><p>When a file is opened in <em>binary mode</em> by adding a <code>b</code> to the mode string argument in the <code>open</code> call, reading its data does not decode it in any way and simply returns its content raw and unchanged as a <code>bytes</code> object. Writing similarly takes a <code>bytes</code> object and transfers it to the file unchanged, and binary-mode files also accept a <code>bytearray</code> object for the content to be written to the file.</p></li>
</ul>
<p>Because <code>str</code> and <code>bytes</code> are sharply differentiated by the language this way, you must decide whether your data is text or binary in nature and use <code>str</code> or <code>bytes</code> objects to represent its content in your script, respectively. Ultimately, the mode in which you open a file will dictate which type of <em>object</em> your script will use to represent its content:</p>
<ul>
<li><p>If you are processing image or audio files, packed data created by other programs whose content you must extract, and some device data streams, chances are good that you will want to deal with it using <code>bytes</code> and binary-mode files. You might also opt for <code>bytearray</code> to update the data without making copies of it in memory.</p></li>
<li><p>If instead you are processing something that is textual in nature, such as program output, HTML or JSON content, and CVS or XML files, you probably want to use <code>str</code> and text-mode files.</p></li>
</ul>
<p>Subtly, the mode-string argument to <code>open</code> (its <code>mode</code> keyword and second positional argument) becomes fairly crucial—its content not only specifies a file processing <em>mode</em> but also implies a Python object <em>type</em>. By adding a <code>b</code> (lowercase only) to the mode string, you specify a binary mode file and will receive, or usually provide, a <code>bytes</code> object to represent the file’s content when reading or writing. Without the <code>b</code>, your file is processed in text mode, and you’ll use <code>str</code> objects to represent its content. For example, modes <code>rb</code>, <code>wb</code>, and <code>rb+</code> imply <code>bytes</code>, but <code>r</code>, <code>w+</code>, and <code>rt</code> (the default: read text) imply <code>str</code>.</p>
<p>If you’re anxious to see files in action, watch for the examples ahead, especially those of Unicode text files. To understand file usage in full, though, we first need to explore <a contenteditable="false" data-type="indexterm" data-primary="text files" data-startref="txtfels" id="id4587"></a><a contenteditable="false" data-type="indexterm" data-primary="binary files" data-startref="brflna" id="id4588"></a>string operations as they extend to Unicode and bytes.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Using Text Strings"><div class="sect1" id="using_text_strings">
<h1>Using Text Strings</h1>
<p>Let’s step through a few examples that demo the prior section’s string types live. Here, our primary focus is on using these types for text (we’ll explore binary roles later). Along the way, you’ll see how literals, conversions, and non-ASCII text are coded in Python.</p>
<section data-type="sect2" data-pdf-bookmark="Literals and Basic Properties"><div class="sect2" id="literals_and_basic_properties">
<h2>Literals and Basic Properties</h2>
<p>Most Python string objects are born when <a contenteditable="false" data-type="indexterm" data-primary="text strings" data-secondary="literals" id="txgltr"></a><a contenteditable="false" data-type="indexterm" data-primary="string literals" id="sgrtls"></a>you call a built-in function such as <code>str</code> or <code>bytes</code>, process a file created by calling <code>open</code>, or code literal syntax in your script. For the latter, the usual <code>'…'</code> makes a <code>str</code>; a unique literal form <code>b'…'</code> is used to create a <code>bytes</code>; and <code>bytearray</code> objects may be made by calling the same-named function with a variety of possible arguments.</p>
<p>More formally, all the usual string literal forms we met in <a data-type="xref" href="ch07.html#string_fundamentals">Chapter 7</a>—<code>'…'</code>, <code>"…"</code>, and triple-quoted blocks—generate a <code>str</code>; adding a <code>b</code> or <code>B</code> just before them creates a <code>bytes</code> instead. This <code>b'…'</code> (and equivalently, <code>B'…'</code>) bytes literal is similar in spirit to the <code>r'…'</code> raw string we’ve also met, which suppresses backslash escapes; in fact, the two prefixes can be combined to use backlashes verbatim in a <code>bytes</code>. Consider the following:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>B = b'code'</strong></code>                <code><em># Make a bytes object: 8-bit bytes</em></code>
&gt;&gt;&gt; <code><strong>S = 'hack'</strong></code>                 <code><em># Make a str object: Unicode characters</em></code>

&gt;&gt;&gt; <code><strong>type(B), type(S)</strong></code>
(&lt;class 'bytes'&gt;, &lt;class 'str'&gt;)

&gt;&gt;&gt; <code><strong>B</strong></code>                          <code><em># Sequence of ints, prints as ASCII characters</em></code>
b'code'
&gt;&gt;&gt; <code><strong>S</strong></code>                         <code><strong></strong> <em># Sequence of code points, prints as text glyphs</em></code>
'hack'

&gt;&gt;&gt; <code><strong>B2 = B"""</strong></code>                  <code><em># bytes prefix works on single, double, triple</em></code>
<code><strong>xxxx</strong></code>
<code><strong>yyyy</strong></code>
<code><strong>"""</strong></code>
&gt;&gt;&gt; <code><strong>B2</strong></code>
b'\nxxxx\nyyyy\n'

&gt;&gt;&gt; <code><strong>b'A\nB\rC', br'A\nB\rC', rb'A\nB\rC'</strong></code>    <code><em># Raw-string combos work too</em></code>
(b'A\nB\rC', b'A\\nB\\rC', b'A\\nB\\rC')</pre>
<p class="pagebreak-before">Once you have a string, all the usual operations we met earlier work, but their results are type specific (<code>bytes</code> is integers and <code>str</code> is characters), and immutability still applies:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>B, S</strong></code>
(b'code', 'hack')

&gt;&gt;&gt; <code><strong>B[0], S[0]</strong></code>                 <code><em># Indexing returns an int for bytes, str for str</em></code>
(99, 'h')

&gt;&gt;&gt; <code><strong>B[1:], S[1:]</strong></code>               <code><em># Slicing makes another bytes or str</em></code>
(b'ode', 'ack')

&gt;&gt;&gt; <code><strong>list(B), list(S)</strong></code>
([99, 111, 100, 101], ['h', 'a', 'c', 'k'])     <code><em># bytes is really ints</em></code>

&gt;&gt;&gt; <code><strong>B[0] = 'x'</strong></code>                                  <code><em># Both are immutable</em></code>
TypeError: 'bytes' object does not support item assignment
&gt;&gt;&gt; <code><strong>S[0] = 'x'</strong></code>
TypeError: 'str' object does not support item assignment</pre>
<p>Because they apply to more than text and have some unique behaviors, we’ll defer <code>bytearray</code> and more about <code>bytes</code> to a dedicated section later in this chapter.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><em>Blast from the past</em>: Python 3.X also recognizes Python 2.X’s Unicode string literals to ease migration of 2.X code: a 2.X <code>u'…'</code> literal in Python 3.X is just a synonym for a 3.X <code>'…' str</code> literal. This makes sense, given that 3.X’s <code>str</code> is all Unicode, and allows some 3.X code to run on 2.X and vice versa. In today’s 3.X world, though, there’s no compelling reason to use the <code>u'…'</code> literal anymore (unless you’re a fan of superfluous prefixes), but it may crop up in Python code you’ll encounter in <a contenteditable="false" data-type="indexterm" data-primary="text strings" data-secondary="literals" data-startref="txgltr" id="id4589"></a><a contenteditable="false" data-type="indexterm" data-primary="string literals" data-startref="sgrtls" id="id4590"></a>the wild. 2.X had a very long shelf life, after all.</p>
</div>
</div></section>
<section data-type="sect2" data-pdf-bookmark="String Type Conversions"><div class="sect2" id="string_type_conversions">
<h2>String Type Conversions</h2>
<p>Syntax aside, the first thing you <a contenteditable="false" data-type="indexterm" data-primary="text strings" data-secondary="type conversions" id="xtgypvs"></a><a contenteditable="false" data-type="indexterm" data-primary="type conversions, text strings" id="ypvxg"></a>might notice about Python strings is what they <em>cannot</em> do—<code>str</code> and <code>bytes</code> never mix automatically in expressions and generally are not converted to one another automatically when passed to functions. A function that expects an argument to be a <code>str</code> may not accept a <code>bytes</code> (and vice versa), and operators are fully rigid:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>'hack' + b'code'</strong></code>
TypeError: can only concatenate str (not "bytes") to str</pre>
<p>This is easier to understand if you remember that a text string may be radically different in its encoded and decoded forms, and Python has no idea what the content of a <code>bytes</code> is: if the <code>bytes</code> is encoded text, its encoding is unknown, but it may also be binary data (e.g., a loaded audio file) that has nothing to do with text at all.</p>

<p>Because of this ambiguity, Python basically requires that you either commit to one type or the other or perform manual, explicit conversions with the following tools (where <code>?</code> means optional):</p>
<dl>
<dt><code><em>S</em>.encode(<em>encoding?</em>)</code> and <code>bytes(<em>S</em>, <em>encoding</em>)</code></dt>
<dd>Encode a <code>str</code> object <code><em>S</em></code> to a new <code>bytes</code> per <code><em>encoding</em></code></dd>
<dt><code><em>B</em>.decode(<em>encoding?</em>)</code> and <code>str(<em>B</em>, <em>encoding</em>)</code></dt>
<dd>Decode a <code>bytes</code> object <code><em>B</em></code> to a new <code>str</code> per <code><em>encoding</em></code></dd>
</dl>
<p>Both the preceding <code><em>S</em>.encode()</code> and <code><em>B</em>.decode(</code>) methods and the file <code>open</code> call we’ll explore ahead use either an explicitly passed-in encoding name or a default. The methods’ default is always UTF-8 (by contrast, <code>open</code> uses a value in the <code>locale</code> module you’ll meet shortly that may vary per platform, settings, and run and should usually be avoided):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>S = 'hack'</strong></code>
&gt;&gt;&gt; <code><strong>S.encode()</strong></code>                     <code><em># str to bytes: encode text into raw bytes</em></code>
b'hack'

&gt;&gt;&gt; <code><strong>bytes(S, encoding='ascii')</strong></code>     <code><em># str to bytes, alternative</em></code>
b'hack'

&gt;&gt;&gt; <code><strong>B = b'code'</strong></code>
&gt;&gt;&gt; <code><strong>B.decode()</strong></code>                     <code><em># bytes to str: decode raw bytes into text</em></code>
'code'

&gt;&gt;&gt; <code><strong>str(B, encoding='ascii')</strong></code>       <code><em># bytes to str, alternative</em></code>
'code'</pre>
<p>Putting this together solves our original type error and allows us to mix strings and bytes as either encoded or decoded text:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>S, B</strong></code>
('hack', b'code')

&gt;&gt;&gt; <code><strong>S.encode('ascii') + B</strong></code>          <code><em># bytes + bytes (encoded)</em></code>
b'hackcode'

&gt;&gt;&gt; <code><strong>S + B.decode('ascii')</strong></code>          <code><em># str + str (code points)</em></code>
'hackcode'</pre>
<p>A few cautions on defaults here. First of all, the encoding argument to <code>bytes</code> is <em>not optional</em>, even though it is in <code><em>S</em>.encode()</code> (and <code><em>B</em>.decode()</code>). More subtly, although <code>str</code> does not require the encoding argument like <code>bytes</code> does, leaving it off in <code>str</code> calls does not mean it defaults—instead, due to Python history, a <code>str</code> without an encoding returns the <code>bytes</code> object’s <em>print string</em>, not its decoded and converted <code>str</code> form (this is usually not what you’ll want!).</p>

<p>Assuming again that <code>B</code> and <code>S</code> are still as in the prior listing:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>bytes(S)</strong></code>
TypeError: string argument without an encoding

&gt;&gt;&gt; <code><strong>str(B)</strong></code>                               <code><em># str() works without encoding</em></code>
"b'code'"                                <code><em># But print string, not conversion!</em></code>
&gt;&gt;&gt; <code><strong>len(str(B))</strong></code>
7

&gt;&gt;&gt; <code><strong>len(str(B, encoding='ascii'))</strong></code>        <code><em># Pass encoding to convert to str</em></code>
4</pre>
<p>Also in the defaults department, your platform’s various default encodings are available in the <code>sys</code> and <code>locale</code> modules but aren’t as trustworthy as you might think:</p>
<pre class="pagebreak-before" data-type="programlisting">$ <code><strong>py -3</strong></code>
&gt;&gt;&gt; <code><strong>import sys, locale</strong></code>
&gt;&gt;&gt; <code><strong>sys.platform</strong></code>                         <code><em># Underlying platform: Windows</em></code>
'win32'
&gt;&gt;&gt; <code><strong>sys.getdefaultencoding()</strong></code>             <code><em># Methods default (but not for str()!)</em></code>
'utf-8'
&gt;&gt;&gt; <code><strong>locale.getpreferredencoding(False)</strong>   <em># open() default: a Latin-1 superset</em></code>
'cp1252'</pre>
<p>As shown, the <code>open</code> function’s default file encoding lives in the <code>locale</code> module. On the PC used for Windows examples in this chapter, it’s <em>cp1252</em>—a superset of Latin-1 that adds characters like slanted quotes. Defaults may differ, however, on other <em>platforms</em> and technically can even depend on environment-variable settings, command-line arguments, and settings on individual host machines.</p>

<p>For example, here’s the differing case on this chapter’s macOS host—like most Unix platforms, its <code>open</code> defaults to <em>UTF-8</em>:</p>
<pre class="widows8" data-type="programlisting">$ <code><strong>python3</strong></code>
&gt;&gt;&gt; <code><strong>import sys, locale</strong></code>
&gt;&gt;&gt; <code><strong>sys.platform</strong></code>                         <code><em># Underlying platform: macOS</em></code>
'darwin'
&gt;&gt;&gt; <code><strong>sys.getdefaultencoding()</strong></code>             <code><em># The default for methods is same</em></code>
'utf-8'
&gt;&gt;&gt; <code><strong>locale.getpreferredencoding(False)</strong></code>   <code><em># But this differs on Unix: be explicit!</em></code>
'utf-8'</pre>
<p>Besides such program-host differences, keep in mind that text <em>content</em> you receive from disparate sources might also use any Unicode encoding at all, making your host’s default a moot point. Hence, your programs shouldn’t generally rely on <code>open</code> defaults if they may need to care about portability now or in the future—always pass an explicit encoding to <code>open</code> when interoperability counts. We’ll revisit encoding defaults and learn how to provide an explicit encoding to <code>open</code> when we explore Unicode files later in this chapter.</p>
<p>Having said all that, it’s important to also note that encoding and decoding are substantially more than simple programming-language type conversions; really, they produce very different kinds of data. Encoding returns the bytes that result from transforming a text string per a Unicode scheme, and decoding returns the text string that is produced by undoing that transformation. While this is a conversion <a contenteditable="false" data-type="indexterm" data-primary="text strings" data-secondary="type conversions" data-startref="xtgypvs" id="id4591"></a><a contenteditable="false" data-type="indexterm" data-primary="type conversions, text strings" data-startref="ypvxg" id="id4592"></a>of sorts, and the mapping may seem trivial for simple text like ASCII, Unicode tends to make much more sense if you avoid blurring the distinction—especially for richer types of text like that in the next section.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Coding Unicode Strings in Python"><div class="sect2" id="coding_unicode_strings_in_python">
<h2>Coding Unicode Strings in Python</h2>
<p>Encoding and decoding grow <a contenteditable="false" data-type="indexterm" data-primary="text strings" data-secondary="Unicode text" id="xgrsucdx"></a><a contenteditable="false" data-type="indexterm" data-primary="Unicode" data-secondary="strings, coding" id="ucsgcd"></a>more meaningful when you start dealing with non-ASCII Unicode text. To code Unicode characters that may be difficult to type on your keyboard, Python string literals support both:</p>
<ul>
<li><p><code>\x<em>NN</em></code> hex escapes, where two hex digits (<code><em>NN</em></code>) specify a character code as a 1-byte (8-bit) numeric value</p></li>
<li><p><code>\u<em>NNNN</em></code> and <code>\U<em>NNNNNNNN</em></code> Unicode escapes, where the first <em>lowercase</em> form gives 4 hex digits to denote a 2-byte (16-bit) character code, and the second <em>uppercase</em> form gives 8 hex digits for a <span class="keep-together">4-byte</span> (32-bit) code</p></li>
</ul>
<p>Importantly, in <code>str</code> objects, all three of these escapes are used to give a Unicode character’s <em>code-point</em> value—not its encoded bytes. By contrast, <code>bytes</code> objects <a contenteditable="false" data-type="indexterm" data-primary="Unicode" data-secondary="code points" data-tertiary="value" id="id4593"></a><a contenteditable="false" data-type="indexterm" data-primary="code points" data-secondary="Unicode" data-tertiary="value" id="id4594"></a>allow only hex escapes for byte values; for text, this gives its <em>encoded form</em>—not its decoded code points.</p>
<p>Let’s see how this all translates to code. Simple 7-bit <em>ASCII</em> text is formatted with one character per byte under most of the encoding schemes described near the start of this chapter (again, this is why ASCII passes as a binary-compatible subset of many other schemes):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>ord('X')</strong></code>                <code><em># Character 'X' has code-point value 88</em></code> 
88
&gt;&gt;&gt; <code><strong>chr(88)</strong></code>                 <code><em># Code-point 88 stands for character 'X'</em></code>
'X'

&gt;&gt;&gt; <code><strong>S = 'XYZ'</strong></code>               <code><em># str: code points display as their character glyphs</em></code>
&gt;&gt;&gt; <code><strong>S</strong></code>
'XYZ'
&gt;&gt;&gt; <code><strong>len(S)</strong></code>                  <code><em># 3 characters (not necessarily bytes) long</em></code>
3

&gt;&gt;&gt; <code><strong>S.encode('ascii')</strong></code>       <code><em># Values 0…127 in 1 byte each (ASCII shown as chars)</em></code>
b'XYZ'
&gt;&gt;&gt; <code><strong>S.encode('latin-1')</strong></code>     <code><em># Values 0…255 in 1 byte each</em></code>
b'XYZ'
&gt;&gt;&gt; <code><strong>S.encode('utf-8')</strong></code>       <code><em># Values 0…127 in 1 byte, 128…2047 in 2, others 3~4</em></code>
b'XYZ'</pre>
<p>By contrast, the less <a contenteditable="false" data-type="indexterm" data-primary="UTF-16 encoding" id="id4595"></a><a contenteditable="false" data-type="indexterm" data-primary="UTF-32 encoding" id="id4596"></a>common <em>UTF-16</em> and <em>UTF-32</em> use 2 and 4 bytes for every character, respectively, even for simple text like ASCII. This makes these encodings’ data fast to process but may consume extra space and bandwidth, which renders them subpar in some applications. In the following, ASCII bytes print as characters, non-ASCIIs print as <code>\x<em>NN</em></code> escapes, padding bytes follow text, and each result has a 2- or 4-byte BOM header at the front whose details we’re largely ignoring here (again, stay tuned for more on BOMs near the end of this chapter):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>S</strong></code>
'XYZ'

&gt;&gt;&gt; <code><strong>S.encode('utf-16')</strong></code>      <code><em># Always 2 or 4 bytes per character, with BOM header</em></code>
b'\xff\xfeX\x00Y\x00Z\x00'

&gt;&gt;&gt; <code><strong>S.encode('utf-32')</strong></code>
b'\xff\xfe\x00\x00X\x00\x00\x00Y\x00\x00\x00Z\x00\x00\x00'</pre>
<p>To code <em>non-ASCII</em> characters, you can use hex and Unicode escapes in your strings. The numeric values coded <a contenteditable="false" data-type="indexterm" data-primary="hex escapes" id="id4597"></a><a contenteditable="false" data-type="indexterm" data-primary="Unicode" data-secondary="escapes" id="id4598"></a>as hexadecimal literals <code>0xC4</code> and <code>0xE8</code>, for instance, are the Unicode code points used to represent two special characters outside the 7-bit range of ASCII; we can embed them in <code>str</code> objects anyhow because <code>str</code> supports Unicode in full:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>chr(0xc4)</strong></code>               <code><em># 0xC4 and 0xE8 are accented characters outside ASCII</em></code>
'Ä'
&gt;&gt;&gt; <code><strong>chr(0xe8)</strong></code>
'è'

&gt;&gt;&gt; <code><strong>S = '\xc4\xe8'</strong></code>          <code><em># Hex escapes: code-point values, not encoded bytes</em></code>
&gt;&gt;&gt; <code><strong>S</strong></code>
'Äè'

&gt;&gt;&gt; <code><strong>S = '\u00c4\u00e8'</strong></code>      <code><em># Unicode escapes: 16-bits (2-bytes)</em></code>
&gt;&gt;&gt; <code><strong>S</strong></code>
'Äè'
&gt;&gt;&gt; <code><strong>len(S</strong></code>)                  <code><em># 2 characters long (not number of bytes!)</em></code>
2</pre>
<p>Now, if we try to encode a non-ASCII string like this to raw bytes as ASCII, we’ll get an error. Encoding as Latin-1 works, though, and allocates 1 byte per character; encoding as UTF-8 allocates 2 bytes per character instead. If you write this string to a text-mode file, the raw bytes shown are what is actually stored on the file for the encoding types given:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>S = '\u00c4\u00e8'</strong></code> 
&gt;&gt;&gt; <code><strong>S.encode('ascii')</strong></code>
UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: 
ordinal not in range(128)

&gt;&gt;&gt; <code><strong>S.encode('latin-1')</strong></code>              <code><em># 1 byte per character</em></code>
b'\xc4\xe8'

&gt;&gt;&gt; <code><strong>S.encode('utf-8')</strong></code>                <code><em># 2 bytes per character</em></code>
b'\xc3\x84\xc3\xa8'

&gt;&gt;&gt; <code><strong>len(S.encode('latin-1'))</strong></code>         <code><em># 2 bytes in latin-1, 4 in utf-8</em></code>
2
&gt;&gt;&gt; <code><strong>len(S.encode('utf-8'))</strong></code>
4</pre>
<p>You can also go <a contenteditable="false" data-type="indexterm" data-primary="Unicode" data-secondary="raw bytes" id="id4599"></a><a contenteditable="false" data-type="indexterm" data-primary="raw bytes" id="id4600"></a>the other way—from raw bytes back to a Unicode string. You could read raw bytes from a file and decode manually this way, but the encoding mode you give to the <code>open</code> call causes this decoding to be done for you automatically (and avoids issues that may arise from reading partial character sequences when reading by blocks of bytes):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>B = b'\xc4\xe8'</strong></code>
&gt;&gt;&gt; <code><strong>B</strong></code>
b'\xc4\xe8'
&gt;&gt;&gt; <code><strong>len(B)</strong></code>                             <code><em># 2 raw bytes, 2 characters</em></code>
2
&gt;&gt;&gt; <code><strong>B.decode('latin-1')</strong></code>                <code><em># Decode to latin-1 text</em></code>
'Äè'

&gt;&gt;&gt; <code><strong>B = b'\xc3\x84\xc3\xa8'</strong></code>
&gt;&gt;&gt; <code><strong>len(B)</strong></code>                             <code><em># 4 raw bytes</em></code>
4
&gt;&gt;&gt; <code><strong>B.decode('utf-8')</strong></code>
'Äè'
&gt;&gt;&gt; <code><strong>len(B.decode('utf-8'))</strong></code>             <code><em># 2 Unicode characters</em></code>
2</pre>
<p>When needed, you can also specify both 16- and 32-bit Unicode code-point values for characters in your <code>str</code> strings: use <code>\u…</code> with 4 hex digits for the former and <code>\U…</code> with 8 hex digits for the latter. As the last example in the following shows, you can also build such strings up piecemeal using <code>chr</code>, but it might become tedious for large strings:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>S = 'A\u00c4B\U000000e8C'</strong></code>
&gt;&gt;&gt; <code><strong>S</strong></code>                                  <code><em># A, B, C, and 2 non-ASCII characters</em></code>
'AÄBèC'
&gt;&gt;&gt; <code><strong>len(S)</strong></code>                             <code><em># 5 characters long</em></code>
5

&gt;&gt;&gt; <code><strong>S.encode('latin-1')</strong></code>
b'A\xc4B\xe8C'
&gt;&gt;&gt; <code><strong>len(S.encode('latin-1'))</strong></code>           <code><em># 5 bytes in latin-1</em></code>
5

&gt;&gt;&gt; <code><strong>S.encode('utf-8')</strong></code>
b'A\xc3\x84B\xc3\xa8C'
&gt;&gt;&gt; <code><strong>len(S.encode('utf-8'))</strong></code>             <code><em># 7 bytes in utf-8</em></code>
7

&gt;&gt;&gt; <code><strong>S.encode('cp500')</strong></code>                  <code><em># Two other Western European encodings</em></code>
b'\xc1c\xc2T\xc3'
&gt;&gt;&gt; <code><strong>S.encode('cp850')</strong></code>                  <code><em># 5 bytes each</em></code>
b'A\x8eB\x8aC'

&gt;&gt;&gt; <code><strong>S = 'code'</strong></code>                         <code><em># ASCII text is the same in most</em></code>
&gt;&gt;&gt; <code><strong>S.encode('latin-1')</strong></code>
b'code'
&gt;&gt;&gt; <code><strong>S.encode('utf-8')</strong></code>
b'code'
&gt;&gt;&gt; <code><strong>S.encode('cp500')</strong></code>                  <code><em># But not in cp500: IBM ebcdic</em></code>
b'\x83\x96\x84\x85'
&gt;&gt;&gt; <code><strong>S.encode('cp850')</strong></code>
b'code'

&gt;&gt;&gt; <code><strong>S = 'A' + chr(0xC4) + 'B' + chr(0xE8) + 'C'</strong></code>    <code><em># str the hard way</em></code>
&gt;&gt;&gt; <code><strong>S</strong></code>
'AÄBèC'</pre>
<p>Another distinction to keep in mind: Python allows special characters’ code points to be coded <a contenteditable="false" data-type="indexterm" data-primary="code points" data-secondary="Unicode" data-tertiary="escapes" id="id4601"></a>with both hex and Unicode escapes in <code>str</code> string literals but allows only <em>hex</em> escapes in <code>bytes</code> literals—and prints a warning in its recent versions if you violate this rule. In fact, Unicode escape sequences are taken <em>verbatim</em> in <code>bytes</code> and not as escapes.</p>
<p>This makes sense if you remember that <code>bytes</code> objects hold binary data, both textual and not. When they contain text, they hold characters’ <em>encoded</em> bytes—not their decoded code points. Thus, Unicode code-point escapes simply don’t apply to <code>bytes</code>, and hex escapes in their literals yield raw byte values, not characters.</p>
<p>This is true even though code-point and encoded-byte values happen to be the same for some characters in some encodings (confusingly!). Because <code>bytes</code> are not code points, they also must be decoded to <code>str</code> to print their non-ASCII characters properly:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>S = 'A\xC4B\xE8C'</strong></code>            <code><em># str recognizes hex and Unicode escapes</em></code>
&gt;&gt;&gt; <code><strong>S</strong></code>
'AÄBèC'

&gt;&gt;&gt; <code><strong>S = 'A\u00C4B\U000000E8C'</strong></code>    <code><em># 4- and 8-digit Unicode escapes (str only)</em></code>
&gt;&gt;&gt; S
'AÄBèC'

&gt;&gt;&gt; <code><strong>B = b'A\xC4B\xE8C'</strong></code>           <code><em># bytes recognizes hex escapes, but not Unicode</em></code>
&gt;&gt;&gt; <code><strong>B</strong></code>
b'A\xc4B\xe8C'

&gt;&gt;&gt; <code><strong>B = b'A\u00C4B\U000000E8C'</strong></code>   <code><em># Unicode escape sequences taken literally!</em></code>
&lt;stdin&gt;:1: SyntaxWarning: invalid escape sequence '\u'
&gt;&gt;&gt; <code><strong>B</strong></code>                            <code><em># bytes is encoded bytes, not code points</em></code>
b'A\\u00C4B\\U000000E8C'

&gt;&gt;&gt; <code><strong>B = b'A\xC4B\xE8C'</strong></code>           <code><em># Use hex escapes for latin-1 bytes</em></code>
&gt;&gt;&gt; <code><strong>B</strong></code>                            <code><em># Prints non-ASCII bytes as hex</em></code> 
b'A\xc4B\xe8C'
&gt;&gt;&gt; <code><strong>print(B)</strong> </code>                    <code><em># For both interactive and print()</em></code>
b'A\xc4B\xe8C'
&gt;&gt;&gt; <code><strong>B.decode('latin-1')</strong></code>          <code><em># Decode to str to interpret as text</em></code> 
'AÄBèC'</pre>
<p>Finally, notice that <code>bytes</code> literals assume that textual characters embedded within them are ASCII and require escapes for byte values &gt; 127. By contrast, <code>str</code> literals in code like that in the following allow embedding any character supported by the source code encoding of the hosting file or GUI (as you’ll learn in a moment, the encoding used for code defaults to UTF-8, sans declarations in the code’s file):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>S = 'AÄBèC'</strong></code>                  <code><em># Chars from UTF-8 if no encoding declaration</em></code>
&gt;&gt;&gt; <code><strong>S </strong>  </code>                         <code><em># Decoded to str when code is read by Py</em></code>
'AÄBèC'

&gt;&gt;&gt; <code><strong>B = b'AÄBèC'</strong></code>
SyntaxError: bytes can only contain ASCII literal characters.

&gt;&gt;&gt; <code><strong>B = b'A\xC4B\xE8C'</strong></code>           <code><em># Chars must be ASCII, or hex escapes</em></code>
&gt;&gt;&gt; <code><strong>B</strong></code>                            <code><em># Non-ASCIIs are latin-1 encoded bytes</em></code>
b'A\xc4B\xe8C'
&gt;&gt;&gt; <code><strong>B.decode('latin-1')</strong></code>
'AÄBèC'

&gt;&gt;&gt; <code><strong>S.encode()</strong></code>                   <code><em># Source code encoded per UTF-8 by default</em></code> 
b'A\xc3\x84B\xc3\xa8C'           <code><em># Methods use UTF-8 to encode, unless passed</em></code>
&gt;&gt;&gt; <code><strong>S.encode('utf-8')</strong></code>
b'A\xc3\x84B\xc3\xa8C'
&gt;&gt;&gt; <code><strong>B.decode()</strong></code>                   <code><em># Raw bytes do not correspond to utf-8</em></code>
UnicodeDecodeError: 'utf-8' codec can't decode byte 0xc4 in position 1:…

&gt;&gt;&gt; <code><strong>S = 'AÄBèC'</strong></code>
&gt;&gt;&gt; <code><strong>S.encode()</strong></code>                   <code><em># Method's default utf-8 encoding</em></code>
b'A\xc3\x84B\xc3\xa8C'
&gt;&gt;&gt;
&gt;&gt;&gt; <code><strong>T = S.encode('cp500')</strong></code>        <code><em># "Convert" to EBCDIC bytes</em></code>
&gt;&gt;&gt; <code><strong>T</strong></code>
b'\xc1c\xc2T\xc3'
&gt;&gt;&gt;
&gt;&gt;&gt; <code><strong>U = T.decode('cp500')</strong></code>        <code><em># Back to Unicode code points</em></code>
&gt;&gt;&gt; <code><strong>U</strong></code>
'AÄBèC'
&gt;&gt;&gt;
&gt;&gt;&gt; <code><strong>U.encode()</strong></code>                   <code><em># Back to UTF-8 bytes, by default</em></code>
b'A\xc3\x84B\xc3\xa8C'</pre>
<p>Notice how the last part of the preceding code seems to “convert” encodings from UTF-8 to cp500 and back again. Really, this just creates different encoded representations of the same Unicode code points, but this pattern can be used to translate encoded text when needed. Text in a file, for instance, can be re-encoded with a decode (to <code>str</code>) plus an encode (to <code>bytes</code>) combination that changes its stored encoding; as you’ll see ahead, the <code>open</code> function does most of this work for you.</p>
<p>Also, note how the preceding code is able to use a <code>str</code> literal <code>'AÄBèC'</code> with raw Unicode characters for its non-ASCII characters. This is noticeably simpler than coding <a contenteditable="false" data-type="indexterm" data-primary="text strings" data-secondary="Unicode text" data-startref="xgrsucdx" id="id4602"></a><a contenteditable="false" data-type="indexterm" data-primary="Unicode" data-secondary="strings, coding" data-startref="ucsgcd" id="id4603"></a>escapes and works as long as your code file (and GUI) support it, as the next section will explain.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Source-File Encoding Declarations"><div class="sect2" id="source_file_encoding_declarations">
<h2>Source-File Encoding Declarations</h2>
<p>Unicode escapes suffice for the occasional Unicode character in string literals, but they can become tedious if <a contenteditable="false" data-type="indexterm" data-primary="string literals" data-secondary="UTF-8 encoding" id="id4604"></a><a contenteditable="false" data-type="indexterm" data-primary="UTF-8 encoding" data-secondary="string literals" id="id4605"></a><a contenteditable="false" data-type="indexterm" data-primary="encoding" data-secondary="source files" id="cncesrcfl"></a>you need to code non-ASCII text in your strings frequently. For string literals and other text that you embed in your script files (or paste into your coding GUI), Python uses the <em>UTF-8</em> encoding by default to read your code’s text but allows you to change this per file to use an arbitrary encoding. With this support, your code can directly embed any unescaped characters that the chosen encoding <span class="keep-together">supports</span>.</p>
<p>To make this work, simply use Python’s default UTF-8 encoding to save your source code file in your text editor, or include a comment that names the Unicode encoding that you used for the save if it differs. This special encoding-declaration comment must appear as either the first or second line in your script (e.g., a <code>#!</code> line works before it: see <a data-type="xref" href="app01.html#appendix_a_platform_usage_tips">Appendix A</a>) and is usually of the following form (see Python’s manuals for other forms it accepts):</p>
<pre data-type="programlisting"># -*- coding: latin-1 -*-</pre>
<p>When present, Python will recognize text in your code represented natively (unescaped) in the given encoding. That way, you can edit your script file in a text editor that accepts, displays, and saves <span class="keep-together">accented</span> and other non-ASCII characters, and Python will correctly decode them when reading your string literals and other program-file text.</p>
<p>For example, notice the <code>coding</code> comment at the top of <a data-type="xref" href="#example_threeseven_onedot_source_encodi">Example 37-1</a>: when this file is saved in the nondefault Latin-1 encoding, it allows Python to recognize Latin-1 characters embedded in the string literal to be assigned to <code>myStr1</code> in the text of the source file. This file also neatly summarizes the various ways to code non-ASCII text in Python.</p>
<div data-type="example" id="example_threeseven_onedot_source_encodi">
<h5><span class="label">Example 37-1. </span>source-encoding-latin1.py</h5>
</div>
<pre data-type="programlisting">
# -*- coding: Latin-1 -*-

#----------------------------------------------------------------------------
# Demo all the ways to code non-ASCII text in Python, plus source encodings.
#
# If this file is saved as Latin-1 text, it works as is.  But changing the 
# coding line above to either ASCII or UTF-8 will then fail because the 
# Latin-1 0xc4 and 0xe8 saved in myStr1's value are not valid in either.
#
# A UTF-8 line works if this file is also saved as UTF-8 to make its mystr1 
# text match.  Because UTF-8 is the default for source, the line above is 
# optional if the file is saved as UTF-8 or its text is all UTF-8 compatible
# (e.g., ASCII, which is a subset of both the Latin-1 and UTF-8 encodings).
#----------------------------------------------------------------------------

myStr1 = 'AÄBèC'                                      <em># Raw, per source encoding</em>

myStr2 = 'A\xc4B\xe8C'                                <em># Hex code-point escapes</em>

myStr3 = 'A\u00c4B\U000000e8C'                        <em># Unicode short/long escapes</em>

myStr4 = 'A' + chr(0xC4) + 'B' + chr(0xE8) + 'C'      <em># Concatenated code points</em>

import sys, locale
print('Sys hosting platform: ', sys.platform)
print('Sys default encoding: ', sys.getdefaultencoding())
print('Open default encoding:', locale.getpreferredencoding(False))

for aStr in (myStr1, myStr2, myStr3, myStr4):
    print(f'{aStr}, strlen={len(aStr)}', end=', ')    <em># Decoded text+length</em>

    bytes1 = aStr.encode()               <em># Default UTF-8: 2 bytes for accents</em>
    bytes2 = aStr.encode('latin-1')      <em># Explicit Latin-1: 1 byte per char </em>
   #bytes3 = aStr.encode('ascii')        <em># ASCII fails: outside 0...127 range</em>

    print(f'byteslen1={len(bytes1)}, byteslen2={len(bytes2)}')   <em># Encoded length</em></pre>
<p>After saving this file in a text editor with encoding Latin-1 (or its default cp1252 superset on some Windows), running it as a script prints its four strings, their character code-point lengths, and their byte lengths in two encodings that work—the <code>encode</code> method’s default UTF-8, and an explicit Latin-1 (ASCII is too narrow to use). The Python default encodings it also prints may vary across host platforms, but the rest of the output will not:</p>
<pre data-type="programlisting">$ <code><strong>python3 source-encoding-latin1.py</strong></code>
Sys hosting platform:  darwin
Sys default encoding:  utf-8
Open default encoding: UTF-8
AÄBèC, strlen=5, byteslen1=7, byteslen2=5
AÄBèC, strlen=5, byteslen1=7, byteslen2=5
AÄBèC, strlen=5, byteslen1=7, byteslen2=5 
AÄBèC, strlen=5, byteslen1=7, byteslen2=5</pre>
<p>To change this file to use UTF-8 instead, first save it with the UTF-8 encoding in your text editor or by running Python code like the following to make its embedded literal match (you’ll learn how and why this code works when we explore Unicode text files ahead):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>text = open('source-encoding-latin1.py', encoding='latin1').read()</strong></code>
&gt;&gt;&gt; <code><strong>open('source-encoding-utf8.py', 'w', encoding='utf8').write(text)</strong></code></pre>
<p>Then, either mod its first line to name UTF-8, or delete the first line altogether (UTF-8 is Python’s default for source code). After you’re done, the only difference in the two versions of the source file will be the way the embedded Unicode literal is rendered on your platform; here’s the verdict on the UTF-8-centric macOS using its <code>diff</code> to compare (use <code>fc</code> instead on Windows):</p>
<pre data-type="programlisting">$ <code><strong>diff source-encoding-latin1.py source-encoding-utf8.py</strong></code>
1c1
&lt; # -*- coding: Latin-1 -*-
---
&gt; # -*- coding: UTF-8 -*-
13c13
&lt; myStr1 = 'A?B?C'
---
&gt; myStr1 = 'AÄBèC'

$ <code><strong>python3 source-encoding-utf8.py</strong></code>    <code><em># Same output as Latin-1 version above</em></code></pre>
<p>Since most programmers are likely to fall back on the default and general (really, <em>universal</em>) UTF-8 encoding in Python, we’ll defer to Python’s standard <a href="https://docs.python.org/3">manual set</a> for more details on this option, as well as its more advanced and obscure Unicode support such as properties and character-name escapes in strings that we’ll skip here.</p>
<div data-type="note" epub:type="note" id="variable_names_note"><h6>Note</h6>
<p><em>Unicode in variable names</em>: Source-file encoding declarations apply to a file’s content in general and support arbitrary kinds of text. The rules for variable names within a file’s code, however, are more stringent.</p>
<p>As noted briefly in <a data-type="xref" href="ch11.html#assignmentscomma_expressionscomma_and_p">Chapter 11</a>, Python allows some, but not all, non-ASCII Unicode characters to be used for variables in your code. Roughly, number- and letter-like characters work, but symbols and emojis are not allowed. For instance, <code>hÄck</code> is a valid variable, but <code>hÄck<img src="assets/snake_1f40d.png" width="160" height="160"/></code> is not. You can check whether a specific string passes as a variable with the <code>isidentifier</code> method of <code>str</code>, but the rules behind this are complex and best had in Python’s language manual.</p>
<p>Also, keep in mind that, even when valid, non-ASCIIs in variables may make your code difficult to use on some keyboards and devices outside a given language’s locale. In fact, all code in <a contenteditable="false" data-type="indexterm" data-primary="encoding" data-secondary="source files" data-startref="cncesrcfl" id="id4606"></a>the Python standard library must use ASCII-only identifiers for this reason. As usual, use with care.</p>
</div>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Using Byte Strings"><div class="sect1" id="using_byte_strings">
<h1>Using Byte Strings</h1>
<p>We’ll be able to see strings in action <a contenteditable="false" data-type="indexterm" data-primary="byte strings" id="id4607"></a>again when we study files ahead. First, though, let’s take a brief side trip to dig a bit deeper into the operation sets provided by objects geared for binary data—the <code>bytes</code> type and its <code>bytearray</code> mutable kin. While these types can be used to hold encoded text too (as in prior sections), their scope is much broader: anything that can be stored as bytes works, and that’s everything digital.</p>
<p>As mentioned earlier, Python’s <code>bytes</code> type supports sequence operations and most of the same methods available on <code>str</code>. Even so, because you cannot mix and match <code>bytes</code> and <code>str</code> without explicit conversions, you’ll generally use <code>str</code> objects and text files for text data and <code>bytes</code> objects and binary files for binary data. This makes <code>bytes</code> a crucial tool in many roles and worthy of a quick demo here.</p>
<section data-type="sect2" data-pdf-bookmark="Methods"><div class="sect2" id="methods-id000102">
<h2>Methods</h2>
<p>If you really want to see what <a contenteditable="false" data-type="indexterm" data-primary="byte strings" data-secondary="methods" id="id4608"></a><a contenteditable="false" data-type="indexterm" data-primary="methods" data-secondary="byte strings" id="id4609"></a>attributes <code>str</code> has that <code>bytes</code> doesn’t, you can always check their <code>dir</code> results (review: <code>set(<em>X</em>)–set(<em>Y</em>)</code> is items in <code><em>X</em></code> but not in <code><em>Y</em></code>). This can also tell you something about the expression operators they support (e.g., <code>__mod__</code> and <code>__rmod__</code> implement the <code>%</code> operator, and they’re present in both today):</p>
<pre data-type="programlisting">$ <code><strong>python3</strong></code>
Python 3.12.2 (v3.12.2:6abddd9f6a, Feb  6 2024,…

<code><em># Attributes unique to str</em></code>

&gt;&gt;&gt; <code><strong>sorted(set(dir('abc')) - set(dir(b'abc')))</strong></code>
['casefold', 'encode', 'format', 'format_map', 'isdecimal', 'isidentifier', 
'isnumeric', 'isprintable']

<code><em># Attributes unique to bytes</em></code>

&gt;&gt;&gt; <code><strong>sorted(set(dir(b'abc')) - set(dir('abc')))</strong></code>
['__buffer__', '__bytes__', 'decode', 'fromhex', 'hex']</pre>
<p>As you can see, <code>str</code> and <code>bytes</code> have almost identical functionality; their unique attributes are generally methods that don’t apply to the other (<code>format</code> is an outlier you’ll meet shortly). For instance, <code>decode</code> translates a raw <code>bytes</code> into its <code>str</code> representation, and <code>encode</code> translates a <code>str</code> into its raw <code>bytes</code> <span class="keep-together">representation</span>. Most other methods are shared between the two types. Moreover, <code>bytes</code> are immutable just like <code>str</code>:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>B = b'code'</strong></code>                    <code><em># b'…' bytes literal</em></code>
&gt;&gt;&gt; <code><strong>B.find(b'od')</strong>   </code>               <code><em># Search for substr offset</em></code>
1

&gt;&gt;&gt; <code><strong>B.replace(b'od', b'XY')</strong>   </code>     <code><em># New bytes with replacement</em></code>
b'cXYe'
&gt;&gt;&gt; <code><strong>B</strong></code>
b'code'

&gt;&gt;&gt; <code><strong>B[0] = 'x'</strong></code>
TypeError: 'bytes' object does not support item assignment</pre>
<p>For more <code>bytes</code> methods, see the earlier coverage of string fundamentals in <a data-type="xref" href="ch07.html#string_fundamentals">Chapter 7</a>; <code>bytes</code> do most of the same work, though their methods generally return a new <code>bytes</code> instead of a <code>str</code>.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Sequence Operations"><div class="sect2" id="sequence_operations-id000122">
<h2>Sequence Operations</h2>
<p>Besides method calls, all the usual <a contenteditable="false" data-type="indexterm" data-primary="byte strings" data-secondary="sequence operations" id="bytrgqpr"></a><a contenteditable="false" data-type="indexterm" data-primary="sequence operations" data-secondary="byte strings" id="sqprygr"></a>generic sequence operations you know from other sequences, like lists, work as expected on both <code>str</code> and <code>bytes</code>. This includes indexing, slicing, concatenation, and so on. As we’ve learned, <code>str</code> is a sequence of character code points, and <code>bytes</code> is a sequence of byte-size integers, but their sequence operations’ semantics are the same.</p>
<p>Notice in the following, though, that indexing <code>bytes</code> returns an integer giving the byte’s binary value; <code>bytes</code> really is a sequence of 8-bit integers in the 0…255 range, but when displayed, its components print as either ASCII characters if their values fall into ASCII’s 0…127 code-point range, or as hex escapes otherwise:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>B = b'code'</strong> </code>          <code><em># bytes and str are both sequences</em></code>
&gt;&gt;&gt; <code><strong>B</strong> </code>                    <code><em># Bytes in the 0…127 range display as ASCII</em></code>
b'code'

&gt;&gt;&gt; <code><strong>B[0], B[-1]</strong></code>           <code><em># Indexing: returns a byte's integer value</em></code>
(99, 101)
&gt;&gt;&gt; <code><strong>'code'[0]</strong></code>             <code><em># But indexing a str returns a 1-item str</em></code>
'c'

&gt;&gt;&gt; <code><strong>chr(B[0])</strong></code>             <code><em># Unicode character (code point) for byte's value</em></code>
'c'
&gt;&gt;&gt; <code><strong>list(B)</strong></code>               <code><em># But it's really integer bytes</em></code>
[99, 111, 100, 101]

&gt;&gt;&gt;<code> <strong>b'A\x42C\xFF\x63'</strong></code>     <code><em># That happen to display as ASCII if in 0…127</em></code><strong></strong>
b'ABC\xffc'
&gt;&gt;&gt; <code><strong>chr(0x63), hex(B[0])</strong>  <em># And accept hex escapes for byte values</em></code>
('c', '0x63')

&gt;&gt;&gt; <code><strong>B[1:], B[:-1]</strong></code>         <code><em># Slicing: bytes (that display 0…127 as ASCII)</em></code>
(b'ode', b'cod')
&gt;&gt;&gt; <code><strong>len(B)</strong></code>                <code><em># Length: number bytes (not necessarily characters)</em></code>
4

&gt;&gt;&gt; <code><strong>B + b'lmn'</strong></code>            <code><em># Concatenation: bytes</em></code>
b'codelmn'
&gt;&gt;&gt; <code><strong>B * 4</strong></code>                 <code><em># Repetition: bytes</em></code>
b'codecodecodecode'</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Formatting"><div class="sect2" id="formatting">
<h2>Formatting</h2>
<p>One notable exception to the same-operations <a contenteditable="false" data-type="indexterm" data-primary="byte strings" data-secondary="sequence operations" data-startref="bytrgqpr" id="id4610"></a><a contenteditable="false" data-type="indexterm" data-primary="sequence operations" data-secondary="byte strings" data-startref="sqprygr" id="id4611"></a><a contenteditable="false" data-type="indexterm" data-primary="string formatting" id="sgfmtt"></a><a contenteditable="false" data-type="indexterm" data-primary="byte strings" data-secondary="formatting" id="bygrsfmt"></a>rule for strings: string formatting <code>%</code> expressions work on <code>bytes</code> too (as of Python 3.5), but neither the <code>format</code> method nor <code>f'…'</code> f-string formatting is available for <code>bytes</code>—an odd bifurcation that seems to forget that formatting comes in multiple flavors today:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>b'a %s string' % b'fine'</strong></code>                  <code><em># Py 3.5+ formatting for bytes</em></code>
b'a fine string'
&gt;&gt;&gt; <code><strong>b'a %s string' % bytes([0xFF, 0xFE])</strong></code>      <code><em># Non-ASCII bytes work too</em></code>
b'a \xff\xfe string'

&gt;&gt;&gt; <code><strong>'a {} string'.format('fine')</strong></code>              <code><em># But format method only for str</em></code>
'a fine string'
&gt;&gt;&gt; <code><strong>b'a {} string'.format(b'fine')</strong></code>
AttributeError: 'bytes' object has no attribute 'format'

&gt;&gt;&gt; <code><strong>kind = 'fine'</strong></code>
&gt;&gt;&gt; <code><strong>f'a {kind} string'</strong></code>                        <code><em># But f-strings only for str</em></code>
'a fine string'
&gt;&gt;&gt; <code><strong>bf'a {kind} string'</strong></code>
SyntaxError: invalid syntax</pre>
<p>There are arguably sound reasons that formatting shouldn’t work on <code>bytes</code>—it’s just raw bytes, after all, which happens to accept and print ASCII characters as their ASCII code-point values, and may use any encoding if it’s text, or none at all if it’s not. Plugging ASCII text into an encoded UTF-16 string or loaded image, for instance, makes no sense. But these sound reasons are inconsistently violated for the sake of the <code>%</code> expression alone.</p>
<p>Moreover, post-operation conversion by encoding isn’t the same as <code>bytes</code> operations, and will fail if the default or explicit encoding isn’t inclusive enough to handle the text:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>kind = 'fine'</strong></code>
&gt;&gt;&gt; <code><strong>f'a {kind} string'.encode()</strong></code>               <code><em># Encoding != bytes operations</em></code>
b'a fine string'

&gt;&gt;&gt; <code><strong>kind = 'AÄBèC'</strong></code>                            <code><em># And narrow encodings may fail</em></code>
&gt;&gt;&gt; <code><strong>f'a {kind} string'.encode('ascii')</strong></code>
UnicodeEncodeError: 'ascii' codec can't encode character '\xc4' in position 3:…</pre>
<p>This inconsistency is prone to change over time, but today, the embarrassment of riches in the formatting department has also given birth to an embarrassment of special cases.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Other Ways to Make Bytes"><div class="sect2" id="other_ways_to_make_bytes">
<h2>Other Ways to Make Bytes</h2>
<p>So far in this section, we’ve been making <code>bytes</code> objects with the <code>b'…'</code> literal syntax, but they <a contenteditable="false" data-type="indexterm" data-primary="byte strings" data-secondary="bytes constructor" id="id4612"></a>can also be created by calling the <code>bytes</code> constructor with a <code>str</code> and an encoding name, by calling <code>bytes</code> with an iterable of integers representing byte values, or by encoding a <code>str</code> object per the default (or passed-in) encoding. We met some of these earlier in the guise of conversions, but they’re more general than previously told.</p>
<p>For example, encoding takes a <code>str</code> and returns the raw binary <code>bytes</code> value of the string according to its encoding specification; decoding takes a raw <code>bytes</code> sequence and encodes it to its string representation—a series of Unicode characters:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>B = b'abc'</strong></code>
&gt;&gt;&gt; <code><strong>B</strong></code>
b'abc'

&gt;&gt;&gt; <code><strong>B = bytes('abc', 'ascii')</strong></code>
&gt;&gt;&gt; <code><strong>B</strong></code>
b'abc'

&gt;&gt;&gt; <code><strong>ord('a')</strong></code>
97
&gt;&gt;&gt; <code><strong>B = bytes([97, 98, 99])</strong></code>
&gt;&gt;&gt; <code><strong>B</strong></code>
b'abc'

&gt;&gt;&gt; <code><strong>B = 'code'.encode()</strong></code>       <code><em># Or bytes()</em></code>
&gt;&gt;&gt; <code><strong>B</strong></code>
b'code'

&gt;&gt;&gt; <code><strong>S = B.decode()</strong></code>            <code><em># Or str()</em></code>
&gt;&gt;&gt; <code><strong>S</strong></code>
'code'</pre>
<p>As we saw earlier, the last two of these operations can also be thought of as tools for converting between <code>str</code> and <code>bytes</code>, as expanded upon in the next section.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Mixing String Types"><div class="sect2" id="mixing_string_types">
<h2>Mixing String Types</h2>
<p>When we used the <code>replace</code> earlier when sampling <code>bytes</code> methods, you may have noticed <a contenteditable="false" data-type="indexterm" data-primary="byte strings" data-secondary="mixing types" id="id4613"></a>that we had to pass in two <code>bytes</code> objects for from and to—<code>str</code> types won’t work there. More generally, Python requires specific string types in some contexts and expects manual conversions if needed. Here’s the story for function and method calls:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>B = b'code'</strong></code>

&gt;&gt;&gt; <code><strong>B.replace('od', 'XY')</strong></code>
TypeError: a bytes-like object is required, not 'str'

&gt;&gt;&gt; <code><strong>B.replace(b'od', b'XY')</strong></code>
b'cXYe'

&gt;&gt;&gt; <code><strong>B.replace(bytes('od'), bytes('XY'))</strong></code>
TypeError: string argument without an encoding

&gt;&gt;&gt; <code><strong>B.replace(bytes('od', 'ascii'), bytes('XY', 'utf-8'))</strong></code>
b'cXYe'</pre>
<p>The same holds for mixed-type expressions: you should try to keep your text and binary data separate, but if you must mix, you generally also must convert:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>b'ab' + 'cd'</strong></code>
TypeError: can't concat str to bytes

&gt;&gt;&gt; <code><strong>b'ab'.decode() + 'cd'</strong></code>                   <code><em># bytes to str</em></code>
'abcd'

&gt;&gt;&gt; <code><strong>b'ab' + 'cd'.encode()</strong></code>                   <code><em># str to bytes</em></code>
b'abcd'

&gt;&gt;&gt; <code><strong>b'ab' + bytes('cd', 'ascii')</strong></code>            <code><em># str to bytes</em></code>
b'abcd'</pre>
<p>Two notes here. First, remember that encoding and decoding are more than a simple type conversion; as we learned in the coverage earlier, they create different types of data altogether. Second, although you can create <code>bytes</code> objects yourself to represent packed binary data, they can also be made automatically by reading files opened in binary mode, as we will later in this chapter. First, though, let’s briefly explore <code>bytes</code>’ elusive and changeable colleague.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="The bytearray Object"><div class="sect2" id="the_bytearray_object-id000113">
<h2>The bytearray Object</h2>
<p>So far in this chapter, we’ve focused <a contenteditable="false" data-type="indexterm" data-primary="byte strings" data-secondary="bytearray object" id="byxybjc"></a><a contenteditable="false" data-type="indexterm" data-primary="bytearray object" id="byrrybj"></a><a contenteditable="false" data-type="indexterm" data-primary="objects" data-secondary="bytearray" id="bjctyrry"></a>on <code>str</code> and <code>bytes</code> because they will be your go-to string tools. Python, however, has a third string type—<code>bytearray</code>, which is essentially a mutable variant of <code>bytes</code>, and thus a mutable sequence of integers in the range 0…255. As such, it supports the same string methods and sequence operations as <code>bytes</code>, as well as the mutable in-place-change operations found on lists.</p>
<p>We’ve already seen most operations that apply to <code>bytearray</code>, so we’ll just take a quick tour here to sample their flavor. First off, you can call <code>bytearray</code> as a function passing a <code>bytes</code> (not a <code>str</code>) to make a new mutable sequence of small (0…255) integers:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>B = b'code'</strong></code>               <code><em># A str 'code' does not work: not bytes</em></code>
&gt;&gt;&gt; <code><strong>C = bytearray(B)</strong></code>
&gt;&gt;&gt; <code><strong>C</strong></code>
bytearray(b'code')
&gt;&gt;&gt; <code><strong>C[0], chr(C[0])</strong></code>           <code><em># ASCII code-point integer for 'c'</em></code>
(99, 'c')</pre>
<p>Once you’ve got a <code>bytearray</code>, you can change it in place using the same sorts of operations available to modify a list, but keep in mind that you must assign just integers to its cells, not <code>str</code> text strings, and not arbitrary objects:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>C[0] = 'x'</strong></code>
TypeError: 'str' object cannot be interpreted as an integer

&gt;&gt;&gt; <code><strong>C[0] = b'x'</strong></code>
TypeError: 'bytes' object cannot be interpreted as an integer

&gt;&gt;&gt; <code><strong>C[0] = ord('x')</strong></code>
&gt;&gt;&gt; <code><strong>C</strong></code>
bytearray(b'xode')

&gt;&gt;&gt; <code><strong>C[1] = b'Y'[0]</strong></code>
&gt;&gt;&gt; <code><strong>C</strong></code>
bytearray(b'xYde')</pre>
<p>The <code>bytearray</code>’s methods set overlaps broadly with both <code>str</code> and <code>bytes</code> because it’s a kind of string sequence, but it also has the list object’s in-place change methods because it’s mutable too (the second of the following means attributes unique to <code>bytearray</code>):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>sorted(set(dir(b'abc')) - set(dir(bytearray(b'abc'))))</strong></code>
{'__bytes__', '__getnewargs__'}
 
&gt;&gt;&gt; <code><strong>sorted(set(dir(bytearray(b'abc'))) - set(dir(b'abc')))</strong></code>
['__alloc__', '__delitem__', '__iadd__', '__imul__', '__release_buffer__',
'__setitem__', 'append', 'clear', 'copy', 'extend', 'insert', 'pop', 'remove', 'reverse']</pre>
<p>Hence, it’s something of a combo platter—you get methods for in-place changes:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>C</strong></code>
bytearray(b'xYde')

&gt;&gt;&gt; <code><strong>C.append(b'LMN')</strong></code>
TypeError: 'bytes' object cannot be interpreted as an integer

&gt;&gt;&gt; <code><strong>C.append(b'LMN'[0])</strong></code>
&gt;&gt;&gt; <code><strong>C</strong></code>
bytearray(b'xYdeL')

&gt;&gt;&gt; <code><strong>C.append(ord('M'))</strong></code>
&gt;&gt;&gt; <code><strong>C</strong></code>
bytearray(b'xYdeLM')

&gt;&gt;&gt; <code><strong>C.extend(b'NO')</strong></code>
&gt;&gt;&gt; <code><strong>C</strong></code>
bytearray(b'xYdeLMNO')</pre>
<p>Plus all the usual sequence operations and string methods:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>C + b'!#'</strong></code>
bytearray(b'xYdeLMNO!#')

&gt;&gt;&gt; <code><strong>C[0], chr(C[0])</strong></code>
(120, 'x')

&gt;&gt;&gt; <code><strong>C[1:]</strong></code>
bytearray(b'YdeLMNO')

&gt;&gt;&gt; <code><strong>len(C)</strong></code>
8
&gt;&gt;&gt; <code><strong>C</strong></code>
bytearray(b'xYdeLMNO')

&gt;&gt;&gt; <code><strong>C.replace('xY', 'co')</strong></code>
TypeError: a bytes-like object is required, not 'str'

&gt;&gt;&gt; <code><strong>C.replace(b'xY', b'co')</strong></code>
bytearray(b'codeLMNO')

&gt;&gt;&gt; <code><strong>C</strong></code>
bytearray(b'xYamLMNO')

&gt;&gt;&gt; <code><strong>C * 4</strong></code>
bytearray(b'xYdeLMNOxYdeLMNOxYdeLMNOxYdeLMNO')</pre>
<p>For completeness, this section would be remiss if it didn’t call out that you can also make a <code>bytes</code> or <code>bytearray</code> by passing in any sort of integer sequence or generator, not just text strings. This also provides a sort of conversion from an integer character code to a <code>bytes</code>, but only if the integer is in the range 0…255, and only if it’s embedded in a sequence (else you get a <code>bytes</code> with that many zeroes—surprisingly!). See Python’s manuals for more esoteric bits that we don’t have space to cover here:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>bytes([1, 2, 3, 4]), bytearray([1, 2, 3, 4])</strong></code>
(b'\x01\x02\x03\x04', bytearray(b'\x01\x02\x03\x04'))

&gt;&gt;&gt; <code><strong>bytes([115])</strong>  </code>      <code><em># int =&gt; bytes</em></code>
b's'

&gt;&gt;&gt; <code><strong>bytes([115])[0]</strong></code>     <code><em># bytes =&gt; int</em></code>
115

&gt;&gt;&gt; <code><strong>bytes([999])</strong>   </code>     <code><em># Too big for a byte</em></code>
ValueError: bytes must be in range(0, 256)

&gt;&gt;&gt; <code><strong>bytes(115)</strong></code>          <code><em># Lots of zeroes!</em></code>
b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00…

&gt;&gt;&gt; <code><strong>bytes(range(97, 104)), bytes(c + 97 for c in range(7))</strong></code>    <code><em># Generators too</em></code>
(b'abcdefg', b'abcdefg')</pre>
<p>Finally, by way of summary, the following <a contenteditable="false" data-type="indexterm" data-primary="byte strings" data-secondary="bytearray object" data-startref="byxybjc" id="id4614"></a><a contenteditable="false" data-type="indexterm" data-primary="bytearray object" data-startref="byrrybj" id="id4615"></a><a contenteditable="false" data-type="indexterm" data-primary="objects" data-secondary="bytearray" data-startref="bjctyrry" id="id4616"></a>examples demonstrate how <code>bytes</code> and <code>bytearray</code> are sequences of integers, and <code>str</code> is a sequence of characters (i.e., decoded Unicode code points); although all three can contain textual content and support many of the same operations, you should use <code>str</code> for decoded text, <code>bytes</code> for binary data including encoded text, and <code>bytearray</code> for binary data you wish to change in place to avoid the time and space overheads of generating copies for each change you make:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>B = b'code'</strong></code>                   <code><em># Bytes</em></code>
&gt;&gt;&gt; <code><strong>list(B)</strong></code>
[99, 111, 100, 101]

&gt;&gt;&gt; <code><strong>C = bytearray(b'code')</strong>   </code>     <code><em># Changeable bytes</em></code>
&gt;&gt;&gt; <code><strong>list(C)</strong></code>
[99, 111, 100, 101]

&gt;&gt;&gt; <code><strong>S = 'code'</strong></code>                    <code><em># Unicode text</em></code>
&gt;&gt;&gt; <code><strong>list(S)</strong></code>
['c', 'o', 'd', 'e']</pre>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Using Text and Binary Files"><div class="sect1" id="using_text_and_binary_files">
<h1>Using Text and Binary Files</h1>
<p>Now that we’ve learned all about Python’s string types, let’s return to their roles in files—the main context in which most programmers will likely encounter Unicode and bytes.</p>
<p>As mentioned earlier, the <em>mode</em> in which you open a file is crucial in Python: it determines both how the file’s content is interpreted as well as the object type you will use to process that content in your script. By way of review, text mode implies <code>str</code> objects and binary mode implies <code>bytes</code>, as follows:</p>
<dl>
<dt>Text-mode files</dt>
<dd>Interpret file contents according <a contenteditable="false" data-type="indexterm" data-primary="files" data-secondary="text-mode" id="id4617"></a>to an encoding—either the default for your platform or one whose name you pass in to <code>open</code>. By passing in an encoding name, you can force conversions for various types of Unicode files. Text-mode files may also handle BOM headers <a contenteditable="false" data-type="indexterm" data-primary="text-mode files" data-secondary="BOM headers" id="id4618"></a><a contenteditable="false" data-type="indexterm" data-primary="BOM (byte order marker)" data-secondary="text-mode files" id="id4619"></a>for some encodings (deferred till the end of this chapter) and may perform universal newline translations for you or not; by default, all newline forms map to the <code>\n</code> character in your script, regardless of which platform you are on.</dd>
<dt>Binary-mode files</dt>
<dd>Instead return file content to you raw as a <a contenteditable="false" data-type="indexterm" data-primary="binary-mode files" id="id4620"></a><a contenteditable="false" data-type="indexterm" data-primary="files" data-secondary="binary-mode" id="id4621"></a>sequence of integers representing byte values, with no encoding or decoding, no BOM handling, and no newline translations.</dd>
</dl>
<p>In terms of code, the second positional argument to <code>open</code> (a.k.a. <code>mode</code> when passed by keyword) determines whether you want text or binary processing and types—adding a <code>b</code> to the mode string implies binary mode. The default mode is <code>rt</code>, which is the same as <code>r</code>, and means text input. In addition, the mode argument to <code>open</code> also implies an object type for file content representation regardless of the underlying platform—text files return a <code>str</code> for reads and expect one for writes, but binary files return a <code>bytes</code> for reads and expect <code>bytes</code> (or <code>bytearray</code>) for writes.</p>
<section data-type="sect2" data-pdf-bookmark="Text-File Basics"><div class="sect2" id="text_file_basics">
<h2>Text-File Basics</h2>
<p>To demonstrate, let’s review basic file I/O. As long as you’re processing simple text files that adhere to your platform’s default encoding, files look and feel much as they do in this book’s earlier coverage (for that matter, so do strings in general). The next example, for instance, writes one line of text to a file and reads it back:<sup> </sup></p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>file = open('temp.txt', 'w')</strong></code>     <code><em># Use default encoding on host, mode w=write</em></code>
&gt;&gt;&gt; <code><strong>size = file.write('abc\n')</strong></code>      <code> <em># Returns number characters written</em></code>
&gt;&gt;&gt; <code><strong>file.close()</strong></code>                     <code><em># Manual close to flush output buffer</em></code>

&gt;&gt;&gt; <code><strong>file = open('temp.txt')</strong> </code>         <code><em># Default mode is "r" == "rt": text input</em></code>
&gt;&gt;&gt; <code><strong>text = file.read()</strong></code>
&gt;&gt;&gt; <code><strong>text</strong></code>
'abc\n'</pre>
<p>As a refresher, the first argument to <code>open</code> is the file’s <em>pathname</em>—the address of a file in the host’s folder hierarchy that’s either absolute or relative to the <a contenteditable="false" data-type="indexterm" data-primary="text files" data-secondary="pathname" id="id4622"></a><a contenteditable="false" data-type="indexterm" data-primary="files" data-secondary="text files" data-tertiary="pathname" id="id4623"></a>current directory. The second argument to open is <em>mode</em>—where <code>w</code> means write text, and the default means read it, and <code>write</code> methods return the number of written <em>items</em>—either characters for text mode or bytes for binary mode. Also, the <code>close</code> call here is optional in some contexts (e.g., the widely used <em>CPython</em> auto-closes files when their objects are garbage collected) but is generally advised to flush changes and avoid memory growth.<sup><a data-type="noteref" id="ch37fn1-marker" href="ch37.html#ch37fn1">1</a></sup></p>
<p>Technically, the preceding example writes and reads Unicode text, but it’s hardly noticeable: the ASCII text string is encoded and decoded per the hosting platform’s encoding default. We’re also relying on platform-agnostic newline handling for <code>\n</code>, but we must move ahead for more on encodings and <span class="keep-together">newlines</span>.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Text and Binary Modes"><div class="sect2" id="text_and_binary_modes">
<h2>Text and Binary Modes</h2>
<p>Next, let’s write a <em>text file</em> and read <a contenteditable="false" data-type="indexterm" data-primary="text files" data-secondary="text mode" id="id4624"></a><a contenteditable="false" data-type="indexterm" data-primary="text files" data-secondary="binary mode" id="id4625"></a><a contenteditable="false" data-type="indexterm" data-primary="binary-mode files" id="id4626"></a>it back in both text and binary modes. Notice in the following how text mode requires us to provide a <code>str</code> for writing, <code>rb</code> distinguishes binary-mode input, and reading gives us a <code>str</code> or <code>bytes</code> depending on the mode (opens and transfer operations are strung together here into one-liners just for brevity; again, remember to <code>close</code> explicitly in production code, and possibly in some IDEs and outside CPython):</p>
<pre data-type="programlisting">$ <code><strong>py -3           </strong>  </code>                         <code><em># Run on Windows (no \r on Unix)</em></code> 
&gt;&gt;&gt; <code><strong>open('temp.txt', 'w').write('abc\n')</strong></code>     <code><em># Text-mode output, provide a str</em></code>
4

&gt;&gt;&gt; <code><strong>open('temp.txt', 'r').read()</strong></code>             <code><em># Text-mode input, returns a str</em></code>
'abc\n'

&gt;&gt;&gt; <code><strong>open('temp.txt', 'rb').read()</strong></code>            <code><em># Binary-mode input, returns a bytes</em></code>
b'abc\r\n'</pre>
<p>Observe how the <em>newline character</em> is always <code>\n</code> when writing and reading in <a contenteditable="false" data-type="indexterm" data-primary="newline character" id="id4627"></a><a contenteditable="false" data-type="indexterm" data-primary="text files" data-secondary="text mode" data-tertiary="newline character" id="id4628"></a><a contenteditable="false" data-type="indexterm" data-primary="text-mode files" data-secondary="newline character" id="id4629"></a>text mode with <code>str</code> but <span class="keep-together"><code>\r\n</code></span> when reading in binary mode with <code>bytes</code>. This reflects the fact that this was run on Windows. Though it has nothing to do with Unicode, text-mode files automatically map all <code>\n</code> in <code>str</code> to and from the host platform’s newline separator: <code>\r\n</code> on Windows and just <code>\n</code> on Unix. When reading in binary mode, though, we get what’s actually in the file—with neither newline mapping nor Unicode decoding.</p>
<p>Now, let’s do the same, but with a <em>binary file</em>. We provide a <code>bytes</code> to write and still get back a <code>str</code> or <code>bytes</code> depending on the input mode, though the <code>\n</code> isn’t expanded to <code>\r\n</code> on Windows this time:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>open('temp.bin', 'wb').write(b'abc\n')</strong> </code>  <code><em># Binary-mode output, send a bytes</em></code>
4

&gt;&gt;&gt; <code><strong>open('temp.bin', 'r').read()</strong></code>             <code><em># Text-mode input, receive a str</em></code>
'abc\n'

&gt;&gt;&gt; <code><strong>open('temp.bin', 'rb').read()</strong></code>            <code><em># Binary-mode input, bytes sans mapping</em></code>
b'abc\n'</pre>
<p>This holds true even if the data we’re writing to the binary file is truly binary in nature. In the following, the <code>\x00</code> is a binary zero byte and not a printable character, though it works in the middle of a <code>bytes</code> and qualifies as a text code point in the default encoding (strictly speaking, zero is a character called null or NUL in ASCII and its supersets like UTF-8):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>open('temp.bin', 'wb').write(b'a\x00c')</strong></code>    <code><em># Binary data included</em></code>
3

&gt;&gt;&gt; <code><strong>open('temp.bin', 'r').read()</strong></code>               <code><em># Text-mode: str with NUL</em></code>
'a\x00c'

&gt;&gt;&gt; <code><strong>open('temp.bin', 'rb').read()</strong></code>              <code><em># Binary mode: bytes</em></code>
b'a\x00c'</pre>
<p>Binary mode files always <a contenteditable="false" data-type="indexterm" data-primary="text files" data-secondary="binary mode" data-tertiary="bytes object" id="id4630"></a><a contenteditable="false" data-type="indexterm" data-primary="binary-mode files" data-secondary="bytes object" id="id4631"></a><a contenteditable="false" data-type="indexterm" data-primary="bytes object" data-secondary="binary-mode files" id="id4632"></a>return contents as a <code>bytes</code> object but accept either a <code>bytes</code> or <code>bytearray</code> object for writing. This naturally follows, given that <code>bytearray</code> is mostly just a mutable variant of <code>bytes</code>. In fact, most APIs in Python that accept a <code>bytes</code> also allow a <code>bytearray</code> (the bytes here are also ASCII characters too obscure for this note):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>BA = bytearray(b'\x01\x02\x03')</strong></code>
&gt;&gt;&gt; <code><strong>open('temp.bin', 'wb').write(BA)</strong></code>
3

&gt;&gt;&gt; <code><strong>open('temp.bin', 'r').read()</strong></code>
'\x01\x02\x03'

&gt;&gt;&gt; <code><strong>open('temp.bin', 'rb').read()</strong></code>
b'\x01\x02\x03'</pre>
<p>Finally, notice that you can’t get away with violating Python’s <code>str</code>/<code>bytes</code> (i.e., text/binary) distinction when it comes to files; in the following, we get errors if we try to write a <code>bytes</code> to a text file or a <code>str</code> to a binary file. Remember, although it is often possible to convert between these two types (as described earlier in this chapter), you will usually want to stick to <code>str</code> for text data and <code>bytes</code> for binary data:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>open('temp.txt', 'w').write('abc\n')</strong></code>            <code><em># Auto encodes str to bytes</em></code>
4
&gt;&gt;&gt; <code><strong>open('temp.txt', 'w').write(b'abc\n')</strong> </code>          <code><em># But bytes != decoded text</em></code>
TypeError: write() argument must be str, not bytes

&gt;&gt;&gt; <code><strong>open('temp.bin', 'wb').write(b'abc\n')</strong></code>          <code><em># Writes raw bytes</em></code>
4
&gt;&gt;&gt; <code><strong>open('temp.bin', 'wb').write('abc\n')</strong></code>           <code><em># But str != raw bytes</em></code>
TypeError: a bytes-like object is required, not 'str'</pre>
<p>This may seem strict, but Python cannot guess how you wish to interpret the contents of a <code>bytes</code> or <code>str</code> when used in the opposite context and wisely refuses to convert implicitly (a <code>bytes</code> might be an image, after all). Moreover, because <code>str</code> and <code>bytes</code> operation sets largely intersect, the choice of types won’t be much of a dilemma for most programs. Watch for the <code>struct</code> module coverage ahead for another binary-file example.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Unicode-Text Files"><div class="sect2" id="unicode_text_files">
<h2>Unicode-Text Files</h2>
<p>And now for the featured attraction <a contenteditable="false" data-type="indexterm" data-primary="text files" data-secondary="Unicode text files" id="txfuxf"></a><a contenteditable="false" data-type="indexterm" data-primary="Unicode" data-secondary="text files" id="uxflcd"></a>of our files tour: text files with non-ASCII text. Beyond their text/binary distinction, Python files come with additional requirements and tools for dealing with Unicode text. In short, text files allow a specific Unicode encoding-scheme name to be passed in with an <code>encoding</code> argument to <code>open</code> and use it to automatically <em>decode</em> and <em>encode</em> text on input and output, respectively. As abstract examples, for a file identified by a <code><em>pathname</em></code> string:</p>
<dl>
<dt><code>open(<em>pathname</em>, 'r', encoding='utf8')</code></dt>
<dd>Returns a file object that decodes text from UTF-8 on reads</dd>
<dt><code>open(<em>pathname</em>, 'w', encoding='latin1')</code></dt>
<dd>Returns a file object that encodes text to Latin-1 on writes</dd>
</dl>
<p>The file object returned by the first of the preceding assumes the file’s content is encoded per UTF-8 and automatically decodes it to <code>str</code> Unicode code points when read by the program. Similarly, the result of the second line of code encodes <code>str</code> code points to their Latin-1 format as they are output to the file. Here’s the text-file story with the universal <em>UTF-8</em> encoding and three non-ASCII characters in the content:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>file = open('uni.txt', 'w', encoding='utf8')</strong></code>          <code><em># Auto encodes to bytes</em></code>
&gt;&gt;&gt; <code><strong>file.write('<img src="assets/yellow-heart_1f49b.png" width="160" height="160"/> 2 hÄck <img src="assets/snake_1f40d.png" width="160" height="160"/>')</strong></code>
10
&gt;&gt;&gt; <code><strong>file.close()</strong></code>

&gt;&gt;&gt; <code><strong>text = open('uni.txt', 'r', encoding='utf8').read()</strong></code>   <code><em># Auto decodes to str</em></code>
&gt;&gt;&gt; <code><strong>text</strong></code>
'<img src="assets/yellow-heart_1f49b.png" width="160" height="160"/> 2 hÄck <img src="assets/snake_1f40d.png" width="160" height="160"/>'
 
&gt;&gt;&gt; <code><strong>[ord(c) for c in text]</strong></code>                                <code><em># Character code points</em></code>
[128155, 32, 50, 32, 104, 196, 99, 107, 32, 128013]
 
&gt;&gt;&gt; <code><strong>raw = open('uni.txt', 'rb').read()</strong></code>                    <code><em># No decoding applied</em></code>
&gt;&gt;&gt; <code><strong>raw</strong></code>
b'\xf0\x9f\x92\x9b 2 h\xc3\x84ck \xf0\x9f\x90\x8d'</pre>
<p>File transfers raise exceptions whenever a requested encoding doesn’t work, so the encoding you pass must match the data. For example, <em>ASCII</em> is not inclusive enough to handle the augmented and emoji characters in the text we’re writing here and fails on both reads and writes:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>open('uni.txt', 'r', encoding='ascii').read()</strong></code>
UnicodeDecodeError: 'ascii' codec can't decode byte 0xf0 in position 0:…

&gt;&gt;&gt; <code><strong>open('ascii.txt', 'w', encoding='ascii').write('<img src="assets/yellow-heart_1f49b.png" width="160" height="160"/> 2 hÄck <img src="assets/snake_1f40d.png" width="160" height="160"/>')</strong></code>
UnicodeEncodeError: 'ascii' codec can't encode character '\U0001f49b'…

&gt;&gt;&gt; <code><strong>hex(ord('<img src="assets/yellow-heart_1f49b.png" width="160" height="160"/>'))</strong></code>    <code><em># ASCII will always break your heart?</em></code>
'0x1f49b'</pre>
<p>By contrast, using the broader and more general <em>UTF-16</em> on both ends handles this text in full, though its encoded bytes stored in the file naturally differ from those of UTF-8:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>file = open('uni2.txt', 'w', encoding='utf16')</strong></code>         <code><em># UTF-16 works too</em></code> 
&gt;&gt;&gt; <code><strong>file.write('<img src="assets/yellow-heart_1f49b.png" width="160" height="160"/> 2 hÄck <img src="assets/snake_1f40d.png" width="160" height="160"/>')</strong></code>
10
&gt;&gt;&gt; <code><strong>file.close()</strong></code>
 
&gt;&gt;&gt; <code><strong>text = open('uni2.txt', 'r', encoding='utf16').read()</strong></code>  <code><em># Files encode+decode</em></code>
&gt;&gt;&gt; <code><strong>text</strong></code>
'<img src="assets/yellow-heart_1f49b.png" width="160" height="160"/> 2 hÄck <img src="assets/snake_1f40d.png" width="160" height="160"/>'
 
&gt;&gt;&gt; <code><strong>[ord(c) for c in text]</strong></code>                                 <code><em># Same code points</em></code>
[128155, 32, 50, 32, 104, 196, 99, 107, 32, 128013]

&gt;&gt;&gt; <code><strong>open('uni2.txt', 'rb').read()</strong></code>                          <code><em># Different encoding</em></code>
b'\xff\xfe=\xd8\x9b\xdc \x002\x00 \x00h\x00\xc4\x00c\x00k\x00 \x00=\xd8\r\xdc'</pre>
<p>Even for broader encodings like UTF-8 and UTF-16, though, you cannot <em>mix and match</em>: using an incompatible encoding still won’t work because encoded bytes in the file differ. Although you can sometimes handle unknown encodings with binary-mode files, <code>open</code> error handlers, and other techniques, your encoding must generally match your file’s data:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>open('uni.txt', 'r', encoding='utf16').read()</strong></code>
UnicodeDecodeError: 'utf-16-le' codec can't decode byte 0x8d in position 16:…

&gt;&gt;&gt; <code><strong>open('uni2.txt', 'r', encoding='utf8').read()</strong></code>
UnicodeDecodeError: 'utf-8' codec can't decode byte 0xff in position 0:…</pre>
<p>In the <em>absence</em> of an <code>encoding</code> argument, text files still encode and decode per a host- and platform-specific default in <code>locale</code> discussed earlier. But as a reminder: although you may not notice these translations if your default and files agree, you generally should not rely on the default; it makes your programs dependent on the context in which their files were created and can lead to portability issues (and nightmares; see the upcoming sidebar <a data-type="xref" href="#unicode_defaults_and_utf_eight_mode">“Unicode Defaults and UTF-8 Mode”</a>).</p>
<p>For instance, a program run on a UTF-8 default platform (the macOS and Android norm) may have trouble using a file made under a cp1252 default (the ASCII-superset default on some Windows hosts) and vice versa, and content fetched from other devices may be encoded arbitrarily. Use explicit <code>open</code> encodings as a rule. This may also help if environment settings are not reliable (e.g., when running as a generic user for security in server-side web scripts).</p>
<p>All that being said, you’ll probably find files to be easier in practice than the full details may suggest. Accessing web pages and images, for example, soon becomes second nature and simple. For variety, the following first omits mode (again, its default is the same as <code>r</code>) and then passes mode by explicit keyword (instead of position), and this example is abstract (substitute pathnames of real and accessible files on your device to run live):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>text = open('Websites/about-lp5e.html', encoding='utf8').read()</strong></code>
&gt;&gt;&gt; <code><strong>text[:79]</strong></code>
'&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.o'

&gt;&gt;&gt; <code><strong>image = open('Websites/lp5e-large.jpg', mode='rb').read()</strong></code>    
&gt;&gt;&gt; <code><strong>image[:20]</strong></code>
b'\xff\xd8\xff\xe0\x00\x10JFIF\x00\x01\x01\x00\x00\x01\x00\x01\x00\x00'</pre>
<p>Once you’ve loaded content this way, all the <code>str</code> and <code>bytes</code> operations we’ve seen in this chapter are at your disposal for wrangling text and binary data, and saving the result follows the same pattern—simply use an encoding for text and binary mode for bytes:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>text = text.replace('2013', '2024')</strong></code>
&gt;&gt;&gt; <code><strong>open('Websites/about-lp6e.html', mode='w', encoding='utf8').write(text)</strong></code>

&gt;&gt;&gt; <code><strong>image = <em>some_sort_of_modding</em>(image)</strong></code>
&gt;&gt;&gt; <code><strong>open('Websites/lp6e-large.jpg', mode='wb').write(image)</strong></code></pre>
<p>You might mod images, for example, with the many tools provided by the third-party <em>Pillow</em> (f.k.a. PIL) imaging library for Python or similar. With Python’s files and strings, content possibilities are largely endless.</p>
<p>In the interest of full disclosure, Python’s <code>open</code> accepts additional arguments that modify its behavior. Among them, <code>newline</code> changes newline mapping; <code>errors</code> specifies handling of encoding and decoding errors (e.g., <code>'surrogateescape'</code> replaces failing bytes with sequences that can be used to restore them on output); and <code>buffering</code> alters, well, buffering. Because their defaults are generally what you’ll use, we’ll defer to the Python standard-library manual for the fine print on these and other advanced file options.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><em>Blast from the past</em>: Python’s <code>codecs</code> module also has an <code>open</code> that returns an auto-decode/encode file object just like the built-in <code>open</code> function. This was used for Python 2.X backward compatibility in times gone by, but there’s no <a contenteditable="false" data-type="indexterm" data-primary="text files" data-secondary="Unicode text files" data-startref="txfuxf" id="id4633"></a><a contenteditable="false" data-type="indexterm" data-primary="Unicode" data-secondary="text files" data-startref="uxflcd" id="id4634"></a>obvious reason to rely on it in new code. Still, you might see it in legacy code (and code that relies on any of its unique behaviors) anyhow:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>import codecs</strong></code>
&gt;&gt;&gt; <code><strong>f = codecs.open('uni.txt', 'r', encoding='utf8')</strong></code>
&gt;&gt;&gt; <code><strong>f.read()</strong></code>
'<img src="assets/yellow-heart_1f49b.png" width="160" height="160"/> 2 hÄck <img src="assets/snake_1f40d.png" width="160" height="160"/>'</pre>
</div>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Unicode, Bytes, and Other String Tools"><div class="sect1" id="unicodecomma_bytescomma_and_other_strin">
<h1>Unicode, Bytes, and Other String Tools</h1>
<p>Besides built-in strings and files, many of the popular string-processing tools in Python’s standard library installed with Python itself also adhere to the <code>str</code>/<code>bytes</code> dichotomy. We won’t cover any of these application-focused topics in detail in this core-language book, but as a sample, here’s a <em>very</em> brief look at how some of these tools handle the split. See Python’s Library Reference for more on the tools used here if any pique your interest.</p>
<section data-type="sect2" data-pdf-bookmark="The re Pattern-Matching Module"><div class="sect2" id="the_re_pattern_matching_module">
<h2>The re Pattern-Matching Module</h2>
<p>Python’s <code>re</code> pattern-matching <a contenteditable="false" data-type="indexterm" data-primary="re module, pattern-matching" id="id4635"></a><a contenteditable="false" data-type="indexterm" data-primary="modules" data-secondary="re" id="id4636"></a><a contenteditable="false" data-type="indexterm" data-primary="patterns" data-secondary="re module" id="id4637"></a>module has been generalized to work on objects of any string type—<code>str</code>, <code>bytes</code>, and <code>bytearray</code> (a <code>(.*)</code> means any run, saved as a group):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>import re</strong></code>
&gt;&gt;&gt; <code><strong>S = '<img src="assets/snake_1f40d.png" width="160" height="160"/> is the fastest way to <img src="assets/pizza_1f355.png" width="160" height="160"/>!'</strong></code>
&gt;&gt;&gt; <code><strong>B = b'Python is the fastest way to pizza!'</strong></code>

&gt;&gt;&gt; <code><strong>re.match('(.*) the (.*) way (.*)', S).groups()</strong></code>       <code><em># str + str =&gt; str</em></code>
('<img src="assets/snake_1f40d.png" width="160" height="160"/> is', 'fastest', 'to <img src="assets/pizza_1f355.png" width="160" height="160"/>!')
 
&gt;&gt;&gt; <code><strong>re.match(b'(.*) the (.*) way (.*)', B).groups()</strong></code>      <code><em># bytes + bytes =&gt; bytes</em></code>
(b'Python is', b'fastest', b'to pizza!')

&gt;&gt;&gt; <code><strong>re.match(b'(.*) the (.*) way (.*)', bytearray(B)).groups()</strong></code>
(b'Python is', b'fastest', b'to pizza!')</pre>
<p>Like many tools, though, its result types depend on the type of strings you pass in, and you can’t mix <code>str</code> and <code>bytes</code> types in its calls’ arguments (sans explicit conversions, of course); <code>bytearray</code> is also unusable here as a pattern because it’s mutable (and changeable means “unhashable”):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>re.match('(.*) the (.*) way (.*)', B).groups()</strong></code>
TypeError: cannot use a string pattern on a bytes-like object
&gt;&gt;&gt; <code><strong>re.match(b'(.*) the (.*) way (.*)', S).groups()</strong></code>
TypeError: cannot use a bytes pattern on a string-like object

&gt;&gt;&gt; <code><strong>re.match('(.*) the (.*) way (.*)', bytearray(B)).groups()</strong></code>
TypeError: cannot use a string pattern on a bytes-like object
&gt;&gt;&gt; <code><strong>re.match(bytearray(b'(.*) the (.*) way (.*)'), bytearray(B)).groups()</strong></code>
TypeError: unhashable type: 'bytearray'</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="The struct Binary-Data Module"><div class="sect2" id="the_struct_binary_data_module">
<h2>The struct Binary-Data Module</h2>
<p>The Python <code>struct</code> module, used to <a contenteditable="false" data-type="indexterm" data-primary="struct module" data-secondary="binary data" id="id4638"></a><a contenteditable="false" data-type="indexterm" data-primary="modules" data-secondary="struct" id="id4639"></a><a contenteditable="false" data-type="indexterm" data-primary="binary data" data-secondary="struct module" id="id4640"></a>create and extract packed binary data from strings, operates on <code>bytes</code> and <code>bytearray</code> only, not <code>str</code>—which makes sense, given that it’s intended for processing binary data, not decoded text. This module uses a format string to specify the types and sizes of objects to pack to and from a bytes string, along with an endianness (i.e., significant side of bitstrings) specifier like <code>&gt;</code> for big-endian:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>import struct</strong></code>
&gt;&gt;&gt; <code><strong>B = struct.pack('&gt;i4sh', 7, b'code', 8)</strong></code>    <code><em># int , bytes(4s), int(h) =&gt; bytes</em></code>
&gt;&gt;&gt; <code><strong>B</strong></code>
b'\x00\x00\x00\x07code\x00\x08'

&gt;&gt;&gt; <code><strong>vals = struct.unpack('&gt;i4sh', B)</strong> </code>          <code><em># Packed data is bytes, not str</em></code> 
&gt;&gt;&gt; <code><strong>vals</strong></code>
(7, b'code', 8)

&gt;&gt;&gt; <code><strong>vals = struct.unpack('&gt;i4sh', B.decode())</strong></code>
TypeError: a bytes-like object is required, not 'str'</pre>
<p>You’ll often use this in conjunction with binary-mode files to make the packed bytes persistent across program runs (e.g., for saving and restoring app user settings):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>F = open('data.bin', 'wb')</strong></code>                    <code><em># Open binary output file</em></code>
&gt;&gt;&gt; <code><strong>data = struct.pack('&gt;i4sh', 7, b'code', 8)</strong></code>    <code><em># Create packed binary data</em></code>
&gt;&gt;&gt; <code><strong>data</strong></code>                                          <code><em># bytes, not str</em></code>
b'\x00\x00\x00\x07code\x00\x08'
&gt;&gt;&gt; <code><strong>F.write(data)</strong></code>                                 <code><em># Write to the file</em></code>
10
&gt;&gt;&gt; <code><strong>F.close()          </strong>  </code>                         <code><em># Flush changes</em></code>

&gt;&gt;&gt; <code><strong>F = open('data.bin', 'rb')</strong></code>                    <code><em># Open binary input file</em></code>
&gt;&gt;&gt; <code><strong>data = F.read()</strong></code>                               <code><em># Read bytes</em></code>
&gt;&gt;&gt; <code><strong>data</strong></code>
b'\x00\x00\x00\x07code\x00\x08'
&gt;&gt;&gt; <code><strong>values = struct.unpack('&gt;i4sh', data)</strong></code>         <code><em># Extract packed binary data</em></code>
&gt;&gt;&gt; <code><strong>values</strong></code>                                        <code><em># Back to Python objects</em></code>
(7, b'code', 8)</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="The pickle and json Serialization Modules"><div class="sect2" id="the_pickle_and_json_serialization_modul">
<h2>The pickle and json Serialization Modules</h2>
<p>Python’s <code>pickle</code> module <a contenteditable="false" data-type="indexterm" data-primary="pickle module" id="pkmocick"></a><a contenteditable="false" data-type="indexterm" data-primary="modules" data-secondary="pickle" id="mlodick"></a><a contenteditable="false" data-type="indexterm" data-primary="serialization" data-secondary="pickle module" id="szkpmlu"></a><a contenteditable="false" data-type="indexterm" data-primary="json module" id="jsnmdu"></a><a contenteditable="false" data-type="indexterm" data-primary="modules" data-secondary="json" id="mldjaon"></a><a contenteditable="false" data-type="indexterm" data-primary="serialization" data-secondary="json module" id="slzjondml"></a>provides another way to save data in files but allows saved data to be nearly arbitrary Python objects instead of values coerced to bytes as in <code>struct</code>. We met this module briefly in Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch09.html#tuplescomma_filescomma_and_everything_e">9</a>, <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch28.html#a_more_realistic_example">28</a>, and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch31.html#designing_with_classes">31</a>. For completeness here, keep in mind that the <code>pickle</code> module always creates a <code>bytes</code> object, regardless of the default or passed-in <code>protocol</code> (data format level). You can see this by using the module’s <code>dumps</code> call to return an object’s pickle string:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>import pickle</strong></code>                                <code><em># dumps() returns pickle string</em></code>
&gt;&gt;&gt; <code><strong>pickle.dumps(['code', 4, '<img src="assets/snake_1f40d.png" width="160" height="160"/>'])</strong></code>              <code><em># Default protocol=binary</em></code>
b'\x80\x04\x95\x15\x00\x00\x00\x00 …<code><em>etc</em></code>… \x04\x8c\x04\xf0\x9f\x90\x8d\x94e.'

&gt;&gt;&gt; <code><strong>pickle.dumps(['code', 4, '<img src="assets/snake_1f40d.png" width="160" height="160"/>'], protocol=0)</strong></code>   <code><em># ASCII protocol 0, still bytes!</em></code>
b'(lp0\nVcode\np1\naI4\naV\\U0001f40d\np2\na.'</pre>
<p>This implies that files used to store pickled objects must always be opened in <em>binary mode</em> because text files use <code>str</code> strings to represent data, not <code>bytes</code>, and the <code>dump</code> call simply attempts to write the pickled byte string to an open output file:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>pickle.dump(['code', 4, '<img src="assets/snake_1f40d.png" width="160" height="160"/>'], open('temp.pkl', 'w'))</strong></code>   <code><em># bytes+text mode fail</em></code>
TypeError: write() argument must be str, not bytes  

&gt;&gt;&gt; <code><strong>pickle.dump(['code', 4, '<img src="assets/snake_1f40d.png" width="160" height="160"/>'], open('temp.pkl', 'w'), protocol=0)</strong></code>
TypeError: write() argument must be str, not bytes

&gt;&gt;&gt; <code><strong>pickle.dump(['code', 4, '<img src="assets/snake_1f40d.png" width="160" height="160"/>'], open('temp.pkl', 'wb'))</strong></code>  <code><em># Always binary mode</em></code>

&gt;&gt;&gt; <code><strong>open('temp.pkl', 'r').read()</strong></code>
UnicodeDecodeError: 'utf-8' codec can't decode byte 0x80 in position 0:…</pre>
<p>Notice the last result fails here in text mode on macOS; if it doesn’t fail for you, it’s only because the stored binary data is compatible with your platform’s default decoding (i.e., just by luck!). A Windows host, for example, prints gibberish for the last result instead of an error message. Because pickle data is not generally decodable Unicode text, the same rule holds on input as output—correct usage always requires both writing and reading pickle data with binary-mode files, whether unpickling or not:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>pickle.dump(['code', 4, '<img src="assets/snake_1f40d.png" width="160" height="160"/>'], open('temp.pkl', 'wb'))</strong></code>    <code><em># Save to file</em></code>

&gt;&gt;&gt; <code><strong>pickle.load(open('temp.pkl', 'rb'))</strong>  </code>                    <code><em># Load from file</em></code>
['code', 4, '<img src="assets/snake_1f40d.png" width="160" height="160"/>']

&gt;&gt;&gt; <code><strong>open('temp.pkl', 'rb').read()</strong></code>
b'\x80\x04\x95\x15\x00\x00\x00\x00 …<code><em>etc</em></code>… \x04\x8c\x04\xf0\x9f\x90\x8d\x94e.'</pre>
<p>The Python <code>json</code> module, introduced in <a data-type="xref" href="ch09.html#tuplescomma_filescomma_and_everything_e">Chapter 9</a>, is a related tool: it converts a nested-object tree to a text string that can be saved on a file to make it persistent. Unlike <code>pickle</code>, <code>json</code> doesn’t support arbitrary objects (just basic types and built-in containers) but uses a language-neutral scheme that can make it more interoperable with other programs.</p>
<p>Also unlike <code>pickle</code>, the <code>json</code> module always produces a <code>str</code>, so files for saves and <a contenteditable="false" data-type="indexterm" data-primary="pickle module" data-startref="pkmocick" id="id4641"></a><a contenteditable="false" data-type="indexterm" data-primary="modules" data-secondary="pickle" data-startref="mlodick" id="id4642"></a><a contenteditable="false" data-type="indexterm" data-primary="serialization" data-secondary="pickle module" data-startref="szkpmlu" id="id4643"></a><a contenteditable="false" data-type="indexterm" data-primary="json module" data-startref="jsnmdu" id="id4644"></a><a contenteditable="false" data-type="indexterm" data-primary="modules" data-secondary="json" data-startref="mldjaon" id="id4645"></a><a contenteditable="false" data-type="indexterm" data-primary="serialization" data-secondary="json module" data-startref="slzjondml" id="id4646"></a>loads should generally use <em>text mode</em> (JSON files are commonly encoded per UTF-8 for portability, but any encoding works as long as it’s consistent and expected):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>import json</strong> </code>
&gt;&gt;&gt; <code><strong>vals = ['code', {'app': ('<img src="assets/slightly-smiling-face_1f642.png" width="160" height="160"/>', None, 1.23, 99)}]</strong></code>
&gt;&gt;&gt; <code><strong>json.dumps(vals)</strong></code>
'["code", {"app": ["\\ud83d\\ude42", null, 1.23, 99]}]'

&gt;&gt;&gt; <code><strong>text = json.dumps(vals)</strong> </code>                         <code><em># Save to/load from str</em></code>
&gt;&gt;&gt; <code><strong>anew = json.loads(text)</strong></code>
&gt;&gt;&gt; <code><strong>anew</strong></code>
['code', {'app': ['<img src="assets/slightly-smiling-face_1f642.png" width="160" height="160"/>', None, 1.23, 99]}]

&gt;&gt;&gt; <code><strong>file = open('data.txt', 'w', encoding='utf8')</strong></code>    <code><em># Save/load text-mode file</em></code>
&gt;&gt;&gt; <code><strong>json.dump(vals, file)</strong></code>
&gt;&gt;&gt; <code><strong>file.close()</strong></code>
&gt;&gt;&gt; <code><strong>file = open('data.txt', 'r', encoding='utf8')</strong></code>
&gt;&gt;&gt; <code><strong>json.load(file)</strong></code>
['code', {'app': ['<img src="assets/slightly-smiling-face_1f642.png" width="160" height="160"/>', None, 1.23, 99]}]</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Filenames in open and Other Filename Tools"><div class="sect2" id="filenames_in_open_and_other_filename_to">
<h2>Filenames in open and Other Filename Tools</h2>
<p>So far in this chapter, we’ve <a contenteditable="false" data-type="indexterm" data-primary="filenames" id="flenmail"></a><a contenteditable="false" data-type="indexterm" data-primary="pathnames" id="phnama"></a>focused on the <em>content</em> of files, but their <em>names</em> have a Unicode story too. Its short version is that <code>str</code> is the norm for file pathnames in Python and is recommended for portability. If your code, like all the examples so far, uses <code>str</code> for filenames and pathnames, they simply work: Python’s file tools automatically translate them to and from the encoding used by the host platform and device.</p>
<p>It turns out, though, that Python’s file tools also allow you to specify file pathnames as <code>bytes</code> to skip automatic filesystem encoding in some contexts. This <code>bytes</code> mode may come in handy if you need more control over filename encodings in cross-platform code, but it is rarely needed in typical programs. Per Python’s manuals, in fact, this mode need be used only on some Unix systems where undecodable filenames may be present.</p>
<p>Nevertheless, <code>bytes</code> filenames do work in these tools, as shown in the following demo, which runs the same on macOS, Windows, Linux, and Android devices tested. As shown, the <code>open</code> function happily accepts text or bytes for a file’s non-ASCII pathname (this section’s examples were run in subfolder <em>_filenames</em> in the book’s examples package):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>import sys, os, glob</strong></code>
&gt;&gt;&gt; <code><strong>sys.getfilesystemencoding()</strong></code>          <code><em># Filesystem default: macOS and Win11</em></code>
'utf-8'

&gt;&gt;&gt; <code><strong>name1 = 'hÄck<img src="assets/slightly-smiling-face_1f642.png" width="160" height="160"/>1'</strong>  </code>                  <code><em># str filenames</em></code>
&gt;&gt;&gt; <code><strong>name2 = 'hÄck<img src="assets/slightly-smiling-face_1f642.png" width="160" height="160"/>2'</strong></code>
&gt;&gt;&gt; <code><strong>name2.encode('utf8')</strong></code>                 <code><em># bytes equivalent for name2 str</em></code>
b'h\xc3\x84ck\xf0\x9f\x99\x822'

&gt;&gt;&gt; <code><strong>os.listdir()</strong></code>                         <code><em># Make files with str and bytes names</em></code>
[]
&gt;&gt;&gt; <code><strong>open(name1, mode='w', encoding='utf8').write('text1')</strong></code>
5
&gt;&gt;&gt; <code><strong>open(b'h\xc3\x84ck\xf0\x9f\x99\x822', 'w', encoding='utf8').write('text2')</strong></code>
5
&gt;&gt;&gt; <code><strong>os.listdir()</strong></code>                         <code><em># Both show up on the filesystem</em></code>
['hÄck<img src="assets/slightly-smiling-face_1f642.png" width="160" height="160"/>1', 'hÄck<img src="assets/slightly-smiling-face_1f642.png" width="160" height="160"/>2']

&gt;&gt;&gt; <code><strong>open('hÄck<img src="assets/slightly-smiling-face_1f642.png" width="160" height="160"/>2').read()</strong></code>               <code><em># And can be accessed either way</em></code>
'text2'
&gt;&gt;&gt; <code><strong>open('hÄck<img src="assets/slightly-smiling-face_1f642.png" width="160" height="160"/>2'.encode('utf8')).read()</strong></code>
'text2'</pre>
<p>For <code>bytes</code> filenames, Python uses UTF-8 encoding on macOS and on Windows since 3.6 (with extra translation for the Windows API’s UTF-16). Linux, and by extension Android, accepts any sort of bytes for filenames, but Python tries to use UTF-8 when converting to and from <code>str</code> (with surrogate escapes for encoding errors: see Python’s manuals).</p>
<p>Whether <code>bytes</code> filenames are a useful tool or neat parlor trick depends on your use cases, but keep in mind that <code>bytes</code> filenames will only work in <code>open</code> if their encoding matches the expectations of Python or the underlying filesystem. To demo, the following passes Latin-1 bytes <code>b'h\xc4ck'<strong></strong> </code>to <code>open</code>: this <em>fails</em> on both macOS and Windows as shown (though with a <code>UnicodeDecodeError</code> on the latter because it’s trapped by Python):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>'hÄck'.encode('latin-1'), 'hÄck'.encode('utf-8')</strong></code>
(b'h\xc4ck', b'h\xc3\x84ck')

&gt;&gt;&gt; <code><strong>b'h\xc4ck'.decode('utf8')</strong></code>
UnicodeDecodeError: 'utf-8' codec can't decode byte 0xc4 in position 1:…

&gt;&gt;&gt; <code><strong>open(b'h\xc4ck', 'w')</strong></code>
OSError: [Errno 92] Illegal byte sequence: b'h\xc4ck'

# open(b'h\xc4ck'.decode('latin1'), 'w')<code><strong></strong></code>    <code><em># Works: convert to str</em></code>
# open(b'h\xc3\x84ck', 'w')<code><strong></strong>  </code>               <code><em># Works: use UTF-8 encoding</em></code></pre>
<p>By contrast, the preceding code’s <code>open</code> <em>works</em> on Linux and Android—which later decode the Latin-1 name <code>b'h\xc4ck'</code> to <code>str</code> by UTF-8, as surrogate-escaped <code>'h\udcc4ck'</code>. Still, this works only on drives using a Linux-native <em>filesystem</em>. For both its <code>bytes</code> and escaped <code>str</code> forms, the Latin-1 name fails in <code>open</code> on Linux and Android when the target is a removable drive formatted as exFAT. Hence, the effect of using arbitrary <code>bytes</code> in <code>open</code> varies by both platform and filesystem (that is, don’t do that!).</p>
<p>The <code>os</code> standard-library module’s directory-listing <code>listdir</code> similarly accepts <code>str</code> or <code>bytes</code> and returns a folder’s names in the same form, ready to be used in other file tools (per the earlier listing, it also defaults to the current directory if no folder is passed):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>os.listdir('.')</strong> </code>                     <code><em># str gives strs, bytes gives bytes</em></code>
['hÄck<img src="assets/slightly-smiling-face_1f642.png" width="160" height="160"/>1', 'hÄck<img src="assets/slightly-smiling-face_1f642.png" width="160" height="160"/>2']

&gt;&gt;&gt; <code><strong>os.listdir(b'.')</strong></code>
[b'h\xc3\x84ck\xf0\x9f\x99\x821', b'h\xc3\x84ck\xf0\x9f\x99\x822']

&gt;&gt;&gt; <code><strong>for name in os.listdir('.'):</strong></code>
        <code><strong>print(name, '=&gt;', open(name).read())</strong></code>
 
hÄck<img src="assets/slightly-smiling-face_1f642.png" width="160" height="160"/>1 =&gt; text1
hÄck<img src="assets/slightly-smiling-face_1f642.png" width="160" height="160"/>2 =&gt; text2

&gt;&gt;&gt; <code><strong>for name in os.listdir(b'.'):</strong></code>
        <code><strong>print(name, '=&gt;', open(name).read())</strong></code>

b'h\xc3\x84ck\xf0\x9f\x99\x821' =&gt; text1
b'h\xc3\x84ck\xf0\x9f\x99\x822' =&gt; text2</pre>
<p>The <code>glob</code> module does filename expansion both ways, too (as <code>str</code> or <code>bytes</code>), and <code>os.fsdecode</code> decodes filenames per the host’s default automatically:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>glob.glob('h*ck*')</strong></code>                   <code><em># str gives str, bytes gives byte</em></code>
['hÄck<img src="assets/slightly-smiling-face_1f642.png" width="160" height="160"/>1', 'hÄck<img src="assets/slightly-smiling-face_1f642.png" width="160" height="160"/>2']

&gt;&gt;&gt; <code><strong>glob.glob(b'h*ck*')</strong></code>
[b'h\xc3\x84ck\xf0\x9f\x99\x821', b'h\xc3\x84ck\xf0\x9f\x99\x822']

&gt;&gt;&gt; <code><strong>for name in glob.glob(b'h*ck*'):</strong></code>
        <code><strong>print(name.decode(sys.getfilesystemencoding()), os.fsdecode(name))</strong></code>

hÄck<img src="assets/slightly-smiling-face_1f642.png" width="160" height="160"/>1 hÄck<img src="assets/slightly-smiling-face_1f642.png" width="160" height="160"/>1
hÄck<img src="assets/slightly-smiling-face_1f642.png" width="160" height="160"/>2 hÄck<img src="assets/slightly-smiling-face_1f642.png" width="160" height="160"/>2</pre>
<p>In addition, tools that create and walk folders are similarly flexible for names and paths (demoed on Windows—your path separators and order may vary):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>os.mkdir('sub<img src="assets/speak-no-evil-monkey_1f64a.png" width="160" height="160"/>')</strong></code>                         <code><em># Make dirs with str or bytes</em></code>
&gt;&gt;&gt; <code><strong>os.mkdir('sub<img src="assets/speak-no-evil-monkey_1f64a.png" width="160" height="160"/>bytes'.encode('utf8'))</strong></code>     <code><em># and walk them with both</em></code>
&gt;&gt;&gt; <code><strong>os.mkdir('sub<img src="assets/speak-no-evil-monkey_1f64a.png" width="160" height="160"/>bytes/subsub<img src="assets/thumbs-up_1f44d.png" width="160" height="160"/>')</strong></code>

&gt;&gt;&gt; <code><strong>os.listdir()</strong></code>
['hÄck<img src="assets/slightly-smiling-face_1f642.png" width="160" height="160"/>1', 'hÄck<img src="assets/slightly-smiling-face_1f642.png" width="160" height="160"/>2', 'sub<img src="assets/speak-no-evil-monkey_1f64a.png" width="160" height="160"/>', 'sub<img src="assets/speak-no-evil-monkey_1f64a.png" width="160" height="160"/>bytes']
&gt;&gt;&gt; <code><strong>os.listdir('sub<img src="assets/speak-no-evil-monkey_1f64a.png" width="160" height="160"/>bytes')</strong></code>
['subsub<img src="assets/thumbs-up_1f44d.png" width="160" height="160"/>']

&gt;&gt;&gt; <code><strong>for (dirhere, subshere, fileshere) in os.walk('.'):</strong></code>
        <code><strong>print(dirhere, '=&gt;', subshere, fileshere)</strong></code>

. =&gt; ['sub<img src="assets/speak-no-evil-monkey_1f64a.png" width="160" height="160"/>', 'sub<img src="assets/speak-no-evil-monkey_1f64a.png" width="160" height="160"/>bytes'] ['hÄck<img src="assets/slightly-smiling-face_1f642.png" width="160" height="160"/>1', 'hÄck<img src="assets/slightly-smiling-face_1f642.png" width="160" height="160"/>2']
.\sub<img src="assets/speak-no-evil-monkey_1f64a.png" width="160" height="160"/> =&gt; [] []
.\sub<img src="assets/speak-no-evil-monkey_1f64a.png" width="160" height="160"/>bytes =&gt; ['subsub<img src="assets/thumbs-up_1f44d.png" width="160" height="160"/>'] []
.\sub<img src="assets/speak-no-evil-monkey_1f64a.png" width="160" height="160"/>bytes\subsub<img src="assets/thumbs-up_1f44d.png" width="160" height="160"/> =&gt; [] []
&gt;&gt;&gt;
&gt;&gt;&gt; <code><strong>for (dirhere, subshere, fileshere) in os.walk(b'.'):</strong></code>
        <code><strong>print(dirhere, '=&gt;', subshere, fileshere)</strong></code>

b'.' =&gt; [b'sub\xf0\x9f\x99\x8a', b'sub\xf0\x9f\x99\x8abytes'] [b'…', b'…']
b'.\\sub\xf0\x9f\x99\x8a' =&gt; [] []
b'.\\sub\xf0\x9f\x99\x8abytes' =&gt; [b'subsub\xf0\x9f\x91\x8d'] []
b'.\\sub\xf0\x9f\x99\x8abytes\\subsub\xf0\x9f\x91\x8d' =&gt; [] []</pre>
<p>While <code>bytes</code> pathnames work as shown and may have some valid roles, it’s important to stress that you’re almost always better off using <code>str</code> strings to name files instead. Doing so leverages tools that already go to great lengths to make pathnames do the right thing and might just avoid at least some portability issues that can arise in apps whose scope must span platforms and devices.</p>
<p>And that’s all the time and space we have for this tools survey. Really, Python’s standard library and third-party domain are large and evolving toolsets that will likely occupy much of your attention after you’ve finished this book and move on to real programming tasks. Again, be sure to consult the Python Library Reference soon and often for more info.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="unicode_defaults_and_utf_eight_mode">
<h1>Unicode Defaults and UTF-8 Mode</h1>
<p>So what’s the default encoding, then? This turns out to be a weirdly convoluted story, which we’ve touched <a contenteditable="false" data-type="indexterm" data-primary="Unicode" data-secondary="default encoding" id="id4647"></a><a contenteditable="false" data-type="indexterm" data-primary="UTF-8 encoding" id="id4648"></a>on lightly a few times. Now that we’ve seen all the players in action, we can finally summarize and finalize this thread.</p>
<p>In short, Python’s default Unicode encoding for both <em>source code</em> and string encoding/decoding <em>methods</em> is always UTF-8 everywhere; for <em>filenames</em> can be had with <code>sys.getfilesystem​encod⁠ing()</code>; and for <em>file content</em> accessed via <code>open</code> is fetched with <code>locale.getpreferred​encod⁠ing(False)</code>.</p>
<p>The <em>methods</em> default is <code>sys.getdefaultencoding()</code>, but it can no longer be changed as of Python 3.2 (and probably shouldn’t have been changed earlier). The <em>filenames</em> default is usually UTF-8, including on Windows as of Python 3.6, but is moot if your names are always <code>str</code> (as we learned in the preceding section).</p>
<p>The <code>open</code> default for <em>file content</em> is bifurcated most and badly. Contrary to Python’s current docs, it’s not simply the result of <code>locale.getencoding()</code> on all platforms. Rather, it’s either UTF-8 if the <em>UTF-8 mode</em> introduced in Python 3.7 is enabled or else <code>getencoding()</code>. This matters on Windows today, where <code>getencoding()</code> may be a code-page encoding like cp1252; because Unix is usually UTF-8, an <code>open</code> sans <code>encoding</code> isn’t portable for non-ASCII content.</p>
<p><em>UTF-8 mode</em> addresses this, but it must be enabled today by setting the environment variable <span class="keep-together"><code>PYTHONUTF8</code></span> to <code>1</code> or using command-line switch <code>-X utf8</code>. The result of <code>getencoding()</code>, added in Python 3.11, is not influenced by UTF-8 mode the way that <code>open</code> and the older <code>getpreferred​encod⁠ing(False)</code> in <code>locale</code> are. Hence, <code>open</code>’s conditional default.</p>
<p>Both of the <code>locale</code> encoding results may also be influenced by platform, environment variables, and command-line switches…<em>except</em> on Android, which is just plain UTF-8, and on Windows in the future, when <em>Python 3.15</em> will turn UTF-8 mode on by default to match other platforms for code that lacks explicit encodings—a good idea, though too late to the party to avoid making a scene.</p>
<p>Separately, environment variable <code>PYTHONIOENCODING</code> can be used to give the encoding of <em>stdio streams</em> (e.g., <code>sys.stdout</code>) when they are redirected to files on Windows and others (e.g., <code>&gt; <em>output</em>.txt</code>)…<em>except</em> when you or a Python of the future enable 3.7’s UTF-8 mode, which applies to redirected streams too…<em>unless</em> variable <code>PYTHONIOENCODING</code> is also set.</p>
<p>Beyond all this, the encoding fate of unredirected console streams on Windows can be sealed with <code>PYTHONLEGACYWINDOWSSTDIO</code>; filename encodings on Windows may also backslide to their code-page roots for the brazenly grandiose <code>PYTHONLEGACYWINDOWSFSENCODING</code>; Unix encodings can be forced to skip UTF-8 similarly with <code>PYTHONCOERCECLOCALE</code>; and UTF-8 mode modulates additional textual tools omitted here for space (and humanity).</p>
<p>Right. If you don’t care to remember all that—and prefer to sleep well at night—enable UTF-8 mode on Windows today before Python 3.15 does; use <code>str</code> for filenames and pass explicit encodings to <code>open</code> instead of relying on tangled and morphing <a contenteditable="false" data-type="indexterm" data-primary="filenames" data-startref="flenmail" id="id4649"></a><a contenteditable="false" data-type="indexterm" data-primary="pathnames" data-startref="phnama" id="id4650"></a>defaults; and see Python’s manuals for the full, if frightening, story.</p>
</div></aside>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="The Unicode Twilight Zone"><div class="sect1" id="the_unicode_twilight_zone">
<h1>The Unicode Twilight Zone</h1>
<p>To wrap up, this chapter is going to briefly present two curated topics from the Unicode realm—BOMs and normalization—that are too convoluted for full coverage in this book and probably too arcane to matter to most Python newcomers. If and when these become important to your projects, you’ll find ample resources in both Python’s docs and the web at large to fill in the bits glossed over here for space. For now, let’s jump right into the first of these arguably explosive topics.</p>
<section data-type="sect2" data-pdf-bookmark="Dropping the BOM in Python"><div class="sect2" id="dropping_the_bom_in_python">
<h2>Dropping the BOM in Python</h2>
<p>As noted briefly earlier in this chapter, some encoding schemes store a special <em>byte order marker</em> (BOM) sequence at the start of files to specify data endianness (which end of a string of bits is most significant to its value) or declare the encoding type in general. Python’s text-mode files both skip this marker on input and write it on output if the encoding implies presence, but we sometimes must use a specific encoding name to force BOM processing explicitly and may need to accommodate it when encoding manually.</p>
<p>For example, in the UTF-16 and UTF-32 encodings, the BOM both identifies the encoding and specifies big- or little-endian format. A UTF-8 text file may also include a BOM, but this isn’t guaranteed and serves only to declare that it is UTF-8 in general.</p>
<p>When reading and writing data using these encoding schemes, Python automatically skips or writes the BOM if it is either implied by a general encoding name or if you provide a more specific encoding name to force the issue. More concretely:</p>
<ul>
<li><p>In <em>UTF-16</em>, the BOM is always processed for encoding name <code>utf-16</code>, and the more specific encoding name <code>utf-16-le</code> denotes little-endian format.</p></li>
<li><p>In <em>UTF-8</em>, the more specific encoding name <code>utf-8-sig</code> forces Python to both skip and write a BOM on input and output, respectively, but the general <code>utf-8</code> does not.</p></li>
</ul>
<section data-type="sect3" data-pdf-bookmark="Making BOMs in Text Editors"><div class="sect3" id="making_boms_in_text_editors">
<h3>Making BOMs in Text Editors</h3>
<p>Let’s make some files with BOMs to see how <a contenteditable="false" data-type="indexterm" data-primary="BOM (byte order marker)" data-secondary="text editors" id="bomyrkr"></a><a contenteditable="false" data-type="indexterm" data-primary="text editors" data-secondary="BOM (byte order marker)" id="txdykr"></a><a contenteditable="false" data-type="indexterm" data-primary="Notepad, BOM (byte order marker)" id="npdbyrdl"></a>this works in practice. We’re going to do this in Python in a moment, too, but let’s start by creating a file in a text editor to underscore that your programs will also have to process content from other sources. If you wish to work along, you can use any text editor that’s Unicode aware for saves, and most editors on PCs, tablets, and phones are today. This demo uses Windows Notepad just because it’s widespread (and documenting multiple editors’ usage here is right out).</p>
<p>When you save a text file in Windows Notepad, you can specify its encoding type in a drop-down list—simple text, little- or big-endian UTF-16, or UTF-8 with or without a BOM. For instance, if you use Notepad to save the two lines “code” and “CODE” in a text file named <em>code.txt</em> with encoding type <em>ANSI</em>, the file is written as simple ASCII text without a BOM. Technically, the save uses the cp1252 default encoding on the Windows host used, but cp1252 is an ASCII superset, and the content is all ASCII.</p>
<p>In Python after the save, when this file is read in binary mode, we can see the actual bytes stored in the file, including <code>\r</code> in newlines. When it’s read as text, Python performs newline translation by default, and we can also decode it explicitly as UTF-8 text since ASCII is a subset of both this encoding and Windows’ default cp1252:</p>
<pre data-type="programlisting">$ <code><strong>py -3</strong></code>                                   <code><em># On Windows, post ANSI save in Notepad</em></code>
&gt;&gt;&gt; <code><strong>import locale</strong></code>
&gt;&gt;&gt; <code><strong>locale.getpreferredencoding(False)</strong></code>    <code><em># open default: ASCII&amp;Latin-1 superset</em></code>
'cp1252'
&gt;&gt;&gt; <code><strong>open('code.txt', 'rb').read()</strong></code>         <code><em># ASCII (and cp1252 and UTF-8) bytes</em></code>
b'code\r\nCODE\r\n'
&gt;&gt;&gt; <code><strong>open('code.txt', 'r').read()</strong></code>          <code><em># Text mode also translates newlines</em></code>
'code\nCODE\n'
&gt;&gt;&gt; <code><strong>open('code.txt', 'r', encoding='utf-8').read()</strong></code>
'code\nCODE\n'</pre>
<p>Now, if this file is instead saved as <em>UTF-8 with BOM</em> in Notepad (<em>UTF</em> in its prior versions), its text is prepended with a three-byte UTF-8 BOM sequence (which prints as non-ASCII <code>\x<em>NN</em></code> hex escapes in <code>bytes</code> in Python), and we need to give the more specific encoding name <code>utf-8-sig</code> to force Python to skip the marker automatically on input (else it prints as a <code>\u<em>NNNN</em></code> Unicode code-point escapes in <code>str</code>):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>open('code.txt', 'rb').read()</strong></code>       <code><em># After resaved: UTF-8 with 3-byte BOM</em></code>
b'\xef\xbb\xbfcode\r\nCODE\r\n'
&gt;&gt;&gt; <code><strong>open('code.txt', 'r').read()</strong>   </code>     <code><em># Default+utf8 keep BOM, utf-8-sig drops</em></code>
'ï»¿code\nCODE\n'
&gt;&gt;&gt; <code><strong>open('code.txt', 'r', encoding='utf-8').read()</strong></code>
'\ufeffcode\nCODE\n'
&gt;&gt;&gt; <code><strong>open('code.txt', 'r', encoding='utf-8-sig').read()</strong></code>
'code\nCODE\n'</pre>
<p>And if the file is stored as <em>UTF-16 BE</em> in Notepad (<em>Unicode big endian</em> formerly), we get UTF-16 big-endian format data in the file, with two bytes (16 bits) prepended to record a two-byte BOM sequence. The encoding name <code>utf-16</code> in Python skips the BOM because it is implied (since all UTF-16 files have a BOM), and <code>utf-16-be</code> handles the big-endian format but does not skip the BOM in the input result:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>open('code.txt', 'rb').read()</strong></code>
b'\xfe\xff\x00c\x00o\x00d\x00e\x00\r\x00\n\x00C\x00O\x00D\x00E\x00\r\x00\n'

&gt;&gt;&gt; <code><strong>open('code.txt', 'r', encoding='utf-16').read()</strong></code>
'code\nCODE\n'

&gt;&gt;&gt; <code><strong>open('code.txt', 'r', encoding='utf-16-be').read()</strong></code>
'\ufeffcode\nCODE\n'</pre>
<p>Experiment with other save/open combinations for more insights. The default encoding in the last example, for example, would print garbage characters because it’s not valid for the text, and UTF-16 little-endian swaps byte order for the BOM and each 2-byte character.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><em>Notepad flux</em>: Notepad recently changed its encoding options for saves. Today, it offers ANSI (the host’s default), UTF-16 in little- and big-endian flavors, and UTF-8 with and without a BOM, and defaults to UTF-8. When this book’s prior edition was penned, Notepad had UTF-8 with an implied BOM, and its “Unicode” meant UTF-16—which, of course, is just one of the very many kinds of Unicode encoding. The narrative here has been updated to reflect the new choices, but this naturally is just the <a contenteditable="false" data-type="indexterm" data-primary="BOM (byte order marker)" data-secondary="text editors" data-startref="bomyrkr" id="id4651"></a><a contenteditable="false" data-type="indexterm" data-primary="text editors" data-secondary="BOM (byte order marker)" data-startref="txdykr" id="id4652"></a><a contenteditable="false" data-type="indexterm" data-primary="Notepad, BOM (byte order marker)" data-startref="npdbyrdl" id="id4653"></a>story today. Because this book staunchly refuses to become a Notepad doc, translate save options as needed to the Notepad on a PC near you.</p>
</div>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Making BOMs in Python"><div class="sect3" id="making_boms_in_python">
<h3>Making BOMs in Python</h3>
<p>The preceding section used Python to read <a contenteditable="false" data-type="indexterm" data-primary="BOM (byte order marker)" data-secondary="adding" id="bompr"></a><a contenteditable="false" data-type="indexterm" data-primary="UTF-8 encoding" data-secondary="BOM (byte order marker)" id="utfbykrr"></a>files made in an editor, but the same patterns apply when Python also makes the files: Python will automatically add a BOM when we write a Unicode file in code, but we need to use a more explicit encoding name to force the BOM in UTF-8 mode—<code>utf-8</code> does not write the BOM on output but <code>utf-8-sig</code> does, and the same goes for skipping UTF-8 BOMs on input. When run on Windows (Unix is the same, but doesn’t add <code>\r</code> to newlines, and usually defaults to UTF-8):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>open('temp.txt', 'w', encoding='utf-8').write('code\nCODE\n')</strong></code>
10
&gt;&gt;&gt; <code><strong>open('temp.txt', 'rb').read()</strong></code>                         <code><em># utf-8: no BOM</em></code>
b'code\r\nCODE\r\n'

&gt;&gt;&gt; <code><strong>open('temp.txt', 'w', encoding='utf-8-sig').write('code\nCODE\n')</strong></code>
10
&gt;&gt;&gt; <code><strong>open('temp.txt', 'rb').read()</strong></code>                         <code><em># utf-8-sig: adds BOM</em></code>
b'\xef\xbb\xbfcode\r\nCODE\r\n'

&gt;&gt;&gt; <code><strong>open('temp.txt', 'r').read()</strong> </code>                         <code><em># Default: bad BOM</em></code>
'ï»¿code\nCODE\n'
&gt;&gt;&gt; <code><strong>open('temp.txt', 'r', encoding='utf-8').read()</strong></code>        <code><em># utf-8: keeps BOM</em></code>
'\ufeffcode\nCODE\n'
&gt;&gt;&gt; <code><strong>open('temp.txt', 'r', encoding='utf-8-sig').read()</strong></code>    <code><em># utf-8-sig: drops BOM</em></code>
'code\nCODE\n'</pre>
<p>Per this code, although <code>utf-8</code> does not drop the BOM when one is present, data <em>without</em> a BOM can be read with both <code>utf-8</code> and <code>utf-8-sig</code>—which means you can use the latter for input if you’re not sure whether a BOM is present in a file or not (and don’t read this paragraph out loud in an airport security line!):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>open('temp.txt', 'w').write('code\nCODE\n')</strong> </code>          <code><em># Default: UTF-8 subset</em></code>
10
&gt;&gt;&gt; <code><strong>open('temp.txt', 'rb').read()</strong></code>                         <code><em># No BOM</em></code>
b'code\r\nCODE\r\n'

&gt;&gt;&gt; <code><strong>open('temp.txt', 'r').read()</strong></code>                          <code><em># Default</em></code>
'code\nCODE\n'
&gt;&gt;&gt; <code><strong>open('temp.txt', 'r', encoding='utf-8').read()</strong>   </code>     <code><em># Either utf-8 works</em></code>
'code\nCODE\n'
&gt;&gt;&gt; <code><strong>open('temp.txt', 'r', encoding='utf-8-sig').read()</strong></code>
'code\nCODE\n'</pre>
<p>For the encoding name <code>utf-16</code>, the BOM is handled automatically: on <em>output</em>, data is written in the platform’s native endianness, and the BOM is always written; on <em>input</em>, data is decoded per the BOM, and the BOM is always stripped. This reflects the fact that BOMs are standard and required in the UTF-16 encoding scheme:</p>
<pre data-type="programlisting" class="less_codespace">&gt;&gt;&gt; <code><strong>import sys</strong></code>
&gt;&gt;&gt; <code><strong>sys.byteorder</strong></code>         <code><em># Windows host's default endianness</em></code>
'little'
&gt;&gt;&gt; <code><strong>open('temp.txt', 'w', encoding='utf-16').write('code\nCODE\n')</strong></code>
10

&gt;&gt;&gt; <code><strong>open('temp.txt', 'rb').read()</strong></code>
b'\xff\xfec\x00o\x00d\x00e\x00\r\x00\n\x00C\x00O\x00D\x00E\x00\r\x00\n\x00'

&gt;&gt;&gt; <code><strong>open('temp.txt', 'r', encoding='utf-16').read()</strong></code>
'code\nCODE\n'</pre>
<p>More specific UTF-16 encoding names can specify different endianness, though you may have to manually write and skip the BOM yourself in some scenarios if it is required or present—study the following examples for more BOM-making instructions (sorry):</p>
<pre class="less_codespace" data-type="programlisting">&gt;&gt;&gt; <code><strong>open('temp.txt', 'r', encoding='utf-16-le').read()</strong></code>
'\ufeffcode\nCODE\n'

&gt;&gt;&gt; <code><strong>open('temp.txt', 'w', encoding='utf-16-be').write('\ufeffcode\nCODE\n')</strong></code>
11
&gt;&gt;&gt; <code><strong>open('temp.txt', 'rb').read()</strong></code>
b'\xfe\xff\x00c\x00o\x00d\x00e\x00\r\x00\n\x00C\x00O\x00D\x00E\x00\r\x00\n'

&gt;&gt;&gt; <code><strong>open('temp.txt', 'r', encoding='utf-16').read()</strong></code>
'code\nCODE\n'
&gt;&gt;&gt; <code><strong>open('temp.txt', 'r', encoding='utf-16-be').read()</strong></code>
'\ufeffcode\nCODE\n'</pre>
<p>The more specific UTF-16 encoding names by themselves create and work fine with BOM-less files, though <code>utf-16</code> requires one on input in order to determine byte order:</p>
<pre class="less_codespace2" data-type="programlisting">&gt;&gt;&gt; <code><strong>open('temp.txt', 'w', encoding='utf-16-le').write('CODE')</strong></code>
4
&gt;&gt;&gt; <code><strong>open('temp.txt', 'rb').read()</strong></code>       <code><em># Okay if BOM not present or expected</em></code>
b'C\x00O\x00D\x00E\x00'

&gt;&gt;&gt; <code><strong>open('temp.txt', 'r', encoding='utf-16-le').read()</strong></code>
'CODE'
&gt;&gt;&gt; <code><strong>open('temp.txt', 'r', encoding='utf-16').read()</strong></code>
UnicodeError: UTF-16 stream does not start with BOM</pre>
<p>Experiment with these encodings yourself, or see Python’s library manuals for more details on the BOM. And if you really want <a contenteditable="false" data-type="indexterm" data-primary="BOM (byte order marker)" data-secondary="adding" data-startref="bompr" id="id4654"></a><a contenteditable="false" data-type="indexterm" data-primary="UTF-8 encoding" data-secondary="BOM (byte order marker)" data-startref="utfbykrr" id="id4655"></a>to drop the bomb in Python (and stretch this section’s silly bit to its breaking point), Unicode emoji characters do the job:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>open('boms.txt', 'w', encoding='utf-8-sig').write('<img src="assets/bomb_1f4a3.png" width="160" height="160"/>' * 10)</strong></code>
10
&gt;&gt;&gt; <code><strong>open('boms.txt', encoding='utf-8-sig').read()</strong></code>
'<img src="assets/bomb_1f4a3.png" width="160" height="160"/><img src="assets/bomb_1f4a3.png" width="160" height="160"/><img src="assets/bomb_1f4a3.png" width="160" height="160"/><img src="assets/bomb_1f4a3.png" width="160" height="160"/><img src="assets/bomb_1f4a3.png" width="160" height="160"/><img src="assets/bomb_1f4a3.png" width="160" height="160"/><img src="assets/bomb_1f4a3.png" width="160" height="160"/><img src="assets/bomb_1f4a3.png" width="160" height="160"/><img src="assets/bomb_1f4a3.png" width="160" height="160"/><img src="assets/bomb_1f4a3.png" width="160" height="160"/>'</pre>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Unicode Normalization: Whither Standard?"><div class="sect2" id="unicode_normalization_whither_standardq">
<h2>Unicode Normalization: Whither Standard?</h2>
<p>Last but not least, after devoting dozens of pages to Unicode, we’ll close by explaining one way in <a contenteditable="false" data-type="indexterm" data-primary="Unicode" data-secondary="normalization" id="unrlzt"></a><a contenteditable="false" data-type="indexterm" data-primary="normalization, Unicode" id="nrmlztcd"></a>which it, at least arguably, falls short. In brief, this standard <em>failed to standardize</em> code points for a handful of characters: it allows the same character to be represented in more than one way, which breaks equality testing and can wreak interoperability havoc with text-processing programs. While there may have been valid rationales for this policy, it adds a special case for programmers and undoubtedly breaks many a tool and app.</p>
<p>For example, the character <code>ñ</code> (an <code>n</code> augmented with a tilde, commonly used in Spanish) can be represented with two different code-point sequences in the Unicode standard:</p>
<ul>
<li><p>As a single character with code point <code>\u00F1</code>—an augmented <code>n</code></p></li>
<li><p>As a two-codepoint sequence <code>\u006E</code> and <code>\u0303</code>—a naked <code>n</code> followed by a combining tilde</p></li>
</ul>
<p>The first of these is called the <em>composed</em> form, known as <em>NFC</em>, because it combines letter and accent. The second is called the <em>decomposed</em> form, known as <em>NFD</em>, because its parts are split. Despite their glaring difference, the Unicode standard mandates that these two forms represent the same character <code>ñ</code> and must be treated as such by programs.</p>
<p>It’s easy to observe these alter egos in Python: the following uses <code>\u…</code> Unicode code-point escapes to specify the code points for <code>ñ</code> in both forms (Windows users: don’t be alarmed if some characters, especially NFDs, render differently in command-line interfaces due to settings that are well beyond this book’s scope):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>L = '\u00F1'</strong></code>            <code><em># NFC form ('\xF1' works too)</em></code>
&gt;&gt;&gt; <code><strong>M = '\u006E\u0303'</strong></code>      <code><em># NFD form</em></code> 
&gt;&gt;&gt; <code><strong>L, M</strong></code>                    <code><em># The same character</em></code>
('ñ', 'ñ')</pre>
<p>Nor is this character alone in its split personality. Other characters such as <code>Å</code>, <code>è</code>, <code>é</code>, and <code><img src="assets/upsilon.png" width="160" height="160"/></code> have both NFC and NFD representations as well:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>'\u00C5', '\u0041\u030A'</strong></code>      <code><em># NFD (1 code point), NFC (2 code points</em></code>)
('Å', 'Å')
&gt;&gt;&gt; <code><strong>'\u00E8', '\u0065\u0300'</strong></code>      <code><em># But it's the same character for both</em></code>
('è', 'è')
&gt;&gt;&gt; <code><strong>'\u00E9', '\u0065\u0301'</strong></code>
('é', 'é')
&gt;&gt;&gt; <code><strong>'\u03D4', '\u03D2\u0308'</strong></code>
('<img src="assets/upsilon.png" width="160" height="160"/>', '<img src="assets/upsilon.png" width="160" height="160"/>̈')</pre>
<p>Importantly, this is not about the <em>encoded</em> representation of this character in bytes, which naturally varies across different encodings. The two alternative representations for each preceding character differ for their decoded, in-memory representation as integer <em>code points</em>. Encoded forms (e.g., stored in files) differ, too, but decode to the same differing code points:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>'\u00F1'.encode('utf8'), '\u006E\u0303'.encode('utf8')</strong></code>
(b'\xc3\xb1', b'n\xcc\x83')

&gt;&gt;&gt; <code><strong>b'\xc3\xb1'.decode('utf8'), b'n\xcc\x83'.decode('utf8')</strong></code>
('ñ', 'ñ')</pre>
<p>The unfortunate consequence of this plurality is that it <em>breaks equality testing</em>: because the same character can be represented in multiple ways, it’s impossible to compare with the usual tools. In Python specifically, the <code>==</code> equal-by-value operator, which compares characters (really, code points), won’t suffice in the presence of Unicode doppelgängers:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>L = '\u00F1'</strong></code>
&gt;&gt;&gt; <code><strong>M = '\u006E\u0303'</strong></code>

&gt;&gt;&gt; <code><strong>L, M</strong></code>                       <code><em># The same character</em></code>
('ñ', 'ñ')
 
&gt;&gt;&gt; <code><strong>L == M</strong></code>                     <code><em># But equality says no!</em></code>
False
 
&gt;&gt;&gt; <code><strong>len(L), len(M)</strong></code>             <code><em># Because their code points differ</em></code>
(1, 2)</pre>
<p>All of which might not be a problem in an ideal computing world that settled on one form as a de facto standard for portability’s sake. Unfortunately, that’s not the world we occupy. Computer vendors, being computer vendors, have opted to favor different forms: broadly speaking, macOS prefers NFD, Windows and others prefer NFC, this can also vary by filesystem, and tolerance of nonnative forms is less than complete. The net effect is that the Unicode standard created an interoperability problem while trying to fix another!</p>
<p>So what to do with a world that just won’t standardize? The trick is that, for every tool that processes file contents or names across divergent platforms, text must be converted to a common form before comparisons. And luckily, Python makes this remarkably easy:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>from unicodedata import normalize</strong></code>             <code><em># Python stdlib tool</em></code>
&gt;&gt;&gt; <code><strong>L = '\u00F1'</strong></code>
&gt;&gt;&gt; <code><strong>M = '\u006E\u0303'</strong> </code>
&gt;&gt;&gt; <code><strong>L, M</strong></code>                                          <code><em># Same char, diff code points</em></code>
('ñ', 'ñ')

&gt;&gt;&gt; <code><strong>L == M</strong></code>                                        <code><em># Equality fails</em></code>
False
 
&gt;&gt;&gt; <code><strong>normalize('NFC', L) == normalize('NFC', M)</strong></code>    <code><em># Common-form equality works</em></code>
True
&gt;&gt;&gt; <code><strong>normalize('NFD', L) == normalize('NFD', M)</strong></code>    <code><em># Either suffices, if the same</em></code>
True</pre>
<p>Programs that compare filenames sent between platforms, for example, should be careful to normalize this way. Otherwise, files whose names look the same to users (and really <em>are</em> the same per Unicode) will fail to match by simple equality and derail searches and syncs. The same goes for text files obtained from arbitrary sources—like most internet content.</p>
<p>There’s more to this story (e.g., the <em>canonical</em> equivalence of NFC and NFD normalized forms is still not the same as <em>compatibility</em>, though most programs don’t need to care). Because we’ve run tight on space, though, we’ll stop short. If you’d like to dig deeper, you’ll find ample follow-up coverage both on the web and in Python’s manual set (see the latter’s <a href="https://docs.python.org/3/howto/unicode.html">Unicode HOWTO</a> and its coverage of the related string <code>casefold</code> method).</p>
<p>At the least, though, you now shouldn’t be wholly surprised when your text-processing code is bitten by this <a contenteditable="false" data-type="indexterm" data-primary="Unicode" data-secondary="normalization" data-startref="unrlzt" id="id4656"></a><a contenteditable="false" data-type="indexterm" data-primary="normalization, Unicode" data-startref="nrmlztcd" id="id4657"></a>curious choice of the Unicode standard.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Chapter Summary"><div class="sect1" id="chapter_summary-id00048">
<h1>Chapter Summary</h1>
<p>This chapter explored the advanced string support available in Python for processing Unicode text and binary data. While some programmers use ASCII text and may get by with the basic string type and its operations, Python’s string model fully supports both richer Unicode text via the normal <code>str</code> string type and byte-oriented binary data with <code>bytes</code> and <code>bytearray</code>.</p>
<p>In addition, we learned how Python’s file object automatically encodes and decodes Unicode text, and deals with byte strings for binary-mode files. Finally, we briefly met some text and binary tools in Python’s library and sampled their behavior with strings, and took a look at the darker Unicode corners of BOMs and normalization.</p>
<p>In the next chapter, we’ll shift our focus to tool-builder topics, with a survey of ways to manage access to object attributes by inserting automatically run code. Before we move on, though, here’s a set of questions to review what we’ve learned. This has been a substantial chapter, so be sure to read the quiz answers eventually for a more in-depth summary.</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Test Your Knowledge: Quiz"><div class="sect1" id="test_your_knowledge_quiz-id000195">
<h1>Test Your Knowledge: Quiz</h1>
<ol>
<li><p>What are the names and roles of string object types in Python?</p></li>
<li><p>How do Python’s string types differ in terms of operations?</p></li>
<li><p>How can you code non-ASCII Unicode characters in a string in Python?</p></li>
<li><p>What are the main differences between text- and binary-mode files in Python?</p></li>
<li><p>How would you read a Unicode text file that contains text in a different encoding than the default for your platform?</p></li>
<li><p>How can you create a Unicode text file in a specific encoding format?</p></li>
<li><p>Why is ASCII text considered to be a kind of Unicode text?</p></li>
<li><p>What do BOM and normalization mean in Unicode?</p></li>
<li><p>How large an impact does Python’s text/binary string dichotomy have on your code?</p></li>
</ol>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Test Your Knowledge: Answers"><div class="sect1" id="test_your_knowledge_answers-id000194">
<h1>Test Your Knowledge: Answers</h1>
<ol>
<li><p>Python has three string types: <code>str</code> (for Unicode text, including ASCII), <code>bytes</code> (for binary data with absolute byte values), and <code>bytearray</code> (a mutable flavor of <code>bytes</code>). The <code>str</code> type usually represents content stored in text files, and the other two types generally represent content stored in binary files (including encoded text).</p></li>
<li><p>Python’s string types share almost all the same operations: method calls, sequence operations, and even larger tools like pattern matching work the same way. On the other hand, only <code>str</code> supports string formatting’s <code>format</code> method and <code>f'…'</code> f-strings, and <code>bytearray</code> has an additional set of operations that perform in-place changes. The <code>str</code> and <code>bytes</code> types also have methods for encoding and decoding text, respectively.</p></li>
<li><p>Non-ASCII Unicode characters can be coded in a <code>str</code> string with both hex (<code>\xNN</code>) and Unicode (<code>\uNNNN</code>, <code>\UNNNNNNNN</code>) escapes for code points, both of which denote character code points. They can also be coded in their encoded form as <code>bytes</code> using hex escapes and decoded to text. On most devices, non-ASCII characters—accented characters and emojis, for example—can also be typed or pasted directly into code and are interpreted per the UTF-8 default or an encoding-directive comment at the top of a source code file.</p></li>
<li><p>Text-mode files assume their content is Unicode text (even if it’s all ASCII) and automatically decode when reading and encode when writing. With binary-mode files, bytes are transferred to and from the file unchanged. The contents of text-mode files are usually represented as <code>str</code> objects in your script, and the contents of binary files are represented as <code>bytes</code> (or <code>bytearray</code>) objects. Text-mode files also handle BOMs for certain encoding types and automatically translate newline sequences to and from the single <code>\n</code> character on input and output unless this is explicitly disabled; binary-mode files do not perform either of these steps.</p></li>
<li><p>To read files encoded in a different encoding than the default for your platform, simply pass the name of the file’s encoding to the <code>open</code> built-in function; data will be decoded per the specified encoding when it is read from the file, and you’ll get back a decoded Unicode-text <code>str</code> string that has no encoding. You can also read in binary mode and manually decode the bytes to a string by giving an encoding name, but this involves extra work and is somewhat error-prone for multibyte characters (you may accidentally read a partial character sequence when loading content by bytes or chunks).</p></li>
<li><p>To create a Unicode text file in a specific encoding format, pass the desired encoding name to <code>open</code>; strings will be encoded per the desired encoding when they are written to the file. You can also manually encode a string to bytes and write it in binary mode, but this is usually extra work.</p></li>
<li><p>ASCII text is considered to be a kind of Unicode text because its 7-bit (0..127) range of values is a subset of many Unicode encodings. For example, valid ASCII text is also valid Latin-1 text (Latin-1 simply assigns the remaining possible values in an 8-bit byte to additional characters) and valid UTF-8 text (UTF-8 uses a variable-byte scheme for representing more characters, but ASCII characters are still represented with the same values in a single byte). This makes Unicode backward compatible with ASCII, as long as the encodings used represent ASCII the same way.</p></li>
<li><p>The Unicode BOM is a sequence of bytes added to the front of a text string or file in some encodings to both identify the encoding and give the string’s endianness. Unicode normalization converts characters to a common format to neutralize differences that arise for characters that have multiple code-point values in the Unicode standard and would fail to match by simple code-point (character) equality.</p></li>
<li><p>The impact of Python’s strings model depends upon the types of strings you use. For scripts that use simple ASCII text on platforms with ASCII-compatible default encodings, the impact is probably minor: the <code>str</code> string sans encodings suffices in this case. Moreover, although string-related tools in the standard library, such as <code>re</code>, <code>struct</code>, <code>pickle</code>, and <code>os</code>, may technically use different types in different contexts, the effect is largely irrelevant to most programs because Python’s <code>str</code> and <code>bytes</code> support almost identical interfaces. On the other hand, if you process non-ASCII Unicode text, you’ll need to use <code>str</code> and pass encodings to <code>open</code>; if you deal with binary data files, you’ll need to deal with content as <code>bytes</code> objects; and if your code must work across many platforms or process content from arbitrary sources, you’ll want to use explicit encodings for text files. In general, Unicode is the way the text world works today and will be a must-know tool for most Python users.</p></li>
</ol>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="ch37fn1"><sup><a href="ch37.html#ch37fn1-marker">1</a></sup> File fine points: most of this chapter’s file examples use filenames relative to, and hence stored in, the current directory, so be sure to run them in a directory (a.k.a. folder) where you have <em>permission</em> to create files; <code>cd</code> to one in your shell or IDE if needed. This may matter on platforms with major storage constraints like Android, but you’ll probably already be in a safe folder in most apps. Also, file <em>extensions</em> (e.g., <code>.txt</code>) don’t mean anything to Python and are technically optional; some IDEs that hang on to objects for debugging may require manual <code>close</code> calls to flush changes too; and purists take note that <code>file</code> is no longer a built-in name in Python and OK to use as a variable here!</p></div></div></section></div>
</div>
</body>
</html>