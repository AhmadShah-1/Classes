<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xml:lang="en"
lang="en"
xmlns="http://www.w3.org/1999/xhtml"
xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<title>Learning Python, 6th Edition</title>
<link rel="stylesheet" type="text/css" href="override_v1.css"/>
<link rel="stylesheet" type="text/css" href="epub.css"/>
</head>
<body>
<div id="book-content">
<div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 18. Arguments"><div class="chapter" id="arguments">
<h1><span class="label">Chapter 18. </span>Arguments</h1>
<p>The preceding chapter explored Python’s <em>scopes</em>—the places where variables are defined and looked up. As we saw, the place where a name is defined in our code determines much of its meaning. This chapter continues the function story by studying the concepts in Python <em>argument passing</em>—the way that objects are sent to functions as inputs. As you’ll see, arguments (a.k.a. parameters) are assigned to names in a function, but have more to do with object references than with variable scopes. You’ll also find that Python provides extra tools, such as keywords, defaults, and argument collectors and extractors, that allow arguments to be sent to functions flexibly.</p>
<section data-type="sect1" data-pdf-bookmark="Argument-Passing Basics"><div class="sect1" id="argument_passing_basics">
<h1>Argument-Passing Basics</h1>
<p>Earlier in this part of the book, we learned that <code>def</code> and <code>lambda</code> are function <em>definitions</em>, and both include argument-list <em>headers</em> that name variables which receive values passed by <em>calls</em>. These arguments are used in function bodies, and may be matched between call and header by position, name, and other means we’ll explore later in this chapter.</p>
<p>More fundamentally, though, it was also <a contenteditable="false" data-type="indexterm" data-primary="assignments" data-secondary="argument passing" id="assgargp"></a>noted that all Python arguments are passed by <em>assignment</em>—which means <em>object reference</em>. This has some subtle ramifications that aren’t always obvious to newcomers. Let’s start our arguments adventure by exploring how this works. Here is a rundown of the key points in this model:</p>
<ul>
<li><p><strong>Arguments are passed <a contenteditable="false" data-type="indexterm" data-primary="argument passing" id="id3013"></a>by automatically assigning objects to local variable names.</strong> Function arguments are just another instance of Python assignment at work: they are <em>references</em> to objects sent by, and possibly shared with, the caller. Because references are implemented as pointers, all arguments are passed by opaque pointer. As for all assignments, objects passed as arguments are never automatically copied.</p></li>
<li><p><strong>Assigning to argument names inside a function does not affect the caller.</strong> Per assignment norms, when the function is run by a call, argument names in the function header simply become new names in the <em>local</em> scope of the function. There is no aliasing between function argument names and variable names in the caller’s scope.</p></li>
<li class="pagebreak-before"><p><strong>Changing a mutable object argument in a function may impact the caller.</strong> On the other hand, as <a contenteditable="false" data-type="indexterm" data-primary="function calls" data-secondary="arguments, mutable" id="id3014"></a><a contenteditable="false" data-type="indexterm" data-primary="arguments" data-secondary="mutable" id="id3015"></a><a contenteditable="false" data-type="indexterm" data-primary="mutable arguments" id="id3016"></a><a contenteditable="false" data-type="indexterm" data-primary="argument passing" data-secondary="mutable arguments" id="id3017"></a>arguments are simply references to passed-in objects, functions can change passed-in mutable objects in place, and the results may affect the caller. Hence, <em>mutable</em> arguments can be both input and output for functions.</p></li>
</ul>
<p>For more details on <em>references</em>, see <a data-type="xref" href="ch06.html#the_dynamic_typing_interlude">Chapter 6</a>; everything we studied there also applies to function arguments, though the assignment to argument names is automatic and implicit.</p>
<p>Python’s pass-by-assignment scheme isn’t quite the same as C++’s reference parameters option, but it turns out to be similar to the argument-passing model of the C language (and others) in practice. You don’t need to know these languages to use Python, of course, but the comparison might help those with backgrounds in other tools:</p>
<ul>
<li><p><strong>Immutable arguments have the same effect as passing “by value.”</strong> Objects such as integers and strings are passed by object reference instead of by copying, but because <a contenteditable="false" data-type="indexterm" data-primary="argument passing" data-secondary="immutable arguments" id="id3018"></a><a contenteditable="false" data-type="indexterm" data-primary="arguments" data-secondary="immutable" id="id3019"></a><a contenteditable="false" data-type="indexterm" data-primary="immutable arguments" id="id3020"></a>you can never <em>change</em> immutable objects in place anyhow, the net result is much like making a copy in other languages: the caller’s values never morph.</p></li>
<li><p><strong>Mutable arguments have the same effect as passing “by pointer.”</strong> Objects such as lists and dictionaries are also passed by object reference, which has similar consequences to passing arrays as pointers in C: mutable objects can be changed <em>in place</em> within the function, with side effects like those for C’s arrays.</p></li>
</ul>
<p>If you’ve never used C, Python’s argument-passing mode will seem simpler still—it involves just the assignment of object references to names, and it works the same whether the objects are mutable or not.</p>
<section data-type="sect2" data-pdf-bookmark="Arguments and Shared References"><div class="sect2" id="arguments_and_shared_references">
<h2>Arguments and Shared References</h2>
<p>To demo argument-passing properties at work, consider <a contenteditable="false" data-type="indexterm" data-primary="argument passing" data-secondary="references, shared" id="argpsrfrsh"></a><a contenteditable="false" data-type="indexterm" data-primary="references" data-secondary="shared" data-tertiary="argument passing" id="refshrgp"></a><a contenteditable="false" data-type="indexterm" data-primary="shared references" data-secondary="argument passing" id="shrfgpss"></a>the following code:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>def f(a):</strong></code>                 <code><em># a is assigned a reference to the passed object
</em></code>        <code><strong>a = 99</strong></code>                <code><em># Changes local variable a only</em></code>

&gt;&gt;&gt; <code><strong>b = 88</strong></code>
&gt;&gt;&gt; <code><strong>f(b)</strong></code>                      <code><em># a and b both reference same 88 initially</em></code>
&gt;&gt;&gt; <code><strong>b</strong>  </code>                       <code><em># But b is not changed by assignment to a in f</em></code>
88</pre>
<p>In this example, the variable <code>a</code> is assigned the object <code>88</code> at the moment the function is called with <code>f(b)</code>, but <code>a</code> lives only within the called function’s local scope. Changing <code>a</code> inside the function has no effect on the place where the function is called; it simply resets the local variable <code>a</code> to a completely different object, <code>99</code>.</p>
<p>That’s what is meant by a lack of name <em>aliasing</em>—assignment to an argument name inside a function (e.g., <code>a=99</code>) does <a contenteditable="false" data-type="indexterm" data-primary="names" data-secondary="aliasing" id="id3021"></a><a contenteditable="false" data-type="indexterm" data-primary="aliasing" id="id3022"></a>not magically change a variable like <code>b</code> in the scope of the function call. Argument names may share passed <em>objects</em> initially (they are essentially pointers to those objects), but only temporarily, when the function is first called. As soon as an argument name is reassigned, this relationship ends.</p>
<p class="pagebreak-before">At least, that’s the case for assignment to argument <em>names</em> themselves. When arguments are passed <em>mutable</em> objects like lists and dictionaries, we also need to be aware that in-place changes to such <em>objects</em> may live on after a function exits, and hence impact callers. Here’s an example that demonstrates this behavior:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>def changer(a, b):</strong></code>        <code><em># Arguments assigned references to objects</em></code>
        <code><strong>a = 2</strong></code>                 <code><em># Changes local name's value only</em></code>
        <code><strong>b[0] = 'mod'</strong></code>          <code><em># Changes shared object in place: outlives call</em></code>

&gt;&gt;&gt; <code><strong>X = 1</strong></code>
&gt;&gt;&gt; <code><strong>L = [1, 2]</strong></code>                <code><em># Caller:</em></code>
&gt;&gt;&gt; <code><strong>changer(X, L)</strong></code>             <code><em># Pass immutable and mutable objects</em></code>
&gt;&gt;&gt; <code><strong>X, L</strong></code>                      <code><em># X is unchanged, but L is different!
</em></code>(1, ['mod', 2])</pre>
<p>In this code, the <code>changer</code> function assigns values to argument <code>a</code> itself, and to a component of the <em>object</em> referenced by argument <code>b</code>. These two assignments within the function are only slightly different in syntax but have radically different results:</p>
<ul>
<li><p>Because <code>a</code> is a local variable name in the function’s scope, the first assignment has no effect on the caller—it simply changes the local variable <code>a</code> to reference a completely different object, and does not change the value of the name <code>X</code> in the caller’s scope. This is the same as in the prior example.</p></li>
<li><p>Argument <code>b</code> is a local variable name, too, but it is passed a mutable object—the list that <code>L</code> also references in the caller’s scope. Because the assignment to <code>b[0]</code> in the function is an in-place change to a shared object, its result impacts the value of <code>L</code> after the function returns.</p></li>
</ul>
<p>Really, the second assignment statement in <code>changer</code> doesn’t change <code>b</code>—it changes part of the object that <code>b</code> currently references. This in-place change impacts the caller only because the changed object outlives the function call. The name <code>L</code> hasn’t changed either—it still references the same, changed object—but it seems as though <code>L</code> differs after the call because the value it references has been modified within the function. In effect, the list name <code>L</code> serves as both <em>input</em> to and <em>output</em> from the function.</p>
<p><a data-type="xref" href="#function_arguments_and_shared_object_re">Figure 18-1</a> illustrates the name/object bindings that exist immediately after the function has been called, and before its code has run. When the call begins, two objects are shared among four names.</p>
<p>If this example is still confusing, it may help to notice that the effect of the automatic assignments of the passed-in arguments is the same as running a series of simple assignment statements. In terms of the <em>first</em> argument, the assignment has no effect on the caller:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>X = 1</strong></code>
&gt;&gt;&gt; <code><strong>a = X</strong></code>               <code><em># They share the same object</em></code>
&gt;&gt;&gt; <code><strong>a = 2</strong></code>               <code><em># Name change resets 'a' only, 'X' is still 1</em></code>
&gt;&gt;&gt; <code><strong>X</strong></code>
1</pre>
<figure><div id="function_arguments_and_shared_object_re" class="figure">
<img src="assets/lpy6_1801.png" alt="" width="927" height="600"/>
<h6><span class="label">Figure 18-1. </span>Function arguments and shared object references</h6>
</div></figure>
<p>The assignment through the <em>second</em> argument does affect a variable at the call, though, because it is an in-place object change:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>L = [1, 2]</strong></code>
&gt;&gt;&gt; <code><strong>b = L</strong></code>               <code><em># They share the same object</em></code>
&gt;&gt;&gt; <code><strong>b[0] = 'mod'</strong></code>        <code><em># In-place change from 'b': 'L' sees the change too</em></code>
&gt;&gt;&gt; <code><strong>L</strong></code>
['mod', 2]</pre>
<p>If you recall our discussions about shared mutable objects in Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch06.html#the_dynamic_typing_interlude">6</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch09.html#tuplescomma_filescomma_and_everything_e">9</a>, you’ll recognize the phenomenon at work: changing a mutable object in place can impact other references to that object. Here, the effect is to make one of <a contenteditable="false" data-type="indexterm" data-primary="argument passing" data-secondary="references, shared" data-startref="argpsrfrsh" id="id3023"></a><a contenteditable="false" data-type="indexterm" data-primary="references" data-secondary="shared" data-tertiary="argument passing" data-startref="refshrgp" id="id3024"></a><a contenteditable="false" data-type="indexterm" data-primary="shared references" data-secondary="argument passing" data-startref="shrfgpss" id="id3025"></a>the arguments work like both an input and an output of the function.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Avoiding Mutable Argument Changes"><div class="sect2" id="avoiding_mutable_argument_changes">
<h2>Avoiding Mutable Argument Changes</h2>
<p>This behavior of in-place changes to mutable arguments isn’t a bug—it’s simply the way argument passing works <a contenteditable="false" data-type="indexterm" data-primary="argument passing" data-secondary="mutable arguments" data-tertiary="changes" id="argmutch"></a><a contenteditable="false" data-type="indexterm" data-primary="mutable arguments" data-secondary="changes" id="mrgchg"></a>in Python, and turns out to be widely useful in practice. Arguments are normally passed to functions by reference because that is what we normally want. It means we can pass large objects around our programs without making multiple copies along the way, and we can easily update these objects as we go. In fact, as you’ll see in <a data-type="xref" href="part06.html#classes_and_oop">Part VI</a>, Python’s <code>class</code> and OOP model <em>depends</em> upon changing a passed-in “self” argument in place, to update mutable object state.</p>
<p>If we don’t want in-place changes within functions to impact objects we pass to them, though, we can simply make explicit copies of mutable objects, as we saw in <a data-type="xref" href="ch06.html#the_dynamic_typing_interlude">Chapter 6</a>. For function arguments, we can always copy the list at the point of <em>call</em> with tools like <code>list</code>, <code>list.copy</code>, or an empty slice (dictionaries have similar copy tools):</p>
<pre data-type="programlisting">L = [1, 2]
changer(X, <code><strong>L[:]</strong></code>)        <code><em># Pass a copy, so our 'L' does not change</em></code></pre>
<p>We can also copy within the <em>function</em> itself, if we never want to change passed-in objects, regardless of how the function is called:</p>
<pre data-type="programlisting">def changer(a, b):
    <code><strong>b = b.copy()</strong></code>        <code><em># Copy input list so we don't impact caller</em></code>
    a = 2
    b[0] = 'mod'        <code><em># Changes our list copy only</em></code></pre>
<p>Both of these copying schemes don’t stop the function from changing the object—they just prevent those changes from impacting the caller. To really prevent changes, we can always convert to <em>immutable</em> objects to force the issue. Tuples, for example, raise an exception when changes are attempted:</p>
<pre data-type="programlisting">L = [1, 2]
changer(X, <code><strong>tuple(L)</strong></code>)    <code><em># Pass a tuple, so changes are errors</em></code>
TypeError: 'tuple' object does not support item assignment</pre>
<p>This scheme uses the built-in <code>tuple</code> function, which builds a new tuple out of all the items in a sequence (really, any iterable). It’s also something of an extreme—because it forces the function to be written to never change passed-in arguments, this solution might impose more limitations on the function than it should, and so should generally be avoided (you never know when changing arguments might come in handy for other calls in the future). Using this technique will also make the function lose the ability to call any list-specific methods on the argument, including methods that do not change the object in place (e.g. <code>copy</code>, though tuples have adopted list <code>count</code> and <code>index</code>).</p>
<p>The main point to remember here is that functions might update mutable objects like lists and dictionaries passed into them. This isn’t necessarily a problem if it’s expected, and often serves useful purposes. Moreover, functions that change passed-in mutable objects in place are probably designed and <em>intended</em> to do so—the change is likely part of a well-defined API that you shouldn’t violate by making copies.</p>
<p>However, you do have to be aware of this property—if objects change out from under you unexpectedly, check whether a called function might be responsible, and make copies when objects are <a contenteditable="false" data-type="indexterm" data-primary="argument passing" data-secondary="mutable arguments" data-tertiary="changes" data-startref="argmutch" id="id3026"></a><a contenteditable="false" data-type="indexterm" data-primary="mutable arguments" data-secondary="changes" data-startref="mrgchg" id="id3027"></a>passed if needed.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Simulating Output Parameters and Multiple Results"><div class="sect2" id="simulating_output_parameters_and_multip">
<h2>Simulating Output Parameters and Multiple Results</h2>
<p>Here’s another function topic from the <a contenteditable="false" data-type="indexterm" data-primary="argument passing" data-secondary="output parameter simulation" id="id3028"></a><a contenteditable="false" data-type="indexterm" data-primary="argument passing" data-secondary="multiple results simulation" id="id3029"></a>assignments department. We’ve already discussed the <code>return</code> statement and used it in examples. What we haven’t yet seen is a common though unusual coding technique it enables: because <code>return</code> can send back any sort of object, it can return <em>multiple values</em> by packaging them in a tuple or other collection type. In fact, although Python doesn’t support what some languages label “call by reference” argument passing, we can simulate it by returning tuples and assigning the results back to the original argument names in the caller:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>def multiple(x, y):</strong></code>
<code> <strong>       x = 2</strong></code>                <code><em># Changes local names only</em></code>
        <code><strong>y = [3, 4]</strong></code>
<code> <strong>       return x, y</strong></code>          <code><em># Return multiple new values in a tuple
</em></code>
&gt;&gt;&gt; <code><strong>X = 1</strong></code>
&gt;&gt;&gt; <code><strong>L = [1, 2]</strong></code>
&gt;&gt;&gt; <code><strong>X, L = multiple(X, L)</strong></code>    <code><em># Assign results to caller's names</em></code>
&gt;&gt;&gt; <code><strong>X, L</strong></code>
(2, [3, 4])</pre>
<p>It looks like the code is returning two values here, but it’s really just one—a two-item <em>tuple</em> with the optional surrounding parentheses omitted. After the call returns, we can use tuple (a.k.a. sequence) assignment to unpack the parts of the returned tuple. (If you’ve forgotten why this works, flip back to “Tuples” in Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch04.html#introducing_python_objects">4</a> and <a data-xrefstyle="select:labelnumber" data-type="xref" href="ch09.html#tuplescomma_filescomma_and_everything_e">9</a>, and “Assignments” in <a data-type="xref" href="ch11.html#assignmentscomma_expressionscomma_and_p">Chapter 11</a>.) The net effect of this coding pattern is to both send back multiple results and simulate the <em>output parameters</em> of other languages by explicit assignments. Here, <code>X</code> and <code>L</code> change after <a contenteditable="false" data-type="indexterm" data-primary="assignments" data-secondary="argument passing" data-startref="assgargp" id="id3030"></a>the call—but only because the code said so. Lists would work, too, but tuples sans <code>()</code> are less to type, and hence common.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Special Argument-Matching Modes"><div class="sect1" id="special_argument_matching_modes">
<h1>Special Argument-Matching Modes</h1>
<p>As we’ve just seen, arguments are always passed by <em>assignment</em> in Python; names in a <code>def</code> or <code>lambda</code> definition’s header are assigned references to passed-in <a contenteditable="false" data-type="indexterm" data-primary="argument matching" id="argmtch"></a>objects. On top of this model, though, Python provides additional tools that alter the way the argument objects in a call are <em>matched</em> with argument names in the definition prior to assignment. These tools are all optional, but allow us to code functions that support more flexible calling patterns and are commonly used by libraries you’re likely to encounter.</p>
<p>By default, arguments are matched between call and definition by <em>position</em>, from left to right, and you must pass exactly as many arguments as there are argument names in the function definition. However, you can also specify matching by name, provide default values, unpack and collect arbitrarily many arguments, and even specify passing-mode requirements. This section presents all these extra tools with a quick overview followed by examples, and a formal look at how they interact at the end after we’ve had a chance to see the basics.</p>
<section data-type="sect2" data-pdf-bookmark="Argument Matching Overview"><div class="sect2" id="argument_matching_overview">
<h2>Argument Matching Overview</h2>
<p>Before we get into syntax details, it’s important to stress that these special modes are optional and deal only with matching objects to names; the underlying passing mechanism after the matching takes place is still assignment. In fact, some of these tools are intended more for people writing libraries than for application developers. That said, you may stumble across these modes even if you don’t code them yourself, so the following summarizes all the options:</p>
<dl>
<dt>Positionals: matched from left to right</dt>
<dd>The normal case, which we’ve mostly <a contenteditable="false" data-type="indexterm" data-primary="positionals, argument matching" id="id3031"></a>been using so far, is to match argument values (passed in a call) to argument names (listed in a function definition) by position, from left to right.</dd>
<dt>Keywords: matched by argument name</dt>
<dd>Alternatively, callers <a contenteditable="false" data-type="indexterm" data-primary="keywords" data-secondary="argument matching" id="id3032"></a>can explicitly specify which argument in the function is to receive a value, by giving the definition’s name for the argument with <code><em>name</em>=<em>value</em></code> syntax.</dd>
<dt>Defaults: specify values for optional arguments that aren’t passed</dt>
<dd>Functions themselves can specify default values for arguments to receive if the call passes too few values, again using the <code><em>name</em>=<em>value</em></code> syntax.</dd>
<dt>Starred collectors: collect <a contenteditable="false" data-type="indexterm" data-primary="collections" data-secondary="argument matching" id="id3033"></a>arbitrarily many positional or keyword arguments</dt>
<dd>Function definitions can use special arguments preceded with one or two <code>*</code> characters to collect an arbitrary number of arguments after other matching. This feature is sometimes referred to as <span class="keep-together"><em>varargs</em>,</span> after a variable-length argument list tool in the C language; in Python, the arguments are collected in a normal object.</dd>
<dt>Starred unpackers: pass arbitrarily many positional or keyword arguments</dt>
<dd>Function calls can also use <a contenteditable="false" data-type="indexterm" data-primary="function calls" data-secondary="argument matching" id="id3034"></a>the one or two <code>*</code> syntax to unpack argument collections into separate arguments. This is the inverse of a <code>*</code> in a function definition—in the definition it means collect arbitrarily many arguments, while in the call it means unpack arbitrarily many arguments, and pass them individually as discrete values.</dd>
<dt>Keyword-only arguments: arguments that must be passed by name</dt>
<dd>Function definitions can also use a <code>*</code> in their headers to specify arguments that must be passed by name as keyword arguments, not position. This is often used for configuration options that augment primary arguments.</dd>
<dt>Positional-only arguments: arguments that must be passed by position</dt>
<dd>As of Python 3.8, function definitions may additionally use a <code>/</code> in their header’s arguments list <a contenteditable="false" data-type="indexterm" data-primary="argument matching" data-startref="argmtch" id="id3035"></a>to specify that all arguments preceding it must be passed by position, not keyword-argument name.</dd>
</dl>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Argument Matching Syntax"><div class="sect2" id="argument_matching_syntax">
<h2>Argument Matching Syntax</h2>
<p>As a reference and preview, <a data-type="xref" href="#function_argument_matching_forms">Table 18-1</a> summarizes the <a contenteditable="false" data-type="indexterm" data-primary="argument matching" data-secondary="syntax" id="grasytx"></a><a contenteditable="false" data-type="indexterm" data-primary="syntax" data-secondary="argument matching" id="sytxrgmt"></a><a contenteditable="false" data-type="indexterm" data-primary="functions" data-secondary="argument matching syntax" id="id3036"></a>syntax that invokes the argument-matching modes.</p>
<table class="border" id="function_argument_matching_forms">
<caption><span class="label">Table 18-1. </span>Function argument-matching forms</caption>
<thead>
<tr>
<th>Syntax</th>
<th>Location</th>
<th>Interpretation</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>func(<em>value</em>)</code></td>
<td>Caller</td>
<td>Normal argument: matched by position</td>
</tr>
<tr>
<td><code>func(<em>name</em>=<em>value</em>)</code></td>
<td>Caller</td>
<td>Keyword argument: matched by name</td>
</tr>
<tr>
<td><code>func(*<em>iterable</em>)</code></td>
<td>Caller</td>
<td>Pass all objects in <code><em>iterable</em></code> as individual positional arguments</td>
</tr>
<tr>
<td><code>func(**<em>dict</em>)</code></td>
<td>Caller</td>
<td>Pass all key/value pairs in <code><em>dict</em></code> as individual keyword arguments</td>
</tr>
<tr>
<td><code>def func(<em>name</em>)</code></td>
<td>Function</td>
<td>Normal argument: matches any passed value by position or name</td>
</tr>
<tr>
<td><code>def func(<em>name</em>=<em>value</em>)</code></td>
<td>Function</td>
<td>Default argument value, if not passed in the call</td>
</tr>
<tr>
<td><code>def func(*<em>name</em>)</code></td>
<td>Function</td>
<td>Matches and collects remaining positional arguments in a tuple</td>
</tr>
<tr>
<td><code>def func(**<em>name</em>)</code></td>
<td>Function</td>
<td>Matches and collects remaining keyword arguments in a dictionary</td>
</tr>
<tr>
<td><code>def func(*<em>name</em>, <em>name</em>)</code></td>
<td>Function</td>
<td>Arguments that must be passed by keyword only in calls</td>
</tr>
<tr>
<td><code>def func(*, <em>name</em>)</code></td>
<td>Function</td>
<td>Arguments that must be passed by keyword only in calls</td>
</tr>
<tr>
<td><code>def func(<em>name</em>, /)</code></td>
<td>Function</td>
<td>Arguments that must be passed by position only in calls</td>
</tr>
</tbody>
</table>
<p>The argument-matching modes listed in this table break down between function <em>calls</em> and <em>definitions</em> as follows:</p>
<dl>
<dt>In a function call (the first four rows of the table)</dt>
<dd>Simple values are matched to <a contenteditable="false" data-type="indexterm" data-primary="argument matching" data-secondary="function calls" id="id3037"></a><a contenteditable="false" data-type="indexterm" data-primary="function calls" data-secondary="argument matching" id="id3038"></a>definition arguments by position, but using the <code><em>name</em>=<em>value</em></code> form tells Python to match arguments by name instead; these are called <em>keyword arguments</em>. Any number of <code>*<em>iterable</em></code> or <code>**<em>dict</em></code> forms can be used in a call, allowing us to bundle many positional or keyword objects in iterables and mappings, respectively, and unpack them as separate, individual arguments when they are passed to the function.</dd>
<dt>In a function definition (the rest of the table)</dt>
<dd>A simple <code><em>name</em></code> is <a contenteditable="false" data-type="indexterm" data-primary="argument matching" data-secondary="function definitions" id="id3039"></a><a contenteditable="false" data-type="indexterm" data-primary="function definitions" data-secondary="argument matching" id="id3040"></a>matched by position or name depending on how the caller passes it, but the <code><em>name</em>=<em>value</em></code> form specifies a <em>default value</em>. The <code>*<em>name</em></code> form collects any extra unmatched positional arguments in a tuple, and <code>**<em>name</em></code> collects unmatched keyword arguments in a dictionary. In addition, any normal or defaulted argument names following a <code>*<em>name</em></code> or a bare <code>*</code> are <em>keyword-only</em> arguments and must be passed by keyword in calls, and arguments preceding a <code>/</code> are <em>positional-only</em> arguments that must <em>not</em> be passed by keyword name.</dd>
</dl>
<p>Of these, keyword arguments and <a contenteditable="false" data-type="indexterm" data-primary="argument matching" data-secondary="keywords" id="id3041"></a><a contenteditable="false" data-type="indexterm" data-primary="keywords" data-secondary="argument matching" id="id3042"></a><a contenteditable="false" data-type="indexterm" data-primary="argument matching" data-secondary="defaults" id="id3043"></a>defaults are probably the most commonly used in Python code. We’ve informally used both of these earlier in this book:</p>
<ul>
<li><p>We’ve already used <em>keywords</em> to specify options to the <code>print</code> function, but they are more general—keywords allow us to label any argument with its name, to make calls more explicit and <span class="keep-together">informational</span>.</p></li>
<li><p>We met <em>defaults</em> earlier, too, as a way to pass in values from the enclosing function’s scope, but they are also more general—they allow us to make any argument optional, providing its default value in a function definition.</p></li>
</ul>
<p>As you’ll see ahead, the combination of defaults in a function definition and keywords in a call further allows us to pick and choose which defaults to override per call.</p>
<p>In short, special argument-matching modes let you be fairly liberal about how many arguments must be passed to a function. If a function specifies defaults, they are used if you pass <em>too few</em> arguments. If a function uses the <code>*</code> argument-collector forms, you can seemingly pass <em>too many</em> arguments; the <code>*</code> names collect the extra arguments in data structures <a contenteditable="false" data-type="indexterm" data-primary="argument matching" data-secondary="syntax" data-startref="grasytx" id="id3044"></a><a contenteditable="false" data-type="indexterm" data-primary="syntax" data-secondary="argument matching" data-startref="sytxrgmt" id="id3045"></a>for processing within the function.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Argument Passing Details"><div class="sect2" id="argument_passing_details">
<h2>Argument Passing Details</h2>
<p>If you choose to use and combine the special argument-matching modes, Python will ask you to follow some ordering rules <a contenteditable="false" data-type="indexterm" data-primary="argument matching" data-secondary="passing arguments" id="argmpssg"></a><a contenteditable="false" data-type="indexterm" data-primary="argument passing" data-secondary="matching arguments" id="argmtgra"></a>among the modes’ optional components. We’re going to defer full and formal coverage of these until we’ve had a chance to observe these modes in action, but as some initial tips:</p>
<ul>
<li><p>In a function <em>call</em>, any number <a contenteditable="false" data-type="indexterm" data-primary="function calls" data-secondary="argument passing" id="id3046"></a><a contenteditable="false" data-type="indexterm" data-primary="argument passing" data-secondary="function calls" id="id3047"></a>of positionals, keywords, and starred unpackings can be used, but positional arguments must precede keyword arguments and <code>**<em>dict</em></code> unpackings, and <code>*<em>iterable</em></code> unpackings must precede <code>**<em>dict</em></code> unpackings.</p></li>
<li><p>In a function <em>definition</em>, arguments <a contenteditable="false" data-type="indexterm" data-primary="argument passing" data-secondary="function definitions" id="id3048"></a><a contenteditable="false" data-type="indexterm" data-primary="function definitions" data-secondary="argument passing" id="id3049"></a>must appear in this order: any positional-only arguments; followed by any positional-or-keyword arguments; followed by the optional <code>*<em>name</em></code> positional collector or <code>*</code> and any keyword-only arguments; followed by the optional <code>**<em>name</em></code> keyword collector. Arguments can have optional defaults (<code><em>name</em>=<em>value</em></code>), but once a default is used, all arguments must use defaults up to a <code>*</code>, after which keyword-only arguments allow defaults and nondefaults to be freely mixed.</p></li>
</ul>
<p>If you mix arguments in any other order, you will get a syntax error because the combinations can be ambiguous. The steps that Python internally carries out to match arguments before assignment can roughly be described as follows:</p>
<ol>
<li><p>Unpack all <code>*<em>args</em></code> at the call into nonkeyword arguments.</p></li>
<li><p>Unpack all <code>**<em>args</em></code> at the call into keyword arguments.</p></li>
<li><p>Assign nonkeyword arguments by position.</p></li>
<li><p>Assign keyword arguments by matching names.</p></li>
<li><p>Collect extra nonkeyword arguments in the <code>*<em>name</em></code> tuple.</p></li>
<li><p>Collect extra keyword arguments in the <code>**<em>name</em></code> dictionary.</p></li>
<li><p>Assign default values to unassigned arguments.</p></li>
</ol>
<p>After arguments in call and definition are matched, Python checks to make sure each argument is passed just one value (or else an error is raised) and then assigns argument names to the objects passed to them and runs the function body.</p>
<p>The actual matching algorithm Python uses is a bit more complex, so we’ll defer to Python’s standard language manual for a more exact description. It’s not required reading, but tracing Python’s matching algorithm may help you to understand some convoluted cases, especially when modes are mixed.</p>
<p>We’ll return to the ordering rules in function calls in definitions with higher fidelity after we’ve had a chance to meet all the players. Let’s get started in the next section with the most common of the bunch.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><em>But annotations are moot</em>: Argument names in a <code>def</code> statement (only) can also have <em>annotation</em> values, specified as <code><em>name</em>:<em>annot</em></code>, or <code><em>name</em>:<em>annot</em>=<em>default</em></code> when defaults are present. This is simply additional syntax for arguments and does not augment or change argument-ordering rules. The function itself can also have an annotation value, given as <code>def f(…)-&gt;<em>annot</em></code>, and <a contenteditable="false" data-type="indexterm" data-primary="argument matching" data-secondary="passing arguments" data-startref="argmpssg" id="id3050"></a><a contenteditable="false" data-type="indexterm" data-primary="argument passing" data-secondary="matching arguments" data-startref="argmtgra" id="id3051"></a>Python attaches all annotation values to the function object. See the discussion of function annotation in <a data-type="xref" href="ch19.html#function_odds_and_ends">Chapter 19</a> for more details, and the section on their role in unused type hinting in <a data-type="xref" href="ch06.html#the_dynamic_typing_interlude">Chapter 6</a>.</p>
</div>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Keyword and Default Examples"><div class="sect2" id="keyword_and_default_examples">
<h2>Keyword and Default Examples</h2>
<p>Argument passing is simpler in code than the <a contenteditable="false" data-type="indexterm" data-primary="argument passing" data-secondary="keywords" id="grakyw"></a><a contenteditable="false" data-type="indexterm" data-primary="keywords" data-secondary="argument passing" id="keywgpss"></a><a contenteditable="false" data-type="indexterm" data-primary="argument passing" data-secondary="defaults" id="agpssfd"></a><a contenteditable="false" data-type="indexterm" data-primary="argument matching" data-secondary="keywords" id="grumkywd"></a>preceding descriptions may imply. First off, if you don’t use any special matching syntax, Python matches names by <em>position</em> from left to right. For instance, if you define a function that requires three arguments, you must call it with three arguments:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>def f(a, b, c): print(a, b, c)</strong></code>

&gt;&gt;&gt; <code><strong>f(1, 2, 3)</strong></code>
1 2 3</pre>
<p>Here, we pass by position—<code>a</code> is matched to <code>1</code>, <code>b</code> is matched to <code>2</code>, and so on. This works like it does in most other programming languages.</p>
<section data-type="sect3" data-pdf-bookmark="Keywords"><div class="sect3" id="keywords">
<h3>Keywords</h3>
<p>In Python, though, you can be more specific about what goes where when you call a function. Keyword arguments allow us to match by <em>name</em>, instead of by position. Using the same function definition but a different call:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>f(c=3, b=2, a=1)</strong></code>
1 2 3</pre>
<p>The <code>c=3</code> in this call, for example, means send <code>3</code> to the argument named <code>c</code>. More formally, Python matches the name <code>c</code> in the call to the argument named <code>c</code> in the function definition, and then assigns the value <code>3</code> to that argument. The net effect of this call is the same as that of the prior call, but notice that the left-to-right order of the arguments no longer matters when keywords are used because arguments are matched by name, not by position.</p>
<p>It’s even possible to combine positional and keyword arguments in a single call. In this case, all positionals are matched first from left to right in the definition, before keywords are matched by name:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>f(1, c=3, b=2)</strong></code>            <code><em># a gets 1 by position, b and c passed by name</em></code>
1 2 3</pre>
<p>When most people see this the first time, they wonder why one would use such a tool. Keywords typically have two roles in Python. First, they make your calls a bit more self-documenting (assuming that you use better argument names than <code>a</code>, <code>b</code>, and <code>c</code>!). For example, a call of this form:</p>
<pre data-type="programlisting">func(title='Learning Python', edition=6, year=2024, python=3.12)</pre>
<p>is much more meaningful than a call with three naked values separated by commas, especially in larger programs—the keywords serve as labels for the data in the call:</p>
<pre data-type="programlisting">func(title='Learning Python', 6, 2024, 3.12)</pre>
<p>The second major use of keywords occurs in conjunction with defaults, which we turn to next.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Defaults"><div class="sect3" id="defaults">
<h3>Defaults</h3>
<p>We talked about defaults in brief earlier, when discussing nested function scopes. In short, defaults allow us to make selected function arguments <em>optional</em>; if not passed a value, the argument is assigned its default before the function runs. For example, here is a function that requires one argument and defaults two others:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>def f(a, b=2, c=3): print(a, b, c)</strong></code>          <code><em># a required, b and c optional</em></code></pre>
<p>As noted earlier, defaults must appear after nondefaults at this point in a header (they can be mixed after a <code>*</code> as you’ll see ahead). When we call this function, we must provide a value for <code>a</code>, either by position or by keyword; however, providing values for <code>b</code> and <code>c</code> is optional. If we don’t pass values to <code>b</code> and <code>c</code>, they default to <code>2</code> and <code>3</code>, respectively:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>f(1)</strong></code>                   <code><em># Use defaults</em></code>
1 2 3
&gt;&gt;&gt; <code><strong>f(a=1)</strong></code>
1 2 3</pre>
<p>If we pass two values, only <code>c</code> gets its default, and when passing three values, no defaults are used:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>f(1, 4)</strong></code>                <code><em># Override defaults</em></code>
1 4 3
&gt;&gt;&gt; <code><strong>f(1, 4, 5)</strong></code>
1 4 5</pre>
<p>Finally, here is how the keyword and default features interact. Because they subvert the normal left-to-right positional mapping, keywords allow us to essentially skip over arguments with defaults:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>f(1, c=6)</strong></code>              <code><em># Choose defaults: b in the middle</em></code>
1 2 6</pre>
<p>Here, <code>a</code> gets <code>1</code> by position, <code>c</code> gets <code>6</code> by keyword, and <code>b</code>, in between, defaults to <code>2</code>.</p>
<p>Be careful not to confuse the special <code><em>name</em>=<em>value</em></code> syntax in a function definition and a function call; in the <em>call</em> it means a match-by-name keyword argument, while in the <em>definition</em> it specifies a default for an optional argument. In both cases, this is not an assignment statement (despite its appearance); it is special syntax for these two contexts, which modifies the default argument-matching mechanics.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Combining keywords and defaults"><div class="sect3" id="combining_keywords_and_defaults">
<h3>Combining keywords and defaults</h3>
<p>Here is a slightly larger example that demonstrates keywords and defaults in action. In the following, the caller must always pass at least two arguments (to match <code>code</code> and <code>hack</code>), but the other two are optional. If they are omitted, Python assigns <code>script</code> and <code>app</code> to the defaults specified in the definition:</p>
<pre data-type="programlisting">def func(code, hack, script=0, app=0):   <code><em># First 2 required</em></code>
    print((code, hack, script, app))

func(1, 2)                               <code><em># Output: (1, 2, 0, 0)</em></code>
func(1, app=1, hack=0)                   <code><em># Output: (1, 0, 0, 1)</em></code>
func(code=1, hack=0)                     <code><em># Output: (1, 0, 0, 0)</em></code>
func(script=1, hack=2, code=3)           <code><em># Output: (3, 2, 1, 0)
</em></code>func(1, 2, 3, 4)                         <code><em># Output: (1, 2, 3, 4)</em></code></pre>
<p>Notice again that when keyword arguments are used in the call, the order in which the arguments are listed doesn’t matter; Python matches by name, not by position. The caller must supply values for <code>code</code> and <code>hack</code>, but they can be given by position or by name.</p>
<p>Also keep in mind that all the special definition-side argument-matching syntax we’re exploring in this chapter works the same in <code>def</code> and <code>lambda</code>, though most examples use the former, and the latter returns results implicitly:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>func = lambda code, hack, script=0, app=0: (code, hack, script, app)</strong></code>
&gt;&gt;&gt; <code><strong>func(1, 2)</strong></code>
(1, 2, 0, 0)
&gt;&gt;&gt; <code><strong>func(script=1, hack=2, code=3)</strong></code>
(3, 2, 1, 0)</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><em>Beware mutable defaults</em>: As noted in the <a contenteditable="false" data-type="indexterm" data-primary="mutability" data-secondary="mutable defaults" id="id3052"></a>prior chapter, if you code a default to be a mutable object (e.g., <code>def f(a=[])</code>), the same, <em>single</em> mutable object is reused every time the function is later called—even if it is changed in place within the function. The net effect is that the argument’s default retains its value from the prior call and is not reset to its original value coded in the function header. To reset anew on each call, move the assignment into the function body instead. Mutable defaults allow state retention, but this is often an <a contenteditable="false" data-type="indexterm" data-primary="argument passing" data-secondary="keywords" data-startref="grakyw" id="id3053"></a><a contenteditable="false" data-type="indexterm" data-primary="keywords" data-secondary="argument passing" data-startref="keywgpss" id="id3054"></a><a contenteditable="false" data-type="indexterm" data-primary="argument passing" data-secondary="defaults" data-startref="agpssfd" id="id3055"></a><a contenteditable="false" data-type="indexterm" data-primary="argument matching" data-secondary="keywords" data-startref="grumkywd" id="id3056"></a>unpleasant surprise. Since this is such a common trap, we’ll postpone further exploration until this part’s “gotchas” list at the end of <a data-type="xref" href="ch21.html#the_benchmarking_interlude">Chapter 21</a>.</p>
</div>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Arbitrary Arguments Examples"><div class="sect2" id="arbitrary_arguments_examples">
<h2>Arbitrary Arguments Examples</h2>
<p>The last two argument-matching <a contenteditable="false" data-type="indexterm" data-primary="argument matching" data-secondary="arbitrary arguments" id="argmatbrg"></a><a contenteditable="false" data-type="indexterm" data-primary="arbitrary arguments, argument matching" id="arbargarg"></a>extensions, <code>*</code> and <code>**</code>, are designed to support <em>any number</em> of arguments. Both can appear in either the function definition or a function call, and they have related purposes in the two locations.</p>
<section data-type="sect3" data-pdf-bookmark="Definitions: Collecting arguments"><div class="sect3" id="definitions_collecting_arguments">
<h3>Definitions: Collecting arguments</h3>
<p>The first use, in the function definition, collects <a contenteditable="false" data-type="indexterm" data-primary="argument matching" data-secondary="function definitions" data-tertiary="collecting arguments" id="gmtfdfcgr"></a><a contenteditable="false" data-type="indexterm" data-primary="function definitions" data-secondary="argument matching" id="fdfgmll"></a>unmatched <em>positional</em> arguments into a tuple:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>def f(*args): print(args)</strong></code></pre>
<p>When this function is called, Python <em>collects</em> all the positional arguments into a new <em>tuple</em> and assigns the variable <code>args</code> to that tuple. Because it is a normal tuple object, it can be indexed, stepped through with a <code>for</code> loop, and so on:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>f()</strong></code>
()
&gt;&gt;&gt; <code><strong>f(1)</strong></code>
(1,)
&gt;&gt;&gt; <code><strong>f(1, 2, 3, 4)</strong></code>
(1, 2, 3, 4)</pre>
<p>The <code>**</code> feature is similar, but it only works for <em>keyword</em> arguments—it collects them into a new <em>dictionary</em>, which can then be processed with normal dictionary tools. In a sense, the <code>**</code> form allows you to convert from keywords to dictionaries, which you can then step through with <code>keys</code> calls, dictionary iterators, and the like (this is roughly what the <code>dict</code> call does when passed keywords, but it <em>returns</em> the new dictionary):</p>
<pre class="pagebreak-before" data-type="programlisting">&gt;&gt;&gt; <code><strong>def f(**args): print(args)</strong></code>

&gt;&gt;&gt; <code><strong>f()</strong></code>
{}
&gt;&gt;&gt; <code><strong>f(a=1, b=2)</strong></code>
{'a': 1, 'b': 2}</pre>
<p>Finally, function definitions can combine normal arguments, the <code>*</code>, and the <code>**</code> to implement wildly flexible call signatures. For instance, in the following, <code>1</code> is passed to <code>a</code> by position, <code>2</code> and <code>3</code> are collected into the <code>pargs</code> positional tuple, and <code>x</code> and <code>y</code> wind up in the <code>kargs</code> keyword dictionary:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>def f(a, *pargs, **kargs): print(a, pargs, kargs)</strong></code>

&gt;&gt;&gt; <code><strong>f(1, 2, 3, x=1, y=2)</strong></code>
1 (2, 3) {'x': 1, 'y': 2}</pre>
<p>Notice that the dictionary’s keys are ordered here: as of Python 3.6, the <code>**</code> collector’s keys preserve the order in which keyword arguments were passed to the function. This relies on the insertion order of keys in dictionaries at large (see <a data-type="xref" href="ch08.html#lists_and_dictionaries">Chapter 8</a> for a refresher if you’ve forgotten what that means).</p>
<p>Functions with both <code>*</code> and <code>**</code> may be rare, but they show up in functions that need to support multiple call patterns (for backward compatibility, for instance). In fact, these features can be combined in even more complex ways that may seem ambiguous at first glance—an idea we will revisit later in this chapter when we lock down <a contenteditable="false" data-type="indexterm" data-primary="argument matching" data-secondary="function definitions" data-tertiary="collecting arguments" data-startref="gmtfdfcgr" id="id3057"></a><a contenteditable="false" data-type="indexterm" data-primary="function definitions" data-secondary="argument matching" data-startref="fdfgmll" id="id3058"></a>ordering rules. First, though, let’s see what happens when <code>*</code> and <code>**</code> are coded in function <em>calls</em> instead of definitions.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Calls: Unpacking arguments"><div class="sect3" id="calls_unpacking_arguments">
<h3>Calls: Unpacking arguments</h3>
<p>It turns out that we can use the <code>*</code> syntax when we call a function, too. In this context, its meaning is <a contenteditable="false" data-type="indexterm" data-primary="argument matching" data-secondary="function calls" data-tertiary="unpacking arguments" id="argmfck"></a><a contenteditable="false" data-type="indexterm" data-primary="function calls" data-secondary="argument matching" data-tertiary="unpacking arguments" id="fccmpkg"></a>the inverse of its meaning in the function definition—it <em>unpacks</em> a collection of arguments, rather than building a collection of arguments. For example, we can pass four arguments to a function in a tuple or other iterable, and let Python unpack them into individual positional arguments:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>def func(a, b, c, d): print(a, b, c, d)</strong></code>

&gt;&gt;&gt; <code><strong>args = (1, 2)</strong></code>
&gt;&gt;&gt; <code><strong>args += (3, 4)</strong></code>
&gt;&gt;&gt; <code><strong>func(*args)</strong></code>                            <code><em># Same as func(1, 2, 3, 4)</em></code>
1 2 3 4</pre>
<p>Similarly, the <code>**</code> syntax in a function call unpacks a dictionary or other mapping of key/value pairs into separate keyword arguments:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>args = {'a': 1, 'b': 2, 'c': 3}</strong></code>
&gt;&gt;&gt; <code><strong>args['d'] = 4</strong></code>
&gt;&gt;&gt; <code><strong>func(**args)</strong></code>                           <code><em># Same as func(a=1, b=2, c=3, d=4)</em></code>
1 2 3 4</pre>
<p>Moreover, we can use other iterables like lists and other dictionary syntax like <code>dict</code>, and we may combine star, positional, and keyword arguments in the call in very flexible ways:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>func(*(1, 2), **{'d': 4, 'c': 3})</strong></code>      <code><em># Same as func(1, 2, d=4, c=3)</em></code>
1 2 3 4
&gt;&gt;&gt; <code><strong>func(1, *[2, 3], **dict(d=4))</strong></code>          <code><em># Same as func(1, 2, 3, d=4)</em></code>
1 2 3 4
&gt;&gt;&gt; <code><strong>func(1, c=3, *[2], **{'d': 4})</strong></code>         <code><em># Same as func(1, 2, c=3, d=4)</em></code>
1 2 3 4
&gt;&gt;&gt; <code><strong>func(1, *(2, 3), d=4)</strong></code>                  <code><em># Same as func(1, 2, 3, d=4)
</em></code>1 2 3 4
&gt;&gt;&gt; <code><strong>func(1, *[2], c=3, **dict(d=4))</strong></code>        <code><em># Same as func(1, 2, c=3, d=4)</em></code>
1 2 3 4</pre>
<p>While the preceding serves to demo the possibilities, its use of stars and literals is overkill when arguments are known; more typical code would build up argument collections ahead of the call and unpack by names:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>pargs, kargs = (1, 2), dict(d=4, c=3)</strong></code>
&gt;&gt;&gt; <code><strong>func(*pargs, **kargs)</strong></code>
1 2 3 4</pre>
<p>Star unpacking is convenient when you cannot predict the number of arguments that will be passed to a function when you write your script; you can build up a collection of arguments at runtime instead and call the function generically this way. Here again, though, don’t confuse the <code>*</code>/<code>**</code> starred-argument syntax in the function definition and the function call—in the <em>definition</em> it collects any number of arguments, while in the <em>call</em> it unpacks any number of arguments. In both, one star means positionals, and two applies to keywords.</p>
<p>Finally, as of Python 3.5, and as noted in <a data-type="xref" href="ch11.html#assignmentscomma_expressionscomma_and_p">Chapter 11</a>’s sidebar <a data-type="xref" href="ch11.html#the_many_stars_of_python">“The Many Stars of Python”</a>, we can even use <em>multiple</em> <code>*</code> and <code>**</code> items in calls to unpack multiple iterables and mappings, respectively. The <code>*</code> unpacks into positional arguments, and <code>**</code> into keyword arguments, though single stars must precede double stars, per formal rules coming up ahead. Again, the following uses literals to demo, but these would usually be names assigned to prebuilt values:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>def func(a, b, c, d): print(a, b, c, d)</strong></code>

&gt;&gt;&gt; <code><strong>func(*[1], *(2,), **dict(c=3), **{'d': 4})</strong></code>         <code><em># *Positionals + **keywords</em></code>
1 2 3 4
&gt;&gt;&gt; <code><strong>func(*[1], *(2,), *[3, 4])</strong></code>                         <code><em># All *positionals</em></code>
1 2 3 4
&gt;&gt;&gt; <code><strong>func(**dict(a=1, b=2), **dict(c=3), **{'d': 4})</strong></code>    <code><em># All **keywords</em></code>
1 2 3 4
&gt;&gt;&gt; <code><strong>func(*[1], 2, **dict(c=3), d=4)</strong></code>                    <code><em># All call modes at once!</em></code>
1 2 3 4

&gt;&gt;&gt; <code><strong>func(*[1], **dict(b=2, c=3), *[4])</strong></code>
SyntaxError: iterable argument unpacking follows keyword argument unpacking</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><em>Unpacking generality—and inconsistency</em>: As previewed in <a data-type="xref" href="ch14.html#iterations_and_comprehensions">Chapter 14</a>, the <code>*</code> form in a call is an <em>iteration tool</em>, so it accepts any iterable object, not just tuples or other sequences used in examples here. For instance, iterables like <code>zip</code> and <code>range</code> work after a <code>*</code> too and unpack into individual arguments, and file objects automatically read and unpack their lines:</p>
<pre data-type="programlisting">func(*range(4))            <code><em># Same as func(0, 1, 2, 3)</em></code>
func(*open('filename'))    <code><em># Read+pass lines as arguments</em></code></pre>
<p>Watch for more examples of this utility in <a data-type="xref" href="ch20.html#comprehensions_and_generations">Chapter 20</a>, after we study generators.</p>
<p>On the downside, stars also come with <em>inconsistencies</em>. For one, this generality holds true only for <em>calls</em>—a <code>*</code> unpacking in a call allows any iterable, but a <code>*</code> in a function <em>definition</em> always collects extra arguments into a <em>tuple</em>. Moreover, this collection behavior in definitions is similar in spirit and syntax to the <code>*</code> in the extended-unpacking <em>assignment</em> forms we met in <a data-type="xref" href="ch11.html#assignmentscomma_expressionscomma_and_p">Chapter 11</a> (e.g., <code>x, *y = z</code>), but that star usage always creates <em>lists</em>, not <a contenteditable="false" data-type="indexterm" data-primary="argument matching" data-secondary="function calls" data-tertiary="unpacking arguments" data-startref="argmfck" id="id3059"></a><a contenteditable="false" data-type="indexterm" data-primary="function calls" data-secondary="argument matching" data-tertiary="unpacking arguments" data-startref="fccmpkg" id="id3060"></a>tuples. Again: these are different rules for different tools—despite the same syntax.</p>
</div>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Why arbitrary arguments?"><div class="sect3" id="why_arbitrary_argumentsquestion_mark">
<h3>Why arbitrary arguments?</h3>
<p>The prior section’s examples may seem academic (if not downright esoteric), but they are used more often than you might expect. Some programs need to call arbitrary functions in a generic fashion, without hardcoding their names or arguments ahead of time. In fact, the real power of the special starred-unpacking call syntax is that you don’t need to know how many arguments a function call requires before you write a script. For example, you can use <code>if</code> logic to select from a set of functions and argument lists, and call any of them generically (functions here are hypothetical):</p>
<pre data-type="programlisting">if <code><em>sometest</em></code>:
    action, args = func1, (1,)             <code><em># Call func1 with one arg in this case</em></code>
else:
    action, args = func2, (1, 2, 3)        <code><em># Call func2 with three args instead</em></code>
…
action(*args)                              <code><em># Dispatch generically</em></code></pre>
<p>This leverages both the <code>*</code> form and the fact that functions are objects that may be both referenced by, and called through, any variable. More generally, this unpacking call syntax is useful anytime you cannot predict the arguments list. If your user selects an arbitrary function via a user interface, for instance, you may be unable to hardcode a function call when writing your script. To work around this, simply build up the arguments list with sequence operations, and call it with starred-argument syntax to unpack the arguments:</p>
<pre data-type="programlisting">args = (2,3)
args += (4,)
…
func3(*args)</pre>
<p>Because the arguments list is passed in as a tuple here, the program can build it at runtime. This technique also comes in handy for functions that test or time other functions. For instance, the code in <a data-type="xref" href="#example_oneeight_onedot_tracerzerodotpy">Example 18-1</a> supports any function with any arguments by passing along whatever arguments were sent in (see <em>tracer0.py</em> in the example package).</p>
<div data-type="example" id="example_oneeight_onedot_tracerzerodotpy">
<h5><span class="label">Example 18-1. </span>tracer0.py</h5>
<pre data-type="programlisting">def tracer(func, *pargs, **kargs):         <code><em># Accept arbitrary arguments</em></code>
    print('calling:', func.__name__)
    return func(*pargs, **kargs)           <code><em># Pass along arbitrary arguments</em></code>

def func(a, b, c, d):
    return a + b + c + d

print(tracer(func, 1, 2, c=3, d=4))</pre>
</div>
<p>This code uses the built-in <code>__name__</code> attribute attached to every function (as you might expect, it’s the function’s name string), and uses stars to collect and then unpack the arguments intended for the traced function. In other words, when this code is run, arguments are intercepted by the tracer and then <em>propagated</em> with unpacking call syntax:</p>
<pre data-type="programlisting">$ <code><strong>python3 tracer0.py</strong></code>
calling: func
10</pre>
<p>For another example of this technique, see <a contenteditable="false" data-type="indexterm" data-primary="argument matching" data-secondary="arbitrary arguments" data-startref="argmatbrg" id="id3061"></a><a contenteditable="false" data-type="indexterm" data-primary="arbitrary arguments, argument matching" data-startref="arbargarg" id="id3062"></a>the preview near the end of the preceding chapter, where it was used to reset the built-in <code>open</code> function (though it probably makes more sense to you now). We’ll code additional examples of such roles later in this book; see especially the sequence timing examples in <a data-type="xref" href="ch21.html#the_benchmarking_interlude">Chapter 21</a> and the various <em>decorator</em> utilities we will code in <a data-type="xref" href="ch39.html#decorators">Chapter 39</a> (after a preview in the next chapter). It’s a common technique in general tools.</p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Keyword-Only Arguments"><div class="sect2" id="keyword_only_arguments">
<h2>Keyword-Only Arguments</h2>
<p>Besides accepting keyword (i.e., pass-by-name) arguments in general, function <em>definitions</em> can also <a contenteditable="false" data-type="indexterm" data-primary="argument matching" data-secondary="keyword-only arguments" id="argmtkywy"></a><a contenteditable="false" data-type="indexterm" data-primary="keyword-only arguments" id="kywygr"></a>specify that some arguments must always be passed by keyword only and will never be filled in by a positional argument. This extension, known as <em>keyword-only arguments</em>, can be useful if we want a function to both process any number of arguments and accept possibly optional configuration options.</p>
<p>Syntactically, keyword-only arguments are coded as named arguments that may appear after <code>*<em>name</em></code> in the arguments list. All such arguments must be passed using keyword syntax in the call. For example, in the following, <code>a</code> may be passed by name or position, <code>b</code> collects any extra positional arguments, and <code>c</code> must be passed by keyword only:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>def kwonly(a, *b, c): print(a, b, c)</strong></code>

&gt;&gt;&gt; <code><strong>kwonly(1, 2, c=3)</strong></code>
1 (2,) 3
&gt;&gt;&gt; <code><strong>kwonly(a=1, c=3)</strong></code>
1 () 3
&gt;&gt;&gt; <code><strong>kwonly(1, 2, 3)</strong></code>
TypeError: kwonly() missing 1 required keyword-only argument: 'c'</pre>
<p>If we don’t need to collect arbitrary positionals, we can also use a bare <code>*</code> character by itself in the arguments list to introduce keyword-only arguments. This indicates that a function does not accept a variable-length argument list but still expects all arguments following the <code>*</code> to be passed as keywords. In the next function, <code>a</code> may be passed by position or name again, but <code>b</code> and <code>c</code> must be keywords, and no extra positionals are allowed:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>def kwonly(a, *, b, c): print(a, b, c)</strong></code>

&gt;&gt;&gt; <code><strong>kwonly(1, c=3, b=2)</strong></code>
1 2 3
&gt;&gt;&gt; <code><strong>kwonly(c=3, b=2, a=1)</strong></code>
1 2 3
&gt;&gt;&gt; <code><strong>kwonly(1, 2, 3)</strong></code>
TypeError: kwonly() takes 1 positional argument but 3 were given
&gt;&gt;&gt; <code><strong>kwonly(1)</strong></code>
TypeError: kwonly() missing 2 required keyword-only arguments: 'b' and 'c'</pre>
<p>You can still use defaults for keyword-only arguments, even though they appear after the <code>*</code> in the function. In the following, <code>a</code> may be passed by name or position, and <code>b</code> and <code>c</code> are optional but must be passed by keyword if used:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>def kwonly(a, *, b='code', c='app'): print(a, b, c)</strong></code>

&gt;&gt;&gt; <code><strong>kwonly(1)</strong></code>
1 code app
&gt;&gt;&gt; <code><strong>kwonly(1, c='hack')</strong></code>
1 code hack
&gt;&gt;&gt; <code><strong>kwonly(a='py')</strong></code>
py code app
&gt;&gt;&gt; <code><strong>kwonly(c=3, b=2, a=1)</strong></code>
1 2 3
&gt;&gt;&gt; <code><strong>kwonly(1, 2)</strong></code>
TypeError: kwonly() takes 1 positional argument but 2 were given</pre>
<p>In fact, keyword-only arguments with <a contenteditable="false" data-type="indexterm" data-primary="keywords" data-secondary="required" id="id3063"></a>defaults are optional, but those without defaults effectively become <em>required keywords</em> for the function—like <code>b</code> in the following:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>def kwonly(a, *, b, c='hack'): print(a, b, c)</strong></code>

&gt;&gt;&gt; <code><strong>kwonly(1, b='code')</strong></code>
1 code hack
&gt;&gt;&gt; <code><strong>kwonly(1, c='code')</strong></code>
TypeError: kwonly() missing 1 required keyword-only argument: 'b'
&gt;&gt;&gt; <code><strong>kwonly(1, 2)</strong></code>
TypeError: kwonly() takes 1 positional argument but 2 were given</pre>
<p>As noted earlier, keyword-only arguments also allow defaults and nondefaults to be <em>mixed</em>, unlike their otherwise more flexible cohorts coded before the optional <code>*</code>—an ostensible inconsistency we’ll return to later:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>def kwonly(a, *, b=2, c, d=4): print(a, b, c, d)</strong></code>

&gt;&gt;&gt; <code><strong>kwonly(1, c=3)</strong></code>
1 2 3 4
&gt;&gt;&gt; <code><strong>kwonly(1, c=5, b=6)</strong></code>
1 6 5 4
&gt;&gt;&gt; <code><strong>kwonly(1)</strong></code>
TypeError: kwonly() missing 1 required keyword-only argument: 'c'
&gt;&gt;&gt; <code><strong>kwonly(1, 2, 3)</strong></code>
TypeError: kwonly() takes 1 positional argument but 3 were given

&gt;&gt;&gt; <code><strong>def badmix(b=2, c, d=5): …</strong></code>
SyntaxError: parameter without a default follows parameter with a default</pre>
<p>Finally, note that keyword-only arguments must be specified after a single star, not two—nothing can appear after the <code>**args</code> arbitrary-keywords form, and, unlike <code>*</code>, a <code>**</code> can’t appear by itself in the arguments list. More generally, keyword-only arguments must be coded <em>between</em> the <code>*</code> and the optional <code>**</code>, and an argument that appears before <code>*</code> is a possibly default argument that can be passed by position or keyword, not keyword-only:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>def kwonly(a, **kargs, b, c):</strong></code>
SyntaxError: arguments cannot follow var-keyword argument
&gt;&gt;&gt; <code><strong>def kwonly(a, **, b, c):</strong></code>
SyntaxError: invalid syntax
&gt;&gt;&gt; <code><strong>def mixed(a, *b, **d, c=6):</strong></code>
SyntaxError: arguments cannot follow var-keyword argument</pre>
<p>These failures will make more sense after we get formal about argument ordering rules later in this chapter. They may also appear to be worst cases in the artificial examples here, but they can come up in real practice, especially for people who write libraries for other Python programmers to use—which leads to the next point.</p>
<section data-type="sect3" data-pdf-bookmark="Why keyword-only arguments?"><div class="sect3" id="why_keyword_only_argumentsquestion_mark">
<h3>Why keyword-only arguments?</h3>
<p>So why care about keyword-only arguments? In short, they make it easier to allow a function to accept both any number of positional arguments to be processed, and configuration options passed as keywords. While their use is optional, without keyword-only arguments extra work may be required to provide defaults for such options and to verify that no superfluous keywords were passed.</p>
<p>Imagine a function that processes a set of passed-in objects and allows a tracing flag to be passed:</p>
<pre data-type="programlisting">process(X, Y, Z)                    <code><em># Use flag's default</em></code>
process(X, Y, notify=True)          <code><em># Override flag default</em></code></pre>
<p>Without keyword-only arguments we have to use both <code>*args</code> and <code>**args</code> and manually inspect the keywords, but with keyword-only arguments less code is required. The following guarantees that no positional argument will be incorrectly matched against <code>notify</code> and requires that it be a keyword if passed:</p>
<pre data-type="programlisting">def process(*args, notify=False): …</pre>
<p>Since we’re going to explore a more realistic example of this later in this chapter, in <a data-type="xref" href="#example_rolling_your_own_print">“Example: Rolling Your Own Print”</a>, we’ll postpone the rest of this story until then. For an additional <a contenteditable="false" data-type="indexterm" data-primary="argument matching" data-secondary="keyword-only arguments" data-startref="argmtkywy" id="id3064"></a><a contenteditable="false" data-type="indexterm" data-primary="keyword-only arguments" data-startref="kywygr" id="id3065"></a>example of keyword-only arguments in action, see the upcoming iteration-options timing case study in <a data-type="xref" href="ch21.html#timer_module_take_two">“Timer Module: Take 2”</a>.</p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Positional-Only Arguments"><div class="sect2" id="positional_only_arguments">
<h2>Positional-Only Arguments</h2>
<p>Beginning with Python 3.8, function <em>definitions</em> may also include a <code>/</code> in the arguments list <a contenteditable="false" data-type="indexterm" data-primary="argument matching" data-secondary="positional-only arguments" id="grumpyg"></a>to designate that all arguments preceding it (i.e., to its left) must be passed by <em>position</em>, not by keyword-argument name. Though arguably ad hoc on first sighting in an arguments list, this notation was being used in documentation for built-in functions that did not accept keywords; making it available to function coders as part of Python’s syntax was deemed a logical extension for library developers who may not want to expose argument names for use by clients as keywords.</p>
<p>To demo, the following function specifies that <code>a</code> and <code>b</code> must be passed by position, though <code>c</code> is more flexible:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>def mostlypos(a, b, /, c): print(a, b, c)</strong></code>
 
&gt;&gt;&gt; <code><strong>mostlypos(1, 2, 3)</strong></code>
1 2 3
&gt;&gt;&gt; <code><strong>mostlypos(1, 2, c=3)</strong></code>
1 2 3</pre>
<p>Passing either of the first two arguments by keyword, however, fails:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>mostlypos(1, b=2, c=3)</strong></code>
TypeError: mostlypos() got some positional-only arguments passed as keyword arguments: 'b'

&gt;&gt;&gt; <code><strong>mostlypos(c=3, b=2, a=1)</strong></code>
TypeError: mostlypos() got some positional-only arguments passed as keyword arguments: 'a, b'</pre>
<p>To define a function that allows <em>only</em> positional arguments, simply code the slash at the end:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>def allpos(a, b, c, /): print(a, b, c)</strong></code>

&gt;&gt;&gt; <code><strong>allpos(1, 2, 3)</strong></code>
1 2 3
&gt;&gt;&gt; <code><strong>allpos(1, 2, c=3)</strong></code>
TypeError: mostlypos() got some positional-only arguments passed as keyword …</pre>
<p>As you should expect, the slash works the same in a <code>lambda</code> argument list:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>f = lambda a, b, /, c: print(a, b, c)</strong></code>

&gt;&gt;&gt; <code><strong>f(1, 2, c=3)</strong></code>
1 2 3
&gt;&gt;&gt; <code><strong>f(1, b=2, c=3)</strong></code>
TypeError: &lt;lambda&gt;() got some positional-only arguments passed as keyword …</pre>
<p class="pagebreak-before">And functions can <em>combine</em> positional- and keyword-only arguments to be as rigid as they wish:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>def combo(a, b, /, *, c, d): print(a, b, c, d)</strong></code>

&gt;&gt;&gt; <code><strong>combo(1, 2, c=3, d=4)</strong></code>
1 2 3 4
&gt;&gt;&gt; <code><strong>combo(1, 2, 3, 4)</strong></code>
TypeError: combo() takes 2 positional arguments but 4 were given
&gt;&gt;&gt; <code><strong>combo(a=1, b=2, c=3, d=4)</strong></code>
TypeError: combo() got some positional-only arguments passed as keyword …</pre>
<p>It’s up to you to ponder whether or not use cases for this syntax justify its convolution of function definitions that follows in the next section. Given that Python users somehow got by without it for over three decades, though, this seems a tough sell. For more on the rationale and usage of the positional-only slash, see Python’s standard manuals. Also watch for an example in <a data-type="xref" href="ch21.html#the_benchmarking_interlude">Chapter 21</a> that uses it to avoid name <a contenteditable="false" data-type="indexterm" data-primary="argument matching" data-secondary="positional-only arguments" data-startref="grumpyg" id="id3066"></a>clashes—and may or may not be compelling.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Argument Ordering: The Gritty Details"><div class="sect1" id="argument_ordering_the_gritty_details">
<h1>Argument Ordering: The Gritty Details</h1>
<p>So far, we’ve been fairly loose about the rules surrounding argument-matching tools, because they don’t crop up very often in the simpler usage patterns of typical code. In more sophisticated roles, though, you need to verify that your code follows Python’s expectations. Now that we’ve seen all of its subjects, the ordering rules for function arguments can finally be summarized in full. While function <em>definitions</em> and <em>calls</em> share some similar syntax, their rules are completely different, owing to their different roles. Let’s take a more formal look at both.</p>
<section data-type="sect2" data-pdf-bookmark="Definition Ordering"><div class="sect2" id="definition_ordering">
<h2>Definition Ordering</h2>
<p>In function <em>definitions</em>, argument lists are enclosed in parentheses in a <code>def</code> statement <a contenteditable="false" data-type="indexterm" data-primary="argument ordering" data-secondary="function definitions" id="id3067"></a><a contenteditable="false" data-type="indexterm" data-primary="function definitions" data-secondary="argument ordering" id="id3068"></a>and coded before a colon in a <code>lambda</code> expression, but follow the same format in both. In short, they consist of four optional parts that must appear in the following order, where <em>position</em> means a simple value in calls, and <em>keyword</em> means a <code><em>name</em>=<em>value</em></code> pair:</p>
<ol>
<li><p>One or more arguments that must be passed by <em>position</em> only, followed by a single <code>/</code></p></li>
<li><p>Any number of arguments that can be passed by either <em>position</em> or <em>keyword</em></p></li>
<li><p>A single <code>*</code> by itself or a single <code>*<em>name</em></code> positional-argument <em>collector</em>, optionally followed by any number of arguments that must be passed by <em>keyword</em> only</p></li>
<li><p>A single <code>**<em>name</em></code> keyword-argument <em>collector</em></p></li>
</ol>
<p>In all cases, individual arguments, including a bare <code>/</code> or <code>*</code>, are separated by commas. In addition, any nonstarred argument name can have a <code><em>name</em>=<em>expression</em></code> default, but all names must have defaults after the first that does, up to the <code>*</code> (keyword-only argument runs following a star may freely mix default and nondefault names).</p>
<p>Inherent in this ordering, positional-only arguments must appear first, <code>*<em>name</em></code> ends positional-argument runs and collects unmatched positionals, and <code>**<em>name</em></code> ends the entire arguments list and collects unmatched keywords. As noted earlier, the <code>**<em>name</em></code> collector’s keys retain the order in which keyword arguments were passed to the function.</p>
<section data-type="sect3" class="pagebreak-before" data-pdf-bookmark="Formal definition"><div class="sect3" id="formal_definition-id00061">
<h3 class="less_space">Formal definition</h3>
<p>More concisely, the ordering of <a contenteditable="false" data-type="indexterm" data-primary="argument ordering" data-secondary="function definitions" data-tertiary="formal definitions" id="id3069"></a><a contenteditable="false" data-type="indexterm" data-primary="function definitions" data-secondary="argument ordering" data-tertiary="formal definitions" id="id3070"></a>arguments in function definitions can be defined as follows, where <code><em>-or-</em></code> is notation for a choice and <code>[]</code> encloses an optional part (neither is part of the actual code you type):</p>
<pre data-type="programlisting">def <code><em>name</em></code>(<code><em>arguments-list</em></code>): <code><em>statements</em></code>
lambda <code><em>arguments-list</em></code>: <code><em>expression</em></code>

<code><em>arguments-list</em></code> = 
         [<code><em>positional-only-arguments</em></code>, /]
         [<code><em>positional-or-keyword-arguments</em></code>]
         [* <code><em>-or-</em></code> *<code><em>positional-collector</em></code>, [<code><em>keyword-only-arguments</em></code>]] 
<code> <em>       </em></code> [**<code><em>keyword-collector</em></code>]</pre>
<p>As a real example, the following defines a function with all these parts in actions:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>def f(a, /, b, c=3, *ps, e=4, **ks):</strong></code> 
        <code><strong>print(f'{a=}, {b=}, {c=}, {ps=}, {e=}, {ks=}')</strong></code>

&gt;&gt;&gt; <code><strong>f(0, 1, 2, 3, 4, e=5, f=6, g=7)</strong></code>
a=0, b=1, c=2, ps=(3, 4), e=5, ks={'f': 6, 'g': 7}</pre>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Boundary cases "><div class="sect3" id="boundary_cases-id00006">
<h3>Boundary cases </h3>
<p>As consequences of the ordering in function <a contenteditable="false" data-type="indexterm" data-primary="argument ordering" data-secondary="function definitions" data-tertiary="boundary cases" id="id3071"></a><a contenteditable="false" data-type="indexterm" data-primary="function definitions" data-secondary="argument ordering" data-tertiary="boundary cases" id="id3072"></a>definitions, <code>/</code> must precede a star, and the double-star keyword collector must be coded last:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>def f(a, *ps, /, b): pass</strong></code>
SyntaxError: / must be ahead of *

&gt;&gt;&gt; <code><strong>def f(a, **ks, b): pass</strong></code>
SyntaxError: arguments cannot follow var-keyword argument</pre>
<p>Though enforced separately from basic argument-ordering rules, once a <em>default</em> is used in a definition, all subsequent arguments must also have defaults—including those following the positional-only <code>/</code> delimiter:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>def f(a, b, c=3, d, e): pass</strong></code>
SyntaxError: parameter without a default follows parameter with a default

&gt;&gt;&gt; <code><strong>def f(a, b=2, /, c): pass</strong></code>
SyntaxError: parameter without a default follows parameter with a default</pre>
<p>However, this constraint applies only to arguments preceding a <code>*</code> or <code>*<em>name</em></code>—defaults and nondefaults <em>can</em> be mixed freely in keyword-only arguments, which seems inconsistent, though a case for sanity could be made here on the grounds that keyword-only arguments never match by position, which reduces ambiguity of defaults:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>def f(a, *, x=1, y): ...</strong> </code>     <code><em># OK: x and y must be keywords</em></code>

&gt;&gt;&gt; <code><strong>def f(a=1, b, *, x=1): ...</strong></code>    <code><em># Not OK: a and b may be positional</em></code>
SyntaxError: parameter without a default follows parameter with a default</pre>
<p>Not shown here, <code>def</code> can also be preceded by a <em>decorator</em> (e.g., <code>@<em>value</em></code>), and, as noted earlier, any of its arguments may be followed by <em>annotations</em> (e.g., <code>:<em>value</em></code>)—extensions we’ll explore in the next chapter and later in this book. Neither of these impact argument ordering or matching, and neither work in <code>lambda</code> due to its limited syntax.</p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Calls Ordering"><div class="sect2" id="calls_ordering">
<h2>Calls Ordering</h2>
<p>On the other side of the fence, the syntax is <a contenteditable="false" data-type="indexterm" data-primary="argument ordering" data-secondary="function calls" id="id3073"></a><a contenteditable="false" data-type="indexterm" data-primary="function calls" data-secondary="argument ordering" id="id3074"></a>similar but the rules differ. In function <em>calls</em>, all positional arguments must precede all keyword arguments, and any number of starred <em>unpackings</em> can be mixed in with individual values: one star unpacks into multiple positional arguments, two unpacks into keywords, and all positional arguments and one-star unpackings must precede all two-star unpackings.</p>
<p>In more detail, function (and by extension, method) calls consist of three optional parts in the following order:</p>
<ol>
<li><p>Any combination of one or more <code><em>expression</em></code> positional arguments, and <code>*<em>expression</em></code> iterable unpackings transformed into positional arguments</p></li>
<li><p>Any combination of one or more <code><em>name</em>=<em>expression</em></code> keyword arguments, and <code>*<em>expression</em></code> iterable unpackings transformed into positional arguments</p></li>
<li><p>Any combination of one or more <code><em>name</em>=<em>expression</em></code> keyword arguments, and <code>**<em>expression</em></code> mapping unpackings transformed into keyword arguments</p></li>
</ol>
<p>In all cases, all arguments, starred or otherwise, are separated by commas.</p>
<section data-type="sect3" data-pdf-bookmark="Formal definition"><div class="sect3" id="formal_definition-id00095">
<h3>Formal definition</h3>
<p>More concisely again, the ordering <a contenteditable="false" data-type="indexterm" data-primary="argument ordering" data-secondary="function calls" data-tertiary="formal definitions" id="id3075"></a><a contenteditable="false" data-type="indexterm" data-primary="function calls" data-secondary="argument ordering" data-tertiary="formal definitions" id="id3076"></a>of arguments in function calls can be defined as follows, where <code><em>function</em></code> is an expression that evaluates to a callable object, and <code><em>-or-</em></code> and <code>[]</code> here again mean a choice and optional part, respectively (they’re not part of the code you type):</p>
<pre data-type="programlisting"><code><em>function</em></code>([<code><em>positional-values -or-</em></code> *<code><em>iterable-positional-unpackings</em></code>]
         [<code><em>keyword-arguments -or-</em></code> *<code><em>iterable-positional-unpackings</em></code>]
         [<code><em>keyword-arguments -or-</em></code> **<code><em>mapping-keyword-unpackings</em></code>])</pre>
<p>As a concrete example, the following passes a variety of positional, keyword, and unpacking arguments (this code serves as a demo here, but is not exactly the sort of thing you should strive to craft in <span class="keep-together">practice!</span>):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>def f(a, b, c, d, e, f, g, h, i):</strong></code> 
        <code><strong>print(a, b, c, d, e, f, g, h, i)</strong></code>

&gt;&gt;&gt; <code><strong>f(*[1], 2, *[3], 4, f=6, *[5], **dict(g=7), h=8, **{'i': 9})</strong></code>
1 2 3 4 5 6 7 8 9</pre>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Boundary cases"><div class="sect3" id="boundary_cases-id00007">
<h3>Boundary cases</h3>
<p>As one consequence of the argument ordering <a contenteditable="false" data-type="indexterm" data-primary="argument ordering" data-secondary="function calls" data-tertiary="boundary cases" id="id3077"></a><a contenteditable="false" data-type="indexterm" data-primary="function calls" data-secondary="argument ordering" data-tertiary="boundary cases" id="id3078"></a>in calls, once you use a <em>keyword</em> argument, you can no longer use any unstarred positionals—all subsequent arguments must also be keywords, or single or double stars:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>f(1, 2, c=3, 4)</strong></code>
SyntaxError: positional argument follows keyword argument unpacking</pre>
<p>This is similar to defaults in definitions—but not exactly. Again, try not to conflate function definitions and calls. Despite their reuse of similar syntax, it has very different roles and rules in these tools. The <code>*</code> and <code>=</code>, for example, are used for unpacking and keywords in calls, but mean collection and defaults in definitions.</p>
<p>Once you code a <em>double star</em>, both positionals and single stars are also out of the game, though this seems inconsistent too—single stars can be freely mixed with keyword arguments (which is what a <span class="keep-together">double</span> star unpacks into), and keyword arguments cannot be mixed with positionals (which is what a single star unpacks into):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>f(1, 2, **{'d': 3}, 4)</strong></code>
SyntaxError: positional argument follows keyword argument unpacking
&gt;&gt;&gt; <code><strong>f(1, 2, **{'d': 3}, *[4])</strong></code>
SyntaxError: iterable argument unpacking follows keyword argument unpacking

&gt;&gt;&gt; <code><strong>f(1, 2, d=3, *[4])</strong></code>    <code><em># OK, but why? – like first error above</em></code>
&gt;&gt;&gt; <code><strong>f(1, 2, d=3, 4)</strong>  </code>     <code><em># Not OK, but why? – like preceding line</em></code>
SyntaxError: positional argument follows keyword argument</pre>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Perspective"><div class="sect3" id="perspective">
<h3>Perspective</h3>
<p>And if this is starting to make your head spin, it probably should. Python’s argument-matching rules have been accumulated over time to incorporate new convolutions, and they are complex and perhaps even kludgy. The first rule of programming applies to function definitions and calls as everywhere else: keep it simple, unless it has to be complex. If you have to agonize over argument-ordering rules to understand code, it’s probably time to reevaluate priorities.</p>
</div></section>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Example: The min Wakeup Call"><div class="sect1" id="example_the_min_wakeup_call">
<h1>Example: The min Wakeup Call</h1>
<p>OK—it’s time for something more realistic. To make the concepts here more concrete, the rest <a contenteditable="false" data-type="indexterm" data-primary="argument matching" data-secondary="mins.py example" id="argminyx"></a><a contenteditable="false" data-type="indexterm" data-primary="mins.py" id="minpys"></a><a contenteditable="false" data-type="indexterm" data-primary="argument matching" data-secondary="minimum value calculation" id="grmtmnmv"></a>of this chapter works through a set of examples that demonstrate practical applications of argument-matching tools. First up is an exercise borrowed from live classes and used to rouse learners like you starting to succumb to the knottiness of argument rules.</p>
<p>Here’s the problem statement: suppose you’re asked to code a function that is able to compute the <em>minimum value</em> from an arbitrary set of arguments, which may be arbitrary sorts of objects. That is, the function should accept <em>zero or more</em> arguments—as many as you wish to pass. Moreover, the function should work for all kinds of Python object <em>types</em>: numbers, strings, lists, lists of lists, files, and even <code>None</code>. To keep this fair, you don’t need to support <em>dictionaries</em> or <em>mixed</em> nonnumeric types, because neither supports direct comparisons, per Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch08.html#lists_and_dictionaries">8</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch09.html#tuplescomma_filescomma_and_everything_e">9</a>.</p>
<p>The first requirement provides a natural example of how the <code>*</code> feature can be put to good use—we can handle arbitrary arguments by collecting them in a tuple, and stepping over each with a simple <code>for</code> loop. The second part of the problem definition is easy in Python: because nearly every object type supports comparisons, we don’t have to specialize the function per type (an application of <em>polymorphism</em>); we can simply compare objects blindly and let Python worry about what sort of comparison to perform according to the objects being compared.</p>
<section data-type="sect2" data-pdf-bookmark="Full Credit"><div class="sect2" id="full_credit">
<h2>Full Credit</h2>
<p>The following script file, <em>mins.py</em> in <a data-type="xref" href="#example_oneeight_twodot_minsdotpy">Example 18-2</a>, shows four ways to code this operation (some of which were suggested by students in a group exercise designed to prevent post-lunch napping):</p>
<ul>
<li><p>The first function fetches the first argument from its <code>args</code> tuple, and traverses the rest by slicing off the first (there’s no point in comparing the first object to itself, especially if it might be a large structure).</p></li>
<li><p>The second version lets Python pick off the first and rest of the arguments automatically, and so avoids an index and slice; the code is simpler, and may be faster (though it would take many calls to matter).</p></li>
<li><p>The third converts from a tuple to a list with the built-in <code>list</code> call and employs the list <code>sort</code> method: the first item has lowest value after an ascending-value sort.</p></li>
<li><p>The fourth sorts too, but skips the list conversion (and two lines) by using the <code>sorted</code> built-in function.</p></li>
</ul>
<p>Python sorting tools are coded in C, so they can be quicker than the other approaches at times, but the linear scans of the first two techniques may often make them faster.<sup><a data-type="noteref" id="ch18fn1-marker" href="ch18.html#ch18fn1">1</a></sup></p>
<div data-type="example" id="example_oneeight_twodot_minsdotpy">
<h5><span class="label">Example 18-2. </span>mins.py</h5>
<pre data-type="programlisting">"Find minimum value among all passed arguments of comparable types"

def min1(*args):
    res = args[0]
    for arg in args[1:]:
        if arg &lt; res:
            res = arg
    return res

def min2(first, *rest):
    for arg in rest:
        if arg &lt; first:
            first = arg
    return first

def min3(*args):
    tmp = list(args)
    tmp.sort()
    return tmp[0]

def min4(*args):
    return sorted(args)[0]

for func in (min1, min2, min3, min4):           <em># Test all 4 functions</em>
    print(func.__name__ + '...')
    print(func(3, 4.0, 1, 2))                   <em># Mixed numerics</em>
    print(func('bb', 'aa'))                     <em># Strings: code points</em>
    print(func([2, 2], [1, 1], [3, 3]))         <em># Lists: recursive</em>
    print(func(*'hack'))                        <em># Unpacked characters</em></pre>
</div>
<p>This script’s testing code uses the <code>__name__</code> attribute we met earlier, along with a <code>for</code> loop to run each function one at a time (remember, functions are objects that work in a tuple too). All four solutions produce the same result when the file is run, so we’ll list just the first’s output here. Run this file live, or import it as a module and type a few calls to its function interactively to experiment with them on your own (see <a data-type="xref" href="ch03.html#how_you_run_programs">Chapter 3</a> for tips on both modes):</p>
<pre data-type="programlisting">$ <code><strong>python3 mins.py</strong></code>
min1...
1
aa
[1, 1]
a
…<code><em>and the same for others</em></code>…</pre>
<p>Notice that none of these four variants tests for the case where <em>no</em> arguments are passed in. They could, but there’s probably no point in doing so here—in all four solutions, Python will automatically raise an exception to signal the error if no arguments are sent. The first variant raises an exception when we try to fetch argument <code>0</code>, the second when Python detects an argument list mismatch, and the third and fourth when we try to return item <code>0</code> post sort.</p>
<p>This is exactly what we want to happen—because these functions support any object (including <code>None</code>), there is no value that we could pass back to designate an error, so we may as well let the exception be raised. There are exceptions to this exceptions rule (e.g., you might test for errors yourself if you’d rather avoid actions that run before reaching the code that triggers an error automatically). But in general—and especially when errors aren’t common—it’s better to assume that arguments will work in your functions’ code, and let Python raise errors for you when they do not.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Bonus Points"><div class="sect2" id="bonus_points">
<h2>Bonus Points</h2>
<p>You can get bonus points here for changing these functions to compute the arguments’ <em>maximum</em>, rather than minimum, value. This one’s trivial: the first two versions only require changing <code>&lt;</code> to <code>&gt;</code>, and the last two simply require that we return item <code>[−1]</code> instead of <code>[0]</code>. For an extra point, be sure to mod the function name to “max” as well (though this part is strictly optional).</p>
<p>True curve busters might also note that it’s possible to generalize a <em>single</em> function to compute either a minimum <em>or</em> a maximum value, by evaluating comparison expression strings with a tool like the <code>eval</code> built-in function (described in Python’s library manual, and at various appearances here, especially its note in <a data-type="xref" href="ch10.html#introducing_python_statements">Chapter 10</a>), or by passing in an arbitrary comparison function. <a data-type="xref" href="#example_oneeight_threedot_minmaxdotpy">Example 18-3</a> shows how to implement the latter scheme for one of the coding options.</p>
<div data-type="example" id="example_oneeight_threedot_minmaxdotpy">
<h5><span class="label">Example 18-3. </span>minmax.py</h5>
<pre data-type="programlisting">"Find minimum -or- maximum value of arguments"

def minmax(test, *args):
    res = args[0]
    for arg in args[1:]:
        if test(arg, res):
            res = arg
    return res

def lessthan(x, y): return x &lt; y                <code><em># See also: lambda, eval</em></code>
def grtrthan(x, y): return x &gt; y

print(minmax(lessthan, 4, 2, 1, 5, 6, 3))       <code><em># Self-test code</em></code>
print(minmax(grtrthan, 4, 2, 1, 5, 6, 3))</pre>
</div>
<p class="pagebreak-before">Running this script prints both minimum and maximum, per its self-test code at the end:</p>
<pre data-type="programlisting">$ <code><strong>python3 minmax.py</strong></code>
1
6</pre>
<p>Again, functions are just another kind of object, which allows them to be passed into other functions as done here. To make this a <code>max</code> (or other) function, for example, we simply pass in the right sort of <code>test</code> function to <code>minmax</code>. This may seem like extra work, but the main point of <em>generalizing</em> functions this way—instead of cutting and pasting to change just a single character—is that we’ll only have one version to change in the future, not two.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="The Punch Line"><div class="sect2" id="the_punch_line">
<h2>The Punch Line</h2>
<p>Of course, all this was just a coding exercise. There’s really no reason to write <code>min</code> or <code>max</code> functions, because both are built-ins in Python! We met them briefly in <a data-type="xref" href="ch05.html#numbers_and_expressions">Chapter 5</a> in conjunction with numeric tools, and again in <a data-type="xref" href="ch14.html#iterations_and_comprehensions">Chapter 14</a> when exploring iteration contexts. The built-in versions work almost exactly like ours, but they’re coded in C for optimal speed and accept either a single iterable or multiple arguments. Still, though it’s superfluous in this context, the general <a contenteditable="false" data-type="indexterm" data-primary="argument matching" data-secondary="mins.py example" data-startref="argminyx" id="id3079"></a><a contenteditable="false" data-type="indexterm" data-primary="mins.py" data-startref="minpys" id="id3080"></a><a contenteditable="false" data-type="indexterm" data-primary="argument matching" data-secondary="minimum value calculation" data-startref="grmtmnmv" id="id3081"></a>coding pattern we used here might be useful in other scenarios.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Example: Generalized Set Functions"><div class="sect1" id="example_generalized_set_functions">
<h1>Example: Generalized Set Functions</h1>
<p>Our next example also demos special argument-matching modes at work. At the end of <a data-type="xref" href="ch16.html#function_basics">Chapter 16</a>, we wrote a function that returned the intersection <a contenteditable="false" data-type="indexterm" data-primary="argument matching" data-secondary="generalized set functions example" id="grmgzf"></a><a contenteditable="false" data-type="indexterm" data-primary="generalized set functions, argument matching" id="genzfrgm"></a>of two sequences (really, it picked out items that appeared in both). <a data-type="xref" href="#example_oneeight_fourdot_intertwodotpy">Example 18-4</a> codes an augmented version that intersects an <em>arbitrary</em> number of sequences (one or more) by using the argument-matching form <code>*args</code> to collect all the passed-in arguments. Because the arguments come in as a tuple, we can process them in a simple <code>for</code> loop. Just for fun, we’ll code a <code>union</code> function that also accepts an arbitrary number of arguments to collect items that appear in <em>any</em> of the operands.</p>
<div data-type="example" id="example_oneeight_fourdot_intertwodotpy">
<h5><span class="label">Example 18-4. </span>inter2.py</h5>
<pre data-type="programlisting">"""
Implement intersection and union for one or more arguments.
Inputs may be any sort of iterable that supports multiple in
tests, and results are always lists.  This intersect avoids 
duplicates in results by in test, but may be slow: improve me.
"""

def intersect(*args):
    res = []
    for x in args[0]:                    <code><em># Scan first sequence</em></code>
        if x in res: continue            <code><em># Skip duplicates in [0]</em></code>
        for other in args[1:]:           <code><em># For all other args</em></code>
            if x not in other: break     <code><em># Item in each one?
</em></code>        else:                            <code><em># No: break out of loop</em></code>
            res.append(x)                <code><em># Yes: add items to end</em></code>
    return res

def union(*args):
    res = []
    for seq in args:                     <code><em># For all args</em></code>
        for x in seq:                    <code><em># For all in this arg</em></code>
            if not x in res:
                res.append(x)            <code><em># Add new items to result</em></code>
    return res</pre>
</div>
<p>Because these tools are potentially worth reusing (and are too big to retype interactively), we’ll store the functions in a <em>module</em> file called <em>inter2.py</em>. Again, if you’re unsure about how modules and imports work, see the introduction in <a data-type="xref" href="ch03.html#how_you_run_programs">Chapter 3</a>, or stay tuned for in-depth coverage in <a data-type="xref" href="part05.html#modules_and_packages">Part V</a>. This chapter’s module usage is simple, but per <a data-type="xref" href="ch03.html#how_you_run_programs">Chapter 3</a>, be sure to launch your REPL in the same <em>folder</em> as the file, so imports can find it.</p>
<p>Like <a data-type="xref" href="ch16.html#function_basics">Chapter 16</a>’s original <code>intersect</code>, both of the functions in this module work on any kind of sequence. Here they are live at the REPL, processing strings, mixed types, and more than two <span class="keep-together">sequences:</span></p>
<pre data-type="programlisting">$ <code><strong>python3</strong></code>
&gt;&gt;&gt; <code><strong>from inter2 import intersect, union</strong></code>
&gt;&gt;&gt; <code><strong>s1, s2, s3 = 'HACKK', 'CODE', 'CASH'</strong></code>

&gt;&gt;&gt; <code><strong>intersect(s1, s2), union(s1, s3)</strong></code>           <code><em># Two operands</em></code>
(['C'], ['H', 'A', 'C', 'K', 'S'])
 
&gt;&gt;&gt; <code><strong>intersect([1, 2, 3, 4], (1, 4))</strong>  </code>          <code><em># Mixed types</em></code>
[1, 4]
 
&gt;&gt;&gt; <code><strong>intersect(s1, s2, s3)</strong>  </code>                    <code><em># Three operands</em></code>
['C']
<code><strong></strong> </code>
&gt;&gt;&gt; <code><strong>union(s1, s2, s3)</strong></code>
['H', 'A', 'C', 'K', 'O', 'D', 'E', 'S']</pre>
<section data-type="sect2" data-pdf-bookmark="Testing the Code"><div class="sect2" id="testing_the_code">
<h2>Testing the Code</h2>
<p>To test more thoroughly, the following continues our REPL session to code a function that applies the two tools to arguments in different orders using a simple <em>shuffling</em> technique that we saw in <span class="keep-together"><a data-type="xref" href="ch13.html#while_and_for_loops">Chapter 13</a>—it</span> slices to move the first to the end on each loop, uses a <code>*</code> to unpack arguments, and sorts so results are comparable. Notice that arguments for the function are sent as a sequence (not discrete items), and the <code>trace</code> configuration option is keyword-only here:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>def tester(func, items, *, trace=True):
       for i in range(len(items)):
           items = items[1:] + items[:1]</strong></code>         <code><em># Move front item to back
</em> <strong>          if trace: print(items)
           print(sorted(func(*items)))</strong> </code>          <code><em># Test with reordered items</em></code>

&gt;&gt;&gt; <code><strong>tester(intersect, (s1, s2, s3))</strong></code>              <code><em># Use strings from prior listing</em></code>
('CODE', 'CASH', 'HACKK')
['C']
('CASH', 'HACKK', 'CODE')
['C']
('HACKK', 'CODE', 'CASH')
['C']

&gt;&gt;&gt; <code><strong>tester(union, (s1, s2, s3), trace=False)</strong></code>
['A', 'C', 'D', 'E', 'H', 'K', 'O', 'S']
['A', 'C', 'D', 'E', 'H', 'K', 'O', 'S']
['A', 'C', 'D', 'E', 'H', 'K', 'O', 'S']

&gt;&gt;&gt; <code><strong>tester(intersect, (s1, s2, s3), trace=False)</strong></code>
['C']
['C']
['C']</pre>
<p>Two context notes here: first, because <em>duplicates</em> won’t appear in these intersection and union functions, they qualify as set operations mathematically, but may not be optimal in term of speed. Still, there’s not much point in improving this demo’s code—intersection and union, like <code>min</code> and <code>max</code>, are built-in operations today: the <em>set</em> object we explored in <a data-type="xref" href="ch05.html#numbers_and_expressions">Chapter 5</a> does intersection and union with <code>&amp;</code> and <code>|</code>, and has methods that take multiple operands too. Hence, optimizing this code is left as suggested exercise, but see <em>inter3.py</em> in the examples package for pointers.</p>
<p>Second, the argument scrambling in the tester here doesn’t generate all possible argument orders (that would require a full permutation, and 6 orderings for 3 arguments), but suffices to check if argument order impacts results. As a preview, though, the tester would be simpler and more flexible if it delegated scrambling to a reusable <em>function</em>. Watch for this revision in <a data-type="xref" href="ch20.html#comprehensions_and_generations">Chapter 20</a>, after we’ve explored <a contenteditable="false" data-type="indexterm" data-primary="argument matching" data-secondary="generalized set functions example" data-startref="grmgzf" id="id3082"></a><a contenteditable="false" data-type="indexterm" data-primary="generalized set functions, argument matching" data-startref="genzfrgm" id="id3083"></a>how to code user-defined <em>generators</em>. We’ll also recode set tools one last time in <a data-type="xref" href="ch32.html#class_odds_and_ends">Chapter 32</a> and a solution to a <a data-type="xref" href="part06.html#classes_and_oop">Part VI</a> exercise, as classes that add them to the list object as methods.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Example: Rolling Your Own Print"><div class="sect1" id="example_rolling_your_own_print">
<h1>Example: Rolling Your Own Print</h1>
<p>To close out the chapter, let’s look at one last example of argument matching at work: this section <a contenteditable="false" data-type="indexterm" data-primary="argument matching" data-secondary="print function example" id="agmpfcx"></a><a contenteditable="false" data-type="indexterm" data-primary="print function" data-secondary="argument matching" id="prtgmtch"></a>uses both <code>*</code> and <code>**</code> arbitrary-arguments collectors up front, and keyword-only arguments later, to emulate most of what Python’s <code>print</code> function does. Like the preceding examples, there’s no urgent reason to code tools that Python provides. Also like the others, though, this is both instructive and may be a basis for custom variants of built-in tools.</p>
<p>For both purposes, the module file in <a data-type="xref" href="#example_oneeight_fivedot_printthreedotp">Example 18-5</a> does roughly the same job as <code>print</code> in a small amount of reusable and modifiable code, by building and routing the print string per configuration arguments.</p>
<div data-type="example" id="example_oneeight_fivedot_printthreedotp">
<h5><span class="label">Example 18-5. </span>print3.py</h5>
<pre data-type="programlisting">r"""
Emulate most of the Python 3.X print function as customizable code.
Call signature: print3(*args, sep=' ', end='\n', file=sys.stdout).
"""
import sys

def print3(*args, **kargs):
    sep  = kargs.get('sep', ' ')            <code><em># Keyword arg defaults</em></code>
    end  = kargs.get('end', '\n')
    file = kargs.get('file', sys.stdout)
    output = ''                             <code><em># Build+print a string</em></code>
    first  = True
    for arg in args:
        output += ('' if first else sep) + str(arg)
        first = False
    file.write(output + end)</pre>
</div>
<p>Notice that this module’s docstring <a contenteditable="false" data-type="indexterm" data-primary="raw strings" id="id3084"></a>uses a <em>raw string</em> to retain its backslash for <code>help</code> (per <a data-type="xref" href="ch15.html#the_documentation_interlude">Chapter 15</a>). Also note that this module’s function need not be called “print3” because “print” is a built-in but not a reserved word, but using a different name avoids inadvertently hiding the built-in. To test it, import this into another file or the interactive prompt, and use it like the <code>print</code> built-in. <a data-type="xref" href="#example_oneeight_sixdot_test_printthree">Example 18-6</a> codes a test script that imports our printer as a demo.</p>
<div data-type="example" id="example_oneeight_sixdot_test_printthree">
<h5><span class="label">Example 18-6. </span>test-print3.py</h5>
<pre data-type="programlisting">from print3 import print3
print3(1, 2, 3)                         <code><em># Defaults</em></code>
print3(1, 2, 3, sep='')                 <code><em># Suppress separator</em></code>
print3(1, 2, 3, sep='...')              <code><em># Custom separator</em></code>
print3(1, [2], (3,), sep='...')         <code><em># Various object types</em></code>

print3(4, 5, 6, sep='', end='')         <code><em># Suppress newline</em></code>
print3(7, 8, 9)                         <code><em># Finish line</em></code>
print3()                                <code><em># Blank line</em></code>

import sys
print3(1, 2, 3, sep='?', end='.\n', file=sys.stderr)    <code><em># Redirect to stream</em></code>

print3('LP6E was here', file=open('log.txt', 'w'))<code> <em>     # Redirect to a file</em></code>
print3(open('log.txt').read())</pre>
</div>
<p>When this is run, our <code>print3</code> produces the same results as the <code>print</code> built-in. Fine points here: <em>stderr</em> goes to your console by default, and it’s OK to use a <em>dash</em> in this script’s name because it’s run, not imported (again, we’ll be focusing on such module details in this book’s next part):</p>
<pre data-type="programlisting">$<code> <strong>python3 test-print3.py</strong></code>
1 2 3
123
1...2...3
1...[2]...(3,)
4567 8 9

1?2?3.
LP6E was here</pre>
<p>As usual, the generality of its toolset allows us to prototype or develop concepts in the Python language itself. In this case, argument-matching tools are as flexible in Python code as they are in Python’s internal implementation.</p>
<section data-type="sect2" data-pdf-bookmark="Using Keyword-Only Arguments"><div class="sect2" id="using_keyword_only_arguments">
<h2>Using Keyword-Only Arguments</h2>
<p>Our print emulator works, but has a minor <a contenteditable="false" data-type="indexterm" data-primary="print emulator, keyword-only arguments" id="id3085"></a><a contenteditable="false" data-type="indexterm" data-primary="arguments" data-secondary="keyword-only" id="id3086"></a>flaw baked in: it assumes that all positional arguments are to be printed, and all keywords are for options only. Any extra keyword arguments are silently ignored, and neither printed nor reported. A call like the following, for instance, will ignore the extra—and likely erroneous—<code>sap</code> argument:</p>
<pre data-type="programlisting">$ <code><strong>python3</strong></code>
&gt;&gt;&gt; <code><strong>from print3 import print3</strong></code>
&gt;&gt;&gt; <code><strong>print3(3.12, 'py', sap='@')</strong></code>
3.12 py</pre>
<p>It may not make sense to print superfluous keywords, but we can detect them manually by using <code>dict.pop()</code> to delete fetched keywords, and checking if the dictionary is not empty when we’re done. The version in <a data-type="xref" href="#example_oneeight_sevendot_printthree_po">Example 18-7</a> does—it’s equivalent to the original, but triggers a built-in exception with a <code>raise</code> statement when unexpected keyword arguments are sent by a call (this is partly preview: we’ll study exceptions and <code>raise</code> in depth in <a data-type="xref" href="part07.html#exceptions">Part VII</a>).</p>
<div data-type="example" id="example_oneeight_sevendot_printthree_po">
<h5><span class="label">Example 18-7. </span>print3_pops.py</h5>
<pre data-type="programlisting">"Use keyword-collector arguments with deletion and defaults"
import sys

def print3(*args, **kargs):
    sep  = kargs.pop('sep', ' ')
    end  = kargs.pop('end', '\n')
    file = kargs.pop('file', sys.stdout)
    if kargs: raise TypeError(f'extra keywords: {kargs}')
    output = ''
    first  = True
    for arg in args:
        output += ('' if first else sep) + str(arg)
        first = False
    file.write(output + end)</pre>
</div>
<p>Notice that this file’s name uses an <em>underscore</em> instead of a dash: because it’s to be imported, its name must follow the rules for variables of <a data-type="xref" href="ch11.html#assignmentscomma_expressionscomma_and_p">Chapter 11</a>. This version works as before, but it now catches extraneous keyword arguments:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>from print3_pops import print3</strong></code>
&gt;&gt;&gt; <code><strong>print3(3.12, 'py', sep='@')</strong></code>
3.12@py
&gt;&gt;&gt; <code><strong>print3(3.12, 'py', sap='@')</strong></code>
TypeError: extra keywords: {'sap': '@'}</pre>
<p>It’s OK to reimport the same <code>print3</code> name from a different file here: this simply replaces the prior version just like reassigning any other variable (more on this later in this book). That being coded, this example could also use keyword-only arguments to <em>automatically</em> validate configuration arguments, as the final variant in <a data-type="xref" href="#example_oneeight_eightdot_printthree_kw">Example 18-8</a> illustrates.</p>
<div data-type="example" id="example_oneeight_eightdot_printthree_kw">
<h5><span class="label">Example 18-8. </span>print3_kwonly.py</h5>
<pre data-type="programlisting">"Use keyword-only arguments to emulate print"
import sys

def print3(*args, sep=' ', end='\n', file=sys.stdout):
    output = ''
    first  = True
    for arg in args:
        output += ('' if first else sep) + str(arg)
        first = False
    file.write(output + end)</pre>
</div>
<p>This version works the same way for valid calls, but catches invalid keywords with keyword-only arguments instead of manual code, and is a prime example of how keyword-only arguments can address coding needs:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>from print3_kwonly import print3</strong></code>
&gt;&gt;&gt; <code><strong>print3(3.12, 'py', sep='@')</strong></code>
3.12@py
&gt;&gt;&gt; <code><strong>print3(3.12, 'py', sap='@')</strong></code>
TypeError: print3() got an unexpected keyword argument 'sap'</pre>
<p>Given that this version of the function also requires <em>four fewer lines</em> of code than its predecessor, keyword-only arguments can simplify a specific category of functions that accept both arguments and options. A similar case can be made for positional-inly arguments versus manual code, but it’s more obscure, and this chapter has run out of space. For another example of keyword-only arguments at work, stay tuned for the iteration-timing case study in <a data-type="xref" href="ch21.html#the_benchmarking_interlude">Chapter 21</a>.</p>
<p>And for more inspiration, also see the sidebar <a data-type="xref" href="ch17.html#why_you_will_care_customizing_open">“Why You Will Care: Customizing open”</a>. Much as we did there, our print emulator could be assigned to <code>builtins.print</code> to replace the built-in with our custom version everywhere in a program. There’s no reason to do that for a version that’s the <em>same</em>, of course, but this technique can be used to install a replacement printer that <a contenteditable="false" data-type="indexterm" data-primary="argument matching" data-secondary="print function example" data-startref="agmpfcx" id="id3087"></a><a contenteditable="false" data-type="indexterm" data-primary="print function" data-secondary="argument matching" data-startref="prtgmtch" id="id3088"></a>mods or extends the built-in (e.g., with logging).</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Chapter Summary"><div class="sect1" id="chapter_summary-id00029">
<h1>Chapter Summary</h1>
<p>In this chapter, we studied the second of two key concepts related to functions: the <em>arguments</em> used to send objects to a function. As we saw, arguments are passed to a function by assignment, which means by object reference (which really means by pointer), and are open to the usual side effects for shared mutable objects, desired or not. We also studied some advanced extensions that generalize argument matching, including default and keyword arguments, tools for collecting and unpacking arbitrarily many arguments, and keyword- and positional-only arguments. Finally, we explored a few larger examples that employed argument tools, and previewed module topics of this book’s next part.</p>
<p>The next chapter continues our look at functions with a grab bag of more advanced function-related ideas: function annotations, recursion, and more on <code>lambda</code> and functional tools such as <code>map</code> and <span class="keep-together"><code>filter</code></span>. Many of these concepts stem from the fact that functions are normal objects in Python, and so support flexible processing tools and modes. Before diving into those topics, however, take this chapter’s quiz to review the argument ideas we’ve studied here.</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Test Your Knowledge: Quiz"><div class="sect1" id="test_your_knowledge_quiz-id000157">
<h1>Test Your Knowledge: Quiz</h1>
<p>This quiz asks you to trace through examples of function definitions and calls to predict their outputs. Try to work out the answers on your own before resorting to cut and paste in a REPL:</p>
<ol>
<li><p>What is the output of the following code, and why?</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>def func(a, b=4, c=5):
        print(a, b, c)

</strong></code>&gt;&gt;&gt; <code><strong>func(1, 2)</strong></code></pre></li>
<li><p>What is the output of this code, and why?</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>def func(a, b, c=5):
        print(a, b, c)

</strong></code>&gt;&gt;&gt; <code><strong>func(1, c=3, b=2)</strong></code></pre></li>
<li><p>How about this code: what is its output, and why?</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>def func(a, *pargs):
        print(a, pargs)

</strong></code>&gt;&gt;&gt; <code><strong>func(1, 2, 3)</strong></code></pre></li>
<li><p>What does this code print, and why?</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>def func(a, **kargs):
        print(a, kargs)

</strong></code>&gt;&gt;&gt; <code><strong>func(a=1, c=3, b=2)</strong></code></pre></li>
<li><p>What gets printed by this, and why?</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>def func(a, b, c=3, d=4): print(a, b, c, d)

</strong></code>&gt;&gt;&gt; <code><strong>func(1, *(5, 6))</strong></code></pre></li>
<li><p>One last time: what is the output of this code, and why?</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>def func(a, b, c):</strong> </code>
        <code><strong>a = 2; b[0] = 'x'; c['a'] = 'y'

</strong></code>&gt;&gt;&gt; <code><strong>L=1; M=[1]; N={'a': 0}</strong></code>
&gt;&gt;&gt; <code><strong>func(L, M, N)</strong></code>
&gt;&gt;&gt; <code><strong>L, M, N</strong></code></pre></li>
</ol>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Test Your Knowledge: Answers"><div class="sect1" id="test_your_knowledge_answers-id000156">
<h1>Test Your Knowledge: Answers</h1>
<ol>
<li><p>The output here is <code>1 2 5</code>, because <code>1</code> and <code>2</code> are passed to <code>a</code> and <code>b</code> by position, and <code>c</code> is omitted in the call and hence defaults to <code>5</code>.</p></li>
<li><p>The output this time is <code>1 2 3</code>: <code>1</code> is passed to <code>a</code> by position, and <code>b</code> and <code>c</code> are passed <code>2</code> and <code>3</code> by name (the left-to-right order doesn’t matter when keyword arguments are used like this).</p></li>
<li><p>This code prints <code>1 (2, 3)</code>, because <code>1</code> is passed to <code>a</code> and the <code>*pargs</code> collects the remaining positional arguments into a new tuple object. We can step through the extra positional arguments tuple with any iteration tool (e.g., <code>for arg in pargs: …</code>).</p></li>
<li><p>This time the code prints <code>1 {'c': 3, 'b': 2}</code>, because <code>1</code> is passed to <code>a</code> by name and the <code>**kargs</code> collects the remaining keyword arguments into a dictionary. We could step through the extra keyword arguments dictionary by key with any iteration tool (e.g., <code>for key in kargs: …</code>). Note that the order of the dictionary’s keys reflects the order in which keyword arguments are passed, in recent Pythons.</p></li>
<li><p>The output here is <code>1 5 6 4</code>: the <code>1</code> matches <code>a</code> by position, <code>5</code> and <code>6</code> match <code>b</code> and <code>c</code> by <code>*</code> positional unpacking (<code>6</code> overrides <code>c</code>’s default), and <code>d</code> defaults to <code>4</code> because it was not passed a value.</p></li>
<li><p>This displays <code>(1, ['x'], {'a': 'y'})</code>—the first assignment in the function doesn’t impact the caller, but the second two do because they change passed-in mutable objects in place.</p></li>
</ol>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="why_you_will_care_keyword_arguments">
<h1>Why You Will Care: Keyword Arguments</h1>
<p>As you can probably tell, some argument-matching mode <a contenteditable="false" data-type="indexterm" data-primary="argument matching" data-secondary="keywords" id="id3089"></a><a contenteditable="false" data-type="indexterm" data-primary="keywords" data-secondary="argument matching" id="id3090"></a>combos can be complex. They are also largely optional in your code; in fact, you can get by with just simple positional matching, and it’s probably a good idea to do so when you’re starting out. However, because many Python tools make good use of them, some general knowledge of these modes is important.</p>
<p>For example, keyword arguments play a key role in <code>tkinter</code>, the de facto standard GUI API for Python. We touch on <code>tkinter</code> only briefly at various points in this book, but in terms of its call patterns, keyword arguments set configuration options when GUI components are built. For instance, a call of the form:</p>
<pre data-type="programlisting">from tkinter import Button
widget = Button(text='Press me', command=someFunction)</pre>
<p>creates a new button and specifies its text displayed in the GUI and callback function run on a press, using the <code>text</code> and <code>command</code> keyword arguments. Since the number of configuration options for a widget can be large, keyword arguments let you pick and choose which to apply. Without them, you might have to either list all the possible options by position or hope for a judicious positional-argument defaults protocol that would handle every possible option arrangement.</p>
<p>Many built-in functions in Python expect us to use keywords for usage-mode options as well, which may or may not have defaults. As we learned in <a data-type="xref" href="ch08.html#lists_and_dictionaries">Chapter 8</a>, for instance, the <code>sorted</code> built-in:</p>
<pre data-type="programlisting">sorted(iterable, key=None, reverse=False)</pre>
<p>expects us to pass an iterable object to be sorted, but also allows us to pass in optional keyword arguments to specify both a value-transform function and a reversal flag, which default to <code>None</code> and <code>False</code>, respectively. Since we normally don’t use these options, they may be omitted to apply defaults.</p>
<p>As we’ve also seen, the <code>dict</code>, <code>str.format</code>, and <code>print</code> calls accept keywords as well—other usages we had to introduce in earlier chapters because of their forward dependence on argument-passing modes we’ve finally studied here (alas, those who change Python already know Python!).</p>
</div></aside>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="ch18fn1"><sup><a href="ch18.html#ch18fn1-marker">1</a></sup> Actually, it’s complicated. CPython’s sort (used by both <code>list.sort</code> and <code>sorted</code>) is coded in C and uses a heavily optimized algorithm that attempts to take advantage of partial ordering in the items to be sorted. Still, sorting is an inherently busy operation (it must chop up the sequence and put it back together many times), and the other versions simply perform one linear left-to-right scan. This suggests that sorting may be quicker if the arguments are partially <em>ordered</em>, but is likely to be slower otherwise. Even so, Python performance changes regularly; the fact that sorting is implemented in the C language can help greatly; and the speed difference may not matter in many programs. For an exact analysis, you should time the alternatives with the <code>time</code> or <code>timeit</code> modules—you’ll see how soon in <a data-type="xref" href="ch21.html#the_benchmarking_interlude">Chapter 21</a>, but file <em>mins-timings.txt</em> in the examples package demos the idea if you can’t wait. The gist: in CPython, the nonsort mins are faster for random arguments, but slower for ordered—today!</p></div></div></section></div>
</div>
</body>
</html>