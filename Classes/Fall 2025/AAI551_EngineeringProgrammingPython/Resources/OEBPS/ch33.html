<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xml:lang="en"
lang="en"
xmlns="http://www.w3.org/1999/xhtml"
xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<title>Learning Python, 6th Edition</title>
<link rel="stylesheet" type="text/css" href="override_v1.css"/>
<link rel="stylesheet" type="text/css" href="epub.css"/>
</head>
<body>
<div id="book-content">
<div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 33. Exception Basics"><div class="chapter" id="exception_basics">
<h1><span class="label">Chapter 33. </span>Exception Basics</h1>
<p>This part of the book deals with <em>exceptions</em>—events that signal conditions and modify the flow of control through a program. In Python, exceptions are triggered automatically on errors, and they can be both triggered and intercepted by your code. They are processed by four statements we’ll study here, the first of which comes in multiple flavors that qualify as different statement forms by some measures:</p>
<dl>
<dt><code>try</code>/<code>except</code>/<code>else</code>/<code>finally</code></dt>
<dd>Catch and recover from exceptions raised by Python, or by you</dd>
<dt><code>raise</code></dt>
<dd>Trigger an exception manually in your code</dd>
<dt><code>assert</code></dt>
<dd>Conditionally trigger an exception in your code</dd>
<dt><code>with</code></dt>
<dd>Use context managers that automate exception handling</dd>
</dl>
<p>We’ve met some of these briefly before, but full coverage of this topic was saved until the end of the main part of this book because you need to know about <em>classes</em> to code exceptions of your own. Still, with a few exceptions (pun intended), you’ll find that exception handling is simple in Python because it’s integrated into the language itself as another high-level tool. Before we dig into the “how,” though, let’s get clear on the “why.”</p>
<section data-type="sect1" data-pdf-bookmark="Why Use Exceptions?"><div class="sect1" id="why_use_exceptionsquestion_mark">
<h1>Why Use Exceptions?</h1>
<p>In a nutshell, exceptions let us jump out of arbitrarily large chunks of a program. Consider the hypothetical <a contenteditable="false" data-type="indexterm" data-primary="exceptions" id="id4362"></a>pizza-making robot we discussed earlier in the book. Suppose we took the idea seriously and actually built such a machine. To make a pizza, our culinary automaton would need to execute a plan, which we would implement as a Python program: it would take an order, prepare the dough, add toppings, bake the pie, and so on.</p>
<p>Now, suppose that something goes very wrong during the “bake the pie” step. Perhaps the oven is broken, or perhaps our robot miscalculates its reach and spontaneously combusts. Clearly, we want to be able to jump to code that handles such unusual states quickly. As we have no hope of finishing the pizza task in such unusual cases, we might as well abandon the entire plan.</p>
<p>That’s exactly what exceptions let your programs do: they can jump to an exception handler in a single step, abandoning all activity begun since the exception handler was entered. Code in the exception handler can then respond to the raised exception as appropriate (by calling the fire department, for instance!).</p>
<p>One way to think of an exception is as a sort of structured “go-to.” An <em>exception handler</em> (<code>try</code> statement) leaves a marker and executes some code. Somewhere further ahead in the program, an exception is raised that makes Python jump back to that marker, abandoning any code that was started and functions that were called after the marker was left. The net effect unwinds the program’s control flow back to the marker and resumes there.</p>
<p>This protocol provides a coherent way to respond to unusual events. Moreover, because Python jumps to the handler statement immediately, your code is simpler—there is usually no need to check status codes after every operation and function call that could possibly fail. Instead, we catch errors only where we need to recover from them.</p>
<section data-type="sect2" data-pdf-bookmark="Exception Roles"><div class="sect2" id="exception_roles">
<h2>Exception Roles</h2>
<p>In less hypothetical programs, exceptions serve a variety of purposes. Here are some of their most common roles:</p>
<dl>
<dt>Error handling</dt>
<dd>Python raises exceptions whenever it <a contenteditable="false" data-type="indexterm" data-primary="exceptions" data-secondary="error handling" id="id4363"></a><a contenteditable="false" data-type="indexterm" data-primary="error handling" data-secondary="exceptions" id="id4364"></a>detects errors in programs at runtime. You can catch and respond to the errors in your code, or ignore the exceptions that are raised. If an error is ignored, Python’s default exception-handling behavior kicks in: it stops the program and prints an error message. If you don’t want this default behavior, code a <code>try</code> statement to catch and recover from the exception—Python will jump to your <code>try</code> handler when the error is detected in the statement’s code, and your program will resume execution after the <code>try</code>.</dd>
<dt>Event notification</dt>
<dd>Exceptions can also be used to signal valid conditions without you having to pass result flags around a program<a contenteditable="false" data-type="indexterm" data-primary="exceptions" data-secondary="event notification" id="id4365"></a><a contenteditable="false" data-type="indexterm" data-primary="event notification" id="id4366"></a> or test them explicitly. For instance, a search routine might raise an exception on failure, rather than returning an integer result code—and hoping that the code will never be a valid result.</dd>
<dt>Special-case handling</dt>
<dd>Sometimes a condition may occur <a contenteditable="false" data-type="indexterm" data-primary="exceptions" data-secondary="special-case handling" id="id4367"></a>so rarely that it’s hard to justify convoluting your code to handle it in multiple places. You can often eliminate special-case code by handling unusual cases in exception handlers in higher levels of your program. An <code>assert</code> can similarly be used to check that conditions are as expected during development.</dd>
<dt>Termination actions</dt>
<dd>As you’ll see, the <code>finally</code> option in a <code>try</code> statement allows you to guarantee <a contenteditable="false" data-type="indexterm" data-primary="exceptions" data-secondary="termination" id="id4368"></a>that required closing-time operations will be performed, regardless of the presence or absence of exceptions in your programs. The <code>with</code> statement offers an alternative in this department for objects that support its expected method-call protocol.</dd>
<dt>Unusual control flows</dt>
<dd>Finally, because exceptions are <a contenteditable="false" data-type="indexterm" data-primary="exceptions" data-secondary="control flow" id="id4369"></a>a sort of high-level and structured “go-to,” you can use them as the basis for implementing exotic control flows. For instance, although the language does not explicitly support backtracking, you can implement it in Python by using exceptions and logic to unwind assignments.<sup><a data-type="noteref" id="ch33fn1-marker" href="ch33.html#ch33fn1">1</a></sup> There is no “go to” statement in Python (thankfully) and no built-in backtracking (today), but exceptions can sometimes serve similar roles; a <code>raise</code>, for instance, can be used to jump out of multiple loops in ways that <code>break</code> cannot.</dd>
</dl>
<p>We saw some of these roles briefly earlier and will study typical exception use cases in action later in this part of the book. For now, let’s get started with a look at Python’s exception-processing tools.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Exceptions: The Short Story"><div class="sect1" id="exceptions_the_short_story">
<h1>Exceptions: The Short Story</h1>
<p>Compared to some other core language topics we’ve explored in this book, exceptions are a fairly lightweight tool in Python. Because they are so simple, let’s jump right into some code.</p>
<section data-type="sect2" data-pdf-bookmark="Default Exception Handler"><div class="sect2" id="default_exception_handler">
<h2>Default Exception Handler</h2>
<p>Suppose we write the following function <a contenteditable="false" data-type="indexterm" data-primary="exceptions" data-secondary="exception handler" id="exechd"></a>in the interactive REPL of our choice:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>def fetcher(obj, index):
        return obj[index]</strong></code></pre>
<p>There’s not much to this function—it simply indexes an object on a passed-in index. In normal operation, it returns the result of a legal index:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>food = 'pizza'
</strong></code>&gt;&gt;&gt; <code><strong>fetcher(food, 4)</strong></code>                        <code><em># Like x[4], last item</em></code>
'a'</pre>
<p>However, if we ask this function to index off the end of the string, an exception will be triggered when the function tries to run <code>obj[index]</code>. Python detects out-of-bounds indexing for sequences and reports it by <em>raising</em> (triggering) the built-in <code>IndexError</code> exception:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>fetcher(food, 5)</strong></code>                        <code><em># Default handler – console interface</em></code>
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 2, in fetcher
IndexError: string index out of range</pre>
<p>Because our code does not explicitly catch this exception, it filters back up to the top level of the program and invokes the <em>default exception handler</em>, which simply prints the standard error message shown here.</p>
<p>By this point in the book, you’ve probably seen your share of standard error messages. They include the exception that was raised, along with a <em>stack trace</em>—a list of all the lines and functions that were active when the exception occurred, which has been largely omitted in this book for space and brevity.</p>
<p>The error message text here was printed by Python 3.12 in a console. It can vary slightly per release, and even per interactive REPL, so you shouldn’t rely upon its exact form—in either this book or your code. When you’re coding interactively in a console interface, the filename may be just “&lt;stdin&gt;,” meaning the standard input stream.</p>
<p>When working in the IDLE GUI’s interactive shell today, though, the filename is “&lt;pyshell…&gt;,” and source lines are displayed, too. Either way, file line numbers are not very meaningful when there is no file (you’ll see more interesting error messages later in this part of the book):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>fetcher(food, 5)</strong></code>                        <code><em># Default handler – IDLE GUI interface</em></code>
Traceback (most recent call last):
  File "&lt;pyshell#3&gt;", line 1, in &lt;module&gt;
    fetcher(food, 5)
  File "&lt;pyshell#0&gt;", line 2, in fetcher
    return obj[index]
IndexError: string index out of range</pre>
<p>In a more realistic program launched outside the interactive REPL, after printing an error message the default handler at the top also <em>terminates</em> the program immediately. That course of action makes sense for simple scripts; errors often should be fatal, and <a contenteditable="false" data-type="indexterm" data-primary="exceptions" data-secondary="exception handler" data-startref="exechd" id="id4370"></a>the best you can do when they occur is inspect the standard error message.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Catching Exceptions"><div class="sect2" id="catching_exceptions">
<h2>Catching Exceptions</h2>
<p>Sometimes, though, program termination <a contenteditable="false" data-type="indexterm" data-primary="exceptions" data-secondary="catching" id="exccatch"></a>on exceptions isn’t what you want. Server programs, for instance, typically need to remain active even after internal errors. If you don’t want the default exception behavior, wrap the call in a <code>try</code> statement to catch exceptions yourself (copy/pasters: omit the “...” here per the note ahead):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>try:</strong></code>
...     <code><strong>fetcher(food, 5)</strong></code>
... <code><strong>except IndexError:</strong></code>                      <code><em># Catch and recover</em></code>
...     <code><strong>print('got exception')</strong></code>
...
got exception
&gt;&gt;&gt;</pre>
<p>Now, Python automatically jumps to your <em>handler</em>—the block under the <code>except</code> clause that names the exception raised—when an exception is triggered while the <code>try</code> block is running. The net effect is to wrap a nested block of code in an error handler that intercepts the block’s exceptions.</p>
<p>When working interactively like this, after the <code>except</code> clause runs, we wind up back at the Python prompt. In a more realistic program, <code>try</code> statements not only catch exceptions but also <em>recover</em> from them:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>def catcher():
        try:
            fetcher(food, 5)
        except IndexError:
            print('got exception')</strong></code>          <code><em># Catch and recover more</em><strong>
        print('continuing')
</strong></code>
&gt;&gt;&gt; <code><strong>catcher()</strong></code>
got exception
continuing
&gt;&gt;&gt;</pre>
<p>This time, after the exception is caught and handled, the program resumes execution after the entire <code>try</code> statement that caught it—which is why we get the “continuing” message here. We don’t see the standard error message, and the program continues on its way normally.</p>
<p class="pagebreak-before">Notice, though, that there’s no way in Python to <em>go back</em> to the code that triggered the exception (short of rerunning the code that reached that point all over again, of course). Once you’ve caught the exception, control continues after the entire <code>try</code> that caught the exception, not after the statement that kicked off the exception. In fact, Python clears the memory of any functions that were exited as a result of the exception, like <code>fetcher</code> in our example; their variables are discarded, and they’re not resumable. The <code>try</code> both catches exceptions and is where the program resumes.</p>
<p>Python does not, however, <em>undo</em> any work done by the <code>try</code> block up to the point where the exception occurred—any changes made to referenced mutable objects and accessible global names live on. This isn’t a problem if it’s known:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>L, S = [], 'text'</strong></code>
&gt;&gt;&gt; <code><strong>def modder():</strong></code>
        <code><strong>L.append('added')</strong></code>                   <code><em># Change a mutable</em></code>
        <code><strong>global S; S = 'changed'</strong>   </code>          <code><em># Change a global</em></code>
        <code><strong>fetcher(food, 5)</strong></code>                    <code><em># Trigger an exception</em></code>
 
&gt;&gt;&gt; <code><strong>try:</strong></code>
...     <code><strong>modder()</strong></code>
... <code><strong>except IndexError:</strong></code>
...     <code><strong>print('got exception')</strong></code>
... 
got exception
&gt;&gt;&gt; <code><strong>L, S         </strong>  </code>                         <code><em># Changes retained</em></code>
(['added'], 'changed')</pre>
<p>As you’ll see later in this part of the book, the <code>try</code> can also use <code>except*</code> clauses to process <em>multiple</em> exceptions, but this is a convoluted extension with narrow scope that doesn’t play well with others, and you can safely defer studying until you’ve mastered the fundamentals.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><em>Presentation note</em>: The interactive REPL’s “...” continuation prompt reappears in this part for some top-level <code>try</code> statements, because their code won’t work if copied and pasted unless nested in a function or class (the <code>except</code> and other lines must align with the <code>try</code>, and not have extra preceding spaces <a contenteditable="false" data-type="indexterm" data-primary="exceptions" data-secondary="catching" data-startref="exccatch" id="id4371"></a>that are needed to illustrate their indentation structure here). To run, simply type or paste statements with “...” prompts one line at a time, and without their leading “...” prompts.</p>
</div>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Raising Exceptions"><div class="sect2" id="raising_exceptions-id00072">
<h2>Raising Exceptions</h2>
<p>So far, we’ve been letting Python raise <a contenteditable="false" data-type="indexterm" data-primary="exceptions" data-secondary="raising" id="exprsg"></a>exceptions for us by making mistakes (on purpose this time!), but our scripts can raise exceptions too—that is, exceptions can be raised by Python or by your program, and can be caught or not. To trigger an exception manually, simply run a <code>raise</code> statement. User-triggered exceptions are caught the same way as those Python raises. The following may not be the most useful Python code ever penned, but it makes the point—raising the built-in <code>IndexError</code> exception:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>try:</strong></code>
...     <code><strong>raise IndexError</strong> </code>                   <code><em># Trigger exception manually</em></code>
... <code><strong>except IndexError:</strong></code>
...     <code><strong>print('got exception')</strong></code>
...
got exception</pre>
<p>As usual, if they’re not caught, user-triggered exceptions are propagated up to the top-level default exception handler and terminate the program with a standard error message:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>raise IndexError</strong></code>
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
IndexError</pre>
<p>As you’ll see in the next chapter, the <code>assert</code> statement can be used to trigger exceptions, too—it’s a conditional <code>raise</code> predicated on a test, used mostly for debugging purposes and sanity checks during development:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>assert 1 &lt; 0, 'Not in this universe!'</strong></code>
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AssertionError: Not in this universe!</pre>
<p>Also in the next chapter, you’ll learn that <code>raise</code> can use a <code>from</code> clause to “chain” exceptions; generally speaking, this is not common, but can be used to give more <a contenteditable="false" data-type="indexterm" data-primary="exceptions" data-secondary="raising" data-startref="exprsg" id="id4372"></a>context where it’s useful.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="User-Defined Exceptions"><div class="sect2" id="user_defined_exceptions">
<h2>User-Defined Exceptions</h2>
<p>The <code>raise</code> statement demos in the prior section raised <code>IndexError</code>, a <em>built-in</em> exception <a contenteditable="false" data-type="indexterm" data-primary="exceptions" data-secondary="user-defined" id="id4373"></a>defined in Python’s built-in scope. As you’ll learn later in this part of the book, you can also define new exceptions of your own that are specific to your programs. User-defined exceptions are coded with <em>classes</em>, which inherit from a built-in exception class—usually, the class named <code>Exception</code>:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>class Combust(Exception): pass</strong></code>          <code><em># User-defined exception</em></code>

&gt;&gt;&gt; <code><strong>def makePizza():
        raise Combust()</strong></code>                     <code><em># Raise an instance</em></code>

&gt;&gt;&gt; <code><strong>try:</strong></code>
...     <code><strong>makePizza()</strong></code>
... <code><strong>except Combust:</strong></code>                         <code><em># Catch class name</em></code>
...     <code><strong>print('got exception')</strong></code>
...
got exception
&gt;&gt;&gt;</pre>
<p>As you’ll see in upcoming chapters, exception classes allow scripts to build exception categories, which can inherit behavior and have attached state information and methods, and an <code>as</code> clause on an <code>except</code> can gain access to the exception object itself. Exception classes can also customize their message text displayed if they’re not caught:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>class Combust(Exception):
        def __str__(self):</strong> </code>
            <code><strong>return 'Call the fire department!...'
</strong></code>
&gt;&gt;&gt; <code><strong>raise Combust()</strong></code>
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
Combust: Call the fire department!...
&gt;&gt;&gt;</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Termination Actions"><div class="sect2" id="termination_actions">
<h2>Termination Actions</h2>
<p>Finally, <code>try</code> statements <a contenteditable="false" data-type="indexterm" data-primary="exceptions" data-secondary="termination" id="excptmr"></a>can say “finally”—that is, they may include <code>finally</code> blocks. These look like <code>except</code> handlers for exceptions, but the <code>try</code>/<code>finally</code> combination specifies termination actions that always execute “on the way out,” regardless of whether an exception occurs in the <code>try</code> block or not. Continuing our REPL session:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>try:</strong></code>
...     <code><strong>fetcher(food, 4)</strong></code>
... <code><strong>finally:</strong></code>                                <code><em># Termination actions</em></code>
...     <code><strong>print('after fetch')</strong></code>
...
'a'
after fetch
&gt;&gt;&gt;</pre>
<p>Here, if the <code>try</code> block finishes <em>without</em> an exception, the <code>finally</code> block will run, and the program will resume after the entire <code>try</code>. In this case, this statement seems a bit silly—we might as well have simply typed the <code>print</code> right after a call to the function, and skipped the <code>try</code> altogether:</p>
<pre data-type="programlisting">fetcher(food, 4)
print('after fetch')</pre>
<p>There is a problem with coding this way, though: if the function call raises an exception, the <code>print</code> will never be reached. The <code>try</code>/<code>finally</code> combination avoids this pitfall—when an exception <em>does</em> occur in a <code>try</code> block, <code>finally</code> blocks are executed while the program is being unwound:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>def after():
        try:
            fetcher(food, 5)
        finally:
            print('after fetch')</strong>  </code>          <code><em># Always run</em></code>
<code> <strong>       print('after try?')</strong>  </code>               <code><em># Run only if no exception</em></code>

&gt;&gt;&gt; <code><strong>after()</strong></code>
after fetch
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 3, in after
  File "&lt;stdin&gt;", line 2, in fetcher
IndexError: string index out of range
&gt;&gt;&gt;</pre>
<p>Here, we don’t get the “after try?” message because control does not resume after the <code>try</code> statement when an exception occurs. Instead, Python jumps back to run the <code>finally</code> action and then <em>propagates</em> the exception up to a prior handler (in this case, to the default handler at the top). If we change the call inside this function so as not to trigger an exception, the <code>finally</code> code still runs, but the program continues after the <code>try</code>:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>def after():
        try:
            fetcher(food, 4)
        finally:
            print('after fetch')</strong>  </code>          <code><em># Both run if no exception</em></code>
<code> <strong>       print('after try?')</strong></code>

&gt;&gt;&gt; <code><strong>after()</strong></code>
after fetch
after try?
&gt;&gt;&gt;</pre>
<p>In practice, <code>except</code> clauses in a <code>try</code> are useful for catching and recovering from exceptions, and <code>finally</code> clauses come in handy to guarantee that termination actions will fire regardless of any exceptions that may occur in the <code>try</code> block’s code. For instance, you might use <code>try</code>/<code>except</code> combinations to catch errors raised by code that you import from a third-party library, and <code>try</code>/<code>finally</code> combos to ensure that calls to close files or terminate server connections are always run. We’ll code some such practical examples later in this part of the book.</p>
<p>Although they serve conceptually distinct purposes, you can also mix <code>except</code> and <code>finally</code> clauses in the <em>same</em> <code>try</code> statement—the <code>finally</code> is run on the way out regardless of whether an exception was raised, and regardless of whether the exception was caught by an <code>except</code> clause. Such combos have rules you’ll meet in the next chapter.</p>
<p>As you’ll also learn in the next chapter, Python provides an alternative to the <code>try</code>/<code>finally</code> mix when using some types of built-in and user-defined objects. The <code>with</code> statement runs a <em>context manager</em> object’s methods to guarantee that termination actions occur, irrespective of any exceptions in its nested block:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>with open('pizzarobot.txt', 'w') as file:</strong></code>        <code><em># Always close file on exit</em></code>
        <code><strong>file.write('Catch fire!\n')</strong></code></pre>
<p>Although this option requires fewer lines of code, it’s applicable only when processing certain object types, so <code>try</code>/<code>finally</code> is a more general termination structure, and is often simpler than coding a class in cases where <code>with</code> is not already supported. On the other hand, <code>with</code> may also run <a contenteditable="false" data-type="indexterm" data-primary="exceptions" data-secondary="termination" data-startref="excptmr" id="id4374"></a>startup actions too, and supports user-defined context management code with access to Python’s full OOP toolset. To see how, let’s move on to the next chapter.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Chapter Summary"><div class="sect1" id="chapter_summary-id00044">
<h1>Chapter Summary</h1>
<p>And that is the majority of the exception story; exceptions really are a simple tool.</p>
<p>To summarize, Python exceptions are a control-flow device. They may be raised by Python, or by your own programs. In both cases, they may be ignored (to trigger the default error handler), or caught by <code>try</code> statements (to be processed by your code). The <code>try</code> statement comes in logically distinct forms that can be combined—one that handles exceptions, and one that runs finalization code regardless of whether exceptions occur or not. Python’s <code>raise</code> and <code>assert</code> statements trigger exceptions on <span class="keep-together">demand—both</span> built-ins and new exceptions we define with classes—and the <code>with</code> statement is an alternative way to ensure that termination actions are carried out for objects that support it.</p>
<p>In the rest of this part of the book, we’ll fill in some of the details about the statements involved, examine the other sorts of clauses that can appear under a <code>try</code> (spoiler: it also allows an <code>else</code> for the no-exception case), and discuss class-based exception objects. The next chapter begins our tour by taking a closer look at the statements we introduced here. Before you turn the page, though, here are a few quiz questions to review.</p>
</div></section>
<section data-type="sect1" class="pagebreak-before" data-pdf-bookmark="Test Your Knowledge: Quiz"><div class="sect1" id="test_your_knowledge_quiz-id000187">
<h1 class="less_space">Test Your Knowledge: Quiz</h1>
<ol>
<li><p>Name three things that exception processing is good for.</p></li>
<li><p>What happens to an exception if you don’t do anything special to handle it?</p></li>
<li><p>How can your script recover from an exception?</p></li>
<li><p>Name two ways to trigger exceptions in your script.</p></li>
<li><p>Name two ways to specify actions to be run at termination time, whether an exception occurs or not.</p></li>
</ol>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Test Your Knowledge: Answers"><div class="sect1" id="test_your_knowledge_answers-id000186">
<h1>Test Your Knowledge: Answers</h1>
<ol>
<li><p>Exception processing is useful for error handling, termination actions, and event notification. It can also simplify the handling of special cases and can be used to implement alternative control flows as a kind of structured “go-to” operation. In general, exception processing also cuts down on the amount of error-checking code your program may require—because all errors filter up to handlers, you may not need to test the outcome of every operation (see this chapter’s sidebar <a data-type="xref" href="#why_you_will_care_error_checks">“Why You Will Care: Error Checks”</a> for an illustration).</p></li>
<li><p>Any uncaught exception eventually filters up to the default exception handler Python provides at the top of your program. This handler prints the familiar error message and shuts down your <span class="keep-together">program</span>.</p></li>
<li><p>If you don’t want the default message and shutdown, you can code <code>try</code> statements with <code>except</code> clauses to catch and recover from exceptions that are raised within its nested code block. Once an exception is caught, the exception is terminated and your program continues after the <code>try</code>.</p></li>
<li><p>The <code>raise</code> and <code>assert</code> statements can be used to trigger an exception, exactly as if it had been raised by Python itself. In principle, you can also raise an exception by making a programming mistake, but that’s not usually an explicit goal!</p></li>
<li><p>The <code>try</code> statement with a <code>finally</code> clause can be used to ensure actions are run after a block of code exits, regardless of whether the block raises an exception or not. The <code>with</code> statement can also be used to ensure termination actions are run, but only when processing object types that support it.</p></li>
</ol>
<aside data-type="sidebar" epub:type="sidebar" class="pagebreak-before"><div class="sidebar" id="why_you_will_care_error_checks">
<h1 class="less_space">Why You Will Care: Error Checks</h1>
<p>One way to see how exceptions are useful is to <a contenteditable="false" data-type="indexterm" data-primary="exceptions" data-secondary="error checks" id="id4375"></a>compare coding styles in Python and languages without exceptions. For instance, if you want to write robust programs in the C language, you generally have to test return values or status codes after every operation that could possibly go astray, and propagate the results of the tests as your programs run:</p>
<pre data-type="programlisting">doStuff()
{                                   <code><em># C program</em></code>
    if (doFirstThing() == ERROR)    <code><em># Detect errors everywhere</em></code>
        return ERROR;               <code><em># even if not handled here
</em></code>    if (doNextThing() == ERROR)
        return ERROR;
    ...
    return doLastThing();
}

main()
{
    if (doStuff() == ERROR)
        badEnding();
    else
        goodEnding();
}</pre>
<p>In fact, realistic C programs often have as much code devoted to error detection as to doing actual work. But in Python, you don’t have to be so methodical (and neurotic!). You can instead wrap arbitrarily vast pieces of a program in exception handlers and simply write the parts that do the actual work, assuming all is normally well:</p>
<pre data-type="programlisting">def doStuff():          <code><em># Python code
</em></code>    doFirstThing()      <code><em># We don't care about exceptions here,</em></code>
    doNextThing()       <code><em># so we don't need to detect them</em></code>
    ...
    doLastThing()

if __name__ == '__main__':
    try:
        doStuff()       <code><em># This is where we care about results,
</em></code>    except:             <code><em># so it's the only place we must check</em></code>
        badEnding()
    else:               <code><em># See the next chapter for else</em></code>
        goodEnding()</pre>
<p>Because control jumps immediately to a handler when an exception occurs, there’s no need to instrument all your code to guard for errors, and there’s no extra performance overhead to run all the tests. Moreover, because Python detects errors automatically, your code often doesn’t need to check for errors in the first place. The upshot is that exceptions let you largely ignore the unusual cases and avoid error-checking code that can distract from your program’s purpose.</p>
</div></aside>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="ch33fn1"><sup><a href="ch33.html#ch33fn1-marker">1</a></sup> For any computer scientists in the audience, true backtracking is not part of the Python language. Backtracking undoes computations before it jumps back, but Python exceptions do not: local variables in open function calls run by the <code>try</code> are simply discarded, but changes made to globals and objects are retained (see the demo ahead). Even the generator functions and expressions we met in <a data-type="xref" href="ch20.html#comprehensions_and_generations">Chapter 20</a> don’t do full backtracking—they simply respond to <code>next(<em>G</em>)</code> requests by restoring saved state and resuming. For more on backtracking, try books on AI or the Prolog or Icon programming <span class="keep-together">languages</span>.</p></div></div></section></div>
</div>
</body>
</html>