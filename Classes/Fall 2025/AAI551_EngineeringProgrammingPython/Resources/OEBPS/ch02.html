<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xml:lang="en"
lang="en"
xmlns="http://www.w3.org/1999/xhtml"
xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<title>Learning Python, 6th Edition</title>
<link rel="stylesheet" type="text/css" href="override_v1.css"/>
<link rel="stylesheet" type="text/css" href="epub.css"/>
</head>
<body>
<div id="book-content">
<div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 2. How Python Runs Programs"><div class="chapter" id="how_python_runs_programs">
<h1><span class="label">Chapter 2. </span>How Python Runs Programs</h1>
<p>This chapter and the next cover program execution—how you launch code and how Python runs it. In this chapter, we’ll begin by studying how the Python interpreter executes programs in general, from an abstract vantage point. With that perspective in hand, <a data-type="xref" href="ch03.html#how_you_run_programs">Chapter 3</a> will dive into the nuts and bolts of getting your own programs up and running.</p>
<p>Startup details are inherently platform specific, and some of the material in these two chapters may not apply to the ways you’ll be using Python, so you should feel free to skip parts not relevant to your goals. Likewise, readers who have used similar tools in the past and prefer to get to the meat of the language quickly may want to file some of these chapters away for future reference. For the rest of us, let’s take a brief look at the way that Python will run our code, before we get into the details of writing or <span class="keep-together">running it</span>.</p>
<section data-type="sect1" data-pdf-bookmark="Introducing the Python Interpreter"><div class="sect1" id="introducing_the_python_interpreter">
<h1>Introducing the Python Interpreter</h1>
<p>So far, we’ve mostly been talking about Python as <a contenteditable="false" data-type="indexterm" data-primary="interpreter" id="interp"></a>a programming language. In its most widely used form, though, it’s also a software system called an <em>interpreter</em>. An interpreter is a kind of program that executes other programs. When you write a Python program, the Python interpreter reads your program and carries out the instructions it contains. In effect, the interpreter is a layer of logic between your code and the computer hardware on your machine.</p>
<p>When Python is installed, it generates a number of components—minimally, an interpreter and a support library. Depending on how you use it, the Python interpreter may take the form of an executable program, or a set of libraries linked into another program. Depending on which flavor of Python you run, the interpreter itself may be implemented as a C program, a set of Java classes, or something else. Whatever form it takes, the Python code you write must always be run by this interpreter. And to enable that, you usually must install a Python interpreter on your computer.</p>
<p>You don’t need to install Python at this point unless you want to work along with the sole trivial example coming up, and this book won’t assume that you’ve got a Python ready to go until the next chapter. When you’re ready, Python installation details vary by platform and are discussed briefly in <a data-type="xref" href="ch03.html#how_you_run_programs">Chapter 3</a>, and covered in full in <a data-type="xref" href="app01.html#appendix_a_platform_usage_tips">Appendix A</a>.</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Program Execution"><div class="sect1" id="program_execution">
<h1>Program Execution</h1>
<p>What it means to run a Python script depends on whether you look at this task as a programmer, or as a Python interpreter. Both views offer important perspectives on Python programming.</p>
<section data-type="sect2" data-pdf-bookmark="The Programmer’s View"><div class="sect2" id="the_programmerapostrophes_view">
<h2>The Programmer’s View</h2>
<p>In its simplest but most common form, a Python <a contenteditable="false" data-type="indexterm" data-primary="program execution" id="id1508"></a>program is just a text file containing Python statements. For example, the file listed in <a data-type="xref" href="#example_two_onedot_scriptzerodotpy">Example 2-1</a>, named <em>script0.py</em>, may be one of the most trivial Python scripts one could dream up, but it passes for a fully functional Python program.</p>
<div data-type="example" id="example_two_onedot_scriptzerodotpy">
<h5><span class="label">Example 2-1. </span>script0.py</h5>
<pre data-type="programlisting">print('hello world')
print(2 ** 100)</pre>
</div>
<p>This file contains <a contenteditable="false" data-type="indexterm" data-primary="print statements" id="id1509"></a>two Python <code>print</code> statements, which simply print a string (the text in quotes) and a numeric expression result (2 to the power 100) to the output stream (the GUI or window where the file is run, normally). Don’t worry about the syntax of this code yet—for now, we’re interested only in how it runs. This book will explain the <code>print</code> statement, and why you can raise 2 to the power 100 so easily in Python, in its later chapters.</p>
<p>You can create such a file of statements with any text editor you like; see <a data-type="xref" href="app01.html#appendix_a_platform_usage_tips">Appendix A</a> for suggestions. By convention, Python <a contenteditable="false" data-type="indexterm" data-primary="filenames" data-secondary="program files" id="id1510"></a><a contenteditable="false" data-type="indexterm" data-primary="program files" data-secondary="naming convention" id="id1511"></a>program files are given names that end in <em>.py</em>; technically, this naming scheme is required only for files that are “imported”—a term clarified in the next chapter—but most Python files have <em>.py</em> names for consistency.</p>
<p>After you’ve typed these statements into a text file, you must tell Python to <em>execute</em> the file—which simply means to run all the statements in the file from top to bottom, one after another. As you’ll see in the next chapter, you can launch Python program files by typing command lines, by clicking their icons, from within coding GUIs, and with other techniques. If all goes well, when you execute the file, you’ll see the results of the two <code>print</code> statements show up somewhere on your computer—usually and by default, in the same window you were in when you ran the program:</p>
<pre data-type="programlisting">hello world
1267650600228229401496703205376</pre>
<p>For example, here’s what happened when this script was run in a Command Prompt window with a command line on a Windows laptop, to make sure it didn’t have any silly typos:</p>
<pre data-type="programlisting">C:\Users\me\code&gt; <code><strong>py script0.py</strong></code>
hello world
1267650600228229401496703205376</pre>
<p>See <a data-type="xref" href="ch03.html#how_you_run_programs">Chapter 3</a> for the full story on this process, especially if you’re new to programming; we’ll get into all the details of writing and launching programs there. For our purposes here, we’ve just run a Python script that prints a string and a number. We probably won’t attract venture capital or go viral on GitHub with this code, but it’s enough to capture the basics of program execution.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Python’s View"><div class="sect2" id="pythonapostrophes_view">
<h2>Python’s View</h2>
<p>The brief description in the prior section is fairly standard for scripting languages, and it’s usually all that most new Python programmers need to know. You type code into text files, and you run those files through the interpreter. Under the hood, though, a bit more happens when you tell Python to “go.” Although knowledge of Python internals is not strictly required for Python programming, having a basic understanding of Python’s runtime structure up front can help you grasp how your code fits into the bigger picture of program execution.</p>
<p>When you instruct Python to run your script, there are a few steps that Python carries out before your code actually starts crunching away. Specifically, it’s first compiled to something <a contenteditable="false" data-type="indexterm" data-primary="VMs (virtual machines)" id="id1512"></a><a contenteditable="false" data-type="indexterm" data-primary="virtual machines (VMs)" data-see="VMs (virtual machines" id="id1513"></a>called “bytecode” and then routed to something called a “virtual machine.” This holds true only for the most common version of Python, and you’ll meet variations on this model in a moment. Since the most common is, well, most common, let’s see how this works first.</p>
<section data-type="sect3" data-pdf-bookmark="Bytecode compilation"><div class="sect3" id="bytecode_compilation">
<h3>Bytecode compilation</h3>
<p>Internally, and almost completely <a contenteditable="false" data-type="indexterm" data-primary="bytecode" id="id1514"></a>hidden from you, when you execute a program Python first compiles your <em>source code</em> (the statements in your text file) into a format known as <em>bytecode</em>. Compilation is simply a translation step, and bytecode is a lower-level, platform-independent representation of your source code. Roughly, Python translates each of your source statements into a group of bytecode instructions by decomposing them into individual steps. This bytecode translation is performed to speed execution—bytecode can be run much more quickly than the original source code statements in your text file.</p>
<p>You’ll notice that the prior paragraph said that this is <em>almost</em> completely hidden from you. If the Python program has write access on your machine, it will save <a contenteditable="false" data-type="indexterm" data-primary="bytecode" data-secondary="files" id="id1515"></a><a contenteditable="false" data-type="indexterm" data-primary="files" data-secondary="bytecode" id="id1516"></a>the bytecode of your programs in files that end with a <em>.pyc</em> extension (<em>.pyc</em> means <em>.py</em> source, compiled). Technically, this save doesn’t happen when running a single file as we did in the preceding section but does for all but the topmost file in meatier multifile programs (more on this in a moment).</p>
<p>Python saves its bytecode files in a subdirectory named <em>__pycache__</em> located in the directory where your source files reside, and in files whose names identify the Python version that created them (e.g., <em>script0.cpython-312.pyc</em> for 3.12). The <em>__pycache__</em> subdirectory avoids clutter, and the naming convention for bytecode files prevents different Python versions installed on the same computer from overwriting each other’s saved bytecode. We’ll study this bytecode file model in more detail in <a data-type="xref" href="ch22.html#modules_the_big_picture">Chapter 22</a>, though it’s automatic and irrelevant to most Python programs and is free to vary among the alternative Python implementations described ahead.</p>
<p>So why all the bother? In short, Python <a contenteditable="false" data-type="indexterm" data-primary="bytecode" data-secondary="startup-speed optimization" id="id1517"></a><a contenteditable="false" data-type="indexterm" data-primary="startup-speed optimization, bytecode and" id="id1518"></a>saves bytecode like this as a <em>startup-speed</em> optimization. The next time you run your program, Python will load the <em>.pyc</em> files and skip the compilation steps, as long as the bytecode is present, you haven’t changed your source code since the bytecode was last saved, and you aren’t running with a different Python than the one that created the bytecode. It works like this:</p>
<dl>
<dt>Source changes</dt><dd>Python saves <a contenteditable="false" data-type="indexterm" data-primary="bytecode" data-secondary="Python versions" id="id1519"></a>the last-modified timestamp and size (or hash value, optionally) of a source code file in its bytecode file, and compares this info to the source when the bytecode is loaded to know when it must <span class="keep-together">recompile—if</span> you edit and resave your source code, its bytecode is re-created the next time your program is run.</dd>
<dt>Python versions</dt><dd>Python also adds a version-information suffix to bytecode filenames to know when it must <span class="keep-together">recompile—if</span> you run your program on a different Python implementation or version, its bytecode is generated and saved for that Python too.</dd>
</dl>
<p>The result is that both source code changes and differing Python versions will trigger a new bytecode file automatically. If Python <em>cannot</em> write the bytecode files to your machine, your <a contenteditable="false" data-type="indexterm" data-primary=".pyc files" data-primary-sortas="pyc files" id="id1520"></a>program still works—the bytecode is generated in memory and simply discarded on program exit.</p>
<p>Because <em>.pyc</em> files speed startup time, though, you’ll want to make sure they are written for larger programs. Bytecode files are also one way to ship Python programs—Python is happy to run a program if all it can find are compatible <em>.pyc</em> files, even if the original <em>.py</em> source files are absent. This isn’t as simple as deleting the <em>.py</em> files, though, and may require file moves and renames, or special techniques discussed later in <a data-type="xref" href="ch22.html#modules_the_big_picture">Chapter 22</a>. See Python’s <code>compileall</code> module to force compiles when needed for packaging, and frozen binaries (see <a data-type="xref" href="#standalone_executables">“Standalone Executables”</a>) for another shipping option.</p>
<p>Strictly speaking, bytecode is an <em>import</em> optimization. Bytecode is saved in <em>.pyc</em> files only <a contenteditable="false" data-type="indexterm" data-primary="import optimization, bytecode" id="id1521"></a><a contenteditable="false" data-type="indexterm" data-primary="bytecode" data-secondary="import optimization" id="id1522"></a>for files that are <em>imported</em>, not for the top-level files of a program that are only run as scripts. Moreover, a given file is imported and possibly compiled only <em>once</em> per program run; later imports use what’s already been loaded. We’ll explore import basics in <a data-type="xref" href="ch03.html#how_you_run_programs">Chapter 3</a> and take a deeper look at imports in <a data-type="xref" href="part05.html#modules_and_packages">Part V</a>. For now, keep in <a contenteditable="false" data-type="indexterm" data-primary="bytecode" data-secondary="interactive prompt code" id="id1523"></a>mind that bytecode is never saved for code typed at the <em>interactive prompt</em>—a programming mode you’ll learn about in <a data-type="xref" href="ch03.html#how_you_run_programs">Chapter 3</a> and use early in this book.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="The Python Virtual Machine (PVM)"><div class="sect3" id="the_python_virtual_machine_left_parenth">
<h3>The Python Virtual Machine (PVM)</h3>
<p>Once your program has been compiled to bytecode (or the bytecode has been loaded from existing <em>.pyc</em> files), it is <a contenteditable="false" data-type="indexterm" data-primary="PVM (Python Virtual Machine)" id="id1524"></a><a contenteditable="false" data-type="indexterm" data-primary="Python Virtual Machine" id="id1525"></a><a contenteditable="false" data-type="indexterm" data-primary="VMs (virtual machines)" data-secondary="PVM (Python Virtual Machine)" id="id1526"></a>shipped off for execution to something generally known as the Python Virtual Machine (PVM, for acronym-inclined readers). The PVM sounds more impressive than it is; really, it’s not a separate program, and it need not be installed by itself. In fact, the PVM is just a big code loop that iterates through your bytecode instructions, one by one, to carry out their operations. That is, the PVM is the runtime engine in Python. It’s always present as part of the Python system, is the component that truly runs your scripts, and is really just <a contenteditable="false" data-type="indexterm" data-primary="interpreter" data-startref="interp" id="id1527"></a>the last step of the “Python interpreter.”</p>
<p><a data-type="xref" href="#pythonapostrophes_traditional_execution">Figure 2-1</a> illustrates this runtime structure. Bear in mind that all of this complexity is deliberately hidden from Python programmers. Bytecode compilation is automatic, and the PVM is just part of the Python system that you have installed on your machine. Again, programmers simply code and run files of statements, and Python handles the logistics of running them behind the scenes.</p>
<figure><div id="pythonapostrophes_traditional_execution" class="figure">
<img src="assets/lpy6_0201.png" alt="" width="1054" height="331"/>
<h6><span class="label">Figure 2-1. </span>Python’s traditional execution model: the PVM runs compiled bytecode</h6>
</div></figure>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Performance implications"><div class="sect3" id="performance_implications">
<h3>Performance implications</h3>
<p>Readers with a background in fully compiled languages such as C and C++ might notice some glaring differences in the <a contenteditable="false" data-type="indexterm" data-primary="performance" id="id1528"></a>Python model. For one thing, there is usually no build or “make” step in Python work: code runs immediately after it is written. For another, Python bytecode is not binary <em>machine code</em> (e.g., instructions for an Intel or ARM chip, known as a <em>CPU</em>): it’s a Python-specific format. There are exceptions to these rules (e.g., app builds for smartphones can take some time, and full compilers do exist, as you’ll see ahead), but we’re focusing on the common here first.</p>
<p>These differences explain why some Python code may not run as fast as C or C++ code, as described in <a data-type="xref" href="ch01.html#a_python_qampersanda_session">Chapter 1</a>—the PVM loop, not the CPU chip, still must interpret the bytecode, and bytecode instructions require more work than CPU instructions. On the other hand, unlike in classic interpreters, there is still an internal compile step—Python does not need to reanalyze and reparse each source statement’s text repeatedly. The net effect is that pure Python code runs at speeds somewhere between those of a traditional compiled language and a traditional interpreted language.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Development implications"><div class="sect3" id="development_implications">
<h3>Development implications</h3>
<p>Another ramification of Python’s execution model is that there is really no distinction between the development and <a contenteditable="false" data-type="indexterm" data-primary="development implications" id="id1529"></a>execution environments: the systems that compile and execute your source code are really one and the same. This similarity may have a bit more significance to readers with a background in traditional compiled languages, but in Python, the compiler is always present at runtime and is part of the system that runs programs.</p>
<p>This makes for a much more <em>rapid</em> development cycle. There is no need to precompile and link before execution can begin; simply type and run the code. This also adds a much more <em>dynamic</em> flavor to the language—it is possible, and often very convenient, for Python programs to construct and execute other Python programs at runtime. The <code>eval</code> and <code>exec</code> built-ins, for instance, accept and run strings containing Python program code. This structure is also why Python lends itself to product customization—because Python code can be changed on the fly, users can modify the Python parts of a system on-site without needing to compile or even possess the rest of the system’s code.</p>
<p>At a more fundamental level, keep in mind that all we really have in Python is <em>runtime</em>—there is no initial compile-time phase at all, and everything happens as the program is running. This even includes operations such as the creation of functions and classes and the linkage of modules. Such events often occur before execution in more static languages, but happen during execution in Python. As you’ll see, this makes for a much more dynamic programming experience than that to which some readers may be accustomed.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="why_does_python_use_bytecodequestion_ma">
<h1>Why Does Python Use Bytecode?</h1>
<p>Given that bytecode generally runs more slowly than machine code, this is a great question. The short answer is that Python <a contenteditable="false" data-type="indexterm" data-primary="bytecode" id="id1530"></a>uses bytecode for the sake of development speed and language <span class="keep-together">flexibility</span>.</p>
<p>In more detail, every program must ultimately run as machine code on the host device’s CPU, but program code is just text written per a language’s rules. Traditional languages like C bridge this gap by constraining code to accommodate the CPU’s expectations and translating the code’s text to machine code ahead of time. This makes programs fast, but translation takes time, and the resulting languages are cumbersome to use.</p>
<p>Python instead defines an easy-to-use language that’s too far removed from machine code for a direct translation and uses the PVM intermediary to run your program’s bytecode on the CPU. This is a classic speed-versus-usability trade-off, but also a false dichotomy: many of the alternative implementations you’ll meet ahead do compile some Python code to machine code, and Python is quick enough for many roles even with its PVM model. For more on this trade-off, see <a data-type="xref" href="ch01.html#okcomma_but_whatapostrophes_the_downsid">“OK, but What’s the Downside?”</a>.</p>
</div></aside>
</div></section>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Execution-Model Variations"><div class="sect1" id="execution_model_variations">
<h1>Execution-Model Variations</h1>
<p>Now that you’ve studied the internal execution flow described in the prior section, you should also know that it reflects just the standard implementation of Python today and is not a requirement of the Python language itself. Because of that, the execution model is prone to change with time. In fact, many systems already modify the picture in <a data-type="xref" href="#pythonapostrophes_traditional_execution">Figure 2-1</a> in one way or another. Before moving on, let’s briefly explore the most prominent of these variations.</p>
<section data-type="sect2" data-pdf-bookmark="Python Implementation Alternatives"><div class="sect2" id="python_implementation_alternatives">
<h2>Python Implementation Alternatives</h2>
<p>As of this writing, there are <a contenteditable="false" data-type="indexterm" data-primary="implementation alternatives" id="ipmltn"></a>multiple implementations of the Python language. Although there is much cross-fertilization of ideas and work between these Pythons, each is a separately installed software system, with its own project and user base. All but one of these systems are optional reading for most Python beginners, but a quick look at the ways they modify the execution model might help demystify what it means to run code in general.</p>
<p>The short story is that <em>CPython</em> is the <a contenteditable="false" data-type="indexterm" data-primary="CPython" id="cpynoth"></a>standard implementation—what we’ve called the “common” version so far. It’s the usual Python on PCs and smartphones, and the system that most readers will be using (and if you’re not sure, this probably includes you). This is also the version used in this book, though the Python language fundamentals presented here apply to all the alternatives too. All the other Python implementations have specific goals and may or may not implement the full Python language defined by CPython, but come close enough to qualify as Pythons.</p>
<p>For example, <em>PyPy</em> is a drop-in <a contenteditable="false" data-type="indexterm" data-primary="PyPy" id="id1531"></a>replacement for CPython that runs many programs quicker by compiling parts of them further as they run. <em>Jython</em> and <em>IronPython</em> instead reimplement CPython to provide access to Java and .NET components; although standard CPython programs can access such components too (e.g., via <em>pyjnius</em> and <em><em>Chaquopy</em></em> for Java), Jython and IronPython aim to be more seamless. Other options accelerate numeric code, or code in general.</p>
<p>In more detail, the following list is a quick rundown on the most prominent Python implementations available today—with the usual apologies to current options omitted for space, and future options omitted for lack of a crystal ball:</p>
<dl>
<dt>CPython: the standard</dt>
<dd>The original, standard, and reference implementation of Python is usually called CPython when you want to contrast it with the other options (and just plain “Python” otherwise). This name comes from the fact that it is coded in portable ANSI C language code. This is the Python that you fetch from <em>python.org</em> for PCs, get with most alternative distributions and Linux repos, and have inside Python apps on Android and iOS smartphones. This is also the flavor whose implementation is captured in <a data-type="xref" href="#pythonapostrophes_traditional_execution">Figure 2-1</a>, though this it prone to change (and in fact may: see <a data-type="xref" href="#future_possibilities">“Future Possibilities”</a>).</dd>
<dt>Jython: Python for Java</dt>
<dd>The Jython system is an alternative <a contenteditable="false" data-type="indexterm" data-primary="Jython" id="id1532"></a><a contenteditable="false" data-type="indexterm" data-primary="JVM (Java Virtual Machine)" data-secondary="Jython" id="id1533"></a>implementation of the Python language. It’s targeted at integration with the Java programming language, much as CPython integrates with C and C++ components. Jython consists of Java classes that compile Python source code to Java bytecode, which is then routed to the Java Virtual Machine (JVM). Programmers still code Python statements in <em>.py</em> text files as usual; the Jython system essentially just replaces the rightmost two bubbles in <a data-type="xref" href="#pythonapostrophes_traditional_execution">Figure 2-1</a> with Java-based equivalents for seamless Java linkage. At this writing, Jython implements the older Python 2.X not used in this book but is working toward 3.X.</dd>
<dt>IronPython: Python for .NET</dt>
<dd>IronPython is another alternative implementation <a contenteditable="false" data-type="indexterm" data-primary="IronPython" id="id1534"></a><a contenteditable="false" data-type="indexterm" data-primary=".NET Framework for Windows, IronPython" data-primary-sortas="NET Framework for Windows" id="id1535"></a>of Python. Coded in C#, it is designed to allow Python programs to integrate with applications written to work with Microsoft’s .NET Framework for Windows, as well as the Mono open source equivalent. Like Jython, IronPython replaces the last two bubbles in <a data-type="xref" href="#pythonapostrophes_traditional_execution">Figure 2-1</a> with equivalents for execution in the .NET environment. With it, Python code can gain accessibility both to and from other .NET languages and leverage .NET libraries.</dd>
<dt>Stackless: Python for concurrency</dt>
<dd>The Stackless Python system is an enhanced <a contenteditable="false" data-type="indexterm" data-primary="Stackless" id="id1536"></a>version of the standard CPython language oriented toward concurrency. Because it does not save state on the C language call stack, Stackless can make Python easier to port to small-stack architectures. Stackless also provides efficient multiprocessing options that some find more straightforward than CPython’s later <code>async</code> coroutines, and fosters novel programming structures. As an example, the game <em>EVE Online</em> uses Stackless Python to achieve high performance for massively parallel tasks.</dd>
<dt>PyPy: a JIT compiler for speed</dt>
<dd>PyPy is a reimplementation of Python for speed. It <a contenteditable="false" data-type="indexterm" data-primary="PyPy" id="id1537"></a><a contenteditable="false" data-type="indexterm" data-primary="JIT compilers" data-secondary="PyPy" id="id1538"></a>was one of the first systems to employ a just-in-time (<em>JIT</em>) compiler for normal Python code. A JIT compiler is just an extension to the PVM—the rightmost bubble in <a data-type="xref" href="#pythonapostrophes_traditional_execution">Figure 2-1</a>—that translates portions of your bytecode all the way to machine code for faster execution. PyPy does this as your program is running, not in a prerun compile step, and is able to create type-specific machine code for the dynamic Python language by keeping track of the data types of the objects your program processes. By replacing portions of your bytecode this way, your program runs faster and faster as it is executing. In addition, some Python programs may also take up less memory under PyPy.</dd>
<dt>Numba: a JIT compiler for numeric speed</dt>
<dd>The Numba extension for Python <a contenteditable="false" data-type="indexterm" data-primary="Numba" id="id1539"></a><a contenteditable="false" data-type="indexterm" data-primary="JIT compilers" data-secondary="Numba" id="id1540"></a>adds a JIT compiler that optimizes numerically oriented code by compiling it all the way to machine code while your program runs. To direct Numba’s compiler, functions are augmented with Python “@” decorators supplied with the Numba install. While not all Python code can be sped up by Numba, it works well for code that uses <em>NumPy</em> arrays and functions, as well as math-oriented loops. Numba also supports code parallelization paradigms commonly used in scientific programming.</dd>
<dt>Shed Skin: an AOT compiler for conforming code</dt>
<dd><p>Shed Skin is an ahead-of-time (<em>AOT</em>) compiler <a contenteditable="false" data-type="indexterm" data-primary="Shed Skin" id="id1541"></a><a contenteditable="false" data-type="indexterm" data-primary="AOT (ahead-of-time) compilers" data-secondary="Shed Skin" id="id1542"></a>that translates unadorned Python code to C++ code, which is then compiled to machine code before it is run. With an AOT, the two rightmost bubbles in <a data-type="xref" href="#pythonapostrophes_traditional_execution">Figure 2-1</a> are replaced with precompiled machine code. Shed Skin can yield both standalone programs and extension modules for use in other programs. In exchange, it implements a restricted subset of Python that requires Python variables to meet an implicit statically typed constraint and does not support some Python features or libraries today. Nevertheless, Shed Skin may outperform both CPython and JIT-based options for some conforming code.</p></dd>
<dt>PyThran: an AOT compiler for numeric speed</dt>
<dd>PyThran implements another AOT compiler <a contenteditable="false" data-type="indexterm" data-primary="PyThran" id="id1543"></a><a contenteditable="false" data-type="indexterm" data-primary="AOT (ahead-of-time) compilers" data-secondary="PyThran" id="id1544"></a>for a subset of the Python language, with a focus on scientific programming. Like Shed Skin, it translates Python code to C++, using static type declarations provided in either formatted comments or separate command files. The result of compiling the generated C++ is a native module that can be imported and used by other Python code.</dd>
<dt>Cython: a Python/C hybrid for speed</dt>
<dd>The Cython system defines a Python/C hybrid <a contenteditable="false" data-type="indexterm" data-primary="Cython" id="id1545"></a>language that combines Python code with the ability to call C functions and use C type declarations for variables, parameters, and class attributes. Cython code can be AOT-compiled to C code that uses the Python/C API, which may then be compiled completely to machine code. Though not compatible with standard Python, Cython can be useful both for wrapping external C libraries and for implementing performance-critical parts of a system as efficient C extensions for use in CPython programs.</dd>
<dt>MicroPython: a Python subset for constraints</dt>
<dd>The MicroPython system is an alternative <a contenteditable="false" data-type="indexterm" data-primary="MicroPython" id="id1546"></a><a contenteditable="false" data-type="indexterm" data-primary="constraints" data-secondary="MicroPython" id="id1547"></a>Python with a focus on efficiency. It implements a limited dialect of the CPython language and a small subset of its standard library, in order to optimize Python to run in constrained environments. Though originally targeted at microcontrollers, MicroPython is also compiled for the <em>WebAssembly</em> system you’ll meet in <a data-type="xref" href="ch03.html#how_you_run_programs">Chapter 3</a>, to support Python programs in web browsers without the full heft of CPython.</dd>
<dt>And (naturally) more</dt>
<dd>For other Python alternatives, see the list at <a href="https://wiki.python.org/moin/PythonImplementations">Python’s wiki</a>, as well as the results of a web search. Among the others, <em>Cinder</em> is a <a contenteditable="false" data-type="indexterm" data-primary="Cinder" id="id1548"></a><a contenteditable="false" data-type="indexterm" data-primary="Pyston" id="id1549"></a><a contenteditable="false" data-type="indexterm" data-primary="Nuitka" id="id1550"></a>performance-focused implementation of CPython with a JIT compiler and more, created by Meta and used for Instagram; <em>Pyston</em> is a fork of CPython with a JIT compiler and other optimizations, started by Dropbox; and <em>Nuitka</em> is a free and paid optimizing AOT compiler that translates standard Python code to C, and is used by the emerging <em>py2wasm</em> to translate Python code to <em>WebAssembly</em> for use in browsers.</dd>
</dl>
<p>All that being said, unless you have a specific need met only by one of the alternatives, you’ll probably want to use the standard CPython system. Because it is the reference implementation of the <a contenteditable="false" data-type="indexterm" data-primary="CPython" data-startref="cpynoth" id="id1551"></a>language, it’s always the most complete, and also tends to be more up-to-date and robust than others. Still, it’s unlikely that CPython will ever subsume all the optimization projects afoot in the Python world, so be sure to vet <a contenteditable="false" data-type="indexterm" data-primary="implementation alternatives" data-startref="ipmltn" id="id1552"></a>the alternatives when your goals gel.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Standalone Executables"><div class="sect2" id="standalone_executables">
<h2>Standalone Executables</h2>
<p>Sometimes when people ask for a “real” Python compiler, what they’re actually seeking is simply a way to generate <a contenteditable="false" data-type="indexterm" data-primary="standalone executables" id="id1553"></a><a contenteditable="false" data-type="indexterm" data-primary="executables, standalone" id="id1554"></a>standalone executables from their Python programs. This is more a packaging and shipping topic than an execution-flow concept—and of more interest to software developers than Python beginners—but it’s a related idea.</p>
<p>In short, with the help of third-party tools that you can fetch off the web, it is possible to turn your Python programs into true self-contained executables, sometimes also called <em>frozen binaries</em> in <a contenteditable="false" data-type="indexterm" data-primary="frozen binaries" id="id1555"></a>the Python world. Whatever they’re called, these programs can be run without requiring a Python installation or shipping your source code files.</p>
<p>Standalone executables bundle together the bytecode of your program files, along with the PVM (interpreter) and any Python support files and libraries your program needs, into a single package. There are some variations on this theme, but the end result can be a single <em>executable</em> (e.g., a <em>.exe</em> file on Windows) or <em>app</em> (e.g., a <em>.app</em> on macOS, and <em>.apk</em> or <em>.aab</em> on Android) that can easily be shipped to customers. In <a data-type="xref" href="#pythonapostrophes_traditional_execution">Figure 2-1</a>, it is as though the two rightmost bubbles—bytecode and PVM—are merged into a single component: a standalone executable bundle.</p>
<p>Today, a variety of systems are capable of generating standalone executables and vary in platforms and features. For example, <em>py2exe</em> builds standalones for Windows; <em>PyInstaller</em> and <em>cx_freeze</em> make them for Windows, macOS, and Linux; <em>py2app</em> creates them for macOS; and <em>Buildozer</em> and <em>Briefcase</em> generate apps for Android and iOS.</p>
<p>Frozen binaries are not the same as the output of a true compiler—they run bytecode through a virtual machine. Hence, apart from a possible startup improvement, frozen binaries run at the same speed as the original source files. Frozen binaries are also not generally small (they contain a PVM), but by current standards they are not unusually large either. Because Python is embedded in the frozen bundle, though, it does not have to be installed on the receiving end to run your program. Moreover, because your bytecode is embedded in the bundle, it isn’t as easily viewed.</p>
<p>For more details, see the alternative coverage of standalones in this book’s <a data-type="xref" href="app01.html#appendix_a_platform_usage_tips">Appendix A</a>, which includes tips on building them on multiple platforms from the same code base.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Future Possibilities"><div class="sect2" id="future_possibilities">
<h2>Future Possibilities</h2>
<p>Finally, note that the runtime execution model sketched here is really an artifact of the current implementation of Python, not of the language itself. For instance, it’s possible that an AOT compiler for translating unrestricted and unadorned Python source code to machine code may appear during the shelf life of this book (although the fact that one has not in over three decades makes this seem unlikely!), and JIT compilers seem to be cropping up everywhere.</p>
<p>Either way, the bytecode model will likely be standard for some time to come. The portability and flexibility of bytecode are important features of many Python systems. Moreover, adding type-constraint declarations to support static compilation would break much of the flexibility, conciseness, simplicity, and spirit of Python coding we’re about to explore. Python’s type hinting, also covered later, comes close, but is thankfully still unused by Python itself today.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><em>JIT futurism</em>: While <em>CPython</em> currently follows the bytecode/PVM model in <a data-type="xref" href="#pythonapostrophes_traditional_execution">Figure 2-1</a>, it may augment it in the future. Version 3.13, still under development as this is being written, will add an experimental JIT compiler. As in <em>PyPy</em> and others, this will translate some bytecode all the way to machine code as your program is running. In 3.13 it will have a negligible speed boost and will be disabled by default. Though prescience is perilous in publishing, the JIT compiler may be enabled by default for CPython in the future if it ever yields a significant net gain for Python programs.</p>
</div>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Chapter Summary"><div class="sect1" id="chapter_summary-id00011">
<h1>Chapter Summary</h1>
<p>This chapter introduced the execution model of Python—how Python runs your programs—and explored some common variations on that model designed for both different roles and better performance. Although you don’t really need to come to grips with Python internals to write Python scripts, a passing acquaintance with this chapter’s topics will help you truly understand how your programs run once you start coding them, as you will in the next chapter. First though, here’s the usual chapter quiz to review what you’ve learned so far.</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Test Your Knowledge: Quiz"><div class="sect1" id="test_your_knowledge_quiz-id000111">
<h1>Test Your Knowledge: Quiz</h1>
<ol>
<li><p>What is the Python interpreter?</p></li>
<li><p>What is source code?</p></li>
<li><p>What is bytecode?</p></li>
<li><p>What is the PVM?</p></li>
<li><p>What is machine code?</p></li>
<li><p>Name two or more variations on Python’s standard execution model.</p></li>
<li><p>How are CPython, Jython, and IronPython different?</p></li>
<li><p>What are PyPy, Shed Skin, and Cython?</p></li>
</ol>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Test Your Knowledge: Answers"><div class="sect1" id="test_your_knowledge_answers-id000110">
<h1>Test Your Knowledge: Answers</h1>
<ol>
<li><p>The Python interpreter is a program that <a contenteditable="false" data-type="indexterm" data-primary="interpreter" id="id1556"></a>runs the Python programs you write. It essentially intermediates between your Python instructions and those available in a CPU’s machine code.</p></li>
<li><p>Source code is the statements you write for your program. It consists of text in text files whose names normally end with a <em>.py</em> extension.</p></li>
<li><p>Bytecode is the lower-level form of your <a contenteditable="false" data-type="indexterm" data-primary="bytecode" id="id1557"></a>program after Python compiles it. Python automatically stores bytecode in files with a <em>.pyc</em> extension when possible, and automatically re-creates it when needed.</p></li>
<li><p>The PVM is the Python Virtual Machine—the runtime <a contenteditable="false" data-type="indexterm" data-primary="PVM (Python Virtual Machine)" id="id1558"></a><a contenteditable="false" data-type="indexterm" data-primary="Python Virtual Machine" id="id1559"></a>engine of Python that interprets your compiled bytecode.</p></li>
<li><p>Machine code is the low-level instructions <a contenteditable="false" data-type="indexterm" data-primary="machine code" id="id1560"></a>of the underlying CPU on a computing device like a PC or phone. Because this is what every program ultimately runs, Python code must be translated to this by a software layer like the PVM interpreter, or JIT or AOT compilers.</p></li>
<li><p>Numba, Shed Skin, and standalone <a contenteditable="false" data-type="indexterm" data-primary="Numba" id="id1561"></a><a contenteditable="false" data-type="indexterm" data-primary="Shed Skin" id="id1562"></a>executables are all variations on the execution model. In addition, the alternative implementations of Python named in the next two answers modify the model in some fashion as well—by replacing bytecode and VMs, or by adding JIT and AOT compilers.</p></li>
<li><p>CPython is the standard and <a contenteditable="false" data-type="indexterm" data-primary="CPython" id="id1563"></a>reference implementation of the language. Jython and IronPython process Python programs for use in Java and .NET environments, respectively; they are alternative compilers for Python.</p></li>
<li><p>PyPy and Shed Skin are <a contenteditable="false" data-type="indexterm" data-primary="PyPy" id="id1564"></a>reimplementations of Python targeted at speed. PyPy speeds normal Python programs by using runtime type information and a JIT compiler to replace some Python bytecode with machine code as the program runs. Shed Skin speeds programs with an AOT compiler that translates a restricted subset of Python to C++, from which it can be fully compiled to machine code to be run as a program or used in others. Cython <a contenteditable="false" data-type="indexterm" data-primary="Cython" id="id1565"></a>is a Python/C combination that can be compiled into machine-code extensions accessible to CPython code.</p></li>
</ol>
</div></section>
</div></section></div>
</div>
</body>
</html>