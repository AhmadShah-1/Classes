<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xml:lang="en"
lang="en"
xmlns="http://www.w3.org/1999/xhtml"
xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<title>Learning Python, 6th Edition</title>
<link rel="stylesheet" type="text/css" href="override_v1.css"/>
<link rel="stylesheet" type="text/css" href="epub.css"/>
</head>
<body>
<div id="book-content">
<div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 34. Exception Coding Details"><div class="chapter" id="exception_coding_details">
<h1><span class="label">Chapter 34. </span>Exception Coding Details</h1>
<p>The prior chapter provided a quick look at exception-related statements in action. Here, we’re going to dig a bit deeper—this chapter provides fuller coverage of exception-processing syntax in Python. Specifically, we’ll explore the details behind the <code>try</code>, <code>raise</code>, <code>assert</code>, and <code>with</code> statements. Although these statements are mostly straightforward, you’ll find that they offer powerful tools for dealing with exceptional conditions in Python code.</p>
<section data-type="sect1" data-pdf-bookmark="The try Statement"><div class="sect1" id="the_try_statement">
<h1>The try Statement</h1>
<p>First up, the <code>try</code> statement is how <a contenteditable="false" data-type="indexterm" data-primary="exceptions" data-secondary="try statement" data-seealso="try statement" id="exprytt"></a><a contenteditable="false" data-type="indexterm" data-primary="try statement" data-secondary="handlers" id="id4376"></a>your code catches exceptions. In short, if an exception occurs while running this statement’s main block, the program jumps back to run one of the statement’s <em>handlers</em> and continues from there. Its handlers may be specified by <code>except</code>, <code>else</code>, <code>finally</code>, and <code>except*</code> <em>clauses</em> nested in the <code>try</code>, and separate rules apply to these clauses’ syntax, and their valid combinations.</p>
<p>This is a simple model on the surface, but the <code>try</code> statement’s handler clauses have disjoint purposes, and its rules for valid combinations mean that it comes in distinct flavors. Because of this, we’ll approach this subject by exploring the <code>try</code>’s common roles in isolation first and putting their pieces together later as a combined statement. This parallels the fact that <code>try</code> really <em>was</em> separate statements in Python’s dim past, but our focus here is on its unified present.</p>
<p>Although technically part of the <code>try</code>, we’ll also defer the <code>except*</code> clause until the next chapter, partly because it encroaches on that chapter’s exception-<em>object</em> topic, but mostly because this is a tool that complicates the <code>try</code> story substantially for an extension that’s rarely useful in practice. Our priority here is learning the fundamentals.</p>
<section data-type="sect2" data-pdf-bookmark="try Statement Clauses"><div class="sect2" id="try_statement_clauses">
<h2>try Statement Clauses</h2>
<p>When you write a <code>try</code> statement, a variety of clauses can appear after and below the <code>try</code> header. <a data-type="xref" href="#try_statement_clauses_and_forms">Table 34-1</a> summarizes all the possible forms as both reference and preview. We’ve already seen that <code>except</code> clauses catch exceptions and <code>finally</code> clauses run on the way out. New here, <code>else</code> clauses run if no exceptions are encountered, and <code>except*</code> clauses process exception groups and support all <code>except</code> forms except the empty.</p>
<p>Formally, a <code>try</code> must use at least one of the clauses in <a data-type="xref" href="#try_statement_clauses_and_forms">Table 34-1</a>. There may be any number of <code>except</code> clauses, but you can code <code>else</code> only if there is at least one <code>except</code>, and there can be only one <code>else</code> and one <code>finally</code>. A <code>finally</code> can appear in the same <a contenteditable="false" data-type="indexterm" data-primary="try statement" data-secondary="forms" id="id4377"></a>statement as <code>except</code> and <code>else</code>, with ordering rules given later in this chapter.</p>
<table class="border" id="try_statement_clauses_and_forms">
<caption><span class="label">Table 34-1. </span><code>try</code> statement clauses and forms</caption>
<thead>
<tr>
<th>Clause form</th>
<th>Interpretation</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>except:</code></td>
<td>Catch all (or all other) exception types</td>
</tr>
<tr>
<td><code>except <code><em>name</em></code>:</code></td>
<td>Catch a specific exception only</td>
</tr>
<tr>
<td><code>except <code><em>name</em></code> as <code><em>var</em></code>:</code></td>
<td>Catch the listed exception and assign its instance</td>
</tr>
<tr>
<td><code>except (<code><em>name1</em></code>, <code><em>name2</em></code>):</code></td>
<td>Catch any of the exceptions listed in a tuple</td>
</tr>
<tr>
<td><code>except (<code><em>name1</em></code>, <code><em>name2</em></code>) as <code><em>var</em></code>:</code></td>
<td>Catch any listed exception and assign its instance</td>
</tr>
<tr>
<td><code>else:</code></td>
<td>Run if no exceptions are raised in the <code>try</code> block</td>
</tr>
<tr>
<td><code>finally:</code></td>
<td>Always perform this block on exit, exception or not</td>
</tr>
<tr>
<td><code>except* …<code><em>nonempty except forms</em></code>…:</code></td>
<td>Catch multiple exceptions in a group (<a data-type="xref" href="ch35.html#exception_objects">Chapter 35</a>)</td>
</tr>
</tbody>
</table>
<p>We’ll explore the <code>as <em>var</em></code> part available in some of <a data-type="xref" href="#try_statement_clauses_and_forms">Table 34-1</a>’s clauses in more detail when we meet the <code>raise</code> statement later in this chapter because it provides access to the object raised as an exception via <code>var</code>. Before all that, let’s get started by examining the more common clauses of <a data-type="xref" href="#try_statement_clauses_and_forms">Table 34-1</a> more closely.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="The except and else Clauses"><div class="sect2" id="the_except_and_else_clauses">
<h2>The except and else Clauses</h2>
<p>Syntactically, the <code>try</code> is a <a contenteditable="false" data-type="indexterm" data-primary="try statement" data-secondary="except clause" id="trysxp"></a><a contenteditable="false" data-type="indexterm" data-primary="try statement" data-secondary="else clause" id="rytesc"></a>compound, multipart statement. It starts with a <code>try</code> header line, followed by a block of (usually) indented statements, which is followed by clauses that each identify a condition to be handled and give a block of statements to handle it. In its most common form, <code>try</code> is coded with one or more <code>except</code> clauses and an optional <code>else</code> clause at the end. You associate the words <code>try</code>, <code>except</code>, and <code>else</code> by indenting them to the same level (i.e., lining them up vertically), like this:</p>
<pre data-type="programlisting">try:
    <code><em>statements</em></code>              <code><em># Run this main action first</em></code>
except <code><em>name1</em></code>:
    <code><em>statements</em></code>              <code><em># Run if name1 is raised during the try block</em></code>
except (<code><em>name2</em></code>, <code><em>name3</em></code>):
    <code><em>statements</em></code>              <code><em># Run if name2 or name3 occur in the try</em></code>
except <code><em>name4</em></code> as <code><em>var</em></code>:
    <code><em>statements</em></code>              <code><em># Run if name4 is raised, and assign it to var</em></code>
except:
    <code><em>statements</em></code>              <code><em># Run for all other exceptions raised</em></code>
else:
    <code><em>statements</em></code>              <code><em># Run if no exception was raised in the try block</em></code></pre>
<p>Semantically, the block under the <code>try</code> header in this statement represents the <em>main action</em> of the statement—the code you’re trying to run, and wrapping in exception handlers. The rest of the statement defines the handlers themselves: <code>except</code> clauses give handlers for exceptions raised during the <code>try</code> block, and the optional <code>else</code> clause gives a handler run if <em>no</em> exceptions occur in the <code>try</code> block.</p>
<p>Within a <code>try</code>, each <code>except</code> names exceptions to catch: a <em>single</em> exception catches just that exception, a tuple catches <em>any</em> exception in the tuple, and an <code>except</code> that omits the exception altogether matches <em>all</em> (or all <em>other</em>) exceptions. Each nonempty <code>except</code> can also give a variable name after <code>as</code> to be assigned the exception object raised by Python or <code>raise</code> statements; again, we’ll explore this option ahead.</p>
<section data-type="sect3" data-pdf-bookmark="How try statements work"><div class="sect3" id="how_try_statements_work">
<h3>How try statements work</h3>
<p>Operationally, here’s how <code>try</code> statements are run. When a <code>try</code> statement is entered, Python records the current program context so it can return to it if an exception occurs. The statements nested under the <code>try</code> header are run first. What happens next depends on whether an exception is raised while the <code>try</code> block’s statements are running, and whether a raised exception matches any of those that the <code>try</code> is watching for:</p>
<dl>
<dt>Exception and match</dt>
<dd>If an exception occurs while the <code>try</code> block’s statements are running, and the exception <em>matches</em> one that the statement names, Python jumps back to the <code>try</code> and runs the statements under its topmost <code>except</code> clause that matches the raised exception, after assigning the raised exception object to the variable named by <code>as</code> in the clause (if present). After the <code>except</code> block runs, control resumes below the entire <code>try</code> statement. If the <code>except</code> block itself raises another exception, the propagation process is started anew from this point in the code.</dd>
<dt>Exception and no match</dt>
<dd>If an exception occurs while the <code>try</code> block’s statements are running, but the exception <em>does not</em> match one that the statement names, the exception is propagated up to the next most recently entered <code>try</code> statement that matches the exception; if no such matching <code>try</code> statement can be found and the search reaches the top level of the program, Python prints a default error message and terminates the program (unless it’s the REPL).</dd>
<dt>No exception</dt>
<dd>If an exception does <em>not</em> occur while the <code>try</code> block’s statements are running, Python runs the statements under the <code>else</code> clause (if present), and control then resumes below the entire <code>try</code> statement. If the <code>else</code> block itself raises another exception, it kicks off the propagation process again.</dd>
</dl>
<p>In sum, <code>except</code> clauses catch any matching exceptions that happen while the <code>try</code> block is running, and the <code>else</code> clause runs only if no exceptions happen while the <code>try</code> block runs. Exceptions raised are <em>matched</em> to exceptions named in <code>except</code> clauses by <em>class</em> relationships we’ll explore both ahead and in the next chapter (brief: a subclass matches its superclass), and the <em>empty</em> <code>except</code> clause with no exception name matches any exception.</p>
<p>In effect, <code>except</code> clauses are <em>focused</em> exception handlers—they catch exceptions that occur only within the statements in the associated <code>try</code> block. However, as the <code>try</code> block’s statements can call functions coded elsewhere in a program, the source of an exception may very well be outside the code of the <code>try</code> statement itself.</p>
<p>In fact, a <code>try</code> block might invoke arbitrarily large amounts of program code—including code that may have <code>try</code> statements of its own, which will be searched first when exceptions occur. In other words, because <code>try</code> statements can nest at runtime, where an exception goes depends on the code run before it, a phenomenon we’ll explore in <a data-type="xref" href="ch36.html#exception_odds_and_ends">Chapter 36</a>.</p>
<p>If a <code>finally</code> clause is added to a <code>try</code>, its code block is run for all three of the cases listed previously, as you’ll see ahead. First, though, let’s take a look at some common variations of exception-catching <span class="keep-together">clauses</span>.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Catching many exceptions with a tuple"><div class="sect3" id="catching_many_exceptions_with_a_tuple">
<h3>Catching many exceptions with a tuple</h3>
<p>Per the fourth and fifth entries in <a data-type="xref" href="#try_statement_clauses_and_forms">Table 34-1</a>, <code>except</code> clauses that list <em>many</em> exceptions <a contenteditable="false" data-type="indexterm" data-primary="try statement" data-secondary="tuples" id="id4378"></a><a contenteditable="false" data-type="indexterm" data-primary="exceptions" data-secondary="tuples" id="id4379"></a><a contenteditable="false" data-type="indexterm" data-primary="tuples" data-secondary="try statement" id="id4380"></a>in a parenthesized tuple catch <em>any</em> of the listed exceptions. Because Python looks for a match within a given <code>try</code> by inspecting the <code>except</code> clauses from <em>top to bottom</em>, the tuple version has the same effect as listing each exception in its own <code>except</code> clause, but you have to code the common statement body associated with each only once.</p>
<p>Here’s a partial example of multiple <code>except</code> clauses at work, which demos just how specific your handlers can be:</p>
<pre data-type="programlisting">try:
    …
except NameError:
    …
except IndexError:
    …
except (AttributeError, TypeError, SyntaxError):
    …</pre>
<p>If an exception is raised while this <code>try</code> block is running, Python returns to the <code>try</code> and searches for the first <code>except</code> that names the exception raised. It inspects clauses from top to bottom—and left to right along the way—and runs the statements under the first clause that matches. If none match, the exception is propagated past this <code>try</code>.</p>
<p>Note that <em>parentheses</em> are required around the tuple in the “any” form, and using an <code>as</code> in this form lets you check which exception occurred when you listed many:</p>
<pre data-type="programlisting">try:
    …
except (AttributeError, TypeError, SyntaxError) as What:
    …<code><em>and check What</em></code>…</pre>
<p>To learn more about both <code>as</code>, as well as what happens when no <code>except</code> matches, we must move on.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Catching all exceptions with empties and Exception"><div class="sect3" id="catching_all_exceptions_with_empties_an">
<h3>Catching all exceptions with empties and Exception</h3>
<p>Per the first entry in <a data-type="xref" href="#try_statement_clauses_and_forms">Table 34-1</a>, <code>except</code> clauses that list <em>no</em> exception name catch <em>all</em> exceptions not previously listed in the <code>try</code> statement. That is, if you want to code a general “catchall” handler to be run when no other <code>except</code> clause matches the exception raised, an empty <code>except</code> does the trick:</p>
<pre data-type="programlisting">try:
    …
except NameError:
    …                   <code><em># Handle NameError</em></code>
except IndexError:
    …                   <code><em># Handle IndexError</em></code>
except:
    …                   <code><em># Handle all other exceptions</em></code>
else:
    …                   <code><em># Handle the no-exception case (preview)</em></code></pre>
<p>The empty <code>except</code> clause is a sort of <em>wildcard</em> feature—because it catches everything, adding it to the mix allows your handlers to be as general or specific as you like. In some scenarios, this form may be more convenient than listing all possible exceptions in a <code>try</code>—especially when working interactively in a REPL, or writing code that must recover no matter what occurs. For example, the following catches <em>everything</em> by not listing anything:</p>
<pre data-type="programlisting">try:
    …
except:
    …                   <code><em># Catch all possible exceptions</em></code></pre>
<p>That being shown, the empty <code>except</code> can also cause problems. It may catch <em>unexpected</em> exceptions, and <a contenteditable="false" data-type="indexterm" data-primary="exceptions" data-secondary="unexpected" id="id4381"></a>intercept events unrelated to your code and <em>required</em> by another handler. For example, even <em>system exit</em> calls and Ctrl+C key-combination interrupts in Python work by triggering exceptions, and you usually want these to pass.</p>
<p>Perhaps worse, the empty <code>except</code> may also catch genuine <em>programming mistakes</em> for which you probably want to see an error message. Otherwise, you may not even know that a bug exists until it’s too late to avoid a user’s report. We’ll revisit this as a gotcha at the end of this part of the book. For now, the standard “use with care” applies.</p>
<p>Python provides an alternative that solves at least one of these problems—catching the built-in <span class="keep-together"><code>Exception</code></span> has almost the same effect as an empty <code>except</code>, but won’t catch exceptions related to system exits and Ctrl+C:</p>
<pre data-type="programlisting">try:
    …
except Exception:
    …                   <code><em># Catch all possible exceptions - except exits</em></code></pre>
<p>We’ll explore how this form does its magic formally in the next chapter when we study exception classes. In short, it works because exceptions match if they are a <em>subclass</em> of one named in an <code>except</code> clause, and <code>Exception</code> is a superclass of all the exceptions you should generally catch this way. This form has most of the same convenience of the empty <code>except</code> without the risk of catching exit events and also allows you to check the exception raised via <code>as</code>. While better, though, it also has some of the same risks—it may still mask and silently ignore programming errors.</p>
<p>The opening snippet of this section deliberately listed an <code>else</code> clause, to call out that it is <em>not</em> a catchall like the empty <code>except</code>—an understandable source of confusion for <code>try</code> newcomers. The next section dissects the difference.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Catching the no-exception case with else"><div class="sect3" id="catching_the_no_exception_case_with_els">
<h3>Catching the no-exception case with else</h3>
<p>All told, <code>else</code> can be used in <em>three</em> places in Python: in <code>if</code> selections, <code>for</code> and <code>while</code> loops, and <code>try</code> exception handlers. In the <a contenteditable="false" data-type="indexterm" data-primary="exceptions" data-secondary="no exception case" id="id4382"></a>latter, <code>else</code> is run when <em>no</em> exception occurs—not for <em>unmatched</em> exceptions (that’s what the prior section’s empty <code>except</code> is for). This <code>else</code> role may seem different than in <code>if</code> and loops, but this context differs.</p>
<p>The need for an <code>else</code> clause in <code>try</code> is not always obvious to Python beginners. Without it, though, there is no direct way to tell whether the flow of control has proceeded past a <code>try</code> statement because no exception was raised, or because an exception occurred and was handled. Either way, we wind up after the <code>try</code>:</p>
<pre data-type="programlisting">try:
    …<code><em>run code</em></code>…
except IndexError:
    …<code><em>handle exception</em></code>…
<code><em># Did we get here because the try failed or not?</em></code></pre>
<p>Of course, we could initialize, set, and check a Boolean flag to know what happened, which adds lines of admin code. Much like the way <code>else</code> clauses in loops make the exit cause more apparent (for exits sans <code>break</code>), the <code>else</code> clause provides syntax in <code>try</code> that makes the outcome unambiguous with minimal extra code:</p>
<pre class="pagebreak-before" data-type="programlisting">try:
    …<code><em>run code</em></code>…
except IndexError:
    …<code><em>handle exception</em></code>…
else:
    …<code><em>no exception occurred</em></code>…</pre>
<p>You can <em>almost</em> emulate an <code>else</code> clause by moving its code into the <code>try</code> block:</p>
<pre data-type="programlisting">try:
    …<code><em>run code</em></code>…
    …<code><em>no exception occurred</em></code>…
except IndexError:
    …<code><em>handle exception</em></code>…</pre>
<p>This can lead to incorrect exception classifications, though. If the “no exception occurred” action itself causes an <code>IndexError</code>, it will register as a failure of the <code>try</code> block and erroneously trigger the exception handler below the <code>try</code> (unlikely perhaps, but true). By using an explicit <code>else</code> clause instead, you make the logic more obvious and guarantee that <code>except</code> handlers will run only for real failures in the code you’re wrapping in a <code>try</code>, not for failures in the <code>else</code> no-exception case’s action.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Example: Default behavior"><div class="sect3" id="example_default_behavior">
<h3>Example: Default behavior</h3>
<p>Because the control flow through a program may <a contenteditable="false" data-type="indexterm" data-primary="exceptions" data-secondary="default behaviors" id="id4383"></a><a contenteditable="false" data-type="indexterm" data-primary="try statement" data-secondary="default exception behavior" id="id4384"></a>be easier to capture in Python than in English, let’s run some simple examples that further illustrate exception basics with real code in files.</p>
<p>As noted, exceptions not caught by <code>try</code> statements percolate up to the top level of the Python process and run Python’s default exception-handling logic (i.e., Python terminates the running program and prints a standard error message). To illustrate, module file <em>crashware.py</em> coded in <a data-type="xref" href="#example_threefour_onedot_crashwaredotpy">Example 34-1</a> generates a divide-by-zero exception—by design.</p>
<div data-type="example" id="example_threefour_onedot_crashwaredotpy">
<h5><span class="label">Example 34-1. </span>crashware.py</h5>
<pre data-type="programlisting">def gobad(x, y):
    return x / y

def gosouth(x):
    print(gobad(x, 0))

if __name__ == '__main__': gosouth(1)</pre>
</div>
<p>Because the program ignores the exception it triggers, Python kills the program and prints a message (edited here to condense paths and drop some interfaces’ code-pointer lines for space):</p>
<pre data-type="programlisting">$ <code><strong>python3 crashware.py</strong></code>
Traceback (most recent call last):
  File "/…/LP6E/Chapter34/crashware.py", line 7, in &lt;module&gt;
    if __name__ == '__main__': gosouth(1)
  File "/…/LP6E/Chapter34/crashware.py", line 5, in gosouth
    print(gobad(x, 0))
  File "/…/LP6E/Chapter34/crashware.py", line 2, in gobad
    return x / y
ZeroDivisionError: division by zero</pre>
<p>This message consists of a stack trace (“Traceback”) and the name of and details about the exception that was raised. The stack trace lists all lines active when the exception occurred, from oldest to newest. Note that because this code was written in a file instead of a REPL, the file and line-number <span class="keep-together">information</span> is more useful here. For example, we can see that the bad divide happens at the last entry in the trace—line 2 of the file <em>crashware.py</em>, a <code>return</code> statement.</p>
<p>Because Python detects and reports all errors at runtime by raising exceptions like this, exceptions are intimately bound up with the ideas of <em>error handling</em> and <em>debugging</em> in general. If you’ve worked through this book’s examples, you’ve undoubtedly seen an exception or two along the way—even typos usually generate a <code>SyntaxError</code> or other exception when a file is imported or executed (that’s when the code compiler is run).</p>
<p>By default, programming errors generate a useful error display like the one just shown, which helps you track down the problem. In some interfaces, this message today even comes with pointers to offending expressions, as well as speculative but mandatory “Did you?” tips (whose merit you may wish to reweigh later in your Python career):</p>
<pre data-type="programlisting">$ <code><strong>python3</strong></code>
&gt;&gt;&gt; <code><strong>import crashware</strong></code>
&gt;&gt;&gt; <code><strong>crashware.gobad(1, 0)</strong></code>
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/…/LP6E/Chapter34/crashware.py", line 2, in gobad
    return x / y
           ~~^~~
ZeroDivisionError: division by zero</pre>
<p>Often, this standard error message is all you need to resolve problems in your code. For more heavy-duty debugging jobs, you can catch exceptions with <code>try</code> statements, or use debugging tools introduced in <a data-type="xref" href="ch03.html#how_you_run_programs">Chapter 3</a>, such as the <code>pdb</code> standard-library module. See <a data-type="xref" href="ch03.html#debugging_python_code">“Debugging Python Code”</a> for more related tips.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Example: Catching built-in exceptions"><div class="sect3" id="example_catching_built_in_exceptions">
<h3>Example: Catching built-in exceptions</h3>
<p>Python’s error checking and default exception <a contenteditable="false" data-type="indexterm" data-primary="exceptions" data-secondary="built-in" data-tertiary="catching" id="id4385"></a><a contenteditable="false" data-type="indexterm" data-primary="try statement" data-secondary="built-in exceptions" id="id4386"></a>handling is often exactly what you want: especially for code in a top-level script file, an error often <em>should</em> terminate your program immediately. For many programs, there is no need to be more specific about errors in your code.</p>
<p>Sometimes, though, you’ll want to catch errors and recover from them instead. If you don’t want your program terminated when Python raises an exception, simply catch it by wrapping the program logic in a <code>try</code>. This is an important capability for programs such as network servers, which must keep running persistently. For example, the code in <a data-type="xref" href="#example_threefour_twodot_kaboomdotpy">Example 34-2</a>, file <em>kaboom.py</em>, catches and recovers from the <code>TypeError</code> Python raises immediately when you try to concatenate a list and a string (remember, the <code>+</code> operator expects the same sequence type on both sides).</p>
<div data-type="example" id="example_threefour_twodot_kaboomdotpy">
<h5><span class="label">Example 34-2. </span>kaboom.py</h5>
<pre data-type="programlisting">def kaboom(x, y):
    print(x + y)                        <code><em># Trigger TypeError</em></code>

def serve(n=2):                         <code><em># Simulate long-running task</em></code>
    for i in range(n):
        try:
            kaboom([1, 2], 'hack')
        except TypeError:               <code><em># Catch and recover here</em></code>
            print('Hello world!')
        print('Resuming here...')       <code><em># Continue here if exception or not</em></code>

if __name__ == '__main__': serve()</pre>
</div>
<p>When the exception occurs in the function <code>kaboom</code>, control jumps to the <code>try</code> statement’s <code>except</code> clause, which prints a message. Since an exception is “dead” after it’s been caught like this, the program continues executing below the <code>try</code> rather than being terminated by Python. In effect, the code processes and clears the error, and your script recovers:</p>
<pre data-type="programlisting">$ <code><strong>python3 kaboom.py</strong></code>
Hello world!
Resuming here...
Hello world!
Resuming here...</pre>
<p>Keep in mind that once you’ve caught an error, control resumes at the place where you caught it (i.e., after the <code>try</code>); there is no direct way to go back to the place where the exception occurred (here, in the function <code>kaboom</code>). This makes exceptions more <a contenteditable="false" data-type="indexterm" data-primary="try statement" data-secondary="except clause" data-startref="trysxp" id="id4387"></a><a contenteditable="false" data-type="indexterm" data-primary="try statement" data-secondary="else clause" data-startref="rytesc" id="id4388"></a>like simple <em>jumps</em> than function calls—there is no way to “return” to the scene of the crime.</p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="The finally Clause"><div class="sect2" id="the_finally_clause">
<h2>The finally Clause</h2>
<p>The other main flavor of the <code>try</code> statement <a contenteditable="false" data-type="indexterm" data-primary="try statement" data-secondary="finally clause" id="tyttmnfy"></a><a contenteditable="false" data-type="indexterm" data-primary="finalization" data-see="termination actions" id="id4389"></a>is for coding <em>finalization</em> (a.k.a. termination) actions and is really related to exceptions only incidentally. If a <code>finally</code> clause is included in a <code>try</code>, Python will always run its block of statements “on the way out” of the <code>try</code> statement—whether an exception occurred while the <code>try</code> block was running or not. That is, this clause doesn’t <em>catch</em> exceptions, it works around them.</p>
<p>When used in isolation, this flavor’s general form is this:</p>
<pre data-type="programlisting">try:
    <code><em>statements</em></code>           <code><em># Run this action first</em></code>
finally:
    <code><em>statements</em></code>           <code><em># Always run this code on the way out</em></code></pre>
<p>When a <code>finally</code> appears in <code>try</code>, Python begins by running the statement block associated with the <code>try</code> header line as usual. What happens next depends on whether an exception occurs during the <code>try</code> block, and what other clauses are present:</p>
<dl>
<dt>Exception and match</dt>
<dd>If an exception occurs during the <code>try</code> block’s run and is matched by an <code>except</code> clause, Python first runs the matching <code>except</code> block and then runs the <code>finally</code> block. After both finish, the program then resumes below the entire <code>try</code> statement. The <code>finally</code> is also run if the <code>except</code> raises a new exception.</dd>
<dt>Exception and no match</dt>
<dd>If an exception occurs during the <code>try</code> block’s run but is <em>not</em> caught by an <code>except</code>, Python still comes back and runs the <code>finally</code> block, but it then propagates the exception up to a previously entered <code>try</code> or the top-level default handler. That is, <code>finally</code> is run even if an exception is raised and uncaught, but unlike an <code>except</code>, the <code>finally</code> does not terminate the exception—it continues being raised after the <code>finally</code> block runs.</dd>
<dt>No exception</dt>
<dd>If an exception does <em>not</em> occur while the <code>try</code> block is running, Python first runs the <code>else</code> block (if present) and then runs the <code>finally</code> block. After both finish, the program then resumes below the entire <code>try</code> statement. The <code>finally</code> is also run if the <code>else</code> raises a new exception.</dd>
</dl>
<p>The <code>try</code>/<code>finally</code> form is useful when you want to be completely sure that an action will happen after some code runs, regardless of the exception behavior of the code. In practice, it allows you to specify cleanup actions that always must occur, such as file closes and server disconnects where required.</p>
<p>Technically speaking, <code>finally</code> can appear in the same statement as <code>except</code> and <code>else</code>, so there is really a single <code>try</code> statement with many optional clauses. Because of its distinct role, though, as well as its ordering rules we will meet in a moment, the <code>finally</code> clause may be best thought of as a distinct tool. Whether mixed or not, <code>finally</code> serves the same purpose—to specify cleanup actions that must always be run, regardless of any exceptions.</p>
<p>As you’ll also see later in this chapter, the <code>with</code> statement and its context managers provide an object-based way to do similar work for exit actions. Unlike <code>finally</code>, this statement also supports entry actions, but it is limited in scope to objects that implement the context-manager protocol it employs.</p>
<section data-type="sect3" data-pdf-bookmark="Example: Coding termination actions with try/finally"><div class="sect3" id="example_coding_termination_actions_with">
<h3>Example: Coding termination actions with try/finally</h3>
<p>We coded some simple <code>try</code>/<code>finally</code> examples <a contenteditable="false" data-type="indexterm" data-primary="termination actions" data-secondary="try/finally and" id="id4390"></a><a contenteditable="false" data-type="indexterm" data-primary="try/finally" data-secondary="termination actions and" id="id4391"></a>in the prior chapter. <a data-type="xref" href="#example_threefour_threedot_closerdotpy">Example 34-3</a> lists a more tangible example that illustrates a typical role for this statement.</p>
<div data-type="example" id="example_threefour_threedot_closerdotpy">
<h5><span class="label">Example 34-3. </span>closer.py</h5>
<pre data-type="programlisting">class MyError(Exception): pass

def stuff(file):
    file.write('Hello?')             <code><em># May be delayed in file buffer</em></code>
    raise MyError()                  <code><em># &lt;= Enable or disable me with a #</em></code>

if __name__ == '__main__':
    file = open('temp.txt', 'w')     <code><em># Open an output file (this can fail too)</em></code>
    try:
        stuff(file)                  <code><em># Raises exception</em></code>
    finally:
        file.close()                 <code><em># Always close file to flush output buffers</em></code>
    print('Am I reached?')           <code><em># Continue here only if no exception</em></code></pre>
</div>
<p>When the function in this code raises its exception, the control flow jumps back and runs the <code>finally</code> block to close the file. The exception is then propagated on to either another <code>try</code> or the default top-level handler, which prints the standard error message and shuts down the program. Hence, the statement after this <code>try</code> is never reached:</p>
<pre data-type="programlisting">$ <code><strong>python3 closer.py</strong> </code>
Traceback (most recent call last):
  File "/…/LP6E/Chapter34/closer.py", line 10, in &lt;module&gt;
    stuff(file)                      <code><em># Raises exception</em></code>
  File "/…/LP6E/Chapter34/closer.py", line 5, in stuff
    raise MyError()                  <code><em># &lt;= Enable or disable me with a #</em></code>
MyError</pre>
<p>If the function here did <em>not</em> raise an exception (e.g., by disabling its <code>raise</code> line with an added <code>#</code>), the program would still execute the <code>finally</code> block to close the file, but it would then continue below the entire <code>try</code> statement:</p>
<pre data-type="programlisting">$ <code><strong>python3 closer.py</strong></code> 
Am I reached?</pre>
<p>In this specific case, we’ve wrapped a call to a file-processing function in a <code>try</code> with a <code>finally</code> clause to make sure that the file is always closed, and thus finalized, whether the function triggers an exception or not. This way, later code can be sure that the file’s output buffer’s content has been flushed from memory to disk. A similar code structure can guarantee that server connections are closed, GUI windows are closed, and so on.</p>
<p>As we learned in <a data-type="xref" href="ch09.html#tuplescomma_filescomma_and_everything_e">Chapter 9</a>, file objects are automatically closed on garbage collection in standard Python (CPython); this is especially useful for temporary files that we don’t assign to variables. However, it’s not always easy to predict when garbage collection will occur, especially in larger programs or alternative Python implementations with differing garbage collection policies. The <code>try</code> statement makes file closes more explicit and predictable: it ensures that the file will be closed on block exit, regardless of whether an exception occurs or not.</p>
<p>This particular example’s function isn’t all that useful (it always raises an exception!), but wrapping calls in <code>try</code>/<code>finally</code> statements is a good way to ensure that your closing-time termination activities always run. All bets are off if Python itself crashes completely, of course, but this is exceedingly rare; because it detects errors as a program runs, hard crashes are usually caused by linked-in C extension code, outside of Python’s scope.</p>
<p>As a preview, notice how the user-defined exception in <a data-type="xref" href="#example_threefour_threedot_closerdotpy">Example 34-3</a> is defined with a <em>class</em>; as you’ll learn more formally in the next chapter, exceptions must all be class <a contenteditable="false" data-type="indexterm" data-primary="try statement" data-secondary="finally clause" data-startref="tyttmnfy" id="id4392"></a>instances, for reasonably good causes.</p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Combined try Clauses"><div class="sect2" id="combined_try_clauses">
<h2>Combined try Clauses</h2>
<p>For the first 15 years of Python’s tenure (more or less), the <code>try</code> statement came in two flavors <a contenteditable="false" data-type="indexterm" data-primary="try statement" data-secondary="combined clauses" id="id4393"></a><a contenteditable="false" data-type="indexterm" data-primary="try statement" data-secondary="finally block" id="trsttblk"></a><a contenteditable="false" data-type="indexterm" data-primary="try/finally" id="trflly"></a>and was two separate statements—we could either use a <code>finally</code> to ensure that cleanup code was always run, or write <code>except</code> blocks to catch and recover from specific exceptions and optionally specify an <code>else</code> clause for when exceptions occurred.</p>
<p>That is, the <code>finally</code> clause could not be <em>mixed</em> with <code>except</code> and <code>else</code>. This was partly because of implementation issues, and partly because the meaning of mixing the two seemed obscure—catching and recovering from exceptions seemed a disjoint concept from performing cleanup actions.</p>
<p>For better or worse, the two statements eventually merged. Today, we can mix <code>finally</code>, <code>except</code>, and <code>else</code> clauses in the same statement—in part because of similar utility in the Java language (alas, many a programming-language mod owes to imitation). That is, the <code>try</code> statement in its most complete form looks like this:</p>
<pre data-type="programlisting">try:                       <code><em># Combined try statement</em></code>
    <code><em>main-action</em></code>
except <code><em>Exception1</em></code>:         <code><em># Catch specific exceptions</em></code>
    <code><em>handler1</em></code>
except <code><em>Exception2</em></code>:         
    <code><em>handler2</em></code>
except:                    <code><em># Catch all (other) exceptions</em></code>
    <code><em>handler3</em></code>
else:                      <code><em># No-exception handler
</em></code>    <code><em>handler4</em></code>
finally:                   <code><em># The finally encloses all</em></code>
    <code><em>finally-block</em></code></pre>
<p>The code in this statement’s <code><em>main-action</em></code> block is executed first, as usual. If that code raises an exception, all the <code>except</code> blocks are tested, one after another, for a match to the exception raised: <code><em>handler1</em></code> is run for <code><em>Exception1</em></code>, <code><em>handler2</em></code> for <code><em>Exception2</em></code>, and <code><em>handler3</em></code> for all others. If no exception is raised, <code><em>handler4</em></code> is run.</p>
<p>No matter what’s happened previously, the <code><em>finally-block</em></code> is executed once, after the main action block is exited and any handler block has been run. In fact, the code in the <code><em>finally-block</em></code> will be run even if an error or <code>raise</code> in an <code>except</code> or <code>else</code> block causes a new exception to be raised.</p>
<p>As outlined earlier, even in mixed usage like this, the <code>finally</code> clause does not end the exception—if an exception is active when the <code><em>finally-block</em></code> is executed, it continues to be propagated after the <code><em>finally-block</em></code> runs, and control jumps somewhere else in the program (to an earlier <code>try</code>, or to the default top-level handler). If no exception is active when the <code>finally</code> is run, control resumes after <span class="keep-together">the entire</span> <code>try</code> statement.</p>
<p>The net effect is that the <code>finally</code> is always run, regardless of whether:</p>
<ul>
<li><p>An exception occurred in the main action and was handled.</p></li>
<li><p>An exception occurred in the main action and was not handled.</p></li>
<li><p>No exceptions occurred in the main action.</p></li>
<li><p>A new exception was triggered in one of the handlers.</p></li>
</ul>
<p>Again, the <code>finally</code> serves to specify cleanup actions that must always occur on the way out <a contenteditable="false" data-type="indexterm" data-primary="try statement" data-secondary="finally block" data-startref="trsttblk" id="id4394"></a><a contenteditable="false" data-type="indexterm" data-primary="try/finally" data-startref="trflly" id="id4395"></a>of the <code>try</code>, regardless of what exceptions have been raised or handled.</p>
<section data-type="sect3" data-pdf-bookmark="Combined-clause syntax rules"><div class="sect3" id="combined_clause_syntax_rules">
<h3>Combined-clause syntax rules</h3>
<p>When combined like this, the <code>try</code> statement <a contenteditable="false" data-type="indexterm" data-primary="try statement" data-secondary="combined clauses" data-tertiary="syntax" id="id4396"></a><a contenteditable="false" data-type="indexterm" data-primary="syntax" data-secondary="combined clauses, try statement" id="id4397"></a><a contenteditable="false" data-type="indexterm" data-primary="try/finally" data-secondary="syntax" id="trfltx"></a>must have either an <code>except</code> or a <code>finally</code>, and the order of its parts must be like this (where “-&gt;” means “is followed by”):</p>
<pre data-type="programlisting">try -&gt; except -&gt; else -&gt; finally</pre>
<p>In this, the <code>else</code> and <code>finally</code> are optional, and there may be zero or more <code>except</code>s, but there must be at least one <code>except</code> if an <code>else</code> appears. Really, the <code>try</code> statement consists of two parts: <code>except</code>s with an optional <code>else</code>, and/or the <code>finally</code>.</p>
<p>In fact, it’s more accurate to describe the combined <code>try</code> statement’s syntactic by the following two alternative formats (where square brackets mean optional and star means any number of what precedes it):</p>
<pre data-type="programlisting">try:                             <code><em># Format 1
</em></code>    <code><em>statements</em></code>
except [<code><em>type</em></code> [as <code><em>value</em></code>]]:
    <code><em>statements</em></code>
[except [<code><em>type</em></code> [as <code><em>value</em></code>]]:
    <code><em>statements</em></code>]*
[else:
    <code><em>statements</em></code>]
[finally:
    <code><em>statements</em></code>]

try:                             <code><em># Format 2</em></code>
    <code><em>statements</em></code>
finally:
    <code><em>statements</em></code></pre>
<p>Because of these rules, the <code>else</code> can appear only if there is at least one <code>except</code>, and it’s always possible to mix <code>except</code> and <code>finally</code>, regardless of whether an <code>else</code> appears or not. It’s also possible to mix <code>finally</code> and <code>else</code>, but only if an <code>except</code> appears too (though the <code>except</code> can omit an exception name to catch everything and run a <code>raise</code> statement, described later, to reraise the current exception). If you violate any of these (arguably intricate!) ordering <a contenteditable="false" data-type="indexterm" data-primary="try/finally" data-secondary="syntax" data-startref="trfltx" id="id4398"></a>rules, Python will raise a syntax error exception before your code runs.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Combining finally and except by nesting"><div class="sect3" id="combining_finally_and_except_by_nesting">
<h3>Combining finally and except by nesting</h3>
<p>It may help to realize that it’s also possible <a contenteditable="false" data-type="indexterm" data-primary="try statement" data-secondary="combined clauses" data-tertiary="nesting" id="id4399"></a><a contenteditable="false" data-type="indexterm" data-primary="nesting" data-secondary="combined clauses, try statement" id="id4400"></a><a contenteditable="false" data-type="indexterm" data-primary="try/finally" data-secondary="nesting" id="id4401"></a>to combine <code>finally</code> and <code>except</code> clauses in a <code>try</code> by syntactically nesting a <code>try</code>/<code>except</code> in the <code>try</code> block of a <code>try</code>/<code>finally</code> statement. We’ll explore this technique more fully in <a data-type="xref" href="ch36.html#exception_odds_and_ends">Chapter 36</a>, but the following has the same effect as the combined form shown at the start of this section:</p>
<pre data-type="programlisting">try:                         <code><em># Nested equivalent to combined form</em></code>
    try:
        <code><em>main-action</em></code>
    except <code><em>Exception1</em></code>:
        <code><em>handler1</em></code>
    except <code><em>Exception2</em></code>:
        <code><em>handler2</em></code>
    except:
        <code><em>handler3</em></code>
    else:
        <code><em>handler4</em></code>
finally:
    <code><em>finally-block</em></code></pre>
<p>Again, the <code>finally</code> block is always run on the way out, regardless of what happened in the main action and regardless of any exception handlers run in the nested <code>try</code> (trace through the four cases listed previously to see how this works the same). Since an <code>else</code> always requires an <code>except</code>, this nested form even sports the same mixing constraints of the combined form outlined in the preceding section.</p>
<p>However, this nested equivalent seems more obscure to some people and requires more code than the new merged form—though just one four-character line plus extra indentation. Mixing <code>finally</code> into the same statement might make your code easier to write and read, though this also might depend on who you ask.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Combined-clauses example"><div class="sect3" id="combined_clauses_example">
<h3>Combined-clauses example</h3>
<p>To demo the effect of mixing <code>finally</code> with other <code>try</code> clauses, the script listed in <a data-type="xref" href="#example_threefour_fourdot_trycombosdotp">Example 34-4</a>, <span class="keep-together"><em>trycombos.py</em></span>, codes four common scenarios, with <code>print</code> statements that describe the meaning of each.</p>
<div data-type="example" id="example_threefour_fourdot_trycombosdotp">
<h5><span class="label">Example 34-4. </span>trycombos.py</h5>
<pre data-type="programlisting">sep = '-' * 45 + '\n'


print(sep + 'EXCEPTION RAISED AND CAUGHT')
try:
    x = 'hack'[99]
except IndexError:
    print('except run')
finally:
    print('finally run')
print('after run')


print(sep + 'EXCEPTION NOT RAISED')
try:
    x = 'hack'[3]
except IndexError:
    print('except run')
finally:
    print('finally run')
print('after run')


print(sep + 'EXCEPTION NOT RAISED, WITH ELSE')
try:
    x = 'hack'[3]
except IndexError:
    print('except run')
else:
    print('else run')
finally:
    print('finally run')
print('after run')


print(sep + 'EXCEPTION RAISED BUT NOT CAUGHT')
try:
    x = 1 / 0
except IndexError:
    print('except run')
finally:
    print('finally run')
print('after run')</pre>
</div>
<p>When this code is run, the following output is produced. Trace through the code to see how exception handling produces the output of each of the four tests here:</p>
<pre data-type="programlisting">$ <code><strong>python3 trycombos.py</strong></code>
---------------------------------------------
EXCEPTION RAISED AND CAUGHT
except run
finally run
after run
---------------------------------------------
EXCEPTION NOT RAISED
finally run
after run
---------------------------------------------
EXCEPTION NOT RAISED, WITH ELSE
else run
finally run
after run
---------------------------------------------
EXCEPTION RAISED BUT NOT CAUGHT
finally run
Traceback (most recent call last):
  File "/…/LP6E/Chapter34/trycombos.py", line 38, in &lt;module&gt;
    x = 1 / 0
ZeroDivisionError: division by zero</pre>
<p>This example uses built-in operations in the main action to trigger exceptions (or not), and it relies on the fact that Python always checks for errors as code is running. The next section <a contenteditable="false" data-type="indexterm" data-primary="exceptions" data-secondary="try statement" data-seealso="try statement" data-startref="exprytt" id="id4402"></a><a contenteditable="false" data-type="indexterm" data-primary="try statement" data-secondary="clauses" data-tertiary="combined clauses" data-startref="tryttcc" id="id4403"></a>shows how to raise exceptions manually instead.</p>
</div></section>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="The raise Statement"><div class="sect1" id="the_raise_statement">
<h1>The raise Statement</h1>
<p>To trigger exceptions explicitly, code <code>raise</code> statements. Their general form is simple—a <code>raise</code> statement <a contenteditable="false" data-type="indexterm" data-primary="exceptions" data-secondary="raise statement" data-seealso="raise statement" id="exprstm"></a><a contenteditable="false" data-type="indexterm" data-primary="raise statement" id="id4404"></a>consists of the word <code>raise</code>, optionally followed by the class to be raised, or an instance of it:</p>
<pre data-type="programlisting">raise <code><em>instance</em></code>           <code><em># Raise an instance of a class
</em></code>raise <code><em>class</em></code>              <code><em># Make and raise an instance of a class
</em></code>raise                    <code><em># Reraise the most recent exception</em></code></pre>
<p>As mentioned earlier, exceptions are always instances of <em>classes</em> today. Hence, the first <code>raise</code> form here is the most common—we provide an <em>instance</em> directly, either created before the <code>raise</code> or within the <code>raise</code> statement itself. If we pass a <em>class</em> instead, Python calls the class with <em>no</em> constructor arguments, to create an instance to be raised; this form is equivalent to adding parentheses after the class reference. The last form reraises the most recently raised exception; it’s commonly used in exception handlers to propagate exceptions that have been caught.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><em>Blast from the past</em>: Long ago and <a contenteditable="false" data-type="indexterm" data-primary="exceptions" data-secondary="as string objects" id="id4405"></a><a contenteditable="false" data-type="indexterm" data-primary="string objects" id="id4406"></a>far away (well, before Python 2.6), exceptions could be identified as simple <em>string</em> objects, with an optional associated data item in <code>raise</code>. This was replaced with <em>classes</em> to support added functionality and categories, as you’ll see in the next chapter. Still, strings were a simpler model for simpler roles, didn’t require newcomers to learn classes and OOP before exceptions, and didn’t force some Python books to put exceptions on hold until <a data-type="xref" href="part07.html#exceptions">Part VII</a>!</p>
</div>
<section data-type="sect2" data-pdf-bookmark="Raising Exceptions"><div class="sect2" id="raising_exceptions-id000106">
<h2>Raising Exceptions</h2>
<p>To make <code>raise</code> more concrete, let’s turn <a contenteditable="false" data-type="indexterm" data-primary="exceptions" data-secondary="raising" id="id4407"></a>to some examples. With built-in exceptions, the following two forms are equivalent—both raise an instance of the exception class named, but the first creates the instance implicitly:</p>
<pre data-type="programlisting">raise IndexError             <code><em># Class (instance created)</em></code>
raise IndexError()           <code><em># Instance (created in statement)</em></code></pre>
<p>We can also create the instance ahead of time—because the <code>raise</code> statement accepts any kind of object reference, the following two examples raise <code>IndexError</code> just like the prior two:</p>
<pre data-type="programlisting">exc = IndexError()           <code><em># Create instance ahead of time</em></code>
raise exc

excs = [IndexError, TypeError]
raise excs[0]</pre>
<p>In fact, the instance provided to <code>raise</code> can be had in the <code>try</code> that catches it too, per the next section.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="The except as hook"><div class="sect2" id="the_except_as_hook">
<h2>The except as hook</h2>
<p>When an exception is raised, Python sends <a contenteditable="false" data-type="indexterm" data-primary="raise statement" data-secondary="except clause" id="rsttxpc"></a>the raised instance along with the exception. If a <code>try</code> includes an <code>except</code> with an <code>as</code> clause per <a data-type="xref" href="#try_statement_clauses_and_forms">Table 34-1</a>, the variable it gives will be assigned the instance raised by <code>raise</code> or Python:</p>
<pre data-type="programlisting">try:
    …
except IndexError as X:      <code><em># X assigned the raised instance object</em></code>
    …</pre>
<p>The <code>as</code> is optional in a <code>try</code> handler (if it’s omitted, the instance is simply not assigned to a name), but including it allows the handler to access both data in the instance and methods in the exception class.</p>
<p>This model works the same for user-defined exceptions we code with classes—the following, for example, passes to the exception class constructor arguments that become available in the handler through the assigned instance:</p>
<pre data-type="programlisting">class MyExc(Exception): pass

try:
    raise MyExc('oops')      <code><em># Exception class with constructor args</em></code>
except MyExc as X:           <code><em># Instance attributes available in handler</em></code>
    print(X.args)            <code><em># Prints ('oops',)</em></code></pre>
<p>Because this encroaches on the next chapter’s topic, though, we’ll defer further details until then.</p>
<p>Regardless of their source, exceptions are always identified by class <em>instance</em> objects, and at most one is active at any given time (sans the <code>except*</code> groups of <a data-type="xref" href="ch35.html#exception_objects">Chapter 35</a>). Once caught by an <code>except</code> clause anywhere in the program, an exception ends and won’t propagate to another <code>try</code>, unless it’s reraised <a contenteditable="false" data-type="indexterm" data-primary="raise statement" data-secondary="except clause" data-startref="rsttxpc" id="id4408"></a>by another <code>raise</code> statement or error.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Scopes and except as"><div class="sect2" id="scopes_and_except_as">
<h2>Scopes and except as</h2>
 <p>We’ll study exception objects in more <a contenteditable="false" data-type="indexterm" data-primary="raise statement" data-secondary="except block, scopes" id="rsttscp"></a><a contenteditable="false" data-type="indexterm" data-primary="scopes" data-secondary="exceptions" id="scpxcp"></a><a contenteditable="false" data-type="indexterm" data-primary="exceptions" data-secondary="scopes" id="exscps"></a>detail in the next chapter. Now that we’ve seen the <code>as</code> variable in action, though, we can finally clarify the related scope issue summarized back in <a data-type="xref" href="ch17.html#scopes">Chapter 17</a>. As mentioned in that chapter, the variable used to access an exception in the <code>as</code> clause of an <code>except</code> is localized to the <code>except</code> block—the variable is not available after the block exits, much like a temporary loop variable in comprehension expressions:</p>
<pre data-type="programlisting">$ <code><strong>python3
</strong></code>&gt;&gt;&gt; <code><strong>try:</strong></code>
...     <code><strong>1 / 0</strong></code>
... <code><strong>except Exception as X:</strong></code>            <code><em># The "as" localizes names to except block</em></code>
...     <code><strong>print(X)</strong></code>
...
division by zero
&gt;&gt;&gt; <code><strong>X</strong></code>
NameError: name 'X' is not defined</pre>
<p>Unlike comprehension loop variables, though, this variable is <em>removed</em> after the <code>except</code> block exits. This is done because the variable would otherwise retain a reference to the runtime call stack, which would defer garbage collection and thus retain excess memory space. This removal occurs, though, <em>even</em> if you’re using the name for other purposes in the surrounding scope, and is a much more extreme policy than that used for comprehensions:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>X = 99
</strong></code>&gt;&gt;&gt; <code><strong>{X for X in 'hack'}</strong></code>               <code><em># Comprehensions localize but don't remove</em></code>
{'a', 'c', 'k', 'h'}
&gt;&gt;&gt; <code><strong>X</strong></code>
99

&gt;&gt;&gt; <code><strong>X = 99
</strong></code>&gt;&gt;&gt; <code><strong>try:</strong></code>
...     <code><strong>1 / 0</strong></code>
... <code><strong>except Exception as X:</strong></code>            <code><em># But "as" localizes _and_ removes on exit!</em></code>
...     <code><strong>print(X)</strong></code>
...
division by zero
&gt;&gt;&gt; <code><strong>X      </strong>  </code>                         <code><em># Where did my X go? – an odd boundary case</em></code>
NameError: name 'X' is not defined</pre>
<p>Because of this, you should generally use unique variable names in your <code>try</code> statement’s <code>except</code> clauses, even if they are localized by scope. If you do need to reference the exception instance after the <code>try</code> statement, simply assign it to another <a contenteditable="false" data-type="indexterm" data-primary="raise statement" data-secondary="except block, scopes" data-startref="rsttscp" id="id4409"></a><a contenteditable="false" data-type="indexterm" data-primary="scopes" data-secondary="exceptions" data-startref="scpxcp" id="id4410"></a><a contenteditable="false" data-type="indexterm" data-primary="exceptions" data-secondary="scopes" data-startref="exscps" id="id4411"></a>name that won’t be automatically removed:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>try:</strong></code>
...     <code><strong>1 / 0</strong></code>
... <code><strong>except Exception as X:</strong></code>            <code><em># Python removes this reference</em></code>
...     <code><strong>print(X)</strong></code>
...     <code><strong>saveit = X</strong></code>                    <code><em># Assign exc to retain exc if needed</em></code>
...
division by zero
&gt;&gt;&gt; <code><strong>X</strong></code>
NameError: name 'X' is not defined
&gt;&gt;&gt; <code><strong>saveit</strong></code>
ZeroDivisionError('division by zero',)</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Propagating Exceptions with raise"><div class="sect2" id="propagating_exceptions_with_raise">
<h2>Propagating Exceptions with raise</h2>
<p>The <code>raise</code> statement is a bit more <a contenteditable="false" data-type="indexterm" data-primary="raise statement" data-secondary="exception propagation" id="id4412"></a><a contenteditable="false" data-type="indexterm" data-primary="exceptions" data-secondary="propagating" id="id4413"></a>feature-rich than we’ve seen thus far. For example, a <code>raise</code> that does not list an exception to raise simply reraises the currently active exception. This form is typically used if you need to catch and handle an exception but don’t want the exception to die in your handler:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>try:</strong></code>
...     <code><strong>raise IndexError('code')</strong></code>         <code><em># Exceptions remember arguments</em></code>
... <code><strong>except IndexError:</strong></code>
...     <code><strong>print('propagating')</strong></code>
...     <code><strong>raise</strong></code>                            <code><em># Reraise most recent exception</em></code>
...
propagating
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 2, in &lt;module&gt;
IndexError: code</pre>
<p>Running a <code>raise</code> this way reraises the exception and propagates it to a higher handler (or the default handler at the top, which stops the program with a standard error message). Notice how the argument we passed to the exception class shows up in the error messages; you’ll learn why this happens in the next chapter.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Exception Chaining: raise from"><div class="sect2" id="exception_chaining_raise_from">
<h2>Exception Chaining: raise from</h2>
<p>Exceptions can sometimes be triggered in response <a contenteditable="false" data-type="indexterm" data-primary="exceptions" data-secondary="chaining" id="xpchin"></a><a contenteditable="false" data-type="indexterm" data-primary="chaining exceptions" id="chxcp"></a><a contenteditable="false" data-type="indexterm" data-primary="raise statement" data-secondary="from clause" id="rsttfcl"></a>to other exceptions—both deliberately and by new program errors. To support full disclosure in such cases, Python also allows <code>raise</code> statements to have an optional <code>from</code> clause:</p>
<pre data-type="programlisting">raise <code><em>newexception</em></code> from <code><em>otherexception</em></code></pre>
<p>When the <code>from</code> is used in an <em>explicit</em> <code>raise</code> request, the expression following <code>from</code> specifies another exception class or instance to attach to the <code>__cause__</code> attribute of the new exception being raised. If the raised exception is not caught, Python prints both exceptions as part of the standard error message:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>try:</strong></code>
...     <code><strong>1 / 0</strong></code>
... <code><strong>except Exception as E:</strong></code>
...     <code><strong>raise TypeError('Bad') from E</strong></code>             <code><em># Explicitly chained exceptions</em></code>
...
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 2, in &lt;module&gt;
ZeroDivisionError: division by zero

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "&lt;stdin&gt;", line 4, in &lt;module&gt;
TypeError: Bad</pre>
<p>When an exception is raised <em>implicitly</em> by a program error inside an exception handler, a similar procedure is followed automatically: the previous exception is attached to the new exception’s <code>__context__</code> attribute and is again displayed in the standard error message if the exception goes uncaught:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>try:</strong></code>
...     <code><strong>1 / 0</strong></code>
... <code><strong>except:</strong></code>
...     <code><strong>badname</strong></code>                                   <code><em># Implicitly chained exceptions</em></code>
...
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 2, in &lt;module&gt;
ZeroDivisionError: division by zero

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "&lt;stdin&gt;", line 4, in &lt;module&gt;
NameError: name 'badname' is not defined</pre>
<p>In both cases, because the original exception objects thus attached to new exception objects may <em>themselves</em> have attached causes, the causality chain can be <em>arbitrarily long</em>, and is displayed in full in error messages. That is, error messages might give more than two exceptions. The net effect in both explicit and implicit chaining contexts is to allow programmers to know all exceptions involved when one exception triggers another:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>try:</strong></code>
...     <code><strong>try:</strong></code>
...         <code><strong>raise IndexError()</strong></code>
...     <code><strong>except Exception as E:</strong></code>
...         <code><strong>raise TypeError() from E</strong></code>
... <code><strong>except Exception as E:</strong></code>
...     <code><strong>raise SyntaxError() from E</strong></code>
...
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 3, in &lt;module&gt;
IndexError

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "&lt;stdin&gt;", line 5, in &lt;module&gt;
TypeError

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "&lt;stdin&gt;", line 7, in &lt;module&gt;
SyntaxError: None</pre>
<p>Code like the following similarly displays three exceptions, though implicitly triggered by handler errors (its separator lines are “During handling of the above exception…” instead of “The above exception was the direct cause…”):</p>
<pre data-type="programlisting">try:
    try:
        1 / 0
    except:
        badname
except:
    open('nonesuch')</pre>
<p>Exception chains impact error displays, but do not affect the way that exceptions are named and caught in <code>try</code> statements: chains are simply recorded in exception-object attributes which may be inspected as usual where useful.</p>
<p>Like the combined <code>try</code>, chained exceptions are similar to utility in other languages (including Java and C#) though it’s not clear which languages were borrowers. In Python, it’s not unusual to see exception chains in error messages, but it is uncommon to create them explicitly with <code>raise</code>, so we’ll defer to Python’s manuals for more details.</p>
<p>As a footnote on this topic, though, Python also provides a way to <em>stop</em> exceptions from chaining: a <code>raise from None</code> allows the display of the chained exception context to be disabled when needed. This makes for less cluttered error messages in <a contenteditable="false" data-type="indexterm" data-primary="exceptions" data-secondary="raise statement" data-seealso="raise statement" data-startref="exprstm" id="id4414"></a><a contenteditable="false" data-type="indexterm" data-primary="exceptions" data-secondary="chaining" data-startref="xpchin" id="id4415"></a><a contenteditable="false" data-type="indexterm" data-primary="chaining exceptions" data-startref="chxcp" id="id4416"></a><a contenteditable="false" data-type="indexterm" data-primary="raise statement" data-secondary="from clause" data-startref="rsttfcl" id="id4417"></a>applications that convert between exception types while processing exception chains.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="The assert Statement"><div class="sect1" id="the_assert_statement">
<h1>The assert Statement</h1>
<p>As a somewhat special case for debugging <a contenteditable="false" data-type="indexterm" data-primary="exceptions" data-secondary="assert statement" data-seealso="assert statement" id="exptasstt"></a><a contenteditable="false" data-type="indexterm" data-primary="assert statement" data-secondary="as conditional raise statement" id="id4418"></a>purposes, Python also includes the <code>assert</code> statement in its exceptions toolset. It is mostly just syntactic shorthand for a common <code>raise</code> usage pattern, and an <code>assert</code> can be thought of as a <em>conditional</em> <code>raise</code> statement. A statement of the form:</p>
<pre data-type="programlisting">assert <code><em>test</em></code>, <code><em>data</em></code>              # The <code><em>data</em></code> part is optional</pre>
<p>works like the following code:</p>
<pre data-type="programlisting">if __debug__:
    if not <code><em>test</em></code>:
        raise AssertionError(<code><em>data</em></code>)</pre>
<p>In other words, if the <code><em>test</em></code> evaluates to false, Python raises an exception: the <code><em>data</em></code> item (if it’s provided) is used as the exception’s constructor argument. Like all exceptions, the built-in <code>AssertionError</code> exception will kill your program if it’s not caught with a <code>try</code>, and the <code><em>data</em></code> item shows up as part of the standard error message:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>language = 'Java'</strong></code>
&gt;&gt;&gt; <code><strong>assert language.startswith('Py'), "You're using the wrong language!"</strong></code>
AssertionError: You're using the wrong language!</pre>
<p>As an added feature, <code>assert</code> statements are removed from a compiled program’s bytecode—and hence not run—if the <code>-O</code> Python command-line flag is used to optimize the program. The <code>__debug__</code> flag is a built-in and unchangeable name that is automatically set to <code>True</code> unless the <code>-O</code> flag is used. When <code>__debug__</code> is <code>False</code> for <code>-O</code>, any code predicated on it being <code>True</code> is removed, including asserts.</p>
<p>Hence, to disable (and omit) asserts, run code with a command line like <code>python –O <em>file</em>.py</code>, or generate optimized bytecode before program runs with similar options in the <code>compileall</code> standard-library module or <code>compile</code> built-in function. See Python’s manuals for details on the module and function.</p>
<section data-type="sect2" data-pdf-bookmark="Example: Trapping Constraints (but Not Errors!)"><div class="sect2" id="example_trapping_constraints_left_paren">
<h2>Example: Trapping Constraints (but Not Errors!)</h2>
<p>Here’s a less politically charged <a contenteditable="false" data-type="indexterm" data-primary="assert statement" data-secondary="constraint trapping" id="id4419"></a><a contenteditable="false" data-type="indexterm" data-primary="constraints" data-secondary="assert statement" id="id4420"></a>example of <code>assert</code> in action. Assertions are typically used to verify program conditions during development. When displayed, their error message text automatically includes source code line information and the value listed in the <code>assert</code> statement. Consider the file <em>asserter.py</em> in <a data-type="xref" href="#example_threefour_fivedot_asserterdotpy">Example 34-5</a>.</p>
<div data-type="example" id="example_threefour_fivedot_asserterdotpy">
<h5><span class="label">Example 34-5. </span>asserter.py</h5>
<pre data-type="programlisting">def f(x):
    assert x &lt; 0, 'x must be negative'
    return x ** 2</pre>
</div>
<p>Running this normally triggers the assertion error for positive numbers, but running with <code>-O</code> does not:</p>
<pre data-type="programlisting">$ <code><strong>python3</strong></code>
&gt;&gt;&gt; <code><strong>import asserter</strong></code>
&gt;&gt;&gt; <code><strong>asserter.f(-3)</strong></code>
9
&gt;&gt;&gt; <code><strong>asserter.f(3)</strong></code>
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/…/LP6E/Chapter34/asserter.py", line 2, in f
    assert x &lt; 0, 'x must be negative'
AssertionError: x must be negative

$ <code><strong>python3 -O</strong></code>
&gt;&gt;&gt; <code><strong>import asserter</strong></code>
&gt;&gt;&gt; <code><strong>asserter.f(3)</strong></code>
9</pre>
<p>It’s important to keep in mind that <code>assert</code> is mostly intended for trapping user-defined constraints, not for catching genuine programming <em>errors</em>. Because Python traps programming errors itself, there is usually no need to code <code>assert</code> to catch things like out-of-bounds indexes, type mismatches, and zero divides:</p>
<pre data-type="programlisting">def reciprocal(x):
    assert x != 0              <code><em># A generally useless assert!</em></code>
    return 1 / x               <code><em># Python checks for zero automatically</em></code></pre>
<p>Such <code>assert</code> use cases are usually superfluous—because Python raises exceptions on errors automatically, you might as well let it do the job for you. As a rule, you normally don’t need to do error checking explicitly in your own code.</p>
<p>Of course, there are exceptions to most rules. As suggested earlier in the book, if a function has to perform long-running or unrecoverable actions before it reaches the place where an exception will be triggered, you still might want to test for errors. Even in this case, though, be careful not to make your tests overly specific or restrictive, or you will limit your code’s utility.</p>
<p>For another example of common <code>assert</code> usage, see the abstract superclass example in <a data-type="xref" href="ch29.html#class_coding_details">Chapter 29</a>; there, we used <code>assert</code> to make calls to undefined methods fail with a <a contenteditable="false" data-type="indexterm" data-primary="exceptions" data-secondary="assert statement" data-seealso="assert statement" data-startref="exptasstt" id="id4421"></a>message. It’s a rare but useful tool.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="The with Statement and Context Managers"><div class="sect1" id="the_with_statement_and_context_managers">
<h1>The with Statement and Context Managers</h1>
<p>In addition to the tools we’ve seen so far, Python includes another that delegates exception-related tasks to <a contenteditable="false" data-type="indexterm" data-primary="exceptions" data-secondary="with statement" data-seealso="with statement" id="exptwth"></a><a contenteditable="false" data-type="indexterm" data-primary="with statement" id="wthttmn"></a>objects. The <code>with</code> statement is designed to work with <em>context manager</em> objects that support a method-based protocol. The combination is similar in spirit to the way that iteration tools like <code>for</code> work with methods of the iteration protocol.</p>
<p>The <code>with</code> statement is also similar to a “using” statement in the C# language. Although a somewhat optional and advanced tools-oriented topic (and once a candidate for the next part of this book), context managers are lightweight and useful enough to group with the rest of the exception toolset here.</p>
<p>In short, the <code>with</code> statement is designed to be an alternative to a common <code>try</code>/<code>finally</code> usage idiom: like that statement, <code>with</code> is in large part <a contenteditable="false" data-type="indexterm" data-primary="termination actions" data-secondary="with statement" id="id4422"></a><a contenteditable="false" data-type="indexterm" data-primary="with statement" data-secondary="termination actions" id="id4423"></a>intended for specifying termination-time or “cleanup” activities that must run regardless of whether an exception occurs during the execution of a block of code.</p>
<p>Unlike <code>try</code>/<code>finally</code>, the <code>with</code> statement is based upon a method-call protocol for specifying actions to be run around a block of code. This makes <code>with</code> less general, qualifies it as redundant in termination roles, and requires coding classes for objects that do not support its protocol. On the other hand, <code>with</code> also handles entry actions, can reduce code size where supported, and allows code contexts to be managed with full OOP.</p>
<p>Python enhances some built-in tools with context managers, such as files that automatically close themselves, thread locks that automatically lock and unlock, and async-function tools that automatically await results per <a data-type="xref" href="ch20.html#comprehensions_and_generations">Chapter 20</a>, but programmers can code context managers of their own with classes, too. Let’s take a brief look at the statement and its implicit protocol.</p>
<section data-type="sect2" data-pdf-bookmark="Basic with Usage"><div class="sect2" id="basic_with_usage">
<h2>Basic with Usage</h2>
<p>The basic format of the <code>with</code> statement looks like this, with an optional part in square brackets here:</p>
<pre data-type="programlisting">with <code><em>expression</em></code> [as <code><em>variable</em></code>]:
    <code><em>with-block</em></code></pre>
<p>The statements of the nested <code><em>with-block</em></code> are the main action to be run here. The <code><em>expression</em></code> is assumed to return an object that supports the context-management protocol (more on this protocol in a moment). This object may also return a value that will be assigned to the name <code><em>variable</em></code> if the optional <code>as</code> clause is present.</p>
<p>Note that the <code><em>variable</em></code> is not necessarily assigned the result of the <code><em>expression</em></code>; the result of the <code><em>expression</em></code> is the object that supports the context protocol, and the <code><em>variable</em></code> may be assigned something else intended to be used inside the <code><em>with-block</em></code>. The object returned by the <code><em>expression</em></code> may then run startup code before the block is started, as well as termination code after the block is done—whether the block raised an exception or not.</p>
<p>As noted, some built-in Python objects have been augmented to support the context-management protocol, and so can be used with the <code>with</code> statement. For example, file objects (covered in <a data-type="xref" href="ch09.html#tuplescomma_filescomma_and_everything_e">Chapter 9</a>) have a context manager that automatically closes the file after the <code>with</code> block regardless of whether an exception is raised, and regardless of if or when the version of Python running the code may close automatically. In abstract code:</p>
<pre data-type="programlisting">with open('somefile.txt') as myfile:
    for line in myfile:
        print(line)</pre>
<p>Here, the call to <code>open</code> returns a simple file object that is assigned to the name <code>myfile</code>. We can use <code>myfile</code> with the usual file tools—in this case, the file iterator reads line by line in the <code>for</code> loop.</p>
<p>However, the <code>open</code> result also supports the context-management protocol used by the <code>with</code> statement. After this <code>with</code> statement has run, the context management machinery guarantees that the file object referenced by <code>myfile</code> is automatically closed, even if the <code>for</code> loop raised an exception while processing the file.</p>
<p>Although file objects may be automatically closed on garbage collection, it’s not always straightforward to know when that will occur, especially when using alternative Python implementations. The <code>with</code> statement in this role is an alternative that allows us to be sure that the close will occur automatically after execution of a specific block of code.</p>
<p>As covered earlier, we can achieve a similar effect with the more general and explicit <code>try</code>/<code>finally</code> idiom, but it requires three more lines of administrative code in this case (four instead of just one):</p>
<pre data-type="programlisting">myfile = open('somefile.txt')
try:
    for line in myfile:
        print(line)
finally:
    myfile.close()</pre>
<p>Of course, we could skip <em>both</em> statements, but our file may not be closed if an exception is raised during the <code>for</code> loop, and this can matter in long-running programs (we’ll revisit such trade-offs in <a data-type="xref" href="ch36.html#exception_odds_and_ends">Chapter 36</a>).</p>
<p>As another example, we won’t cover Python’s multithreading modules in this book, but the lock and condition synchronization objects they define may also be used with the <code>with</code> statement because they support the context-management protocol—in this case adding both entry and exit actions around a block. After importing <code>threading</code>:</p>
<pre data-type="programlisting">lock = threading.Lock()   
with lock:
    …<code><em>access shared resources</em></code>…</pre>
<p>Here, the context management machinery guarantees that the lock is automatically <em>acquired</em> before the block is executed and <em>released</em> once the block is complete, regardless of exception outcomes.</p>
<p>Finally, the <code>decimal</code> module introduced in <a data-type="xref" href="ch05.html#numbers_and_expressions">Chapter 5</a> also uses context managers to simplify saving and restoring the current decimal context, which specifies the precision and rounding characteristics for calculations:</p>
<pre data-type="programlisting">with decimal.localcontext() as ctx:
    ctx.prec = 2
    x = decimal.Decimal('1.00') / decimal.Decimal('3.00')</pre>
<p>After this statement runs, the current thread’s context manager state is automatically restored to what it was before <a contenteditable="false" data-type="indexterm" data-primary="with statement" data-startref="wthttmn" id="id4424"></a>the statement began. To do the same with a <code>try</code>/<code>finally</code>, we would need to save the context before and restore it manually after the nested block.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="The Context-Management Protocol"><div class="sect2" id="the_context_management_protocol">
<h2>The Context-Management Protocol</h2>
<p>Although some built-in types come with <a contenteditable="false" data-type="indexterm" data-primary="with statement" data-secondary="context-management protocol" id="wttxmtc"></a><a contenteditable="false" data-type="indexterm" data-primary="context managers" data-secondary="with statement" data-tertiary="context-management protocol" id="ctxtwtt"></a>context managers, we can also write new ones of our own. To implement context managers, classes use special methods that fall into the operator-overloading category to tap into the <code>with</code> statement. The interface expected of objects used in <code>with</code> statements is somewhat complex, and most programmers only need to know how to use existing context managers. For tool builders who might want to write new application-specific context managers, though, let’s take a quick look at what’s involved.</p>
<p>Here’s how the <code>with</code> statement actually works:</p>
<ol>
<li><p>The expression is evaluated, resulting in an object known as a <em>context manager</em> that must have <code>__enter__</code> and <code>__exit__</code> methods.</p></li>
<li><p>The context manager’s <code>__enter__</code> method is called. The value it returns is assigned to the variable in the <code>as</code> clause if present, or simply discarded otherwise.</p></li>
<li><p>The code in the nested <code>with</code> block is executed.</p></li>
<li><p>If the <code>with</code> block raises an exception, the context manager’s <code>__exit__(<em>type</em>, <em>value</em>, <em>traceback</em>)</code> method is called with the exception details. These are the same three values returned by <code>sys.exc_info</code>, described in the Python manuals and later in this part of the book. If this method returns a false value, the exception is reraised; otherwise, the exception is terminated. The exception should normally be reraised so that it is propagated outside the <code>with</code> statement after <code>__exit__</code> returns.</p></li>
<li><p>If the <code>with</code> block does <em>not</em> raise an exception, the <code>__exit__</code> method is still called, but its <code><em>type</em></code>, <code><em>value</em></code>, and <code><em>traceback</em></code> arguments are all passed in as <code>None</code>, and its return value is ignored.</p></li>
</ol>
<p>Let’s look at a quick demo of the protocol in action. The file <em>withas.py</em> in <a data-type="xref" href="#example_threefour_sixdot_withasdotpy">Example 34-6</a> defines a context-manager object that simply traces the entry and exit of the <code>with</code> block in any <code>with</code> statement it is used for.</p>
<div data-type="example" id="example_threefour_sixdot_withasdotpy">
<h5><span class="label">Example 34-6. </span>withas.py</h5>
<pre data-type="programlisting">"A context manager that traces entry and exit of any with statement's block"

class TraceBlock:
    def message(self, arg):
        print('running ' + arg)

    def __enter__(self):
        print('[starting with block]')
        return self

    def __exit__(self, exc_type, exc_value, exc_tb):
        if exc_type is None:
            print('[exited normally]\n')
        else:
            print(f'[propagating exception: {exc_type}]')
            return False

if __name__ == '__main__':
    with TraceBlock() as action:
        action.message('test 1')
        print('reached')

    with TraceBlock() as action:
        action.message('test 2')
        raise TypeError
        print('not reached')</pre>
</div>
<p>Notice that this class’s <code>__exit__</code> method returns <code>False</code> to propagate the exception; deleting the <code>return</code> statement would have the same effect, as the default <code>None</code> return value of functions is false by definition, but explicit is generally better in coding. Also notice that the <code>__enter__</code> method returns <code>self</code> as the object to assign to the <code>as</code> variable; in other use cases, this might return a completely different object instead.</p>
<p>When run, this module’s self-test code uses its context manager to trace the entry and exit of two <code>with</code> statement blocks. The net effect automatically invokes the manager’s <code>__enter__</code> and <code>__exit__</code> methods:</p>
<pre data-type="programlisting">$ <code><strong>python3 withas.py</strong></code>
[starting with block]
running test 1
reached
[exited normally]

[starting with block]
running test 2
[propagating exception: &lt;class 'TypeError'&gt;]
Traceback (most recent call last):
  File "/…/LP6E/Chapter34/withas.py", line 25, in &lt;module&gt;
    raise TypeError
TypeError</pre>
<p>Context managers can also utilize OOP state information and inheritance, but are somewhat advanced devices meant for tool builders, so we’ll skip additional details here. See Python’s standard manuals for the full story—including its coverage of the <code>contextlib</code> standard module that provides additional tools for coding context managers.</p>
<p>Also remember that the <code>try</code>/<code>finally</code> combination provides support for termination-time activities too, and is generally sufficient in roles that don’t warrant <a contenteditable="false" data-type="indexterm" data-primary="with statement" data-secondary="context-management protocol" data-startref="wttxmtc" id="id4425"></a><a contenteditable="false" data-type="indexterm" data-primary="context managers" data-secondary="with statement" data-tertiary="context-management protocol" data-startref="ctxtwtt" id="id4426"></a>coding classes to support the <code>with</code> statement’s protocol.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Multiple Context Managers"><div class="sect2" id="multiple_context_managers">
<h2>Multiple Context Managers</h2>
<p>The <code>with</code> statement has one <a contenteditable="false" data-type="indexterm" data-primary="with statement" data-secondary="context managers, multiple" id="wttxmn"></a><a contenteditable="false" data-type="indexterm" data-primary="context managers" data-secondary="with statement" data-tertiary="multiple context managers" id="xmttpxm"></a>last card to turn over: it may also specify <em>multiple</em> (sometimes called “nested”) context managers with comma syntax. For example, in the following code snippet that selects lines by substring, both files’ exit actions are automatically run to close the files when the statement block exits, regardless of exception outcomes:</p>
<pre data-type="programlisting">with open('lines.txt') as input, open('matches.txt', 'w') as output:
    for line in input:
        if 'somekey' in line:
            output.write(line)</pre>
<p>Any number of context manager items may be listed, and multiple items work the same as nested <code>with</code> statements. That is, the following hypothetical code:</p>
<pre data-type="programlisting">with A() as a, B() as b:
    <code><em>statements</em></code></pre>
<p>is equivalent to (and possibly simpler than) the following:</p>
<pre data-type="programlisting">with A() as a:
    with B() as b:
        <code><em>statements</em></code></pre>
<p>The net effect is that each context manager’s entry and exit method is run in turn on block entry and exit, and exceptions in the block are caught automatically and possibly reraised on <code>with</code> exit at the <span class="keep-together">discretion</span> of the outermost manager’s exit method. Multiple <em>file</em> context managers, for instance, will all be run to open <a contenteditable="false" data-type="indexterm" data-primary="with statement" data-secondary="context managers, multiple" data-startref="wttxmn" id="id4427"></a><a contenteditable="false" data-type="indexterm" data-primary="context managers" data-secondary="with statement" data-tertiary="multiple context managers" data-startref="xmttpxm" id="id4428"></a>files on entry, and close them on exit—exception or not.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="The Termination-Handlers Shoot-Out"><div class="sect2" id="the_termination_handlers_shoot_out">
<h2>The Termination-Handlers Shoot-Out</h2>
<p>You can find more info on context managers <a contenteditable="false" data-type="indexterm" data-primary="exceptions" data-secondary="termination handlers" id="exptmnh"></a><a contenteditable="false" data-type="indexterm" data-primary="termination handlers" id="tmnhdr"></a>in Python’s docs. Rather than getting more detailed here, let’s close out this chapter with a quick look at this extension in action and a vetting of its roles. Using newer and redundant tools like <code>with</code> doesn’t in and of itself prove intelligence, and it’s important to understand the trade-offs such options imply.</p>
<p>First up, the following <a contenteditable="false" data-type="indexterm" data-primary="with statement" data-secondary="termination handlers" id="id4429"></a>codes a parallel <em>lines scan</em> of files located in this book’s examples package. It uses <code>with</code> to open two files at once and then reads and zips together their next-line pairs on each iteration of a <code>for</code> loop. Thanks to the file object’s context manager, there’s no need to manually catch exceptions or close files when finished:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>with open('lines1.txt') as file1, open('lines2.txt') as file2:</strong></code>
        <code><strong>for pair in zip(file1, file2):</strong></code>
            <code><strong>print(pair)</strong></code>

('hack\n', 'HACK\n')
('code\n', 'GOOD\n')
('well\n', 'CODE\n')</pre>
<p>You might also use this coding <a contenteditable="false" data-type="indexterm" data-primary="text files" data-secondary="lines comparison" id="id4430"></a><a contenteditable="false" data-type="indexterm" data-primary="lines comparison, text files" id="id4431"></a>structure to do a <em>lines comparison</em> of two text files. The following simply replaces the former’s <code>print</code> with an <code>if</code> for a comparison operation, and adds an <code>enumerate</code> for automatic line numbers:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>with open('lines1.txt') as file1, open('lines2.txt') as file2:</strong></code>
<code> <strong>       for (linenum, (line1, line2)) in enumerate(zip(file1, file2)):</strong></code>
<code> <strong>           if line1.lower() != line2.lower():</strong></code>
<code> <strong>               print(f'{linenum} =&gt; {line1!r} != {line2!r}')</strong></code>
 
1 =&gt; 'code\n' != 'GOOD\n'
2 =&gt; 'well\n' != 'CODE\n'</pre>
<p>That said, <code>with</code> isn’t all that useful in the preceding examples when using CPython, because <em>input</em> file objects don’t require a buffer flush, and file objects are <em>closed</em> automatically when garbage collected if still open. Moreover, <em>exceptions</em> in the <code>with</code> block are still propagated outside the statement if not explicitly caught. Hence, the temporary files would be auto-closed immediately and exception behavior would be the same for simpler code like this:</p>
<pre data-type="programlisting">for pair in zip(open('lines1.txt'), open('lines2.txt')):     <code><em># Same if auto close</em></code>
    print(pair)                                              <code><em># Ditto for != test</em></code></pre>
<p>On the other hand, some of the alternative <em>Pythons</em> of <a data-type="xref" href="ch02.html#how_python_runs_programs">Chapter 2</a> may use different garbage collectors that require direct closes, to avoid taxing system resources. In addition, <em>output</em> files may require closes to ensure that any buffered content is transferred to disk so it’s available for opens in later code.</p>
<p>The following <em>lines filter</em> code addresses both concerns, by automatically closing files on statement exit, exception or not (it also uses parentheses and line splits after <code>with</code>, available as of Python 3.10, and omits write counts for brevity):</p>
<pre class="pagebreak-before" data-type="programlisting">&gt;&gt;&gt; <code><strong>with (open('lines1.txt') as input,</strong> </code>
<code> <strong>         open('uppers.txt', 'w') as output):</strong></code>
        <code><strong>for line in input:</strong></code>
            <code><strong>output.write(line.upper())</strong></code>
   
&gt;&gt;&gt; <code><strong>print(open('uppers.txt').read())</strong></code>          <code><em># File content is available here</em></code>
HACK
CODE
WELL</pre>
<p>Still, in simple scripts, we can often just open files in separate statements and close after processing if needed. There’s no point in catching an exception if it means your program is out of business anyhow, and closes are required to flush output buffers only if files will be reopened by later code—which may never be reached after exceptions anyhow:</p>
<pre data-type="programlisting">input  = open('lines1.txt')
output = open('uppers.txt', 'w')
for line in input:                            <code><em># Same effect if files auto close,</em></code>
    output.write(line.upper())                <code><em># and file is not reopened ahead</em></code></pre>
<p>Nevertheless, in programs that must <em>both</em> continue after exceptions and close output files for later use in the same program (or REPL) run, the <code>with</code> avoids an equivalent <code>try</code>/<code>finally</code> combination that may be more obvious to some readers, but also requires noticeably more code—eight lines instead of four, quantitatively speaking:</p>
<pre data-type="programlisting">input  = open('lines1.txt')
output = open('uppers.txt', 'w')
try:                                         <code><em># Same but explicit close on errors</em></code>
    for line in input:
        output.write(line.upper())
finally:
    input.close()                            <code><em># Ensure output file is complete</em></code>
    output.close()                           <code><em># Whether exception occurs or not</em></code></pre>
<p>Even so, the <code>try</code>/<code>finally</code> is a single tool that applies to all finalization cases and makes code explicit. The <code>with</code> can be more concise for context-manager users, but applies only to objects that implement its complex protocol, relies on implicit “magic” that obscures meaning, and adds redundancy that doubles the required knowledge base of programmers. As usual, you’ll have to <a contenteditable="false" data-type="indexterm" data-primary="exceptions" data-secondary="with statement" data-seealso="with statement" data-startref="exptwth" id="id4432"></a><a contenteditable="false" data-type="indexterm" data-primary="exceptions" data-secondary="termination handlers" data-startref="exptmnh" id="id4433"></a><a contenteditable="false" data-type="indexterm" data-primary="termination handlers" data-startref="tmnhdr" id="id4434"></a>weigh these tools’ trade-offs for yourself.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Chapter Summary"><div class="sect1" id="chapter_summary-id00045">
<h1>Chapter Summary</h1>
<p>In this chapter, we took a more detailed look at exception processing by exploring the statements related to exceptions in Python: <code>try</code> to catch them, <code>raise</code> to trigger them, <code>assert</code> to raise them conditionally, and <code>with</code> to wrap code blocks in context managers that automate entry and exit actions.</p>
<p>Up to this point, exceptions may seem like a fairly lightweight tool (apart from the <code>with</code> protocol, that is). The most complex thing about them may be how they are identified—a topic the next chapter will address by showing how exception objects are made. As you’ll see there, classes allow you to code new exceptions specific to your programs. Before we move ahead, though, let’s work through the following short quiz on the basics covered here.</p>
</div></section>
<section data-type="sect1" class="pagebreak-before" data-pdf-bookmark="Test Your Knowledge: Quiz"><div class="sect1" id="test_your_knowledge_quiz-id000189">
<h1 class="less_space">Test Your Knowledge: Quiz</h1>
<ol>
<li><p>What is the <code>try</code> statement for?</p></li>
<li><p>What are the two common variations of the <code>try</code> statement?</p></li>
<li><p>What is the <code>raise</code> statement for?</p></li>
<li><p>What is the <code>assert</code> statement designed to do, and what other statement is it like?</p></li>
<li><p>What is the <code>with</code> statement designed to do, and what other statement is it like?</p></li>
</ol>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Test Your Knowledge: Answers"><div class="sect1" id="test_your_knowledge_answers-id000188">
<h1>Test Your Knowledge: Answers</h1>
<ol>
<li><p>The <code>try</code> statement catches and recovers from exceptions—it specifies a block of code to run and one or more handlers for exceptions that may be raised during the block’s execution.</p></li>
<li><p>The two common variations on the <code>try</code> statement are <code>try</code>/<code>except</code>/<code>else</code> (for catching exceptions) and <code>try</code>/<code>finally</code> (for specifying cleanup actions that must occur whether an exception is raised or not). Despite these logically distinct roles, the <code>except</code> and <code>finally</code> blocks may be mixed in the same statement, so the two forms are really part of the single <code>try</code> statement. Even when mixed with <code>except</code>, though, the <code>finally</code> is still run on the way out of the <code>try</code>, regardless of what exceptions may have been raised or handled. In fact, the combined form is equivalent to nesting a <span class="keep-together"><code>try</code>/<code>except</code>/<code>else</code></span> in a <code>try</code>/<code>finally</code>.</p></li>
<li><p>The <code>raise</code> statement raises (triggers) an exception. Python raises built-in exceptions on errors internally, but your scripts can trigger built-in or user-defined exceptions too with <code>raise</code>.</p></li>
<li><p>The <code>assert</code> statement raises an <code>AssertionError</code> exception if a condition is false. It’s similar to a conditional <code>raise</code> statement wrapped up in an <code>if</code> statement, and can be disabled with a <code>–O</code> command switch.</p></li>
<li><p>The <code>with</code> statement is designed to automate startup and termination activities that must occur around a block of code. It is roughly like a <code>try</code>/<code>finally</code> combination in that its exit actions run whether an exception occurred or not, but it employs an object-based protocol for specifying entry and exit actions and may reduce code size for context-manger users. Still, it’s not quite as general, as it applies only to objects that support its protocol; <code>try</code> with <code>finally</code> clauses can handle more use cases.</p></li>
</ol>
</div></section>
</div></section></div>
</div>
</body>
</html>