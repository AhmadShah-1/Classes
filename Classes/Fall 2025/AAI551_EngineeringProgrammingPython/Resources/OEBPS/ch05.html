<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xml:lang="en"
lang="en"
xmlns="http://www.w3.org/1999/xhtml"
xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<title>Learning Python, 6th Edition</title>
<link rel="stylesheet" type="text/css" href="override_v1.css"/>
<link rel="stylesheet" type="text/css" href="epub.css"/>
</head>
<body>
<div id="book-content">
<div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 5. Numbers and Expressions"><div class="chapter" id="numbers_and_expressions">
<h1><span class="label">Chapter 5. </span>Numbers and Expressions</h1>
<p>This chapter begins our in-depth tour of the Python language. In Python, data takes the form of <span class="keep-together"><em>objects</em>—either</span> built-in objects that Python provides or objects we create using Python tools and other languages like C. In fact, objects are the basis of every Python program you will ever write. Because they are the most fundamental notion in Python programming, objects are also our first focus in this book.</p>
<p>In the preceding chapter, we took a quick first pass over Python’s core object types. Although essential terms were introduced in that chapter, we avoided covering too many specifics in the interest of space. Here, we’ll begin a more careful second look at object concepts, to fill in details we glossed over earlier. Let’s get started by exploring our first category: Python’s numeric objects and operations.</p>
<section data-type="sect1" data-pdf-bookmark="Numeric Object Basics"><div class="sect1" id="numeric_object_basics">
<h1>Numeric Object Basics</h1>
<p>Most of Python’s numeric support is fairly typical and will probably seem familiar if you’ve used almost any other programming language in the past. They can be used to keep track of your bank balance, the distance to Mars, the number of visitors to your website, and just about any other numeric quantity.</p>
<p>In Python, numbers are not really a single object type, but a category of similar types. Python supports the usual numeric types (integers and floating points), as well as literals for creating numbers and expressions for processing them. In addition, Python provides more advanced numeric programming support and objects for more advanced needs. A fairly complete inventory of Python’s numeric toolbox includes:</p>
<ul>
<li><p>Integer and floating-point objects</p></li>
<li><p>Complex number objects</p></li>
<li><p>Decimal fixed-precision objects</p></li>
<li><p>Fraction rational number objects</p></li>
<li><p>Set objects and operations</p></li>
<li><p>Boolean and bitwise operations</p></li>
<li><p>Built-in modules, such as <code>math</code>, <code>cmath</code>, <code>random</code>, and <code>statistics</code></p></li>
<li><p>Third-party add-ons, including vectors, visualization, plotting, and extended precision</p></li>
</ul>
<p>Because the object types in this list’s first bullet item tend to see the most action in Python code, this chapter starts with basic numbers and fundamentals, then moves on to explore other types on this list, which serve specialized roles. We’ll also study <em>sets</em> here, which have both numeric and collection qualities, but are generally considered more the former than the latter. Before we jump into code, though, the next few sections get us started with a brief overview of how we write and process numbers in our scripts.</p>
<section data-type="sect2" data-pdf-bookmark="Numeric Literals"><div class="sect2" id="numeric_literals">
<h2>Numeric Literals</h2>
<p>Among its basic object types, Python provides <em>integers</em>, which are positive and negative whole numbers, and <em>floating-point</em> numbers, which are numbers with a fractional part (sometimes called <em>floats</em> for verbal economy). Python also allows us to write integers using hexadecimal, octal, and binary literals; offers a complex number type; and allows integers to have unlimited <em>precision</em>—they can grow to have as many digits as your memory space allows. <a data-type="xref" href="#numeric_literals_and_constructors">Table 5-1</a> shows what Python’s numeric types look like when written out in a program as literals or constructor-function calls.</p>
<table class="border" id="numeric_literals_and_constructors">
<caption><span class="label">Table 5-1. </span>Numeric literals and constructors</caption>
<thead>
<tr>
<th>Literal</th>
<th>Interpretation</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>1234</code>, <code>−24</code>, <code>0</code>, <code>9_999_999_999_999</code></td>
<td>Integers (unlimited size)</td>
</tr>
<tr>
<td><code>1.23</code>, <code>1.</code>, <code>3.14e-10</code>, <code>4E210</code>, <code>4.0e+210</code></td>
<td>Floating-point numbers</td>
</tr>
<tr>
<td><code>0o177</code>, <code>0x9ff</code>, <code>0b101010</code></td>
<td>Octal, hex, and binary literals</td>
</tr>
<tr>
<td><code>3+4j</code>, <code>3.0+4.0j</code>, <code>3J</code></td>
<td>Complex number literals</td>
</tr>
<tr>
<td><code>set('hack')</code>, <code>{1, 2, 3, 4}</code></td>
<td>Sets: constructors and literals</td>
</tr>
<tr>
<td><code>Decimal('1.0')</code>, <code>Fraction(1, 3)</code></td>
<td>Decimal and fraction extension types</td>
</tr>
<tr>
<td><code>bool(X)</code>, <code>True</code>, <code>False</code></td>
<td>Boolean type and constants</td>
</tr>
</tbody>
</table>
<p>In general, Python’s numeric type literals are straightforward to write, but a few coding concepts are worth highlighting up front:</p>
<dl>
<dt>Integer and floating-point literals</dt>
<dd><p>Integers are written as strings of decimal digits. As noted, they have precision (number of digits) limited only by your device’s available memory. You can easily compute 2 raised to the power 1,000,000, though with 300K digits, it may take some time to print (and can’t be converted to a print string today by default, per <a data-type="xref" href="ch04.html#introducing_python_objects">Chapter 4</a>).</p>
<p>Floating-point numbers have a decimal point and/or an optional signed exponent introduced by an <code>e</code> or <code>E</code> and followed by an optional sign. If you write a number with a decimal point or exponent, Python makes it a floating-point object and uses floating-point (not integer) math when the object is used in an expression. As you’ll learn, mixing a floating-point number with an integer does floating-point math too, after converting the integer up.</p></dd>
<dt>Hexadecimal, octal, and binary literals</dt>
<dd><p>Integers may be coded in decimal (base 10), hexadecimal (base 16), octal (base 8), or binary (base 2), the last three of which are common in some programming domains. Hexadecimals start with a leading <code>0x</code> or <code>0X</code>, followed by a string of hexadecimal digits (<code>0</code>–<code>9</code> and <code>A</code>–<code>F</code>). Hex digits may be coded in lowercase or uppercase. Octal literals start with a leading <code>0o</code> or <code>0O</code> (zero and lowercase or <span class="keep-together">uppercase</span> letter <em>o</em>), followed by a string of octal digits (<code>0</code>–<code>7</code>). Binary literals begin with a leading <code>0b</code> or <code>0B</code>, followed by binary digits (<code>0</code>–<code>1</code>).</p>
<p>All of these literals produce integer objects in program code; they are just alternative syntaxes for specifying values. The built-in calls <code>hex(<em>I</em>)</code>, <code>oct(<em>I</em>)</code>, and <code>bin(<em>I</em>)</code> convert an integer to its representation string in these three bases, and <code>int(<em>str</em>, <em>base</em>)</code> converts a runtime string to an integer per a given base.</p></dd>
<dt>Complex numbers</dt>
<dd>Though used more rarely, Python complex literals are written as <code><em>realpart</em>+<em>imaginarypart</em></code>, where the <code><em>imaginarypart</em></code> is terminated with a <code>j</code> or <code>J</code>. The <code><em>realpart</em></code> is technically optional, so the <span class="keep-together"><code><em>imaginarypart</em></code></span> may appear on its own. Internally, complex numbers are implemented as pairs of floating-point numbers, but all numeric operations perform complex math when applied to complex numbers. Complex numbers may also be created with the <code>complex(<em>real</em>, <em>imag</em>)</code> built-in call.</dd>
<dt>Coding other numeric types</dt>
<dd>As you’ll see later in this chapter, there are additional numeric types near the end of <a data-type="xref" href="#numeric_literals_and_constructors">Table 5-1</a> that serve more advanced or specialized roles. You create some of these by calling functions in imported modules (e.g., decimals and fractions), others have literal syntax all their own (e.g., sets), and Booleans are a kind of specialized integer.</dd>
</dl>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Built-in Numeric Tools"><div class="sect2" id="built_in_numeric_tools">
<h2>Built-in Numeric Tools</h2>
<p>Besides the built-in number literals and construction calls shown in <a data-type="xref" href="#numeric_literals_and_constructors">Table 5-1</a>, Python provides a set of tools for processing number objects:</p>
<dl>
<dt>Expression operators</dt>
<dd><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>&gt;&gt;</code>, <code>**</code>, <code>&amp;</code>, <code>%</code>, etc.</dd>
<dt>Built-in mathematical functions</dt>
<dd><code>pow</code>, <code>abs</code>, <code>round</code>, <code>int</code>, <code>hex</code>, <code>bin</code>, etc.</dd>
<dt>Utility modules</dt>
<dd><code>random</code>, <code>math</code>, <code>statistics</code>, etc.</dd>
</dl>
<p>You’ll meet all of these as we go along.</p>
<p>Although numbers are primarily processed with expressions, built-ins, and modules, they also have a handful of type-specific <em>methods</em> today, which you’ll meet in this chapter. Floating-point numbers, for example, have an <code>as_integer_ratio</code> method useful for the fraction number type, and an <code>is_integer</code> method to test if the number is an integer. Integer attributes include a <code>bit_length</code> method that gives the number of bits necessary to represent the object’s value, and as part collection and part number, <em>sets</em> support both expressions and methods too.</p>
<p>Since expressions are the most essential tool for most number types, though, let’s turn to them next.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Python Expression Operators"><div class="sect1" id="python_expression_operators">
<h1>Python Expression Operators</h1>
<p>The most fundamental tool that processes numbers is the <em>expression</em>: a combination of numbers (or other objects) and operators that computes a value when executed by Python. In Python, you write expressions using the usual mathematical notation and operator symbols. For instance, to add two numbers <code>X</code> and <code>Y</code> you would say <code>X + Y</code>, which tells Python to apply the <code>+</code> operator to the values named by <code>X</code> and <code>Y</code>. The result of the expression is the sum of <code>X</code> and <code>Y</code>, another number object.</p>
<p><a data-type="xref" href="#python_expression_operatorscomma_by_inc">Table 5-2</a> lists all the operator expressions available in Python, abstractly. Many are self-explanatory; for instance, the usual mathematical operators (<code>+</code>, <code>−</code>, <code>*</code>, <code>/</code>, and so on) are supported. A few will be familiar if you’ve used other languages in the past: <code>%</code> computes a division remainder, <code>&lt;&lt;</code> performs a bitwise left-shift, <code>&amp;</code> computes a bitwise AND result, and so on. Others are more Python specific, and not all are numeric in nature: for example, the <code>is</code> operator tests object identity (i.e., same address in memory, a strict form of equality), and <code>lambda</code> creates unnamed functions.</p>
<table class="border" id="python_expression_operatorscomma_by_inc">
<caption><span class="label">Table 5-2. </span>Python expression operators, by increasing precedence (binding)</caption>
<thead>
<tr>
<th>Operators</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>yield <em>x</em></code>, <code>yield from <em>x</em></code></td>
<td>Generator function <code>send</code> protocol</td>
</tr>
<tr>
<td><code><code><em>x</em> := <em>y</em></code></code></td>
<td>Assignment expression</td>
</tr>
<tr>
<td><code><code>lambda <em>args</em>: <em>expression</em></code></code></td>
<td>Anonymous function generation</td>
</tr>
<tr>
<td><code><code><em>x</em> if <em>y</em> else <em>z</em></code></code></td>
<td>Ternary selection (<code><em>x</em></code> is evaluated only if <code><em>y</em></code> is true)</td>
</tr>
<tr>
<td><code><code><em>x</em> or <em>y</em></code></code></td>
<td>Logical OR (<code><em>y</em></code> is evaluated only if <code><em>x</em></code> is false)</td>
</tr>
<tr>
<td><code><code><em>x</em> and <em>y</em></code></code></td>
<td>Logical AND (<code><em>y</em></code> is evaluated only if <code><em>x</em></code> is true)</td>
</tr>
<tr>
<td><code><code>not <em>x</em></code></code></td>
<td>Logical negation</td>
</tr>
<tr>
<td><code><em>x</em> in <em>y</em></code>, <code><em>x</em> not in <em>y</em></code><br/>
<code><em>x</em> is <em>y</em></code>, <code><em>x</em> is not <em>y</em></code><br/>
<code><em>x</em> &lt; <em>y</em></code>, <code><em>x</em> &lt;= <em>y</em></code>, <code><em>x</em> &gt; <em>y</em></code>, <code><em>x</em> &gt;= <em>y</em></code><br/>
<code><em>x</em> == <em>y</em></code>, <code><em>x</em> != <em>y</em></code></td>
<td>Membership (iterables)<br/>Object identity tests<br/>Magnitude comparison, set subset and superset<br/>Value equality operators</td>
</tr>
<tr>
<td><code><code><em>x</em> | <em>y</em></code></code></td>
<td>Bitwise OR, set union, dictionary merge</td>
</tr>
<tr>
<td><code><code><em>x</em> ^ <em>y</em></code></code></td>
<td>Bitwise XOR, set symmetric difference</td>
</tr>
<tr>
<td><code><code><em>x</em> &amp; <em>y</em></code></code></td>
<td>Bitwise AND, set intersection</td>
</tr>
<tr>
<td><code><em>x</em> &lt;&lt; <em>y</em></code>, <code><em>x</em> &gt;&gt; <em>y</em></code></td>
<td>Shift <code><em>x</em></code> left or right by <code><em>y</em></code> bits</td>
</tr>
<tr>
<td><code><em>x</em> + <em>y</em></code><br/>
<code><em>x</em> – <em>y</em></code></td>
<td>Addition, concatenation<br/>Subtraction, set difference</td>
</tr>
<tr>
<td><code><em>x</em> * <em>y</em></code><br/>
<code><em>x</em> % <em>y</em></code><br/>
<code><em>x</em> / <em>y</em>, <em>x</em> // <em>y</em></code><br/>
<code><em>x</em> @ <em>y</em></code></td>
<td>Multiplication, repetition<br/>Remainder, format<br/>Division: true and floor<br/>Matrix multiplication (unused by Python)</td>
</tr>
<tr>
<td><code>−<em>x</em></code>, <code>+<em>x</em></code>, 
<code>˜<em>x</em></code></td>
<td>Negation, identity<br/>Bitwise NOT (inversion)</td>
</tr>
<tr>
<td><code><code><em>x</em> ** <em>y</em></code></code></td>
<td>Power (exponentiation)</td>
</tr>
<tr>
<td><code><code>await <em>x</em></code></code></td>
<td>Await expression (async functions)</td>
</tr>
<tr>
<td><code><em>x</em>[<em>i</em>]</code><br/>
<code><em>x</em>[<em>i</em>:<em>j</em>:<em>k</em>]</code><br/>
<code><em>x</em>(...)</code><br/>
<code><em>x</em>.<em>attr</em></code></td>
<td>Indexing (sequence, mapping, others)<br/>Slicing<br/>Call (function, method, class, other callable)<br/>Attribute reference</td>
</tr>
<tr>
<td><code>(...)</code><br/>
<code>[...]</code><br/>
<code>{...}</code></td>
<td>Tuple, expression, generator expression<br/>List, list comprehension<br/>Dictionary, set, dictionary and set comprehensions</td>
</tr>
</tbody>
</table>
<p>While <a data-type="xref" href="#python_expression_operatorscomma_by_inc">Table 5-2</a> works as a reference, some of its operators won’t make sense until you’ve seen them in action, and some are more subtle than the table may imply. For instance:</p>
<ul>
<li><p>Parentheses are required for <code>yield</code> if it’s not alone on the right side of an assignment statement, as well as the <code>:=</code> named-assignment operator if it’s used in some contexts.</p></li>
<li><p>Comparison operators compare all parts of collections automatically and may be chained as a shorthand and potential optimization (e.g., <code>X &lt; Y &lt; Z</code> produces the same result as <code>X &lt; Y</code> and <span class="keep-together"><code>Y &lt; Z</code></span>).</p></li>
<li><p>Python defines an <code>@</code> operator meant for matrix multiplication but does not provide an implementation for it; unless you code one in a class or use a library that does, this operator does <em>nothing</em>.</p></li>
<li><p>The parentheses used for tuples, expressions, and generators may sometimes be omitted; when omitted for tuples, the <em>comma</em> separating its items acts like a lowest-precedence operator if not otherwise significant.</p></li>
<li><p>Some operators, like <code>yield</code>, <code>lambda</code>, and <code>await</code>, have to do with larger topics that have little to do with numbers and can safely be ignored at this early point in your Python career.</p></li>
</ul>
<p>This book will defer to Python’s manuals for other minutiae, but you’ll see most of the operators in <a data-type="xref" href="#python_expression_operatorscomma_by_inc">Table 5-2</a> in action later. First, though, we need to take a quick look at the ways these operators may be combined in expressions.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><em>Meet the Python no-ops</em>: The <code>@</code> character is used by Python to introduce function decorators (covered later in this book), but not as an expression operator—despite its being specified as such. In the latter role, <code>@</code> joins <code>Ellipsis</code> (<code>...</code>) and <em>type hinting</em> as tools defined but wholly unused by Python itself. As if you didn’t have enough to learn with the real stuff!</p>
</div>
<section data-type="sect2" data-pdf-bookmark="Mixed Operators: Precedence"><div class="sect2" id="mixed_operators_precedence">
<h2>Mixed Operators: Precedence</h2>
<p>As in most languages, in Python, you code more complex expressions by stringing together the operator expressions in <a data-type="xref" href="#python_expression_operatorscomma_by_inc">Table 5-2</a>. For instance, the sum of two multiplications might be written as a mix of variables and operators:</p>
<pre data-type="programlisting">A * B + C * D</pre>
<p>Which raises the question: how does Python know which operation to perform first? The answer to this question lies in <em>operator precedence</em>. When you write an expression with more than one operator, Python groups its parts according to what are called <em>precedence rules</em>, and this grouping determines the order in which the expression’s parts are computed. To denote this, <a data-type="xref" href="#python_expression_operatorscomma_by_inc">Table 5-2</a> is ordered by operator precedence:</p>
<ul>
<li><p>Operators <em>lower</em> in the table have higher precedence, and so bind more <em>tightly</em> in mixed expressions. Put another way, operators <em>higher</em> in the table have lower precedence and bind less tightly than those below them.</p></li>
<li><p>Operators in the <em>same row</em> in the table generally group from <em>left to right</em> when combined (except for exponentiation, which groups right to left, and comparisons, which chain left to right).</p></li>
</ul>
<p>So, for example, if you write <code>X + Y * Z</code>, Python evaluates the multiplication first (<code>Y * Z</code>) then adds that result to <code>X</code>, because <code>*</code> has higher precedence (is lower in the table) than <code>+</code>. Similarly, in this section’s original example, both multiplications (<code>A * B</code> and <code>C * D</code>) will happen before their results are added because <code>+</code> is above <code>*</code>.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Parentheses Group Subexpressions"><div class="sect2" id="parentheses_group_subexpressions">
<h2>Parentheses Group Subexpressions</h2>
<p>You can largely forget about precedence rules if you’re careful to group parts of expressions with parentheses. When you enclose subexpressions in parentheses, you override Python’s precedence rules; Python always evaluates expressions in parentheses <em>first</em> before using their results in the enclosing expressions.</p>
<p>For instance, instead of coding <code>X + Y * Z</code>, you could write one of the following to force Python to evaluate the expression in either desired order:</p>
<pre data-type="programlisting">(X + Y) * Z
X + (Y * Z)</pre>
<p>In the first case, <code>+</code> is applied to <code>X</code> and <code>Y</code> first, because this subexpression is wrapped in parentheses. In the second case, the <code>*</code> is performed first (just as if there were no parentheses at all). Generally speaking, adding parentheses in large expressions is a good idea—it not only forces the evaluation order you want, but also aids readability.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Mixed Types Are Converted Up"><div class="sect2" id="mixed_types_are_converted_up">
<h2>Mixed Types Are Converted Up</h2>
<p>Besides mixing operators in expressions, you can also mix numeric types. For instance, you can add an integer to a floating-point number:</p>
<pre data-type="programlisting">40 + 3.14</pre>
<p>But this leads to another question: what type is the result—integer or floating point? The answer is simple, especially if you’ve used almost any other language before: in mixed-type numeric expressions, <em>operands</em> (the parts of the expression that aren’t operators) are first converted <em>up</em> to the type of the most complicated operand, and then the math is performed on same-type operands. The result is that of the up-converted operands.</p>
<p>For this, Python ranks the complexity of numeric types like so: integers are simpler than floating-point numbers, which are simpler than complex numbers. So, when an integer is mixed with a floating point, as in the preceding example, the integer is converted up to a floating-point value first, and floating-point math yields the floating-point result. See for yourself in your local Python REPL:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>40 + 3.14</strong></code>       <code><em># Integer to float, float math/result</em></code>
43.14</pre>
<p>Similarly, any mixed-type expression where one operand is a complex number results in the other operand being converted up to a complex number, and the expression yields a complex result. Conversions also run in equality and magnitude comparisons: <code>3 == 3.0</code> is true, but <code>3 &gt; 3.0</code> is not.</p>
<p>You can force the issue by calling built-in functions to convert types manually:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>int(3.1415)</strong></code>     <code><em># Truncates float to integer</em></code>
3
&gt;&gt;&gt; <code><strong>float(3)</strong></code>        <code><em># Converts integer to float</em></code>
3.0</pre>
<p>However, you won’t usually need to do this: because Python automatically converts up to the more complex type within an expression, the results are normally what you want.</p>
<p>While automatic conversions are run for both numeric and comparison operators, keep in mind that they apply only when mixing <em>numeric</em> objects (e.g., an integer and a float) in an expression. In general, Python does <em>not</em> convert across any other type boundaries automatically. Adding a string of digits to an integer, for example, results in an error, unless you manually convert one or the other; watch for an example and rationale when we explore strings in <a data-type="xref" href="ch07.html#string_fundamentals">Chapter 7</a>. Equality tests do work on mixed types (e.g., a string is never equal to any integer), but magnitude comparisons do not.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Preview: Operator Overloading and Polymorphism"><div class="sect2" id="preview_operator_overloading_and_polymo">
<h2>Preview: Operator Overloading and Polymorphism</h2>
<p>Although we’re focusing on built-in numbers right now, all Python operators may be <em>overloaded</em> (i.e., implemented) by Python classes and C extension types to work on objects you create. For instance, you’ll see later that objects coded with classes may be added or concatenated with <code>x+y</code> expressions, indexed with <code>x[i]</code> expressions, and so on.</p>
<p>Furthermore, Python itself automatically overloads some operators, such that they perform different actions depending on the type of built-in objects being processed. For example, the <code>+</code> operator performs addition when applied to numbers but performs concatenation when applied to sequence objects like strings and lists. In fact, <code>+</code> can mean anything at all when applied to objects you define with classes.</p>
<p>As we saw in the prior chapter, this property is usually called <em>polymorphism</em>—a term indicating that the meaning of an operation depends on the type of the objects being processed. We’ll revisit this concept when we explore functions in <a data-type="xref" href="ch16.html#function_basics">Chapter 16</a>, because it becomes a much more obvious feature in that <span class="keep-together">context</span>.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Numbers in Action"><div class="sect1" id="numbers_in_action">
<h1>Numbers in Action</h1>
<p>On to the code! Probably the best way to understand numeric objects and expressions is to see them in action, so with all the preceding basics in hand, let’s start up the interactive command line and try some simple but illustrative operations (be sure to see <a data-type="xref" href="ch03.html#how_you_run_programs">Chapter 3</a> for pointers if you need help starting a REPL).</p>
<section data-type="sect2" data-pdf-bookmark="Variables and Basic Expressions"><div class="sect2" id="variables_and_basic_expressions">
<h2>Variables and Basic Expressions</h2>
<p>First of all, let’s do the math to demo some basics. In the following interaction, we first assign two variables (<code>a</code> and <code>b</code>) to integers so we can use them later in a larger expression. <em>Variables</em> are simply names—created by you or Python—that are used to keep track of information in your program. We’ll say more about this in the next chapter, but in Python:</p>
<ul>
<li><p>Variables are created when they are first assigned values.</p></li>
<li><p>Variables are replaced with their values when used in expressions.</p></li>
<li><p>Variables must be assigned before they can be used in expressions.</p></li>
<li><p>Variables refer to objects and need not be declared ahead of time.</p></li>
</ul>
<p>In other words, these assignments cause the variables <code>a</code> and <code>b</code> to spring into existence automatically:</p>
<pre data-type="programlisting">$ <code><strong>python3</strong>   </code>               <code><em># Fire up a REPL</em></code>
&gt;&gt;&gt; <code><strong>a = 3</strong></code>                  <code><em># Name created: no need to declare ahead of time</em></code>
&gt;&gt;&gt; <code><strong>b = 4</strong></code></pre>
<p>This code also uses <em>comments</em>. Recall from <a data-type="xref" href="ch03.html#how_you_run_programs">Chapter 3</a> that in Python code, text after a <code>#</code> mark and continuing to the end of the line is considered to be a comment and is ignored by Python. Comments are one way to write human-readable documentation for your code, and an important part of programming. They describe aspects of the code, salient or subtle, as an aid for others (and you, six months down the road!). In the next part of the book, you’ll also meet a related feature—<em>documentation</em> <span class="keep-together"><em>strings</em>—that</span> attaches docs to objects so it’s available after your code is loaded.</p>
<p>Again, though, because code you type interactively is temporary, you won’t normally write comments in this context. If you’re working along, this means you don’t need to type any of the comment text from the <code>#</code> through to the end of the line in a REPL; it’s not a required part of the statements we’re running this way.</p>
<p>Now, let’s use our new integer objects in expressions. At this point, the values of <code>a</code> and <code>b</code> are still <code>3</code> and <code>4</code>, respectively. Variables like these are replaced with their values whenever they’re used inside an expression, and the expression results are echoed back immediately and automatically when we’re working interactively:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>a + 1, a − 1</strong></code>           <code><em># Addition (3 + 1), subtraction (3 − 1)
</em></code>(4, 2)
&gt;&gt;&gt; <code><strong>b * 3, b / 2</strong></code>           <code><em># Multiplication (4 * 3), division (4 / 2)
</em></code>(12, 2.0)                  
&gt;&gt;&gt; <code><strong>a % 2, b ** 2</strong></code>          <code><em># Modulus (remainder), power (4 ** 2)</em></code>
(1, 16)
&gt;&gt;&gt; <code><strong>2 + 4.0, 2.0 ** b</strong></code>      <code><em># Mixed-type conversions</em></code>
(6.0, 16.0)</pre>
<p>Per <a data-type="xref" href="ch03.html#how_you_run_programs">Chapter 3</a>, the results being echoed back here are <em>tuples</em> of two values because the lines typed at the prompt contain two expressions separated by commas; that’s why the results are displayed in parentheses. More importantly, these expressions work because the variables <code>a</code> and <code>b</code> within them have been assigned values. If you use a different variable that has <em>not yet been assigned</em>, Python reports an error rather than filling in some default value:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>c * 2</strong></code>
NameError: name 'c' is not defined</pre>
<p>As also previewed in <a data-type="xref" href="ch03.html#how_you_run_programs">Chapter 3</a>, you don’t need to predeclare variables in Python, but they must have been assigned at least once before you can use them. In practice, this means you have to initialize counters to zero before you can add to them, initialize lists to an empty list before you can append to them, and so on.</p>
<p>Here are two slightly larger expressions to illustrate operator grouping and more about conversions:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>b / 2 + a</strong></code>              <code><em># Same as ((4 / 2) + 3)</em></code>
5.0
&gt;&gt;&gt; <code><strong>b / (2 + a)</strong></code>            <code><em># Same as (4 / (2 + 3))</em></code>
0.8</pre>
<p>In the <em>first</em> expression, there are no parentheses, so Python automatically groups the components according to its precedence rules—because <code>/</code> is lower in <a data-type="xref" href="#python_expression_operatorscomma_by_inc">Table 5-2</a> than <code>+</code>, it binds more tightly and so is evaluated first. The result is as if the expression had been organized with parentheses as shown in the comment to the right of the code. In the <em>second</em> expression, parentheses are added around the <code>+</code> part to force Python to evaluate it first (i.e., before the <code>/</code>).</p>
<p>Also, notice that all the numbers are integers in each of these examples. Python’s <code>/</code> performs <em>true</em> division, which always retains fractional remainders and gives a floating-point result—which is in turn reflected in the result of the whole expression. You can force a fractional result by coding <code>2.0</code> instead of <code>2</code> but don’t have to. You can also opt to use <em>floor</em> division by coding these examples with <code>//</code> instead of <em>/</em>, and Python will discard decimal digits in the result; because results reflect the types of operands, you’ll get back truncated floating-point for floats:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>a, b</strong></code>                   <code><em># Same, original values</em></code>
(3, 4)

&gt;&gt;&gt; <code><strong>b // 2 + a</strong></code>             <code><em># Floor division: integer</em></code>
5
&gt;&gt;&gt; <code><strong>b // (2 + a)</strong> </code>          <code><em># Truncates fraction (for positives)</em></code>
0

&gt;&gt;&gt; <code><strong>b // 2.0 + a</strong></code>           <code><em># Auto-conversions: floating-point</em></code>
5.0
&gt;&gt;&gt; <code><strong>b // (2.0 + a)</strong></code>
0.0</pre>
<p>You’ll learn more about division later in this section.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Numeric Display Formats"><div class="sect2" id="numeric_display_formats">
<h2>Numeric Display Formats</h2>
<p>Once you start playing with Python numbers in earnest, the results of some expressions may look a bit odd the first time you see them:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>1.1 + 2.2</strong></code>               <code><em># What's up with the 3 at the end?</em></code>
3.3000000000000003
&gt;&gt;&gt; <code><strong>print(1.1 + 2.2)</strong></code>        <code><em># Same for prints</em></code>
3.3000000000000003</pre>
<p>The full story behind this odd result has to do with the limitations of floating-point hardware and its inability to exactly represent some values in a limited number of bits. Python floating-point numbers map to the underling chips on your device and are only as accurate as those chips allow—a physical constraint that can be addressed with add-ons that extend floating-point precision, as well as techniques discussed in <a data-type="xref" href="#floating_point_equality">“Floating-point equality”</a>.</p>
<p>Because computer architecture is well beyond this book’s scope, though, we’ll finesse this by saying that your computer’s floating-point hardware is doing the best it can, and neither it nor Python is in error here. In fact, this is partly a <em>display</em> issue—Python’s floating-point display logic tries to be intelligent and usually shows fewer decimal digits, but occasionally cannot. Our earlier examples gave fewer digits automatically, and you can always force the issue in programs with string formatting:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>num = 1.1 + 2.2</strong></code>
&gt;&gt;&gt; <code><strong>num</strong></code>                          <code><em># Auto-echoes (and prints)</em></code>
3.3000000000000003

&gt;&gt;&gt; <code><strong>'%e' % num</strong></code>                   <code><em># String-formatting expression</em></code>
'3.300000e+00'
&gt;&gt;&gt; <code><strong>'%.1f' % num</strong></code>                 <code><em># Alternative floating-point format</em></code>
'3.3'

&gt;&gt;&gt; <code><strong>f'{num:e}', f'{num:.1f}'</strong></code>     <code><em># F-strings (see also format method)</em></code>
('3.300000e+00', '3.3')</pre>
<p>The last three tests here employ flexible string formatting, which we will explore in full in the upcoming chapter on strings (<a data-type="xref" href="ch07.html#string_fundamentals">Chapter 7</a>). Its results are strings that are typically, but not always, printed to displays or reports.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="display_formats_str_and_repr">
<h1>Display Formats: str and repr</h1>
<p>Although it’s not yet obvious in this chapter, the default output format of interactive echoes and <code>print</code> technically correspond to the built-in <code>repr</code> and <code>str</code> functions, respectively:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>repr('hack')</strong></code>           <code><em># Used by echoes: as-code form</em></code>
"'hack'"
&gt;&gt;&gt; <code><strong>str('hack')</strong></code>            <code><em># Used by print: user-friendly form</em></code>
'hack'</pre>
<p>Both of these convert arbitrary objects to their string representations: <code>repr</code> (and the default interactive echo) produces results that look as though they were code; <code>str</code> (and the <code>print</code> operation) converts to a typically more user-friendly format if available. Some objects have both—a <code>str</code> for general use, and a <code>repr</code> with extra details. This notion will resurface when we explore both strings and operator overloading in classes.</p>
<p>Besides providing print strings for arbitrary objects, the <code>str</code> built-in is also the name of the string object type, which can be called with an encoding name to decode a Unicode string from a byte string as an alternative to the <code>bytes.decode</code> method introduced briefly in <a data-type="xref" href="ch04.html#introducing_python_objects">Chapter 4</a>. You’ll learn more about this advanced <code>str</code> role in <a data-type="xref" href="ch37.html#unicode_and_byte_strings">Chapter 37</a>.</p>
</div></aside>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Comparison Operators"><div class="sect2" id="comparisons_operators">
<h2>Comparison Operators</h2>
<p>So far, we’ve been dealing with standard numeric operations (e.g., addition and multiplication), but numbers, like all Python objects, can also be compared. Normal comparisons work for numbers exactly as you’d expect—they compare the relative magnitudes of their operands and return a Boolean result, which we would normally test and take action on in a larger statement and program (e.g., see the intro to <code>if</code> in <a data-type="xref" href="ch04.html#introducing_python_objects">Chapter 4</a>):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>1 &lt; 2</strong></code>                  <code><em># Less than (magnitude)</em></code>
True
&gt;&gt;&gt; <code><strong>2.0 &gt;= 1</strong></code>               <code><em># Greater than or equal: mixed-type 1 converted to 1.0</em></code>
True
&gt;&gt;&gt; <code><strong>2.0 == 2.0</strong></code>             <code><em># Equal value</em></code>
True
&gt;&gt;&gt; <code><strong>2.0 != 2.0</strong></code>             <code><em># Not equal value</em></code>
False</pre>
<p>Notice again how mixed types are allowed in numeric expressions (only); in the second test here, Python compares values in terms of the more complex type, float.</p>
<section data-type="sect3" data-pdf-bookmark="Chained comparisons"><div class="sect3" id="chained_comparisons">
<h3>Chained comparisons</h3>
<p>Interestingly, Python also allows us to <em>chain</em> multiple comparisons together to perform range tests. Chained comparisons are a sort of shorthand for larger Boolean expressions. In short, Python lets us string together magnitude comparison tests to code chained comparisons such as range tests. The expression <code>(A &lt; B &lt; C)</code>, for instance, tests whether <code>B</code> is between <code>A</code> and <code>C</code>, noninclusively; it is equivalent to the Boolean test <code>(A &lt; B and B &lt; C)</code> but is easier on the eyes (and the keyboard). For example, assume the following assignments:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>X = 2</strong></code>
&gt;&gt;&gt; <code><strong>Y = 4</strong></code>
&gt;&gt;&gt; <code><strong>Z = 6</strong></code></pre>
<p>The following two expressions have identical effects, but the first is shorter to type, and it may run slightly faster since Python needs to evaluate <code>Y</code> only once—and it may matter if <code>Y</code> is a call to a complicated function:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>X &lt; Y &lt; Z</strong></code>              <code><em># Chained comparisons: range tests</em></code>
True
&gt;&gt;&gt; <code><strong>X &lt; Y and Y &lt; Z</strong></code>
True</pre>
<p>The same equivalence holds for false results, and arbitrary chain lengths are allowed:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>X &lt; Y &gt; Z</strong></code>
False
&gt;&gt;&gt; <code><strong>X &lt; Y and Y &gt; Z</strong></code>
False

&gt;&gt;&gt; <code><strong>1 &lt; 2 &lt; 3.0 &lt; 4</strong></code>
True
&gt;&gt;&gt; <code><strong>1 &gt; 2 &gt; 3.0 &gt; 4</strong></code>
False</pre>
<p>You can use other comparisons in chained tests, but the resulting expressions can become nonintuitive unless you evaluate them the way Python does. The first of the following, for instance, is false just because 1 is not equal to 2:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>1 == 2 &lt; 3</strong></code>               <code><em># Same as: (1 == 2) and (2 &lt; 3), but not: False &lt; 3!</em></code>
False      
&gt;&gt;&gt; <code><strong>True is False is True</strong></code>    <code><em># Same as: (True is False) and (False is True)</em></code>
False</pre>
<p>Python does not compare the <code>1 == 2</code> expression’s <code>False</code> result to 3—this would technically mean the same as <code>0 &lt; 3</code>, which would be <code>True</code> (you’ll learn more about the <code>True</code> and <code>False</code> objects later in this chapter and explore the rarely used <code>is</code> identity operator in the next).</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Floating-point equality"><div class="sect3" id="floating_point_equality">
<h3>Floating-point equality</h3>
<p>One last note here before we move on: chaining aside, numeric comparisons are based on magnitudes, which are generally simple—though <em>floating-point</em> numbers may not always work as you’d expect, and may require conversions or other massaging to be compared meaningfully:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>1.1 + 2.2 == 3.3</strong> </code>             <code><em># Shouldn't this be True?</em></code>
False
&gt;&gt;&gt; <code><strong>1.1 + 2.2</strong></code>                     <code><em># Close to 3.3, but not exactly: limited precision</em></code>
3.3000000000000003</pre>
<p>This is related to the earlier coverage of numeric display formats and stems from the fact that floating-point numbers cannot represent some values exactly due to their limited number of bits—a fundamental issue in numeric programming not unique to Python. To accommodate this imprecision in equality tests, either truncate, round, use floors, or, as of Python 3.5, import and call the <code>math</code> standard-library module’s <code>isclose</code>, which is true if values are within a tolerance of each other (there’s more on <code>math</code> and floors ahead, and more on <code>isclose</code> in Python’s manuals):</p>
<pre data-type="programlisting" class="pagebreak-before">&gt;&gt;&gt; <code><strong>int(1.1 + 2.2) == int(3.3)</strong></code>        <code><em># OK if convert: see also floor, trunc ahead</em></code>
True
&gt;&gt;&gt; <code><strong>round(1.1 + 2.2, 1) == round(3.3, 1)</strong></code>
True
&gt;&gt;&gt; <code><strong>import math</strong>   </code>                    <code><em># Import modules to call their functions</em></code>
&gt;&gt;&gt; <code><strong>math.isclose(1.1 + 2.2, 3.3)</strong> </code>     <code><em># Within default-but-passable tolerances</em></code>
True</pre>
<p>We’ll revisit this later in this chapter when we meet <em>decimals</em> and <em>fractions</em>, which can also address such limitations. First, though, let’s continue our tour of Python’s core numeric operations, with a deeper look at division.</p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Division Operators"><div class="sect2" id="division_operators">
<h2>Division Operators</h2>
<p>Python has two division operators introduced earlier, as well as one that’s strongly related. Here’s the whole gang:</p>
<dl>
<dt><code>X / Y</code></dt>
<dd>Called <em>true</em> division, this always keeps remainders in floating-point results, regardless of types.</dd>
<dt><code>X // Y</code></dt>
<dd>Called <em>floor</em> division, this always truncates fractional remainders down to their floor, regardless of types, and its result type depends on the types of its operands.</dd>
<dt><code>X % Y</code></dt>
<dd>Called <em>modulus</em>, this returns a division’s remainder, with a result type that varies per operand types. This also does formatting when used on strings, per <a data-type="xref" href="ch07.html#string_fundamentals">Chapter 7</a>.</dd>
</dl>
<p>The following demos the two <em>division</em> operators at work:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>10 / 4</strong> </code>             <code><em># True div: keeps remainder always</em></code>
2.5
&gt;&gt;&gt; <code><strong>10 / 4.0</strong></code>            <code><em># Same for floats
</em></code>2.5
&gt;&gt;&gt; <code><strong>10 // 4</strong> </code>            <code><em># Floor div: drops remainder always</em></code>
2
&gt;&gt;&gt; <code><strong>10 // 4.0</strong></code>           <code><em># Same for floats, but type varies</em></code>
2.0</pre>
<p>Notice that the object type of the result for <code>//</code> is dependent on its operand’s types: if either is a float, the result is a float; otherwise, it is an integer. If you want to ensure an integer result, simply wrap the expression in <code>int</code> to convert:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>int(10 // 4.0)</strong></code>
2</pre>
<p>The related <em>modulus</em> returns the remainder of division with a type to match operands (useful when your code needs to know how much is “left over” after a <code>//</code>), and the <code>divmod</code> built-in function gives both parts when needed:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>10 % 3, 10 % 3.0</strong></code>    <code><em># Remainder of division: (3 * 3) + 1</em></code>
(1, 1.0)
&gt;&gt;&gt; <code><strong>divmod(10, 3)</strong></code>       <code><em># Both parts of division in a tuple</em></code>
(3, 1)</pre>
<section data-type="sect3" data-pdf-bookmark="Floor versus truncation"><div class="sect3" id="floor_versus_truncation">
<h3>Floor versus truncation</h3>
<p>One subtlety here: the <code>//</code> operator is informally called <em>truncating</em> division, but it’s more accurate to refer to it as <em>floor</em> division—it truncates the result down to its floor, which means the closest whole number below the true result. The net effect is to round down, not strictly truncate, and this matters for negatives. You can see the difference for yourself with the Python <code>math</code> module (as you’ve learned, modules must be imported before you can use their contents):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>import math</strong></code>
&gt;&gt;&gt; <code><strong>math.floor(2.5)</strong></code>           <code><em># Closest number below value</em></code>
2
&gt;&gt;&gt; <code><strong>math.floor(-2.5)</strong></code>          <code><em># But not truncation for negative!</em></code>
-3
&gt;&gt;&gt; <code><strong>math.trunc(2.5)</strong></code>           <code><em># Truncate fractional part (toward zero)</em></code>
2
&gt;&gt;&gt; <code><strong>math.trunc(-2.5)</strong></code>          <code><em># And is truncation for negative</em></code>
-2</pre>
<p>When running division operators, you only really truncate for positive results, since truncation is then the same as floor; for negatives, it’s a floor result. Really, they are both floor, but floor just happens to be the same as truncation for positives (<em>cut-and-pasters</em>: if minus signs morph to Unicode dashes in this book, replace them with simple ASCII “-” hyphens to run; Python requires the latter for the minus sign, and tools are notorious for botching this):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>5 / 2, 5 / -2</strong>   </code>          <code><em># True division keeps remainders</em></code>
(2.5, −2.5)

&gt;&gt;&gt; <code><strong>5 // 2, 5 // -2</strong></code>           <code><em># Truncates to floor: rounds to first lower integer</em></code>
(2, −3)

&gt;&gt;&gt; <code><strong>5 / 2.0, 5 / -2.0</strong></code>         <code><em># Ditto for floats</em></code>
(2.5, −2.5)

&gt;&gt;&gt; <code><strong>5 // 2.0, 5 // -2.0</strong></code>       <code><em># Though result is float too
</em></code>(2.0, −3.0)</pre>
<p>If you really want truncation toward zero regardless of sign, you can always run a true division result through <code>math.trunc</code> (as demoed earlier, the <code>round</code> built-in has related functionality and the <code>int</code> built-in has the same effect, and neither requires an import):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>import math</strong></code>
&gt;&gt;&gt; <code><strong>5 / −2</strong></code>                    <code><em># Keep remainder</em></code>
−2.5
&gt;&gt;&gt; <code><strong>5 // −2</strong></code>                   <code><em># Floor below result</em></code>
-3
&gt;&gt;&gt; <code><strong>math.trunc(5 / −2)</strong></code>        <code><em># Truncate instead of floor (same as int())</em></code>
−2</pre>
<p>So why the fuss over truncation? This won’t be obvious until you graduate to writing larger Python programs later in this book, but it’s an essential tool in some use cases. Watch for a prime-number <code>while</code> loop example in <a data-type="xref" href="ch13.html#while_and_for_loops">Chapter 13</a> and a corresponding exercise at the end of <a data-type="xref" href="part04.html#functions_and_generators">Part IV</a> that wholly rely on the truncating behavior of <code>//</code>.</p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Integer Precision"><div class="sect2" id="integer_precision">
<h2>Integer Precision</h2>
<p>Python division may come in multiple flavors, but it’s still fairly standard as programming languages go. Here’s something a bit more unusual. As mentioned earlier, Python integers support unlimited size:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>999999999999999999999999999999 + 1</strong></code>
1000000000000000000000000000000</pre>
<p>Unlimited-precision integers are a convenient built-in tool. For instance, you can use them to count your country’s national debt in Python without numeric-value overflow (which is, of course, more impressive and resource intensive in some locales than others). More universally, a 2 raised to the power 269 isn’t particularly large, but nearly breaches this page’s width limits, and much larger numbers work sans the safeguards against DOS attacks noted in <a data-type="xref" href="ch04.html#introducing_python_objects">Chapter 4</a>:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>2 ** 269</strong></code>
948568795032094272909893509191171341133987714380927500611236528192824358010355712

&gt;&gt;&gt; <code><strong>x = 2 ** 1000000</strong></code>
&gt;&gt;&gt; <code><strong>x</strong></code>
ValueError: Exceeds the limit (4300 digits) for integer string conversion; 
use sys.set_int_max_str_digits() to increase the limit</pre>
<p>Because Python must do extra work to support the extended precision, integer math is usually substantially slower than normal when numbers grow large. However, if you need the precision, the fact that it’s built in for you to use will likely outweigh its performance penalty.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Complex Numbers"><div class="sect2" id="complex_numbers">
<h2>Complex Numbers</h2>
<p>Although less commonly used than the types we’ve been exploring thus far, complex numbers are a distinct core object type in Python. They are typically used in engineering and science applications. If you know what they are, you know why they are useful; if not, consider this section optional reading (until they appear in code you must reuse).</p>
<p>Complex numbers are represented as two floating-point numbers—the real and imaginary parts—and you code them by adding a <code>j</code> or <code>J</code> suffix to the imaginary part. We can also write complex numbers with a nonzero real part by adding the two parts with a <code>+</code>. For example, the complex number with a real part of <code>2</code> and an imaginary part of <code>−3</code> is written <code>2 + −3j</code>. Here are some examples of complex math at work:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>1j * 1J</strong></code>
(-1+0j)
&gt;&gt;&gt; <code><strong>2 + 1j * 3</strong></code>
(2+3j)
&gt;&gt;&gt; <code><strong>(2 + 1j) * 3</strong></code>
(6+3j)</pre>
<p>Complex numbers also allow us to extract their parts as attributes (via attributes <code>real</code> and <code>imag</code>), support all the usual mathematical expressions, and may be processed with tools in the standard <code>cmath</code> module (the complex analogue of the standard <code>math</code> module). Because complex numbers are rare in most programming domains, though, we’ll skip the rest of this story here. Check Python’s language reference manual for additional details.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Hex, Octal, and Binary"><div class="sect2" id="hexcomma_octalcomma_and_binary">
<h2>Hex, Octal, and Binary</h2>
<p>As previewed near the start of this chapter, Python integers can be coded in hexadecimal, octal, and binary notation, in addition to the normal base-10 decimal coding we’ve been using so far. The first three of these may at first seem foreign to 10-fingered beings, but some programmers find them <span class="keep-together">convenient</span> alternatives for specifying values, especially when their mapping to bytes and bits is important. We detailed coding rules before; let’s try these out live.</p>
<p>As noted earlier, these other-base <em>literals</em> are simply an alternative syntax for specifying the value of an integer object. For example, the following literals produce normal integers with the specified values. In memory, an integer’s value is the same, regardless of the base we use to specify it in our code:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>0x01, 0x10, 0xFF</strong></code>            <code><em># Hex literals: base 16, digits 0-9/A-F</em></code>
(1, 16, 255)
&gt;&gt;&gt; <code><strong>0o1, 0o20, 0o377</strong></code>            <code><em># Octal literals: base 8, digits 0-7</em></code>
(1, 16, 255)
&gt;&gt;&gt; <code><strong>0b1, 0b10000, 0b11111111</strong></code>    <code><em># Binary literals: base 2, digits 0-1
</em></code>(1, 16, 255)</pre>
<p>Here, the hex value <code>0xFF</code>, the octal value <code>0o377</code>, and the binary value <code>0b11111111</code> are all decimal <code>255</code>. The <code>F</code> digits in the hex value, for example, each mean <code>15</code> in decimal and a 4-bit <code>1111</code> in binary, and reflect powers of 16. Thus, the hex value <code>0xFF</code> and others convert to decimal values as follows:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>0xFF, (15 * (16 ** 1)) + (15 * (16 ** 0))</strong></code>     <code><em># How hex/binary map to decimal</em></code>
(255, 255)
&gt;&gt;&gt; <code><strong>0x2F, (2  * (16 ** 1)) + (15 * (16 ** 0))</strong></code>
(47, 47)
&gt;&gt;&gt; <code><strong>0xF, 0b1111, (1*(2**3) + 1*(2**2) + 1*(2**1) + 1*(2**0))</strong></code>
(15, 15, 15)</pre>
<p>Python prints integer values in decimal (base 10) by default, but it also provides built-in functions that convert integers to other bases’ digit strings formatted per Python-literal syntax—useful when programs or users expect to see values in a given base:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>oct(64), hex(64), bin(64)</strong></code>               <code><em># Numbers=&gt;digit strings</em></code>
('0o100', '0x40', '0b1000000')</pre>
<p>The <code>oct</code> function converts decimal to octal, <code>hex</code> to hexadecimal, and <code>bin</code> to binary—all as strings. To go the other way, the built-in <code>int</code> function converts a string of digits to an integer, and an optional second argument lets you specify the numeric base—useful for numbers read from files as strings instead of coded in scripts:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>64, 0o100, 0x40, 0b1000000</strong></code>              <code><em># Digits=&gt;numbers in scripts and strings</em></code>
(64, 64, 64, 64)

&gt;&gt;&gt; <code><strong>int('64'), int('100', 8), int('40', 16), int('1000000', 2)</strong></code>
(64, 64, 64, 64)

&gt;&gt;&gt; <code><strong>int('0x40', 16), int('0b1000000', 2)</strong></code>    <code><em># Literal forms supported too</em></code>
(64, 64)</pre>
<p>The <code>eval</code> function can also be used to convert digit strings to numbers, because it treats strings as though they were Python code. Therefore, it has a similar effect, but usually runs more <em>slowly</em>—it actually compiles and runs the string as a piece of a program, and it assumes the string being run comes from a <em>trusted source</em>—a clever user might be able to submit a string that deletes files on your machine. In other words, be sparing and careful with this call:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>eval('64'), eval('0o100'), eval('0x40'), eval('0b1000000')</strong></code>
(64, 64, 64, 64)</pre>
<p>Finally, you can also convert integers to base-specific strings with any of Python’s three <em>string-formatting</em> tools, though you’ll have to take this partly on faith until we reach strings’ full coverage in <a data-type="xref" href="ch07.html#string_fundamentals">Chapter 7</a>:</p>
<pre data-type="programlisting" class="pagebreak-before">&gt;&gt;&gt; <code><strong>'%o, %x, %#X' % (64, 255, 255)</strong></code>          <code><em># Numbers=&gt;digits formatting*3</em></code>
'100, ff, 0XFF'

&gt;&gt;&gt; <code><strong>'{:o}, {:b}, {:x}, {:#X}'.format(64, 64, 255, 255)</strong></code>
'100, 1000000, ff, 0XFF'
 
&gt;&gt;&gt; <code><strong>f'{64:o}, {64:b}, {255:x}, {255:#X}'</strong></code>    <code><em># The newest latest-and-greatest</em></code>
'100, 1000000, ff, 0XFF'</pre>
<p>In this code, <code>o</code>, <code>b</code>, and <code>x</code> format as octal, binary, and hex, respectively, and <code>#X</code> adds a base prefix and uses uppercase. As an aside, you can avoid the repeated inputs in each of these three formatting tools (but you’re probably starting to see why picking just one is generally a good idea—and why feature redundancy is generally a bad idea!):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>'%(i)o, %(j)x, %(j)#X' % dict(i=64, j=255)</strong></code>
'100, ff, 0XFF'
&gt;&gt;&gt; <code><strong>'{0:o}, {0:b}, {1:x}, {1:#X}'.format(64, 255)</strong></code>
'100, 1000000, ff, 0XFF'
&gt;&gt;&gt; <code><strong>f'{(i:=64):o}, {i:b}, {(i:=255):x}, {i:#X}'</strong></code>
'100, 1000000, ff, 0XFF'</pre>
<p>Before we move on, keep in mind that other-base literals and converters support <em>arbitrarily</em> large integers too. The following, for instance, creates an integer in hex and displays it in decimal and octal and binary with converters:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>X = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF</strong></code>
&gt;&gt;&gt; <code><strong>X</strong></code>
5192296858534827628530496329220095
&gt;&gt;&gt; <code><strong>oct(X)</strong></code>
'0o17777777777777777777777777777777777777'
&gt;&gt;&gt; <code><strong>bin(X)</strong></code>
'0b111111111111111111111111111111111111111111111111111111111 ...<code><em>and so on</em></code>... 11111'</pre>
<p>Speaking of binary digits, the next section takes us on a tour of tools that process numbers’ individual bits.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Bitwise Operations"><div class="sect2" id="bitwise_operations">
<h2>Bitwise Operations</h2>
<p>Besides the normal numeric operations (addition, subtraction, and so on), Python supports most of the numeric expressions available in the C language. This includes operators that treat integers as strings of <em>binary bits</em> and can come in handy if your Python code must deal with things like network packets, serial ports, or packed binary data produced by or intended for a C program.</p>
<p>We can’t dwell on the fundamentals of Boolean math here—again, those who must use it probably already know how it works, and others can often postpone the topic altogether—but the basics are straightforward. For instance, here are some of Python’s bitwise expression operators at work performing bitwise shift and Boolean operations on integers:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>x = 1</strong></code>                <code><em># 1 decimal is 0001 in bits</em></code>
&gt;&gt;&gt; <code><strong>x &lt;&lt; 2</strong></code>               <code><em># Shift left 2 bits: 0100</em></code>
4
&gt;&gt;&gt; <code><strong>x | 3</strong> </code>               <code><em># Bitwise OR (either bit=1): 0001 | 0011</em></code>
3
&gt;&gt;&gt; <code><strong>x &amp; 3</strong></code>                <code><em># Bitwise AND (both bits=1): 0001 &amp; 0011</em></code>
1</pre>
<p>In the first expression, a binary <code>1</code> (in base 2, <code>0001</code>) is shifted left two slots to create a binary <code>4</code> (<code>0100</code>). The last two operations perform a binary OR to combine bits (<code>0001|0011</code> = <code>0011</code>) and a binary AND to select common bits (<code>0001&amp;0011</code> = <code>0001</code>). Such bit-masking operations allow us to encode and extract multiple flags and other values within a single integer.</p>
<p>This is one area where the binary and hexadecimal number support in Python become especially <span class="keep-together">useful—they</span> allow us to code and inspect numbers by bit-strings:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>X = 0b0001</strong></code>           <code><em># Binary literals</em></code>
&gt;&gt;&gt; <code><strong>X &lt;&lt; 2</strong></code>               <code><em># Shift left</em></code>
4
&gt;&gt;&gt; <code><strong>bin(X &lt;&lt; 2)</strong></code>          <code><em># Binary digits string
</em></code>'0b100'

&gt;&gt;&gt; <code><strong>bin(X | 0b0011)</strong></code>      <code><em># Bitwise OR: either
</em></code>'0b11'
&gt;&gt;&gt; <code><strong>bin(X &amp; 0b11)</strong></code>        <code><em># Bitwise AND: both</em></code>
'0b1'</pre>
<p>This is also true for values that begin life as hex literals, or undergo base conversions:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>X = 0xFF</strong> </code>            <code><em># Hex literals
</em></code>&gt;&gt;&gt; <code><strong>bin(X)</strong></code>
'0b11111111'
&gt;&gt;&gt; <code><strong>X ^ 0b10101010</strong></code>       <code><em># Bitwise XOR: either but not both</em></code>
85
&gt;&gt;&gt; <code><strong>bin(X ^ 0b10101010)</strong></code>
'0b1010101'

&gt;&gt;&gt; <code><strong>int('01010101', 2)</strong></code>   <code><em># Digits=&gt;number: string to int per base</em></code>
85
&gt;&gt;&gt; <code><strong>hex(85)</strong></code>              <code><em># Number=&gt;digits: Hex digit string
</em></code>'0x55'</pre>
<p>Also in this department, Python integers come with a <code>bit_length</code> method, which allows you to query the number of bits required to represent the number’s value in binary. Sharp-eyed readers might point out that you can often achieve the same effect by subtracting 2 from the length of the <code>bin</code> string using the <code>len</code> built-in function we first used in <a data-type="xref" href="ch04.html#introducing_python_objects">Chapter 4</a> (to account for the leading “0b”), though its temporary string result may make it less efficient:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>X = 99</strong></code>
&gt;&gt;&gt; <code><strong>bin(X), X.bit_length(), len(bin(X)) - 2</strong></code>
('0b1100011', 7, 7)
&gt;&gt;&gt; <code><strong>bin(256), (256).bit_length(), len(bin(256)) - 2</strong></code>
('0b100000000', 9, 9)</pre>
<p>We won’t go into much more detail on such “bit twiddling” here. It’s supported if you need it, but bitwise operations are often not as important in a high-level language such as Python as they are in a low-level language such as C. As a rule of thumb, if you find yourself wanting to flip bits in Python, you should think about which language you’re really coding. As you’ll see in upcoming chapters, Python’s lists, dictionaries, and the like provide richer ways to encode information than bit strings, especially when your data’s audience includes readers of the human variety.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Underscore Separators in Numbers"><div class="sect2" id="underscore_separators_in_numbers">
<h2>Underscore Separators in Numbers</h2>
<p>If you’re finding it hard to read the longer digit strings in this chapter, there’s some good news: as of 3.6, numeric literals in Python can be coded with embedded underscores (“_”) to group digits for easier viewing. These underscores don’t modify number values; Python simply discards them after reading your code. They do, however, work on all the numbers and bases we’ve met, including complex-number parts and float-point decimal digits, and can enhance the readability of numeric literals in your scripts. Here’s how they look—with before on the left and after on the right:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>9999999999999 == 9_999_999_999_999</strong>  </code>               <code><em># Decimal: thousands</em></code>
True
&gt;&gt;&gt; <code><strong>0xFFFFFFFF == 0xFF_FF_FF_FF</strong></code>                        <code><em># Hex: 8-bit bytes</em></code>
True
&gt;&gt;&gt; <code><strong>0o777777777777 == 0o777_777_777_777</strong> </code>               <code><em># Octal: 9 bits each</em></code>
True 
&gt;&gt;&gt; <code><strong>0b1111111111111111 == 0b1111_1111_1111_1111</strong>   </code>     <code><em># Binary: 4-bit nibbles</em></code>
True
&gt;&gt;&gt; <code><strong>3.141592653589793 == 3.141_592_653_589_793</strong></code>         <code><em># Float: decimal digits</em></code>
True
&gt;&gt;&gt; <code><strong>123456789.123456789 == 123_456_789.123_456_789</strong></code>     <code><em># Float: both sides</em></code>
True</pre>
<p>While this is a useful feature, you should keep in mind that it’s just skin deep. For example, numbers lose their underscores once read. You can add back comma and underscore separators with the <em>string-formatting</em> method and f-string we’ll explore in <a data-type="xref" href="ch07.html#string_fundamentals">Chapter 7</a>, but this is mostly just for display, and the originals are lost:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>x = 9_999_998</strong>  </code>            <code><em># Your number with "_"s for digit groupings</em></code>
&gt;&gt;&gt; <code><strong>x</strong> </code>                         <code><em># But dropped when read: not in displays</em></code>
9999998
&gt;&gt;&gt; <code><strong>x + 1</strong></code>                      <code><em># Ditto for derived computation results</em></code>
9999999

&gt;&gt;&gt; <code><strong>f'{x:,} and {x:_}'</strong></code>         <code><em># Formatting adds separators, but just for show</em></code>
'9,999,998 and 9_999_998'</pre>
<p>Moreover, Python doesn’t do any sort of sanity checks on underscores, except for disallowing leading, trailing, and multiple-appearance uses. The underscores are really just digit “spacers” that can be used—and misused—arbitrarily:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>99_9</strong></code>                       <code><em># No position-error checking provided</em></code>
999
&gt;&gt;&gt; <code><strong>1_23_456_7890</strong></code>              <code><em># Hmm…</em></code>
1234567890

&gt;&gt;&gt; <code><strong>_9</strong></code>
NameError: name '_9' is not defined. Did you mean: '_'?
&gt;&gt;&gt; <code><strong>9_</strong></code>
SyntaxError: invalid decimal literal
&gt;&gt;&gt; <code><strong>9_9__9</strong></code>
SyntaxError: invalid decimal literal

&gt;&gt;&gt; <code><strong>9_9_9</strong></code>                      <code><em># Syntax oddities checked, semantics not</em></code>
999
&gt;&gt;&gt; <code><strong>hex(0xf_ff_fff_f_f)</strong></code>        <code><em># And Python won't retain your "_"s</em></code>
'0xffffffff'</pre>
<p>Also bear in mind that <em>commas</em> cannot be used in numeric literals you code—despite their similarity, underscores are essentially ignored as documentation, but commas are taken to be <em>tuple</em> item separators if erroneously used:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>12_345_678</strong>  </code>               <code><em># Underscores are ignored</em></code> 
12345678
&gt;&gt;&gt; <code><strong>12,345,678</strong>  </code>               <code><em># But commas mean a tuple!</em></code>
(12, 345, 678)</pre>
<p>Underscores can enhance readability to be sure, but they are largely cosmetic and apply only to large numeric literals in your code—because typical Python programs <em>compute</em> most numbers rather than <em>hardcoding</em> them, this seems likely to be uncommon in practice. A more promising use case is <em>input</em>—string-to-number converters allow underscores too:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>int('1_234_567')</strong></code>           <code><em># Works in text read from data files too</em></code>
1234567
&gt;&gt;&gt; <code><strong>eval('1_234_567')</strong></code>          <code><em># But does raw-data readability matter?</em></code>
1234567
&gt;&gt;&gt; <code><strong>float('1_2_34.567_8_90')</strong></code>
1234.56789</pre>
<p>But it’s difficult to justify underscores on data alone, given that scripts could simply strip underscores themselves. Like all such tools, use when it makes sense (and don’t be shocked if this crops up in unfair interview questions!).<strong></strong></p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Other Built-in Numeric Tools"><div class="sect2" id="other_built_in_numeric_tools">
<h2>Other Built-in Numeric Tools</h2>
<p>In addition to its core object types, Python also provides both built-in <em>functions</em> and standard-library <em>modules</em> for numeric processing. The <code>pow</code> and <code>abs</code> built-in functions, for instance, compute powers and absolute values, respectively. Here’s a brief roundup of common tools in the built-in <code>math</code> module (which contains most of the tools in the C language’s math library), along with a few numeric built-in functions:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>import math</strong></code>
&gt;&gt;&gt; <code><strong>math.pi, math.e</strong></code>                               <code><em># Common constants
</em></code>(3.141592653589793, 2.718281828459045)

&gt;&gt;&gt; <code><strong>math.sin(2 * math.pi / 180)</strong></code>                   <code><em># Sine, tangent, cosine</em></code>
0.03489949670250097

&gt;&gt;&gt; <code><strong>math.sqrt(144), math.sqrt(2)</strong></code>                  <code><em># Square root</em></code>
(12.0, 1.4142135623730951)

&gt;&gt;&gt; <code><strong>pow(2, 4), 2 ** 4, 2.0 ** 4.0</strong></code>                 <code><em># Exponentiation (power)</em></code>
(16, 16, 16.0)

&gt;&gt;&gt; <code><strong>abs(-62.0), sum((1, 2, 3, 4))</strong></code>                 <code><em># Absolute value, summation</em></code>
(62.0, 10)

&gt;&gt;&gt; <code><strong>min(3, 1, 2, 4), max(3, 1, 2, 4)</strong></code>              <code><em># Minimum, maximum</em></code>
(1, 4)</pre>
<p>The <code>sum</code> function shown here works on a sequence (really, <em>iterable</em>) of numbers, and <code>min</code> and <code>max</code> accept either a collection or individual arguments. There are also multiple ways to drop the decimal digits of floating-point numbers, both for calculations and displays; some of these are richer than previously shown:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>math.floor(2.567), math.floor(-2.567)</strong></code>            <code><em># Floor: next-lower integer</em></code>
(2, −3)

&gt;&gt;&gt; <code><strong>math.trunc(2.567), math.trunc(−2.567)</strong></code>            <code><em># Truncate: drop digits</em></code> 
(2, −2)

&gt;&gt;&gt; <code><strong>int(2.567), int(−2.567)</strong></code>                          <code><em># Truncate: alternative</em></code>
(2, −2)

&gt;&gt;&gt; <code><strong>round(2.567), round(2.567, 2), round(2567, -3)</strong></code>   <code><em># Round to digits (+/-)</em></code>
(3, 2.57, 3000)

&gt;&gt;&gt; <strong>'%.1f' % 2.567, '{0:.2f}'.format(2.567)</strong>         <em># Format display (Chapter 7)</em>
('2.6', '2.57')</pre>
<p>As shown earlier, the last of these produces strings that we would usually print and supports a variety of formatting options. String formatting is still subtly different, though: <code>round</code> rounds and drops decimal digits but still produces a number in memory, whereas string formatting produces a string, not a <span class="keep-together">number</span>:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>(1 / 3.0), round(1 / 3.0, 2), f'{(1 / 3.0):.2f}'</strong></code>
(0.3333333333333333, 0.33, '0.33')</pre>
<p>Interestingly, there are three ways to compute <em>square roots</em> in Python: using a module function, an expression, or a built-in function (if you’re interested in performance, we will revisit these in an exercise and its solution at the end of <a data-type="xref" href="part04.html#functions_and_generators">Part IV</a>, to see which runs quicker):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>import math</strong></code>
&gt;&gt;&gt; <code><strong>math.sqrt(144)</strong></code>              <code><em># Module</em></code>
12.0
&gt;&gt;&gt; <code><strong>144 ** .5</strong></code>                   <code><em># Expression</em></code>
12.0
&gt;&gt;&gt; <code><strong>pow(144, .5)</strong></code>                <code><em># Built-in</em></code>
12.0</pre>
<p>Notice that standard-library modules such as <code>math</code> must be imported, but built-in functions such as <code>abs</code> and <code>round</code> are always available without imports. This is because modules are external components, but built-in functions live in an implied namespace that Python automatically searches to find names used in your program. This namespace simply corresponds to the standard-library module called <code>builtins</code>, and there is much more about name resolution in the function and module parts of this book; for now, when you hear “module,” think “import.”</p>
<p>The standard library’s <code>statistics</code> and <code>random</code> modules must be imported as well. Both modules provide an array of tools; <code>statistics</code> supports operations commonly found on calculators, and <code>random</code> enables tasks such as picking a random number between 0 and 1 and selecting a random integer between two numbers:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>import statistics</strong></code>
&gt;&gt;&gt; <code><strong>statistics.mean([1, 2, 4, 5, 7])</strong>   </code>     <code><em># Average, median</em></code>
3.8
&gt;&gt;&gt; <code><strong>statistics.median([1, 2, 4, 5, 7])</strong></code>      <code><em># And a whole lot more: see its docs</em></code>
4

&gt;&gt;&gt; <code><strong>import random</strong></code>
&gt;&gt;&gt; <code><strong>random.random()</strong></code>
0.5566014960423105
&gt;&gt;&gt; <code><strong>random.random()</strong></code>              <code><em># Random floats, integers, choices, shuffles</em></code>
0.051308506597373515

&gt;&gt;&gt; <code><strong>random.randint(1, 10)</strong></code>
5
&gt;&gt;&gt; <code><strong>random.randint(1, 10)</strong></code>
9</pre>
<p>The <code>random</code> module can also <em>choose</em> an item at random from a sequence, and <em>shuffle</em> a list of items <span class="keep-together">randomly</span>:</p>
<pre data-type="programlisting" class="pagebreak-before">&gt;&gt;&gt; <code><strong>random.choice(['Pizza', 'Tacos', 'Tikka', 'Lasagna'])</strong></code>
'Tikka'
&gt;&gt;&gt; <code><strong>random.choice(['Pizza', 'Tacos', 'Tikka', 'Lasagna'])</strong></code>
'Lasagna'

&gt;&gt;&gt; <code><strong>suits = ['hearts', 'clubs', 'diamonds', 'spades']</strong></code>
&gt;&gt;&gt; <code><strong>random.shuffle(suits)</strong></code>
&gt;&gt;&gt; <code><strong>suits</strong></code>
['spades', 'hearts', 'diamonds', 'clubs']
&gt;&gt;&gt; <code><strong>random.shuffle(suits)</strong></code>
&gt;&gt;&gt; <code><strong>suits</strong></code>
['clubs', 'diamonds', 'hearts', 'spades']</pre>
<p>Though we’d need additional code to make this more tangible here, the <code>random</code> module can be useful for shuffling cards in games, picking images at random in a slideshow GUI, performing statistical simulations, and much more. We’ll deploy it again later in this book (e.g., in <a data-type="xref" href="ch20.html#comprehensions_and_generations">Chapter 20</a>’s permutations case study), but for more details, consult Python’s library manual.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Other Numeric Objects"><div class="sect1" id="other_numeric_objects">
<h1>Other Numeric Objects</h1>
<p>So far in this chapter, we’ve been using Python’s core numeric types—integer, floating point, and complex. These will suffice for most of the number crunching that many programmers will ever need to do. Python comes with a handful of more exotic numeric types, though, that merit a brief look here.</p>
<section data-type="sect2" data-pdf-bookmark="Decimal Objects"><div class="sect2" id="decimal_objects">
<h2>Decimal Objects</h2>
<p>First up, is Python’s special-purpose numeric object known formally as <code>Decimal</code> (and informally as decimal). Syntactically, decimals are created by calling a function within an imported standard-library module, rather than running a literal expression. Functionally, decimals are like floating-point numbers, but they have a fixed and configurable number of decimal digits. Hence, decimals are <em>fixed-precision</em> floating-point values.</p>
<p>For example, with decimals, we can have a floating-point value that always retains just two decimal digits. Furthermore, we can specify how to round or truncate the extra decimal digits beyond the object’s cutoff. Although it generally incurs a performance penalty compared to normal floating point, decimal is well suited to representing fixed-precision quantities like sums of money and can achieve better numeric accuracy in some contexts.</p>
<section data-type="sect3" data-pdf-bookmark="Decimal basics"><div class="sect3" id="decimal_basics">
<h3>Decimal basics</h3>
<p>As we learned when we explored comparisons, floating-point math is less than exact because of the limited space used to store values. For instance, the following should yield zero, but it does not. The result is close to zero, but there are not enough bits to be precise here:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>0.1 + 0.1 + 0.1 - 0.3</strong></code>                       <code><em># Almost zero, but not quite</em></code>
5.551115123125783e-17</pre>
<p>Using <code>print</code> for the user-friendly display format doesn’t help here, because the hardware related to floating-point math is inherently limited in terms of accuracy (a.k.a. <em>precision</em>). With decimals, however, the result can be dead-on:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>from decimal import Decimal</strong></code>
&gt;&gt;&gt; <code><strong>Decimal('0.1') + Decimal('0.1') + Decimal('0.1') - Decimal('0.3')</strong></code>
Decimal('0.0')</pre>
<p>As shown here, we can make decimal objects by calling the <code>Decimal</code> constructor function in the <span class="keep-together"><code>decimal</code></span> module and passing in strings that have the desired number of decimal digits for the resulting object (using the <code>str</code> function to convert floating-point values to strings if needed). When decimals of different precision are mixed in expressions, Python converts up to the largest number of decimal digits automatically:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>Decimal('0.1') + Decimal('0.10') + Decimal('0.1000') - Decimal('0.30')</strong></code>
Decimal('0.0000')</pre>
<p>It’s also possible to create a decimal object from a floating-point object, with either a call to <span class="keep-together"><code>Decimal.from_float</code></span> or by passing floating-point numbers directly:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>Decimal(0.1) + Decimal(0.1) + Decimal(0.1) - Decimal(0.3)</strong></code>
Decimal('2.775557561565156540423631668E-17')</pre>
<p>The conversion is exact but can yield a large default number of digits, unless they are fixed per the next section.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Setting decimal precision"><div class="sect3" id="setting_decimal_precision">
<h3>Setting decimal precision</h3>
<p>Other tools in the <code>decimal</code> module can be used to set the precision of all decimal numbers, arrange error handling, and more. For instance, a context object in this module allows for specifying precision (number of decimal digits) and rounding modes (down, ceiling, etc.). The precision is applied globally for all decimals created by the caller:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>import decimal</strong></code>
&gt;&gt;&gt; <code><strong>decimal.Decimal(1) / decimal.Decimal(7)</strong></code>                     <code><em># Default precision
</em></code>Decimal('0.1428571428571428571428571429')

&gt;&gt;&gt; <code><strong>decimal.getcontext().prec = 4</strong></code>                               <code><em># Fixed precision</em></code>
&gt;&gt;&gt; <code><strong>decimal.Decimal(1) / decimal.Decimal(7)</strong></code>
Decimal('0.1429')

&gt;&gt;&gt; <code><strong>Decimal(0.1) + Decimal(0.1) + Decimal(0.1) - Decimal(0.3)</strong></code>   <code><em># Closer to 0…</em></code>
Decimal('1.110E-17')</pre>
<p>Technically, significance is determined by digits input, and precision is applied on math operations. Although more subtle than we can explore in this brief overview, this property can make decimals useful as the basis for some monetary applications and may sometimes serve as an alternative to manual rounding and string formatting.</p>
<p>Because use of the decimal type is relatively rare in practice, though, this book will defer to Python’s interactive <code>help</code> function and standard-library manuals for more details. And because decimals address some of the same floating-point accuracy issues as the fraction type, let’s move on to the next section to see how the two compare.</p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Fraction Objects"><div class="sect2" id="fraction_objects">
<h2>Fraction Objects</h2>
<p>Python’s standard-library <code>fractions</code> module implements a <em>rational number</em> object. It essentially keeps both a numerator and a denominator explicitly, so as to avoid some of the inaccuracies and limitations of floating-point math. Like decimals, fractions do not map as closely to computer hardware as floating-point numbers. This means their performance may not be as good, but it also allows them to provide extra utility in a standard tool where useful.</p>
<section data-type="sect3" data-pdf-bookmark="Fraction basics"><div class="sect3" id="fraction_basics">
<h3>Fraction basics</h3>
<p><code>Fraction</code> is a functional cousin to the <code>Decimal</code> fixed-precision object of the prior section, as both can be used to address the floating-point object’s numerical inaccuracies. It’s also used in similar ways—like <code>Decimal</code>, <code>Fraction</code> resides in a module; import its constructor and pass in a numerator and a denominator to make one (among other schemes). The following interaction shows how:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>from fractions import Fraction</strong></code>
&gt;&gt;&gt; <code><strong>x = Fraction(1, 3)</strong></code>                    <code><em># Numerator, denominator</em></code>
&gt;&gt;&gt; <code><strong>y = Fraction(4, 6)</strong></code>                    <code><em># Simplified to 2, 3 by gcd</em></code>

&gt;&gt;&gt; <code><strong>x</strong></code>
Fraction(1, 3)
&gt;&gt;&gt; <code><strong>y</strong></code>
Fraction(2, 3)
&gt;&gt;&gt; <code><strong>print(y)</strong></code>
2/3</pre>
<p>Once created, <code>Fraction</code>s can be used in mathematical expressions as usual:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>x + y</strong></code>
Fraction(1, 1)
&gt;&gt;&gt; <code><strong>x − y</strong></code>                           <code><em># Results are exact: numerator, denominator
</em></code>Fraction(−1, 3)
&gt;&gt;&gt; <code><strong>x * y</strong></code>
Fraction(2, 9)</pre>
<p><code>Fraction</code> objects can also be created from floating-point number strings, much like decimals:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>Fraction('.25')</strong></code>
Fraction(1, 4)
&gt;&gt;&gt; <code><strong>Fraction('1.25')</strong></code>
Fraction(5, 4)

&gt;&gt;&gt; <code><strong>Fraction('.25') + Fraction('1.25')</strong></code>
Fraction(3, 2)</pre>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Numeric accuracy in fractions and decimals"><div class="sect3" id="numeric_accuracy_in_fractions_and_decim">
<h3>Numeric accuracy in fractions and decimals</h3>
<p>Fraction math is different from floating-point-type math, which is constrained by the underlying limitations of floating-point hardware. To compare, here are the same operations run with floating-point objects, and notes on their limited accuracy—they may display fewer digits in recent Pythons than they used to, but they still aren’t exact values in memory:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>a = 1 / 3</strong>  </code>                     <code><em># Only as accurate as floating-point hardware</em></code>
&gt;&gt;&gt; <code><strong>b = 4 / 6</strong>  </code>                     <code><em># Can lose precision over many calculations</em></code>
&gt;&gt;&gt; <code><strong>a</strong></code>
0.3333333333333333
&gt;&gt;&gt; <code><strong>b</strong></code>
0.6666666666666666

&gt;&gt;&gt; <code><strong>a + b</strong></code>
1.0
&gt;&gt;&gt; <code><strong>a - b</strong></code>
-0.3333333333333333
&gt;&gt;&gt; <code><strong>a * b</strong></code>
0.2222222222222222</pre>
<p>This floating-point limitation is especially apparent for values that cannot be represented accurately given their limited number of bits in memory. Both <code>Fraction</code> and <code>Decimal</code> provide ways to get exact results, albeit at the cost of some lost speed and added code verbosity. For instance, in the following example (repeated from the prior section), floating-point numbers do not accurately give the zero answer expected, but both of the other types do:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>0.1 + 0.1 + 0.1 - 0.3</strong></code>           <code><em># This should be zero (close, but not exact)</em></code>
5.551115123125783e-17

&gt;&gt;&gt; <code><strong>from fractions import Fraction
</strong></code>&gt;&gt;&gt; <code><strong>Fraction(1, 10) + Fraction(1, 10) + Fraction(1, 10) - Fraction(3, 10)</strong></code>
Fraction(0, 1)

&gt;&gt;&gt; <code><strong>from decimal import Decimal</strong></code>
&gt;&gt;&gt; <code><strong>Decimal('0.1') + Decimal('0.1') + Decimal('0.1') - Decimal('0.3')</strong></code>
Decimal('0.0')</pre>
<p>Moreover, fractions and decimals both allow more intuitive and accurate results than floating points sometimes can, in different ways—by using rational representation and by limiting precision:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>1 / 3</strong></code>                           <code><em># Normal floating-point</em></code>
0.3333333333333333

&gt;&gt;&gt; <code><strong>Fraction(1, 3)</strong></code>                  <code><em># Numeric accuracy, two ways</em></code>
Fraction(1, 3)

&gt;&gt;&gt; <code><strong>import decimal</strong></code>
&gt;&gt;&gt; <code><strong>decimal.getcontext().prec = 2</strong></code>
&gt;&gt;&gt; <code><strong>Decimal(1) / Decimal(3)</strong></code>
Decimal('0.33')</pre>
<p>In fact, fractions both retain accuracy and automatically simplify results. Continuing the preceding interaction:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>(1 / 3) + (6 / 12)</strong></code>
0.8333333333333333

&gt;&gt;&gt; <code><strong>Fraction(1, 3) + Fraction(6, 12)</strong></code>
Fraction(5, 6)

&gt;&gt;&gt; <code><strong>decimal.Decimal(1 / 3) + decimal.Decimal(6 / 12)</strong></code>
Decimal('0.83')</pre>
<p>To support conversions, floating-point objects have an <code>as_integer_ratio</code> method noted earlier that yields numerator and denominator; fractions have a <code>from_float</code> method; and <code>float</code> accepts a <code>Fraction</code> as an argument. Because <code>Fraction</code> is also a lesser-used utility, though, we’re going to stop short here too; for more details on <code>Fraction</code>, experiment further on your own and consult Python’s <span class="keep-together">documentation</span>.</p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Set Objects"><div class="sect2" id="set_objects">
<h2>Set Objects</h2>
<p>In addition to all the numeric objects we’ve explored, Python has built-in support for <em>sets</em>—an <span class="keep-together">unordered</span> collection of unique and immutable objects that supports operations corresponding to mathematical set theory. Sets straddle the fence between collections and math but lean far enough on the latter side to warrant coverage in this chapter.</p>
<p>By definition, an item appears only once in a set, no matter how many times it is added. Accordingly, sets have a variety of applications, especially in numeric and database-focused work. On the other hand, because sets are collections of other objects, they share some behavior with objects such as lists and <span class="keep-together">dictionaries</span> previewed in <a data-type="xref" href="ch04.html#introducing_python_objects">Chapter 4</a>. For example, sets are iterable, can grow and shrink on demand, and may contain a variety of object types.</p>
<p>Still, because sets are unordered and do not map keys to values, they are neither sequence nor mapping types; they are a type category unto themselves. Moreover, because sets also tend to be used much less often than pervasive objects like lists and dictionaries, a brief look should suffice for most readers; let’s get started here with the usual REPL tour.</p>
<section data-type="sect3" data-pdf-bookmark="Sets in action"><div class="sect3" id="sets_in_action">
<h3>Sets in action</h3>
<p>First off, there are two ways to make sets—by call and literal. The <em>literal</em> uses the same “{}” braces as dictionaries but simply enumerates items (there is no key) and allows you to initialize the set with individual objects. The <em>call</em> to <code>set</code> accepts an existing sequence (or other iterable) of items to add to the new set and is required to make an empty set (<code>{}</code> is reserved for an empty dictionary). When sets are printed, they prefer the literal form, except when empty:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>x = set('abcde')</strong></code>                    <code><em># Make a set by calling its type/function</em></code>
&gt;&gt;&gt; <code><strong>y = {99, 'b', 'y', 'd', 1.2}</strong>   </code>     <code><em># Make a set by literal</em></code>

&gt;&gt;&gt; <code><strong>x</strong> </code>
{'d', 'c', 'e', 'a', 'b'}               <code><em># Order is scrambled, displays literal</em></code>
&gt;&gt;&gt; <code><strong>y</strong></code>
{1.2, 99, 'y', 'd', 'b'}</pre>
<p>Notice that sets don’t maintain insertion order, unlike the keys in a dictionary (see <a data-type="xref" href="ch04.html#introducing_python_objects">Chapter 4</a>’s introduction). This is by definition—sets are just groups of items—but the lack of positional ordering means that sequence operations won’t work on sets. Per the following, empty sets require a call, a <code>*</code> in a literal unpacks items, both call and <code>*</code> accept any iterable, and sets always filter out duplicate entries; again, this is just how sets work in Python and elsewhere:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>z = set()</strong></code>                           <code><em># Make empty set: {} is empty dictionary</em></code>
&gt;&gt;&gt; <code><strong>z</strong></code>
set()

&gt;&gt;&gt; <code><strong>z = set([1.2, 'a', 3, 1.2, 'a'])</strong> </code>   <code><em># Any sequence works, duplicates dropped</em></code>
&gt;&gt;&gt; <code><strong>z</strong></code>
{'a', 1.2, 3}

&gt;&gt;&gt; <code><strong>{1, *'abc', *[1, 2, 3]}</strong>   </code>          <code><em># Literal star unpacking (Python 3.5+)</em></code>
{1, 2, 3, 'c', 'b', 'a'}</pre>
<p>Once you have sets, expression operators invoke set operations. Here are the most common in action; to run any of these on plain sequences like strings and list, you must first create a set of their items:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>x = set('abcd')</strong></code>
&gt;&gt;&gt; <code><strong>y = set('bdxy')</strong></code>

&gt;&gt;&gt; <code><strong>x – y</strong> </code>                          <code><em># Difference: in x, not in y</em></code>
{'a', 'c'}
 
&gt;&gt;&gt; <code><strong>x | y</strong></code>                           <code><em># Union: in either</em></code>
{'y', 'd', 'x', 'c', 'a', 'b'}
 
&gt;&gt;&gt; <code><strong>x &amp; y</strong></code>                           <code><em># Intersection: in both</em></code>
{'d', 'b'}
 
&gt;&gt;&gt; <code><strong>x ^ y</strong></code>                           <code><em># Symmetric difference: not in both</em></code>
{'y', 'x', 'c', 'a'}
  
&gt;&gt;&gt; <code><strong>x &lt; y, x &gt; y</strong></code>                    <code><em># Superset, subset tests</em></code>
(False, False)</pre>
<p>An exception: the <code>in</code> set membership test expression is also defined to work on all other collection types, where it also performs membership (or a search, if you prefer to think in procedural terms). Hence, we do not need to convert things like strings and lists to sets to run this test:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>'d' in x</strong></code>                                      <code><em># Membership (sets)</em></code>
True

&gt;&gt;&gt; <code><strong>'d' in 'code', 2 in [1, 2, 3]</strong></code>                 <code><em># But works on other types too</em></code>
(True, True)</pre>
<p>In addition to expressions, the set object provides <em>methods</em> that correspond to these operations and more, and that support set changes. For instance, the set <code>add</code> method inserts one item, <code>update</code> is an in-place union, and <code>remove</code> deletes an item by value (per the prior chapter, run a <code>dir</code> call on any set instance or the <code>set</code> type name to see all the available methods). Assuming <code>x</code> and <code>y</code> are still as they were in the prior interaction:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>z = x.intersection(y)</strong></code>                         <code><em># Same as x &amp; y</em></code>
&gt;&gt;&gt; <code><strong>z</strong></code>
{'d', 'b'}
&gt;&gt;&gt; <code><strong>z.add('HACK')      </strong>  </code>                         <code><em># Insert one item</em></code>
&gt;&gt;&gt; <code><strong>z</strong></code>
{'HACK', 'd', 'b'}
&gt;&gt;&gt; <code><strong>z.update(set(['X', 'Y']))</strong></code>                     <code><em># Merge: in-place union</em></code>
&gt;&gt;&gt; <code><strong>z</strong></code>
{'X', 'HACK', 'd', 'b', 'Y'}
&gt;&gt;&gt; <code><strong>z.remove('b')      </strong>  </code>                         <code><em># Delete one item</em></code>
&gt;&gt;&gt; <code><strong>z</strong></code>
{'X', 'HACK', 'd', 'Y'}</pre>
<p>Sets also are <em>iterable</em> (i.e., they support the iteration protocol introduced in the prior chapter) and hence can also be used in operations such as <code>len</code>, <code>for</code> loops, and list comprehensions. Because they are <span class="keep-together">unordered</span>, though, they don’t support sequence operations like indexing, slicing, or concatenation:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>for item in set('abc'):</strong>   </code>                    <code><em># See Chapter 4 for "for"</em></code>
        <code><strong>print(item * 3)</strong></code>

aaa
ccc
bbb
&gt;&gt;&gt; <code><strong>{'a', 'b', 'c'} + {'d'}</strong></code>
TypeError: unsupported operand type(s) for +: 'set' and 'set'</pre>
<p>Finally, although the set expressions shown earlier generally require two sets, their method-based counterparts can often work with <em>any iterable</em> as well—and may run faster because of it (though speed guesses are perilous in Python):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>S = set([1, 2, 3])</strong></code>
&gt;&gt;&gt; <code><strong>S | set([3, 4])</strong></code>                <code><em># Expressions require both to be sets</em></code>
{1, 2, 3, 4}
&gt;&gt;&gt; <code><strong>S | [3, 4]</strong></code>
TypeError: unsupported operand type(s) for |: 'set' and 'list'

&gt;&gt;&gt; <code><strong>S.union([3, 4])</strong></code>                <code><em># But their methods allow any iterable</em></code>
{1, 2, 3, 4}
&gt;&gt;&gt; <code><strong>S.intersection((1, 3, 5))</strong></code>
{1, 3}
&gt;&gt;&gt; <code><strong>S.issubset(range(-5, 5))</strong>  </code>     <code><em># Subset of range -5...4 series generator</em></code>
True

&gt;&gt;&gt; <strong>S = set([1, 2, 3])</strong>
&gt;&gt;&gt; <strong>S.intersection_update((1, 2, 5))</strong>
&gt;&gt;&gt; <strong>S</strong>
{1, 2}
&gt;&gt;&gt; 
&gt;&gt;&gt; <strong>S |= {1, 2, 4}</strong>
&gt;&gt;&gt; <strong>S</strong>
{1, 2, 4}</pre>
<p>For more details on set operations, see Python’s library manual. Among topics skipped here, sets also support in-place changes with additional methods, as well as assignment operators we’ll study later (e.g., <code>&amp;=</code> and <code>|=</code>). Although sets can be coded manually in Python with other types like lists and dictionaries (and often were in the past), Python’s built-in sets use efficient algorithms and implementation techniques to provide quick and standard operations.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Immutable constraints and frozen sets"><div class="sect3" id="immutable_constraints_and_frozen_sets">
<h3>Immutable constraints and frozen sets</h3>
<p>Sets are powerful and flexible objects, but they do have one constraint that you should keep in mind—largely because of their implementation, sets can contain only <em>immutable</em> object types (Python refers to this as “hashable,” which is close enough to “immutable” to use the latter here). Hence, lists and dictionaries cannot be embedded in sets, but tuples of other immutables can if you need to store compound values. Tuples compare by full values when used in sets:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>S = {1.23}</strong></code>

&gt;&gt;&gt; <code><strong>S.add([1, 2, 3])</strong></code>                   <code><em># Only immutable objects work in a set</em></code>
TypeError: unhashable type: 'list'
&gt;&gt;&gt; <code><strong>S.add({'a':1})</strong></code>
TypeError: unhashable type: 'dict'

&gt;&gt;&gt; <code><strong>S.add((1, 2, 3))</strong></code>
&gt;&gt;&gt; <code><strong>S</strong></code>                                  <code><em># No list or dict; tuple, str, numbers OK</em></code>
{1.23, (1, 2, 3)}

&gt;&gt;&gt; <code><strong>S | {(4, 5, 6), (1, 2, 3)}</strong></code>         <code><em># Union: same as S.union(...)</em></code>
{1.23, (4, 5, 6), (1, 2, 3)}

&gt;&gt;&gt; <code><strong>(1, 2, 3) in S</strong></code>                     <code><em># Membership: by complete values
</em></code>True
&gt;&gt;&gt; <code><strong>(1, 4, 3) in S</strong></code>
False</pre>
<p>Tuples in a set, for instance, might be used to represent dates, records, IP addresses, and so on (more on tuples later in this part of the book). Sets may also contain modules, type objects, and more. Sets themselves are mutable too, and so cannot be nested in other sets directly; if you need to store a set inside another set, the <code>frozenset</code> built-in call works just like <code>set</code> but creates an immutable set that cannot change and thus can be embedded in other sets:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>S.add(frozenset('app'))</strong></code>
&gt;&gt;&gt; <code><strong>S</strong></code>
{1.23, (1, 2, 3), frozenset({'a', 'p'})}</pre>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Set comprehensions"><div class="sect3" id="set_comprehensions">
<h3>Set comprehensions</h3>
<p>In addition to literals and calls, sets can also be made by running comprehension expressions, previewed briefly in <a data-type="xref" href="ch04.html#introducing_python_objects">Chapter 4</a>. Comprehensions also work for lists, dictionaries, and generators, and behave largely the same in all. For sets, comprehensions are coded in curly braces. When run, they perform a loop that collects the result of an expression on each iteration; a loop variable gives access to the current iteration value for use in the collection expression. The result is a new set with all the normal set behavior. For example:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>{x ** 2 for x in [1, 2, 3, 4]}</strong></code>         <code><em># Make a new set with a comprehension</em></code>
{16, 1, 4, 9}</pre>
<p>In this expression, the loop is coded on the right, and the collection expression is coded on the left (<code>x ** 2</code>). As for list comprehensions, we get back pretty much what this expression says: “Give me a new set containing X squared, for every X in a list.” Comprehensions can also iterate across other kinds of objects, such as strings; the first of the following examples also illustrates the comprehension-based way to make a set from an existing iterable:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>{x for x in 'py3X'}</strong> </code>                   <code><em># Same as: set('py3x')</em></code>
{'p', 'X', '3', 'y'}
 
&gt;&gt;&gt; <code><strong>{c * 4 for c in 'py3X'}</strong></code>                <code><em># Set of collected expression results
</em></code>{'yyyy', '3333', 'XXXX', 'pppp'}
&gt;&gt;&gt; <code><strong>{c * 4 for c in 'py3X' + 'py2X'}</strong>  </code>     <code><em># Expressions work on both sides</em></code>
{'yyyy', '3333', 'XXXX', '2222', 'pppp'}

&gt;&gt;&gt; <code><strong>S = {c * 4 for c in 'py3X'}</strong>  </code>          <code><em># All set ops work on results</em></code>
&gt;&gt;&gt; <code><strong>S | {'zzzz', 'XXXX'}</strong></code>
{'yyyy', '3333', 'XXXX', 'pppp', 'zzzz'}
&gt;&gt;&gt; <code><strong>S &amp; {'zzzz', 'XXXX'}</strong></code>
{'XXXX'}</pre>
<p>Because the rest of the comprehensions story relies upon underlying concepts we’re not yet prepared to tackle, we’ll postpone further details until later in this book. In <a data-type="xref" href="ch08.html#lists_and_dictionaries">Chapter 8</a>, you’ll meet first cousins, the list and dictionary comprehension, and you’ll learn much more about all comprehensions—set, list, dictionary, and generator—later on, especially in Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch14.html#iterations_and_comprehensions">14</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch20.html#comprehensions_and_generations">20</a>. As you’ll find, all comprehensions support additional syntax not shown here, including nested loops and <code>if</code> tests, which can be challenging before you’ve had a chance to study larger statements.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Why sets?"><div class="sect3" id="why_setsquestion_mark">
<h3>Why sets?</h3>
<p>Set operations have a variety of common uses, some more practical than mathematical. For example, because items are stored only once in a set, sets can be used to <em>filter duplicates</em> out of other collections, albeit at the cost of original ordering because sets are unordered in general. Simply convert the collection to a set, and then convert it back:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>L = [1, 2, 1, 3, 2, 4, 5]</strong></code>
&gt;&gt;&gt; <code><strong>set(L)</strong></code>
{1, 2, 3, 4, 5}
&gt;&gt;&gt; <code><strong>L = list(set(L))</strong></code>                                  <code><em># Removing duplicates</em></code>
&gt;&gt;&gt; <code><strong>L</strong></code>
[1, 2, 3, 4, 5]

&gt;&gt;&gt; <code><strong>list(set(['yy', 'cc', 'aa', 'xx', 'dd', 'aa']))</strong></code>   <code><em># But order may change</em></code>
['xx', 'cc', 'yy', 'aa', 'dd']</pre>
<p>Sets can be used to <em>isolate differences</em> in lists, strings, and other iterable objects too—simply convert to sets and take the difference—though again the unordered nature of sets means that the results may not match that of the originals:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>set([1, 3, 5, 7]) - set([1, 2, 4, 5, 6])</strong></code>          <code><em># Find list differences
</em></code>{3, 7}
&gt;&gt;&gt; <code><strong>set('abcdefg') - set('abdghij')</strong></code>                   <code><em># Find string differences</em></code>
{'c', 'e', 'f'}
&gt;&gt;&gt; <code><strong>set('code') - set(['t', 'o', 'e'])</strong></code>                <code><em># Find differences, mixed
</em></code>{'c', 'd'}</pre>
<p>You can also use sets to perform <em>order-neutral equality</em> tests by converting to a set before the test, because order doesn’t matter in a set. More formally, two sets are <em>equal</em> if and only if every element of each set is contained in the other—that is, each is a subset of the other, regardless of order. For instance, you might use this to compare the outputs of programs that should work the same but may generate results in different order. Sorting with Python’s <code>sorted</code> built-in before testing has the same effect for equality; sets don’t rely on an expensive sort, but also don’t order items:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>L1, L2 = [1, 3, 5, 2, 4], [2, 5, 3, 4, 1]</strong></code>
&gt;&gt;&gt; <code><strong>L1 == L2</strong></code>                                          <code><em># Order matters in sequences</em></code>
False
&gt;&gt;&gt; <code><strong>set(L1) == set(L2)</strong></code>                                <code><em># Order-neutral equality
</em></code>True
&gt;&gt;&gt; <code><strong>sorted(L1) == sorted(L2)</strong></code>                          <code><em># Similar but results ordered</em></code>
True
&gt;&gt;&gt; <code><strong>'code' == 'edoc', set('code') == set('edoc'), sorted('code') == sorted('edoc')</strong></code>
(False, True, True)</pre>
<p>Sets can also be used to keep track of where you’ve already been when traversing a graph or other <em>cyclic</em> structure. For example, the transitive module reloader and inheritance-tree lister examples we’ll code in Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch25.html#module_odds_and_ends">25</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch31.html#designing_with_classes">31</a>, respectively, must keep track of items visited to avoid loops, as <a data-type="xref" href="ch19.html#function_odds_and_ends">Chapter 19</a> discusses in the abstract. Using a list in this context is inefficient because searches require linear scans. Although recording states visited as keys in a dictionary is efficient, sets offer an alternative that’s essentially equivalent and may be more intuitive.</p>
<p>Finally, sets are also convenient when you’re dealing with large data collections like database query results—the intersection of two sets contains objects common to both categories, and the union contains all items in either set. To illustrate, here’s a more tangible example of set operations at work, applied to people in a hypothetical company (like all examples in this book, any resemblance to the real world is purely coincidental!):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>engineers = {'pat', 'ann', 'bob', 'sue'}</strong></code>
&gt;&gt;&gt; <code><strong>managers  = {'sue', 'tom'}</strong></code>

&gt;&gt;&gt; <code><strong>'pat' in engineers</strong></code>                   <code><em># Is pat an engineer?</em></code>
True

&gt;&gt;&gt; <code><strong>engineers &amp; managers</strong></code>                 <code><em># Who is both engineer and manager?</em></code>
{'sue'}

&gt;&gt;&gt; <code><strong>engineers | managers</strong></code>                 <code><em># All people in either category</em></code>
{'ann', 'sue', 'pat', 'tom', 'bob'} 

&gt;&gt;&gt; <code><strong>engineers - managers</strong></code>                 <code><em># Engineers who are not managers</em></code>
{'pat', 'ann', 'bob'}

&gt;&gt;&gt; <code><strong>managers - engineers</strong></code>                 <code><em># Managers who are not engineers</em></code>
{'tom'}

&gt;&gt;&gt; <code><strong>engineers &gt; managers</strong></code>                 <code><em># Are all managers engineers? (superset)</em></code>
False

&gt;&gt;&gt; <code><strong>{'sue', 'bob'} &lt; engineers</strong></code>           <code><em># Are both engineers? (subset)</em></code>
True

&gt;&gt;&gt; <code><strong>(managers | engineers) &gt; managers</strong></code>    <code><em># All people is a superset of managers
</em></code>True

&gt;&gt;&gt; <code><strong>managers ^ engineers</strong></code>                 <code><em># Who is in one group but not both?
</em></code>{'ann', 'pat', 'tom', 'bob'}</pre>
<p>You can find more details on set operations in the Python library manual and some mathematical and database texts. Also stay tuned for <a data-type="xref" href="ch08.html#lists_and_dictionaries">Chapter 8</a>’s revival of set operations we’ve seen here, in the context of dictionary view objects. Here, we have time for just one last numeric object type.</p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Boolean Objects"><div class="sect2" id="boolean_objects">
<h2>Boolean Objects</h2>
<p>Though somewhat gray, the Python Boolean type, <code>bool</code>, is arguably numeric in nature because its two values, <code>True</code> and <code>False</code>, are just customized versions of the integers 1 and 0 that print themselves differently. Python treats 1 and 0 as true and false like many programming languages, but its <code>True</code> and <code>False</code> makes Boolean roles more explicit. Although that’s all some programmers may need to know, let’s briefly reveal this type’s forgery.</p>
<p>To represent truth values, Python has an explicit Boolean type called <code>bool</code>, from which the objects preassigned to built-in names <code>True</code> and <code>False</code> are made. That is, <code>True</code> and <code>False</code> are instances of <code>bool</code>, which is in turn just a subclass (in the object-oriented sense) of the built-in integer type <code>int</code>. <code>True</code> and <code>False</code> behave exactly like the integers 1 and 0, except that they have customized printing logic—they print themselves as the words <code>True</code> and <code>False</code>, instead of the digits <code>1</code> and <code>0</code>. <code>bool</code> accomplishes this by redefining <code>str</code> and <code>repr</code> string formats (introduced earlier in this chapter) for its two objects, and all logical tests yield <code>True</code> or <code>False</code> for their results.</p>
<p>Because of this customization, Boolean expressions typed at the interactive prompt print results as the words <code>True</code> and <code>False</code> instead of the less obvious <code>1</code> and <code>0</code>. In addition, Booleans make truth values more apparent in your code. For instance, an infinite loop can be coded as <code>while True:</code> instead of the less intuitive <code>while 1:</code>, and flags can be initialized more clearly with <code><em>flag</em> = False</code>. We’ll discuss these statements further in <a data-type="xref" href="part03.html#statements_and_syntax">Part III</a>.</p>
<p>Again, though, for most practical purposes, you can treat <code>True</code> and <code>False</code> as though they are predefined variables set to integers <code>1</code> and <code>0</code>. This implementation can lead to curious results, though; because <code>True</code> is just the integer <code>1</code> with a custom display format, <code>True + 4</code> yields integer <code>5</code> in Python:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>type(True)</strong></code>               <code><em># True is a bool</em></code>
&lt;class 'bool'&gt;
&gt;&gt;&gt; <code><strong>isinstance(True, int)</strong></code>    <code><em># As well as an int
</em></code>True
&gt;&gt;&gt; <code><strong>True == 1</strong></code>                <code><em># Same value</em></code>
True
&gt;&gt;&gt; <code><strong>True is 1</strong></code>                <code><em># But a different object: see the next chapter!</em></code>
False
&gt;&gt;&gt; <code><strong>True or False</strong></code>            <code><em># Same as: 1 or 0</em></code>
True
&gt;&gt;&gt; <code><strong>True + 4</strong></code>                 <code><em># (Hmmm)</em></code>
5</pre>
<p>Since you probably won’t come across an expression like the last of these in real Python code, you can safely ignore any of its deeper metaphysical implications. We’ll revisit Booleans in <a data-type="xref" href="ch09.html#tuplescomma_filescomma_and_everything_e">Chapter 9</a> to define Python’s notion of truth, and again in <a data-type="xref" href="ch12.html#if_and_match_selections">Chapter 12</a> to see how Boolean operators like <code>and</code> and <code>or</code> work.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Numeric Extensions"><div class="sect1" id="numeric_extensions">
<h1>Numeric Extensions</h1>
<p>Finally, although Python’s core numeric objects offer plenty of power for most applications, a large catalog of third-party open source extensions is available to address more focused numeric needs.</p>
<p>We surveyed tools in this domain in <a data-type="xref" href="ch01.html#a_python_qampersanda_session">Chapter 1</a>’s section “What Can I Do with Python?” In short, there is a now-common stack of tools for advanced numeric coding in Python today, including <em>NumPy</em>, <em>SciPy</em>, <em>pandas</em>, <em>matplotlib</em>, <em>Jupyter</em>, and more, and additional tools address subdomains like statistics, astronomy, and AI.</p>
<p>This toolkit is used by research organizations, financial entities, and aerospace groups around the world, and performs the sort of tasks formerly coded in languages like C++ or Fortran. Many who work in this field liken the combination of Python plus numeric extensions to a free, flexible, and powerful alternative to systems like MATLAB.</p>
<p>Though a popular and exciting domain, Python numeric programming is just one way to use the language (Python web development, for example, is similarly sized) and is easily rich enough to fill entire books by itself. Hence, this book doesn’t cover numeric extensions and focuses instead on teaching you the Python language that’s used in every domain. Once you’ve learned Python itself, you’ll find copious resources for add-ons both on the web and at book outlets near you when you’re ready to level up.</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Chapter Summary"><div class="sect1" id="chapter_summary-id00015">
<h1>Chapter Summary</h1>
<p>This chapter has toured Python’s numeric object types and the operations we can apply to them. Along the way, we met the trusty integer and floating-point objects, as well as some more exotic and less commonly used types such as complex numbers, decimals, fractions, and sets. We also explored Python’s expression syntax, type conversions, bitwise operations, and various literal forms for coding numbers in scripts.</p>
<p>Later in this part of the book, we’ll continue our in-depth object tour by filling in details about the next object type—the string. In the next chapter, however, we’ll take some time to explore the mechanics of variable assignment in more detail than we have here. This turns out to be perhaps the most fundamental idea in Python, so make sure you check out the next chapter before moving on. First, though, it’s time to take the usual chapter quiz.</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Test Your Knowledge: Quiz"><div class="sect1" id="test_your_knowledge_quiz-id000131">
<h1>Test Your Knowledge: Quiz</h1>
<ol>
<li><p>What is the value of the expression <code>2 * (3 + 4)</code> in Python, and why?</p></li>
<li><p>What is the value of the expression <code>2 * 3 + 4</code> in Python, and why?</p></li>
<li><p>What is the value of the expression <code>2 + 3 * 4</code> in Python, and why?</p></li>
<li><p>What tools can you use to find a number’s square root, as well as its square?</p></li>
<li><p>What is the type of the result of the expression <code>1 + 2.0 + 3</code>, and why?</p></li>
<li><p>How can you truncate and round a floating-point number?</p></li>
<li><p>How can you convert an integer to a floating-point number?</p></li>
<li><p>How would you display an integer in octal, hexadecimal, or binary notation?</p></li>
<li><p>How might you convert an octal, hexadecimal, or binary string to a plain integer?</p></li>
</ol>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Test Your Knowledge: Answers"><div class="sect1" id="test_your_knowledge_answers-id000130">
<h1>Test Your Knowledge: Answers</h1>
<ol>
<li><p>The value will be <code>14</code>, the result of 2 * 7, because the parentheses force the addition to happen before the multiplication.</p></li>
<li><p>The value will <a contenteditable="false" data-type="indexterm" data-primary="expressions" id="id1867"></a>be <code>10</code>, the result of 6 + 4. Python’s operator precedence rules are applied in the absence of parentheses, and multiplication has higher precedence than (i.e., happens before) addition, per <a data-type="xref" href="#python_expression_operatorscomma_by_inc">Table 5-2</a>.</p></li>
<li><p>This expression yields <code>14</code>, the result of 2 + 12, for the same precedence reasons as in the prior <span class="keep-together">question</span>.</p></li>
<li><p>Functions for obtaining the square root, as well as <em>pi</em>, tangents, and more, are available in the imported <code>math</code> module. To find a number’s square root, import <code>math</code> and call <code>math.sqrt(<em>N</em>)</code>. To get a number’s square, use either the exponent expression <code><em>X</em> ** 2</code> or the built-in function <code>pow(<em>X</em>, 2)</code>. Either of these last two can also compute the square root when given a power of <code>0.5</code> (e.g., <span class="keep-together"><code><em>X</em> ** .5</code></span>).</p></li>
<li><p>The result will <a contenteditable="false" data-type="indexterm" data-primary="floating point numbers" id="id1868"></a><a contenteditable="false" data-type="indexterm" data-primary="numbers" data-secondary="floating-point" id="id1869"></a>be a floating-point number: the integers are converted up to floating point, the most complex type in the expression, and floating-point math is used to evaluate it.</p></li>
<li><p>The <code>int(<em>N</em>)</code> and <code>math.trunc(<em>N</em>)</code> functions truncate, and the <code>round(<em>N</em>, <em>digits</em>)</code> function rounds. We can also compute the floor with <code>math.floor(<em>N</em>)</code> and round for display with string-formatting operations.</p></li>
<li><p>The <code>float(<em>I</em>)</code> function converts an integer to a floating point; mixing an integer with a floating point within an expression will result in a conversion as well. In some sense, Python <code>/</code> true division converts too—it always returns a floating-point result that includes the remainder, even if both operands are integers.</p></li>
<li><p>The <code>oct(<em>I</em>)</code>, <code>hex(<em>I</em>)</code>, and <code>bin(<em>I</em>)</code> built-in functions return the octal, hexadecimal, and binary string forms for an integer. All three flavors of string formatting (expression, method, and f-string) also provide targets for some such conversions.</p></li>
<li><p>The <code>int(<em>S</em>, <em>base</em>)</code> function can be used to convert from octal, hexadecimal, and binary digit strings to normal integers (pass in <code>8</code>, <code>16</code>, or <code>2</code> for the <code><em>base</em></code>). The <code>eval(<em>S</em>)</code> function can be used for this purpose too, but it’s more expensive to run and can have security risks. To some extent, other-base literals like <code>0xFFFF</code> and <code>0b1111</code> in your code do this work too when read by Python. Note that integers are always stored in binary form in computer memory; these are just display string format conversions.</p></li>
</ol>
</div></section>
</div></section></div>
</div>
</body>
</html>