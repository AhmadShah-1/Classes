<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xml:lang="en"
lang="en"
xmlns="http://www.w3.org/1999/xhtml"
xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<title>Learning Python, 6th Edition</title>
<link rel="stylesheet" type="text/css" href="override_v1.css"/>
<link rel="stylesheet" type="text/css" href="epub.css"/>
</head>
<body>
<div id="book-content">
<div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 20. Comprehensions and Generations"><div class="chapter" id="comprehensions_and_generations">
<h1><span class="label">Chapter 20. </span>Comprehensions and Generations</h1>
<p>This chapter explores a set of advanced function-related tools and topics. Its main subjects are <em>generator functions</em> and their <em>generator expression</em> relatives—user-defined ways <a contenteditable="false" data-type="indexterm" data-primary="generator functions" id="id3173"></a><a contenteditable="false" data-type="indexterm" data-primary="generator expressions" id="id3174"></a><a contenteditable="false" data-type="indexterm" data-primary="expressions" data-secondary="generator expressions" id="id3175"></a><a contenteditable="false" data-type="indexterm" data-primary="functions" data-secondary="generator functions" id="id3176"></a><a contenteditable="false" data-type="indexterm" data-primary="comprehensions" data-secondary="syntax" id="id3177"></a><a contenteditable="false" data-type="indexterm" data-primary="syntax" data-secondary="comprehension syntax" id="id3178"></a>to produce results on demand the same way that many built-ins do. Because generators <a contenteditable="false" data-type="indexterm" data-primary="iteration" data-secondary="generators" id="id3179"></a>apply the <em>iteration</em> protocol and generator expressions reuse <em>comprehension</em> syntax, this chapter is also partly a follow-up to <a data-type="xref" href="ch14.html#iterations_and_comprehensions">Chapter 14</a> (hence its title). We’ll extend these topics to their completion here and demo with larger examples that tie ideas together.</p>
<p>Finally, this chapter provides just enough of an intro to get you started with <code>async</code> <em>coroutines</em>—tools that build on generators, but assume knowledge of parallel programming, which is outside the scope of this book and the needs of most Python learners. You won’t become an <code>async</code> master here, but you’ll get a head start for further explorations.</p>
<p>Iteration and generation in Python also encompasses user-defined <em>classes</em>, but we’ll defer that final part of this story until <a data-type="xref" href="part06.html#classes_and_oop">Part VI</a>, when we study operator overloading. The next chapter continues threads spun here by timing the relative performance of some of this chapter’s tools as a larger case study. Before that, though, let’s pick up the comprehensions and iterations story where it was last left, and extend it to include value generators.</p>
<section data-type="sect1" data-pdf-bookmark="Comprehensions: The Final Act"><div class="sect1" id="comprehensions_the_final_act">
<h1>Comprehensions: The Final Act</h1>
<p>As mentioned early in this book, Python supports the procedural, object-oriented, and function programming paradigms. Among these, Python has a host of tools that most observers would consider <em>functional</em> in nature, which we enumerated in the preceding chapter—closures, generators, lambdas, comprehensions, maps, decorators, function objects, and more. These tools allow us to apply and combine functions in powerful ways, and often offer state retention and coding solutions that are alternatives to classes and OOP.</p>
<p>For instance, the prior chapter explored tools such as <code>map</code> and <code>filter</code>—key members of Python’s early functional-programming toolset inspired by the Lisp language—that map operations over iterables and collect results. Because this is such a common task in coding, Python eventually sprouted a new <a contenteditable="false" data-type="indexterm" data-primary="list comprehensions" id="id3180"></a><a contenteditable="false" data-type="indexterm" data-primary="comprehensions" data-secondary="list comprehensions" id="id3181"></a><a contenteditable="false" data-type="indexterm" data-primary="Haskell" id="id3182"></a>expression—the <em>list comprehension</em>—a device inspired by languages like Haskell, which is even more flexible than the original functional toolset.</p>
<p>As we’ve seen, list comprehensions <a contenteditable="false" data-type="indexterm" data-primary="expressions" data-secondary="list comprehensions" id="id3183"></a><a contenteditable="false" data-type="indexterm" data-primary="list comprehensions" data-secondary="expressions" id="id3184"></a>apply an arbitrary <em>expression</em> to items in an iterable, rather than applying a function. Accordingly, they can be more general tools. In later Pythons, the list comprehension was extended to other roles—sets, dictionaries, and even the value generator expressions we’ll explore in this chapter. Hence, it’s not just for lists anymore, and we’ll simply call it <em>comprehension</em> when referring to all its forms collectively.</p>
<p>We first met comprehensions in <a data-type="xref" href="ch04.html#introducing_python_objects">Chapter 4</a>’s preview, introduced them in <a data-type="xref" href="part02.html#objects_and_operations">Part II</a>’s coverage of sets, lists, and dictionaries, and studied them further in <a data-type="xref" href="ch14.html#iterations_and_comprehensions">Chapter 14</a>, in conjunction with looping statements. Because they’re also related to functional programming tools like the <code>map</code> and <code>filter</code> calls and repurposed by generator expressions, though, let’s resurrect the topic here for one last look.</p>
<section data-type="sect2" data-pdf-bookmark="List Comprehensions Review"><div class="sect2" id="list_comprehensions_review">
<h2>List Comprehensions Review</h2>
<p>Here’s a brief example to refresh a few neurons. As we learned in <a data-type="xref" href="ch07.html#string_fundamentals">Chapter 7</a>, Python’s built-in <code>ord</code> function returns the integer code point of a single character. If we wish to collect code points of <em>all</em> characters in an entire string, a straightforward approach is to use a simple <code>for</code> loop and append the results to a list. In a REPL:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>res = []</strong></code>
&gt;&gt;&gt; <code><strong>for x in 'text':</strong></code>
<code> <strong>       res.append(ord(x))</strong></code>                 <code><em># Manual results collection</em></code>

&gt;&gt;&gt; <code><strong>res</strong></code>
[116, 101, 120, 116]</pre>
<p>Now that we know about <code>map</code>, though, we can <a contenteditable="false" data-type="indexterm" data-primary="list comprehensions" data-secondary="map function" id="id3185"></a><a contenteditable="false" data-type="indexterm" data-primary="map function" data-secondary="list comprehensions" id="id3186"></a>achieve similar results with a single function call without having to manage list construction in the code:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>res = list(map(ord, 'text'))</strong></code>           <code><em># Apply function to iterable</em></code>
&gt;&gt;&gt; <code><strong>res</strong></code>
[116, 101, 120, 116]</pre>
<p>However, we can get the same results <a contenteditable="false" data-type="indexterm" data-primary="list comprehensions" data-secondary="expression mapping" id="id3187"></a><a contenteditable="false" data-type="indexterm" data-primary="expressions" data-secondary="list comprehensions" data-tertiary="mapping" id="id3188"></a>from a list comprehension expression—while <code>map</code> maps a <em>function</em> over an iterable, list comprehensions map an <em>expression</em>:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>res = [ord(x) for x in 'text']</strong></code>         <code><em># Apply expression to iterable</em></code>
&gt;&gt;&gt; <code><strong>res</strong></code>
[116, 101, 120, 116]</pre>
<p>List comprehensions collect the results of applying an expression to an iterable of values, and return <a contenteditable="false" data-type="indexterm" data-primary="list comprehensions" data-secondary="expressions" data-tertiary="arbitrary" id="id3189"></a><a contenteditable="false" data-type="indexterm" data-primary="expressions" data-secondary="arbitrary" id="id3190"></a>them in a new list. Syntactically, list comprehensions are enclosed in square brackets—to remind you that they construct lists. In their basic form, within the brackets you code an expression that names a variable, followed by what looks like a <code>for</code> loop header that names the same variable. You get back the expression’s results for each iteration of the implied loop.</p>
<p>The effect of the preceding example is similar to that of the manual <code>for</code> loop and the <code>map</code> call. List comprehensions become more convenient, though, when we wish to apply an arbitrary expression instead of a function:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>[x ** 2 for x in range(10)]</strong>  </code>          <code><em># Squares of numbers 0 to 9
</em></code>[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</pre>
<p>To do similar work with a <code>map</code> call, we may need to invent a little function to implement the square operation. Because we won’t need this function elsewhere, we’d typically (but not necessarily) code it inline, with a <code>lambda</code>:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>list(map((lambda x: x ** 2), range(10)))</strong></code>
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</pre>
<p>This does the same job, and it’s only a few keystrokes longer than the equivalent list comprehension. It’s also only marginally more complex (at least, once you understand the <code>lambda</code>). For more advanced roles, though, list comprehensions will often require considerably less typing.</p>
<p>For instance, as we learned in <a data-type="xref" href="ch14.html#iterations_and_comprehensions">Chapter 14</a>, you can code an <code>if</code> clause after the <a contenteditable="false" data-type="indexterm" data-primary="list comprehensions" data-secondary="if clause" id="id3191"></a>comprehension’s <code>for</code> to add selection logic. List comprehensions with <code>if</code> clauses can be thought of as analogous to the <code>filter</code> built-in in the preceding chapter—they skip an iterable’s items for which the <code>if</code> clause is not true. As a demo, following are both schemes, along with the equivalent <code>for</code>, picking up even numbers from 0 to 9 (<code>x % 2</code> is zero for evens only):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>[x for x in range(10) if x % 2 == 0]</strong></code>
[0, 2, 4, 6, 8] 

&gt;&gt;&gt; <code><strong>list(filter((lambda x: x % 2 == 0), range(10)))</strong></code>
[0, 2, 4, 6, 8] 

&gt;&gt;&gt; <code><strong>res = []</strong></code>
&gt;&gt;&gt; <code><strong>for x in range(10):
        if x % 2 == 0:
            res.append(x)</strong></code>

&gt;&gt;&gt; <code><strong>res</strong></code>
[0, 2, 4, 6, 8]</pre>
<p>Though it’s penalized by having to code a function to be applied, the <code>filter</code> call here is still not much longer than the list comprehension either. However, the list comprehension can <em>combine</em> an <code>if</code> clause and an arbitrary expression, to give it the effect of a <code>filter</code> <em>and</em> a <code>map</code>—in a single expression:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>[x ** 2 for x in range(10) if x % 2 == 0]</strong></code>
[0, 4, 16, 36, 64]</pre>
<p>This time, we collect the squares of the even numbers from 0 through 9: the <code>for</code> loop skips numbers for which the attached <code>if</code> clause on the right is false, and the expression on the left computes the squares. The equivalent <code>map</code> call would require a lot more work on our part—we would have to combine <code>filter</code> selections with <code>map</code> iteration, making for a noticeably more complex expression:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>list( map((lambda x: x**2), filter((lambda x: x % 2 == 0), range(10))) )</strong></code>
[0, 4, 16, 36, 64]</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Formal Comprehension Syntax"><div class="sect2" id="formal_comprehension_syntax">
<h2>Formal Comprehension Syntax</h2>
<p>In fact, list comprehensions are more <a contenteditable="false" data-type="indexterm" data-primary="list comprehensions" data-secondary="syntax, formal" id="lpmytx"></a><a contenteditable="false" data-type="indexterm" data-primary="syntax" data-secondary="list comprehensions, formal" id="id3192"></a>general still. In their simplest form, you must always code an accumulation expression and a single <code>for</code> clause:</p>
<pre data-type="programlisting">[ <code><em>expression</em></code> for <code><em>target</em></code> in <code><em>iterable</em></code> ]</pre>
<p>Though all other parts are optional, they allow richer iterations to be expressed—you can code any number of nested <code>for</code> loops in a list comprehension, and each may have an optional associated <code>if</code> test to act as a filter. The general structure of list comprehensions looks like this:</p>
<pre data-type="programlisting">[ <code><em>expression</em></code> for <code><em>target1</em></code> in <code><em>iterable1</em></code> if <code><em>condition1</em></code>
             for <code><em>target2</em></code> in <code><em>iterable2</em></code> if <code><em>condition2</em></code> ...
             for <code><em>targetN</em></code> in <code><em>iterableN</em></code> if <code><em>conditionN</em></code> ]</pre>
<p>This exact same syntax is <a contenteditable="false" data-type="indexterm" data-primary="set comprehensions" data-secondary="syntax" id="id3193"></a><a contenteditable="false" data-type="indexterm" data-primary="dictionaries" data-secondary="comprehensions" data-tertiary="syntax" id="id3194"></a><a contenteditable="false" data-type="indexterm" data-primary="syntax" data-secondary="dictionary comprehensions" id="id3195"></a><a contenteditable="false" data-type="indexterm" data-primary="syntax" data-secondary="set comprehensions" id="id3196"></a>inherited by <em>set</em> and <em>dictionary</em> comprehensions as well as the <em>generator expressions</em> coming up, though these use different enclosing characters—curly braces for the first two and often-optional parentheses for the latter—and the dictionary comprehension begins with two expressions separated by a colon (for key and value).</p>
<p>We experimented with the <code>if</code> filter <a contenteditable="false" data-type="indexterm" data-primary="list comprehensions" data-secondary="for clauses, nested" id="id3197"></a><a contenteditable="false" data-type="indexterm" data-primary="for loops" data-secondary="nested" data-tertiary="list comprehensions" id="id3198"></a>clause in the previous section. When <code>for</code> clauses are <em>nested</em> within a list comprehension, they work like equivalent nested <code>for</code> loop statements. For example:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>res = [x + y for x in [0, 1, 2] for y in [100, 200, 300]]</strong></code>
&gt;&gt;&gt; <code><strong>res</strong></code>
[100, 200, 300, 101, 201, 301, 102, 202, 302]</pre>
<p>This has the same effect as this substantially more verbose equivalent:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>res = []</strong></code>
&gt;&gt;&gt; <code><strong>for x in [0, 1, 2]:
        for y in [100, 200, 300]:
            res.append(x + y)</strong></code>

&gt;&gt;&gt; <code><strong>res</strong></code>
[100, 200, 300, 101, 201, 301, 102, 202, 302]</pre>
<p>Although list comprehensions construct list results, remember that they can iterate over any <a contenteditable="false" data-type="indexterm" data-primary="iteration" data-secondary="list comprehensions" id="id3199"></a><a contenteditable="false" data-type="indexterm" data-primary="list comprehensions" data-secondary="iteration" id="id3200"></a>iterable object. Here’s a similar bit of code that traverses strings instead of lists of numbers, and so collects concatenation results:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>[x + y for x in 'orm' for y in 'ORM']</strong> </code>                    <code><em># 3 * 3 results</em></code>
['oO', 'oR', 'oM', 'rO', 'rR', 'rM', 'mO', 'mR', 'mM']</pre>
<p>Each <code>for</code> clause can have an associated <code>if</code> filter, no matter how deeply the loops are nested—though use cases for the following sort of code, apart perhaps from the multidimensional arrays ahead, start to become more and more difficult to imagine at this level:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>[x + y for x in 'orm' if x in 'ro' for y in 'ORM' if y &gt; 'M']</strong></code>
['oO', 'oR', 'rO', 'rR']

&gt;&gt;&gt; <code><strong>[x + y + z for x in 'hack' if x &gt; 'c'
               for y in 'CODE' if y in 'OD'
               for z in '123'  if z &gt; '1']</strong></code>
['hO2', 'hO3', 'hD2', 'hD3', 'kO2', 'kO3', 'kD2', 'kD3']</pre>
<p>Finally, here is a similar list comprehension that illustrates the effect of attached <code>if</code> selections on nested <code>for</code> clauses applied to numeric objects rather than strings:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>[(x, y) for x in range(5) if x % 2 == 0</strong> </code>
                <code><strong>for y in range(5) if y % 2 == 1]</strong></code>
[(0, 1), (0, 3), (2, 1), (2, 3), (4, 1), (4, 3)]</pre>
<p>This expression combines <em>even</em> numbers from 0 through 4 with <em>odd</em> numbers from 0 through 4. The <code>if</code> clauses filter out items in each iteration. Here is the equivalent statement-based code:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>res = []</strong></code>
&gt;&gt;&gt; <code><strong>for x in range(5):
        if x % 2 == 0:
            for y in range(5):
                if y % 2 == 1:
                    res.append((x, y))
</strong></code>
&gt;&gt;&gt; <code><strong>res</strong></code>
[(0, 1), (0, 3), (2, 1), (2, 3), (4, 1), (4, 3)]</pre>
<p>Recall that if you’re confused about what a complex list comprehension does, you can always nest the list comprehension’s <code>for</code> and <code>if</code> clauses inside each other like this—indenting each clause successively further to the right—to derive the equivalent statements. The result is longer, but perhaps clearer in intent to some human readers on first glance, especially those more familiar with basic statements.</p>
<p>The <code>map</code> and <code>filter</code> equivalent of this last example would be wildly complex and deeply nested, so this book will leave its coding as an exercise for Zen masters, ex–Lisp programmers, and those with far too much free time.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Example: List Comprehensions and Matrixes"><div class="sect2" id="example_list_comprehensions_and_matrixe">
<h2>Example: List Comprehensions and Matrixes</h2>
<p>Not all list comprehensions are so <a contenteditable="false" data-type="indexterm" data-primary="list comprehensions" data-secondary="matrixes and" id="lscphmtx"></a><a contenteditable="false" data-type="indexterm" data-primary="matrixes, list comprehensions" id="mtxlphs"></a>artificial, of course. Let’s look at one more application to stretch our comprehension muscles. As we saw in Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch04.html#introducing_python_objects">4</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch08.html#lists_and_dictionaries">8</a>, one basic way to code matrixes (a.k.a. multidimensional arrays) in Python is with nested list structures. The following, for example, defines two 3 × 3 matrixes as lists of nested lists:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>M = [[1, 2, 3],
         [4, 5, 6],
         [7, 8, 9]]
</strong></code>
&gt;&gt;&gt; <code><strong>N = [[2, 2, 2],
         [3, 3, 3],
         [4, 4, 4]]</strong></code></pre>
<p>Given this structure, we can always index rows, and columns within rows, using normal index <span class="keep-together">operations</span>:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>M[1]</strong></code>              <code><em># Row 2</em></code>
[4, 5, 6]

&gt;&gt;&gt; <code><strong>M[1][2]</strong></code>           <code><em># Row 2, item 3</em></code>
6</pre>
<p>List comprehensions are powerful tools for processing such structures because they automatically scan rows and columns. For instance, although this code stores the matrix by rows, to collect the second <em>column</em> we can simply iterate across the rows and pull out the desired column, or iterate through positions in the rows and index as we go:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>[row[1] for row in M]</strong></code>                          <code><em># Column 2</em></code>
[2, 5, 8]

&gt;&gt;&gt; <code><strong>[M[row][1] for row in (0, 1, 2)]</strong></code>               <code><em># Using offsets</em></code>
[2, 5, 8]</pre>
<p>Given positions, we can also easily <a contenteditable="false" data-type="indexterm" data-primary="list comprehensions" data-secondary="diagonals" id="id3201"></a><a contenteditable="false" data-type="indexterm" data-primary="diagonals" id="id3202"></a>perform tasks such as pulling out a <em>diagonal</em>. The first of the following expressions uses <code>range</code> to generate the list of offsets and then indexes with the row and column the same, picking out <code>M[0][0]</code>, then <code>M[1][1]</code>, and so on. The second scales the column index to fetch <code>M[0][2]</code>, <code>M[1][1]</code>, etc. (we assume the matrix has the same number of rows and columns):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>[M[i][i] for i in range(len(M))]</strong></code>               <code><em># Diagonals</em></code>
[1, 5, 9]

&gt;&gt;&gt; <code><strong>[M[i][len(M)-1-i] for i in range(len(M))]</strong></code>
[3, 5, 7]</pre>
<p>Changing such a matrix <em>in place</em> requires assignment to offsets (use <code>range</code> twice if shapes differ):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>L = [[1, 2, 3], [4, 5, 6]]</strong></code>
&gt;&gt;&gt; <code><strong>for i in range(len(L)):
        for j in range(len(L[i])):</strong></code>                 <code><em># Update in place</em></code>
            <code><strong>L[i][j] += 10
</strong></code>
&gt;&gt;&gt; <code><strong>L</strong></code>
[[11, 12, 13], [14, 15, 16]]</pre>
<p>We can’t really do the same with list comprehensions, as they make <em>new lists</em>, but we could always assign their results to the original name for a similar effect. For example, we can apply an operation to every item in a matrix, producing results in either a simple vector or a matrix of the same shape:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>[col + 10 for row in M for col in row]</strong></code>         <code><em># Assign to M to retain new value
</em></code>[11, 12, 13, 14, 15, 16, 17, 18, 19]

&gt;&gt;&gt; <code><strong>[[col + 10 for col in row] for row in M]</strong></code>
[[11, 12, 13], [14, 15, 16], [17, 18, 19]]</pre>
<p>To understand these, translate to their simple statement form equivalents that follow—indent parts that are further to the right in the expression (as in the first loop in the following), and make a new list when comprehensions are nested on the left (like the second loop in the following). As its statement equivalent makes clearer, the second expression in the preceding works because the row iteration is an outer loop: for each row, it runs the nested column iteration to build up one row of the result matrix:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>res = []</strong></code>
&gt;&gt;&gt; <code><strong>for row in M:</strong></code>                                  <code><em># Statement equivalents
</em></code>        <code><strong>for col in row:</strong></code>                            <code><em># Indent parts further right</em></code>
            <code><strong>res.append(col + 10)
</strong></code>
&gt;&gt;&gt; <code><strong>res</strong></code>
[11, 12, 13, 14, 15, 16, 17, 18, 19]

&gt;&gt;&gt; <code><strong>res = []</strong></code>
&gt;&gt;&gt; <code><strong>for row in M:
        tmp = []</strong></code>                                   <code><em># Left-nesting starts new list</em></code>
        <code><strong>for col in row:
            tmp.append(col + 10)
        res.append(tmp)
</strong></code>
&gt;&gt;&gt; <code><strong>res</strong></code>
[[11, 12, 13], [14, 15, 16], [17, 18, 19]]</pre>
<p>Finally, with a bit of creativity, we can also use list comprehensions to combine values of <em>multiple matrixes</em>. The following first builds a flat list that contains the result of multiplying the matrixes pairwise, and then builds a nested list structure having the same values by nesting list comprehensions again:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>M</strong></code>
[[1, 2, 3], [4, 5, 6], [7, 8, 9]]
&gt;&gt;&gt; <code><strong>N</strong></code>
[[2, 2, 2], [3, 3, 3], [4, 4, 4]]

&gt;&gt;&gt; <code><strong>[M[row][col] * N[row][col] for row in range(3) for col in range(3)]</strong></code>
[2, 4, 6, 12, 15, 18, 28, 32, 36]

&gt;&gt;&gt; <code><strong>[[M[row][col] * N[row][col] for col in range(3)] for row in range(3)]</strong></code>
[[2, 4, 6], [12, 15, 18], [28, 32, 36]]</pre>
<p>This last expression works because the row iteration is an outer loop again; it’s equivalent to this statement-based code:</p>
<pre data-type="programlisting">res = []
for row in range(3):
    tmp = []
    for col in range(3):
        tmp.append(M[row][col] * N[row][col])
    res.append(tmp)</pre>
<p>And for more fun, we can use <code>zip</code> to pair items to be multiplied—the following comprehension and loop statement both produce the same list-of-lists pairwise multiplication result as the last preceding example (and because <code>zip</code> is a generator of values, this isn’t as inefficient as it may seem):</p>
<pre data-type="programlisting">[[col1 * col2 for (col1, col2) in zip(row1, row2)] for (row1, row2) in zip(M, N)]

res = []
for (row1, row2) in zip(M, N):
    tmp = []
    for (col1, col2) in zip(row1, row2):
        tmp.append(col1 * col2)
    res.append(tmp)</pre>
<p>Compared to their statement equivalents, the list comprehension versions here require only one line of code, might run substantially faster for large matrixes, and just might make your head explode. Which brings us to the next section.</p>
<section data-type="sect3" data-pdf-bookmark="When not to use list comprehensions: Code obfuscation"><div class="sect3" id="when_not_to_use_list_comprehensions_cod">
<h3>When not to use list comprehensions: Code obfuscation</h3>
<p>With such generality, list comprehensions can quickly become, well, incomprehensible, especially when <a contenteditable="false" data-type="indexterm" data-primary="list comprehensions" data-secondary="code obfuscation and" id="id3203"></a><a contenteditable="false" data-type="indexterm" data-primary="code obfuscation, list comprehensions and" id="id3204"></a><a contenteditable="false" data-type="indexterm" data-primary="obfuscation, list comprehensions and" id="id3205"></a>nested. Some programming tasks are inherently complex, and we can’t sugarcoat them to make them any simpler than they are (see the upcoming permutations for a prime example). Tools like comprehensions are powerful solutions when used wisely, and there’s nothing inherently wrong with using them in your scripts.</p>
<p>At the same time, code like that at the end of the prior section may introduce more complexity than it should—and, frankly, tends to disproportionately spark the interest of those holding the darker and misinformed assumption that code obfuscation somehow implies talent. In the interest of software citizenship, some perspective seems in order here.</p>
<p>This book demonstrates advanced comprehensions to teach, but in the real world, programming is not about being <em>clever and obscure</em>—it’s about how clearly your program communicates its purpose. Writing tricky comprehensions may be a fun academic recreation, but it doesn’t work in programs that others will someday need to understand.</p>
<p>In other words, the age-old acronym <em>KISS</em> applies here as always: Keep It Simple—traditionally followed either by a word that is now too sexist, or another that is too colorful for a G-rated book like this. If you have to translate code to simpler statements to understand it, it should probably be simpler statements in the first place.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="When to use list comprehensions: Speed, conciseness, etc."><div class="sect3" id="when_to_use_list_comprehensions_speedco">
<h3>When to use list comprehensions: Speed, conciseness, etc.</h3>
<p>Nevertheless, in this case, there <a contenteditable="false" data-type="indexterm" data-primary="list comprehensions" data-secondary="best use" id="lscphbx"></a><a contenteditable="false" data-type="indexterm" data-primary="performance" data-secondary="list comprehensions" id="id3206"></a>is currently a <em>performance</em> advantage to the extra complexity: based on tests run under Python today, <code>map</code> calls and list comprehensions can be significantly faster than equivalent <code>for</code> loops. This speed difference can vary per usage and Python, but is due to the fact that <code>map</code> and list comprehensions run at compiled-language speed inside the interpreter, which is generally faster than running <code>for</code> loop bytecode within the PVM.</p>
<p>Also in the plus column, list comprehensions offer a code <em>conciseness</em> that’s compelling and even warranted when that reduction in size doesn’t also imply a reduction in meaning for the next programmer; many find the <em>expressiveness</em> of comprehensions to be a powerful ally; and because <code>map</code> and list comprehensions are both expressions, they also can show up syntactically in places that <code>for</code> loop statements cannot, such as in <code>lambda</code> and object literals.</p>
<p>Because of all this, list comprehensions and <code>map</code> calls are worth knowing and using for simple sorts of iterations, especially if your application’s speed is an important consideration. For example, it’s hard to argue with the ease and power of code like either of the following:</p>
<pre data-type="programlisting">[line.rstrip() for line in open('myfile')]
map((lambda line: line.rstrip()), open('myfile'))</pre>
<p>To achieve the same memory economy and execution time division as <code>map</code>, though, list comprehensions must be coded as <em>generator expressions</em>—which is why we’ve run through <a contenteditable="false" data-type="indexterm" data-primary="list comprehensions" data-secondary="matrixes and" data-startref="lscphmtx" id="id3207"></a><a contenteditable="false" data-type="indexterm" data-primary="matrixes, list comprehensions" data-startref="mtxlphs" id="id3208"></a><a contenteditable="false" data-type="indexterm" data-primary="list comprehensions" data-secondary="best use" data-startref="lscphbx" id="id3209"></a>this review in the first place, and one of the major topics this chapter turns to next.</p>
</div></section>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Generator Functions and Expressions"><div class="sect1" id="generator_functions_and_expressions">
<h1>Generator Functions and Expressions</h1>
<p>Python today supports procrastination much more than it did in the past—it provides tools that produce results only when needed, instead of all at once. We’ve seen this at work in built-in tools: files that read lines on request, and functions like <code>map</code> and <code>zip</code> that produce items on demand. Such laziness isn’t confined to Python itself, though. In particular, two language constructs delay result creation whenever possible in user-defined operations:</p>
<ul>
<li><p><em>Generator functions</em> are <a contenteditable="false" data-type="indexterm" data-primary="generator functions" id="id3210"></a><a contenteditable="false" data-type="indexterm" data-primary="functions" data-secondary="generator functions" id="id3211"></a>coded as normal <code>def</code> statements, but use <code>yield</code> statements to return results one at a time, suspending and resuming their state between each.</p></li>
<li><p><em>Generator expressions</em> are similar t<a contenteditable="false" data-type="indexterm" data-primary="generator expressions" id="id3212"></a><a contenteditable="false" data-type="indexterm" data-primary="expressions" data-secondary="generator expressions" id="id3213"></a>o the list comprehensions of the prior section, but they return an object that produces results on demand instead of building a result list.</p></li>
</ul>
<p>Because neither of these constructs a result list all at once, they both save memory space and allow computation to be split across requests to avoid pauses and enable large (and even “infinite”) results. As you’ll see, both of these ultimately perform their delayed-results magic by implementing the <em>iteration protocol</em> we studied in <a data-type="xref" href="ch14.html#iterations_and_comprehensions">Chapter 14</a>.</p>
<p>These features date back to at least Python 2.2 (and were explored even earlier in languages like Icon), and are common in Python code today. Though they may initially seem unusual if you’re accustomed to simpler models, you’ll probably find generators to be a powerful tool. Moreover, because they are a natural extension to the function, comprehension, and iteration topics we’ve already explored, you already know more about coding generators than you might expect.</p>
<section data-type="sect2" data-pdf-bookmark="Generator Functions: yield Versus return"><div class="sect2" id="generator_functions_yield_versus_return">
<h2>Generator Functions: yield Versus return</h2>
<p>In this part of the book, we’ve learned about coding normal functions that receive input parameters and send back a single result immediately. It is also possible, however, to write functions that may send back a value and later be resumed, picking up where they left off. Such functions are known as <em>generator functions</em> because they generate a series of values over time instead of stopping after just one.</p>
<p>Generator functions are like normal functions in most respects, and in fact are coded with normal <code>def</code> statements. However, when created, they are compiled specially into an object that supports the iteration protocol. When called, they don’t return a result: they return a result generator that can appear in any iteration context. We studied iterables in <a data-type="xref" href="ch14.html#iterations_and_comprehensions">Chapter 14</a>, and <a data-type="xref" href="ch14.html#the_iteration_protocolcomma_used_by_for">Figure 14-1</a> gave a formal and graphic summary of their operation. Here, we’ll revisit the subject to see how it applies to generators.</p>
<section data-type="sect3" data-pdf-bookmark="State suspension"><div class="sect3" id="state_suspension">
<h3>State suspension</h3>
<p>Unlike normal functions that return <a contenteditable="false" data-type="indexterm" data-primary="generator functions" data-secondary="state suspension" id="gfstts"></a><a contenteditable="false" data-type="indexterm" data-primary="state" data-secondary="suspension" id="sttspgf"></a><a contenteditable="false" data-type="indexterm" data-primary="functions" data-secondary="generator functions" data-tertiary="state suspension" id="fgfsttp"></a>a value and exit, generator functions automatically suspend and resume their execution and state around the point of value generation. Because of that, they are often a useful alternative to both computing an entire series of values up front and manually saving and restoring state in classes. The <em>state</em> that generator functions retain when they are suspended includes both their code location and their entire local scope. Hence, their <em>local variables</em> retain information between results, and make it available when the functions are resumed.</p>
<p>The chief code difference between generator and normal functions is that a generator <em>yields</em> a value, rather than <em>returning</em> one—the <code>yield</code> statement suspends the function and sends a value back to the caller, but retains enough state to enable the function to resume from where it left off. When resumed, the function continues execution immediately after the last <code>yield</code> run. From the function’s perspective, this allows its code to produce a series of values over time, rather than computing them all at once and sending them <a contenteditable="false" data-type="indexterm" data-primary="generator functions" data-secondary="state suspension" data-startref="gfstts" id="id3214"></a><a contenteditable="false" data-type="indexterm" data-primary="state" data-secondary="suspension" data-startref="sttspgf" id="id3215"></a><a contenteditable="false" data-type="indexterm" data-primary="functions" data-secondary="generator functions" data-tertiary="state suspension" data-startref="fgfsttp" id="id3216"></a>back in something like a list.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Iteration protocol integration"><div class="sect3" id="iteration_protocol_integration">
<h3>Iteration protocol integration</h3>
<p>To truly understand generator functions, you need to know that they are closely bound up with the notion of the <a contenteditable="false" data-type="indexterm" data-primary="generator functions" data-secondary="iteration protocol" id="id3217"></a><a contenteditable="false" data-type="indexterm" data-primary="iteration protocol" data-secondary="generator functions" id="id3218"></a>iteration protocol in Python. As we’ve seen, iterator objects define a <code>__next__</code> method, which either returns the next item in the iteration, or raises the <code>StopIteration</code> exception to end the iteration. An iterable object’s iterator is fetched initially with the <code>__iter__</code> method, though this step is a no-op for objects that are their own iterator.</p>
<p>Python <code>for</code> loops, and <a contenteditable="false" data-type="indexterm" data-primary="iteration protocol" data-secondary="for loops" id="id3219"></a><a contenteditable="false" data-type="indexterm" data-primary="for loops" data-secondary="iteration protocol" id="id3220"></a>all other iteration tools, use this iteration protocol to step through a sequence or value generator, if the protocol is supported (if not, iteration falls back on repeatedly indexing sequences instead). Any object that supports this interface works in all iteration tools, and the <code>iter</code> and <code>next</code> built-ins simplify manual iteration by calling the corresponding double-underscore method (or its internal equivalent).</p>
<p>To support this protocol, functions containing a <code>yield</code> statement are compiled <a contenteditable="false" data-type="indexterm" data-primary="yield statement" id="id3221"></a><a contenteditable="false" data-type="indexterm" data-primary="statements" data-secondary="yield" id="id3222"></a>specially as <em>generators</em>—they are not normal functions, but rather are built to return an object with the expected iteration-protocol methods. When later called, such functions return an iterable object that supports the iteration protocol with an automatically created method named <code>__next__</code> to start or resume execution.</p>
<p>Besides <code>yield</code>, generator functions may also use a <code>return</code> statement that, along with falling off the end of the <code>def</code> block, terminates the generation of values by automatically raising a <code>StopIteration</code> exception. A generator’s <code>return</code> can also give an object that becomes the <code>value</code> attribute of the <code>StopIteration</code> exception, but it’s ignored by iteration tools and uncommon. From the caller’s perspective, the generator’s <code>__next__</code> method simply starts or resumes the function and runs until either the next <code>yield</code> result is returned, or a <code>StopIteration</code> is raised.</p>
<p>The net effect is that generator functions, coded as <code>def</code> statements containing <code>yield</code> statements, are automatically made to support the iteration methods protocol and thus may be used in any iteration tool to produce results over time and on demand. The presence of a <code>yield</code> in a <code>def</code> suffices to make all this happen, and none of this applies to <code>lambda</code> because it doesn’t allow statements like <code>yield</code> (which is yet another reason to prefer <code>def</code>).</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Generator functions in action"><div class="sect3" id="generator_functions_in_action">
<h3>Generator functions in action</h3>
<p>As usual, this is probably simpler in code <a contenteditable="false" data-type="indexterm" data-primary="generator functions" id="id3223"></a><a contenteditable="false" data-type="indexterm" data-primary="functions" data-secondary="generator functions" id="id3224"></a>than narrative. The following defines a generator function that can be used to produce the squares of a series of numbers—over time:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>def gensquares(n):
        for i in range(n):
            yield i ** 2</strong></code>        <code><em># Resume here later</em></code></pre>
<p>This function yields a value, and so returns to its caller, each time through the loop. When it is resumed, its prior state is restored, including the last values of its variables <code>i</code> and <code>n</code>, and control picks up again immediately after the <code>yield</code> statement. For example, when it’s used in the body of a <code>for</code> loop, the first iteration starts the function and gets its first result; thereafter, control returns to the function after its <code>yield</code> statement each time through the loop:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>for i in gensquares(5):</strong></code>     <code><em># Resume the function
</em></code>        <code><strong>print(i, end=' ')</strong>  </code>     <code><em># Print last yielded value</em></code>

0 1 4 9 16</pre>
<p>To end the generation of values, functions either use a <code>return</code> statement or simply allow control to fall off the end of the function body. As noted, <code>return</code> can give a value attached to the exit exception, but usually does not.</p>
<p>To most people, this process seems a bit implicit (if not enchanted) on first encounter. It’s actually quite tangible, though. If you really want to see what is going on inside the <code>for</code>, call the generator function directly:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>x = gensquares(3)</strong> </code>          <code><em># Generator of 0..2 squares</em></code>
&gt;&gt;&gt; <code><strong>x</strong></code>
&lt;generator object gensquares at 0x10dc6d700&gt;</pre>
<p>You get back a <em>generator object</em> that supports the iteration protocol—the generator function was <a contenteditable="false" data-type="indexterm" data-primary="generator functions" data-secondary="iteration protocol" id="id3225"></a><a contenteditable="false" data-type="indexterm" data-primary="functions" data-secondary="generator functions" data-tertiary="iteration protocol" id="id3226"></a><a contenteditable="false" data-type="indexterm" data-primary="iteration protocol" data-secondary="generator functions" id="id3227"></a>compiled to return this automatically. The returned generator object in turn has a <code>__next__</code> method that starts the function or resumes it from where it last yielded a value, and raises a <code>StopIteration</code> exception when the end of the series of values is reached and the function returns. As noted, <code>next(<em>X</em>)</code> here calls <code><em>X</em>.__next__()</code> for convenience:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>next(x)</strong></code>                     <code><em># Run to first yield</em></code>
0
&gt;&gt;&gt; <code><strong>next(x)</strong></code>                     <code><em># Resume after yield, run to next yield
</em></code>1
&gt;&gt;&gt; <code><strong>next(x)</strong> </code>                    <code><em># Resume after yield, run to next yield
</em></code>4
&gt;&gt;&gt; <code><strong>next(x)</strong> </code>                    <code><em># Resume after yield, exception on return</em></code>
StopIteration</pre>
<p>Per <a data-type="xref" href="ch14.html#iterations_and_comprehensions">Chapter 14</a>, <code>for</code> loops and other iteration tools work with generators in the same way—by calling the <code>__next__</code> method repeatedly, until the exit exception is caught. For generators, the result produces yielded values over time.</p>
<p>Notice that <a contenteditable="false" data-type="indexterm" data-primary="iteration protocol" data-secondary="iter" id="id3228"></a>the top-level <code>iter</code> call of the iteration protocol isn’t required here because generators are their own iterator, supporting just one active iteration scan. To put that another way, generators return themselves for <code>iter</code> and support <code>next</code> directly. This also holds true in the generator expressions you’ll meet later in this chapter:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>y = gensquares(5)</strong></code>           <code><em># Returns a generator which is its own iterator</em></code>
&gt;&gt;&gt; <code><strong>iter(y) is y</strong></code>                <code><em># iter() is not required: a no-op here
</em></code>True
&gt;&gt;&gt; <code><strong>next(y)</strong></code>                     <code><em># Can run next() immediately
</em></code>0</pre>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Why generator functions?"><div class="sect3" id="why_generator_functionsquestion_mark">
<h3>Why generator functions?</h3>
<p>Given the simple example we’re using to illustrate fundamentals, you might be wondering just why you’d ever <a contenteditable="false" data-type="indexterm" data-primary="generator functions" data-secondary="best uses" id="gnfctbs"></a><a contenteditable="false" data-type="indexterm" data-primary="functions" data-secondary="generator functions" data-tertiary="best uses" id="id3229"></a>care to code a generator at all. In code so far, for instance, we could simply build the list of result values all at once:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>def buildsquares(n):
        res = []
        for i in range(n): res.append(i ** 2)
        return res
</strong></code>
&gt;&gt;&gt; <code><strong>for x in buildsquares(5): print(x, end=' ')</strong></code>

0 1 4 9 16</pre>
<p>For that matter, we could use any of the <code>for</code> loop, <code>map</code>, or list comprehension techniques we’ve already mastered:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>for x in [n ** 2 for n in range(5)]:
        print(x, end=' ')</strong></code>

0 1 4 9 16

&gt;&gt;&gt; <code><strong>for x in map((lambda n: n ** 2), range(5)):
        print(x, end=' ')</strong></code>

0 1 4 9 16</pre>
<p>However, generators can be better in terms of both memory use and performance in larger programs. They allow functions to avoid doing all the work up front, which is especially useful when the result lists are large or when it takes a lot of computation to produce each value. Generators distribute the time required to produce the series of values among loop iterations, and can even produce a series of values that has no end at all (an “infinite” result).</p>
<p>Moreover, for more advanced uses, generators can provide a simpler alternative to manually saving the state between iterations in class objects—with generators, variables accessible in the function’s scopes are saved and restored automatically. You’ll be able to judge this contrast after we discuss class-based iterables in more detail in <a data-type="xref" href="part06.html#classes_and_oop">Part VI</a>.</p>
<p>Generator functions are also more broadly focused than implied so far. They can operate on and return any type of object, and as <em>iterables</em> may appear in any of <a data-type="xref" href="ch14.html#iterations_and_comprehensions">Chapter 14</a>’s iteration tools, including <code>tuple</code> calls, enumerations, and dictionary comprehensions:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>def ups(line):
        for sub in line.split(','):</strong></code>          <code><em># Substring generator</em></code>
            <code><strong>yield sub.upper()
</strong></code>
&gt;&gt;&gt; <code><strong>tuple(ups('aaa,bbb,ccc'))</strong></code>                <code><em># All iteration contexts</em></code>
('AAA', 'BBB', 'CCC')

&gt;&gt;&gt; <code><strong>{i: s for (i, s) in enumerate(ups('aaa,bbb,ccc'))}</strong></code>
{0: 'AAA', 1: 'BBB', 2: 'CCC'}</pre>
<p>In a moment you’ll observe the same assets for generator expressions—a tool that trades function flexibility for comprehension conciseness. Later in this chapter you’ll also see that generators can sometimes enable otherwise impractical tasks, by producing components of result sets that would be far too large to create all at once. First, though, let’s explore some advanced generator function features.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Extended generator function protocol: send versus next"><div class="sect3" id="extended_generator_function_protocol_se">
<h3>Extended generator function protocol: send versus next</h3>
<p>Somewhere along generators’ evolutionary path (in Python 2.5), a <code>send</code> method was added to the <a contenteditable="false" data-type="indexterm" data-primary="generator functions" data-secondary="send method" id="id3230"></a><a contenteditable="false" data-type="indexterm" data-primary="functions" data-secondary="generator functions" data-tertiary="send method" id="id3231"></a><a contenteditable="false" data-type="indexterm" data-primary="send method" id="id3232"></a>generator function protocol. The <code>send</code> method advances to the next item in the series of results, just like <code>__next__</code>, but also provides a way for the caller to communicate with the generator, and hence to affect its operation.</p>
<p>Technically, <code>yield</code> is an <em>expression</em> form that returns the item passed to <code>send</code>, not a statement. It can be coded either way (and usually is a statement), but when used as an expression must be enclosed in parentheses unless it’s the only item on the right side of an assignment statement. For example, <code>X = yield Y</code> is OK, as is <code>X = (yield Y) + Z</code>.</p>
<p>When this extra protocol is used, values are sent into a generator <code>G</code> by calling <code>G.send(<em>value</em>)</code>. The generator’s code is then resumed, and the <code>yield</code> expression inside the generator returns the value passed to <code>send</code> by the caller. If the regular <code>G.__next__()</code> method (or its <code>next(G)</code> equivalent) is called to advance, the <code>yield</code> simply returns <code>None</code>. For example:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>def gen():
       for i in range(10):
           X = yield i
           print('=&gt;', X)
</strong></code>
&gt;&gt;&gt; <code><strong>G = gen()</strong></code>
&gt;&gt;&gt; <code><strong>next(G)</strong></code>              <code><em># Must call next() first, to start generator</em></code>
0
&gt;&gt;&gt; <code><strong>G.send(77)</strong></code>           <code><em># Advance, and send value to yield expression</em></code>
=&gt; 77
1
&gt;&gt;&gt; <code><strong>G.send(88)</strong></code>
=&gt; 88
2
&gt;&gt;&gt; <code><strong>next(G)</strong></code>              <code><em># next() and X.__next__() send None</em></code>
=&gt; None
3</pre>
<p>The <code>send</code> method can be used, for example, to code a generator that its caller can terminate by sending a termination code, or redirect by passing a new position in data being processed inside the generator.</p>
<p>In addition, generators also support a <code>throw(<em>type</em>)</code> method to raise an exception inside the generator at the latest <code>yield</code>, and a <code>close</code> method that raises a special <code>GeneratorExit</code> exception inside the generator to terminate the iteration entirely. Together with <code>send</code>, these are advanced features added to make generators more like a tool called coroutines, a role eventually subsumed in part by the upcoming <code>async</code>. Hence, we won’t delve further here; see Python’s standard manuals for more information, and watch for more on exceptions in <a data-type="xref" href="part07.html#exceptions">Part VII</a>.</p>
<p>Note, though, that while Python provides a <code>next(<em>X</em>)</code> convenience built-in that calls the <code><em>X</em>.__next__()</code> method of an object, other generator methods, like <code>send</code>, must be called as methods of generator objects directly (e.g., <code>G.send(<em>X</em>)</code>). This makes sense if you realize that these extra methods are implemented on built-in generator objects only, whereas the <code>__next__</code> method applies to all iterable objects—both built-in types and user-defined classes.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="The yield from extension"><div class="sect3" id="the_yield_from_extension">
<h3>The yield from extension</h3>
<p>Even later, Python 3.3 introduced <a contenteditable="false" data-type="indexterm" data-primary="generator functions" data-secondary="yield statement" id="grrfcy"></a><a contenteditable="false" data-type="indexterm" data-primary="functions" data-secondary="generator functions" data-tertiary="yield statement" id="fgfcys"></a><a contenteditable="false" data-type="indexterm" data-primary="yield statement" data-secondary="generator functions" id="yttgfc"></a>extended syntax for the <code>yield</code> statement with a <code>from <em>generator</em></code> clause that allows generators to delegate to nested generators (known as <em>subgenerators</em>). In simple cases, it’s the equivalent to a yielding <code>for</code> loop. As a demo, the <code>list</code> call in the following forces a generator to produce values from two sources:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>def both(N):
        for i in range(N): yield i
        for i in map(lambda x: x ** 2, range(N)): yield i
</strong></code>
&gt;&gt;&gt; <code><strong>list(both(5))</strong></code>
[0, 1, 2, 3, 4, 0, 1, 4, 9, 16]</pre>
<p>The <code>yield from</code> syntax makes this more concise and explicit, and supports all the usual generator usage contexts. In the following, <code>both</code> is called a <em>delegating</em> generator, and the <code>range</code> and <code>map</code> built-ins serve as subgenerators (<code>join</code> also uses a generator expression here: see the next section):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>def both(N):
        yield from range(N)
        yield from map(lambda x: x ** 2, range(N))
</strong></code>
&gt;&gt;&gt; <code><strong>list(both(5))</strong></code>
[0, 1, 2, 3, 4, 0, 1, 4, 9, 16]

&gt;&gt;&gt; <code><strong>' : '.join(str(i) for i in both(5))</strong></code>
'0 : 1 : 2 : 3 : 4 : 0 : 1 : 4 : 9 : 16'</pre>
<p>The <code>yield from</code> also supports arbitrary <em>chains</em> of generators. In the following, for example, two generators <code>yield from</code> others, the last of which ultimately uses <code>yield</code> to send results up though the chain:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>def c(n):</strong></code>
<code> <strong>       yield n * 8</strong></code>                   <code><em># The bottom of the "chain"</em></code>
<code> <strong>       yield n ** 2</strong></code>

&gt;&gt;&gt; <code><strong>def b(n):</strong></code>
<code> <strong>       yield from c(n)</strong></code>               <code><em># Delegate to subgenerator</em></code>
 
&gt;&gt;&gt; <code><strong>def a(n):</strong></code>
<code> <strong>       yield from b(n)</strong></code>               <code><em># Delegate to subgenerator</em></code>

&gt;&gt;&gt; <code><strong>g = a(4)</strong> </code>                         <code><em># Make top generator, fetch results</em></code>
&gt;&gt;&gt; <code><strong>g</strong></code>
&lt;generator object a at 0x10bd17940&gt;
&gt;&gt;&gt; <code><strong>next(g)</strong></code>
32

&gt;&gt;&gt; <code><strong>for i in a(4): print(i)</strong> </code>          <code><em># Force results production</em></code>
32
16</pre>
<p>In more advanced roles, though, this extension allows subgenerators to receive <em>sent</em> and <em>thrown</em> values directly from the delegating generator’s caller, and return a final value to the delegating generator as the result of the <code>yield from</code> expression. The net effect allows generators to be split into multiple subgenerators much as a single function can be split into multiple subfunctions, but still operate as though their code appeared inline where the <code>yield from</code> appears.</p>
<p>Since this is both uncommon and beyond this chapter’s scope, we’ll again defer to Python’s standard manuals for more details. For an additional <code>yield from</code> example, see the solution to Exercise 11 from <a data-type="xref" href="ch21.html#test_your_knowledge_part_iv_exercises">“Test Your Knowledge: Part IV Exercises”</a>, and stay tuned for a glimpse of <code>async def</code> coroutines ahead—whose <code>await</code> is something like a generator <code>yield from</code>, with a delegation to an event loop to allow other tasks to be run during pauses. Here, let’s move on to a tool close enough to <code>yield</code> to be <a contenteditable="false" data-type="indexterm" data-primary="generator functions" data-secondary="yield statement" data-startref="grrfcy" id="id3233"></a><a contenteditable="false" data-type="indexterm" data-primary="functions" data-secondary="generator functions" data-tertiary="yield statement" data-startref="fgfcys" id="id3234"></a><a contenteditable="false" data-type="indexterm" data-primary="yield statement" data-secondary="generator functions" data-startref="yttgfc" id="id3235"></a>called a fraternal twin.</p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Generator Expressions: Iterables Meet Comprehensions"><div class="sect2" id="generator_expressions_iterables_meet_co">
<h2>Generator Expressions: Iterables Meet Comprehensions</h2>
<p>Because the delayed evaluation of generator functions was so useful, later Pythons eventually combined the notions of iterables and comprehensions in a new tool: <em>generator expressions</em>. Syntactically, generator expressions are just like normal list comprehensions, and support all their syntax—including <code>if</code> filters and <code>for</code> loop nesting—but they are enclosed in parentheses instead of square brackets (like tuples, their enclosing parentheses are often optional):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>[x ** 2 for x in range(5)]</strong></code>          <code><em># List comprehension: build a list</em></code>
[0, 1, 4, 9, 16]

&gt;&gt;&gt; <code><strong>(x ** 2 for x in range(5))</strong></code>          <code><em># Generator expression: make an iterable</em></code>
&lt;generator object &lt;genexpr&gt; at 0x109607ac0&gt;</pre>
<p>In fact, at least on a functionality basis, coding a list comprehension is essentially the same as wrapping a generator expression in a <code>list</code> built-in call to force it to produce all its results in a list at once:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>list(x ** 2 for x in range(5))</strong></code>      <code><em># List comprehension equivalence</em></code>
[0, 1, 4, 9, 16]</pre>
<p>Operationally, however, generator expressions are very different: instead of building the result list in memory, <a contenteditable="false" data-type="indexterm" data-primary="generator expressions" data-secondary="generator objects" id="id3236"></a><a contenteditable="false" data-type="indexterm" data-primary="expressions" data-secondary="generator expressions" data-tertiary="generator objects" id="id3237"></a><a contenteditable="false" data-type="indexterm" data-primary="generator objects" data-secondary="generator expressions" id="id3238"></a><a contenteditable="false" data-type="indexterm" data-primary="objects" data-secondary="generator objects" id="id3239"></a>they return a <em>generator object</em>—an automatically created iterable. This iterable object in turn supports the <em>iteration protocol</em> to yield one piece of the result list at a time in any iteration tool. The iterable object also retains generator state while active—the variable <code>x</code> in the preceding expressions, along with the generator’s code location.</p>
<p>The net effect is much like that of generator functions, but in the context of a comprehension <em>expression</em>: we get back an object that remembers where it left off after each part of its result is returned. Also like generator functions, looking under the hood at the protocol that these objects automatically support can help demystify them; the <code>iter</code> call is again not required at the top here, for reasons we’ll expand on ahead:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>G = (x ** 2 for x in range(3))</strong></code>
&gt;&gt;&gt; <code><strong>iter(G) is G</strong></code>                        <code><em># iter(G) optional: __iter__ returns self
</em></code>True
&gt;&gt;&gt; <code><strong>next(G)</strong></code>                             <code><em># Generator objects: automatic methods</em></code>
0
&gt;&gt;&gt; <code><strong>next(G)</strong></code>
1
&gt;&gt;&gt; <code><strong>next(G)</strong></code>
4
&gt;&gt;&gt; <code><strong>next(G)</strong></code>
StopIteration

&gt;&gt;&gt; <code><strong>G</strong></code>
&lt;generator object &lt;genexpr&gt; at 0x109607920&gt;</pre>
<p>Again, we don’t typically see the <code>next</code> iterator machinery under the hood of a generator expression like this because <code>for</code> loops and similar tools trigger it for us automatically:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>for num in (x ** 2 for x in range(3)):</strong></code>        <code><em># Calls next() automatically</em></code>
        <code><strong>print(num, num / 2.0, sep=', ')</strong></code>

0, 0.0
1, 0.5
4, 2.0</pre>
<p class="pagebreak-before">As we’ve already seen, every iteration tool does this—including <code>for</code> loops; the <code>list</code> call we used earlier; comprehensions of all kinds; the <code>map</code> and <code>filter</code> functional tools; and other iteration tools we explored in <a data-type="xref" href="ch14.html#iterations_and_comprehensions">Chapter 14</a>, including the <code>sum</code>, <code>sorted</code>, <code>any</code>, and <code>all</code> built-in functions. As <em>iterables</em>, generator <a contenteditable="false" data-type="indexterm" data-primary="generator expressions" data-secondary="as iterables" id="id3240"></a><a contenteditable="false" data-type="indexterm" data-primary="expressions" data-secondary="generator expressions" data-tertiary="as iterables" id="id3241"></a><a contenteditable="false" data-type="indexterm" data-primary="iterables" data-secondary="generator expressions as" id="id3242"></a>expressions can be used in any of these iteration tools, just like both physical sequences and the results of a generator-function call.</p>
<p>For example, the following deploys generator expressions in the string <code>join</code> method call and tuple assignment, iteration tools both. Recall that <code>join</code> with an empty-string delimiter concatenates values produced by its iterable:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>''.join(x.upper() for x in 'aaa,bbb,ccc'.split(','))</strong></code>
'AAABBBCCC'

&gt;&gt;&gt; <code><strong>a, b, c = (x + '\n' for x in 'aaa,bbb,ccc'.split(','))</strong></code>
&gt;&gt;&gt; <code><strong>a, c</strong></code>
('aaa\n', 'ccc\n')</pre>
<p>Notice how the <code>join</code> call in the preceding doesn’t require <em>extra</em> parentheses around the generator. Syntactically, parentheses are <em>not required</em> around a generator expression that is the sole item already enclosed in parentheses used for other purposes—like those of a function call. Parentheses are required in all other cases, however, even if they seem extra, as in the second call to <code>sorted</code> that follows:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>sum(x ** 2 for x in range(3))</strong></code>                           <code><em># Parens optional</em></code>
5
&gt;&gt;&gt; <code><strong>sorted(x ** 2 for x in range(3))</strong></code>                        <code><em># Parens optional
</em></code>[0, 1, 4]
&gt;&gt;&gt; <code><strong>sorted((x ** 2 for x in range(3)), reverse=True)</strong></code>        <code><em># Parens required!</em></code>
[4, 1, 0]</pre>
<p>Like the often-optional parentheses in tuples, there is no widely accepted rule on this, though a generator expression does not have as clear a role as a fixed collection of other objects as a tuple, making extra parentheses seem perhaps more spurious here.</p>
<section data-type="sect3" data-pdf-bookmark="Why generator expressions?"><div class="sect3" id="why_generator_expressionsquestion_mark">
<h3>Why generator expressions?</h3>
<p>Just like generator functions, generator expressions are a <em>memory-space</em> optimization—they do not require <a contenteditable="false" data-type="indexterm" data-primary="generator expressions" data-secondary="best uses" id="id3243"></a><a contenteditable="false" data-type="indexterm" data-primary="expressions" data-secondary="generator expressions" data-tertiary="best uses" id="id3244"></a>the entire result list to be constructed all at once, as the square-bracketed list comprehension does. Also like generator functions, they divide the work of results production into smaller <em>time slices</em>—they yield results in piecemeal fashion, instead of making the caller wait for the full set to be created in a single call.</p>
<p>On the other hand, because generator expressions often run <em>slower</em> today than list comprehensions, they may be best reserved for result sets that are very large, or programs that cannot wait for full results generation. A more authoritative statement about performance, though, will have to await the timing scripts we’ll code in the next chapter.</p>
<p>On the subjective upside, generator expressions also offer significant <em>coding</em> advantages—as the next sections show.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Generator expressions versus map"><div class="sect3" id="generator_expressions_versus_map">
<h3>Generator expressions versus map</h3>
<p>One way to see the coding benefits of <a contenteditable="false" data-type="indexterm" data-primary="expressions" data-secondary="generator expressions" data-tertiary="versus map function" data-tertiary-sortas="map" id="exgexvp"></a><a contenteditable="false" data-type="indexterm" data-primary="generator expressions" data-secondary="versus map function" data-secondary-sortas="map" id="gtxpvmp"></a><a contenteditable="false" data-type="indexterm" data-primary="map function" data-secondary="versus generator expressions" id="mpvgxprs"></a>generator expressions is to compare them to other functional tools, as we did for list comprehensions. For example, generator expressions often are equivalent to <code>map</code> calls, because both generate result items on request. Like list comprehensions, though, generator expressions may be simpler to code when the operation applied is not a function call:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>list(map(abs, (-1, -2, 3, 4)))</strong></code>                        <code><em># Map function on tuple</em></code>
[1, 2, 3, 4]
&gt;&gt;&gt; <code><strong>list(abs(x) for x in (-1, -2, 3, 4))</strong></code>                  <code><em># Generator expression</em></code>
[1, 2, 3, 4]

&gt;&gt;&gt; <code><strong>list(map(lambda x: x * 2, (1, 2, 3, 4)))</strong></code>              <code><em># Nonfunction case</em></code>
[2, 4, 6, 8]
&gt;&gt;&gt; <code><strong>list(x * 2 for x in (1, 2, 3, 4))</strong></code>                     <code><em># Simpler as generator?</em></code>
[2, 4, 6, 8]</pre>
<p>The same holds true for text-processing use cases like the <code>join</code> call we saw earlier—a list comprehension makes an extra temporary list of results, which is completely <em>pointless</em> in this context because the list is not retained, and <code>map</code> loses simplicity points compared to generator expression syntax when the operation being applied is not a call:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>line = 'aaa,bbb,ccc'</strong></code>
&gt;&gt;&gt; <code><strong>''.join([x.upper() for x in line.split(',')])</strong></code>         <code><em># Makes temporary list</em></code>
'AAABBBCCC'

&gt;&gt;&gt; <code><strong>''.join(x.upper() for x in line.split(','))</strong></code>           <code><em># Generates results</em></code>
'AAABBBCCC'
&gt;&gt;&gt; <code><strong>''.join(map(str.upper, line.split(',')))</strong></code>              <code><em># Generates results</em></code>
'AAABBBCCC'

&gt;&gt;&gt; <code><strong>''.join(x * 2 for x in line.split(','))</strong></code>               <code><em># Simpler as generator?</em></code>
'aaaaaabbbbbbcccccc'
&gt;&gt;&gt; <code><strong>''.join(map(lambda x: x * 2, line.split(',')))</strong></code>
'aaaaaabbbbbbcccccc'</pre>
<p>Both <code>map</code> and generator <a contenteditable="false" data-type="indexterm" data-primary="map function" data-secondary="nesting" id="id3245"></a><a contenteditable="false" data-type="indexterm" data-primary="generator expressions" data-secondary="nesting" id="id3246"></a><a contenteditable="false" data-type="indexterm" data-primary="nesting" data-secondary="generator expressions" id="id3247"></a><a contenteditable="false" data-type="indexterm" data-primary="nesting" data-secondary="map function" id="id3248"></a>expressions can also be arbitrarily <em>nested</em>; when coded this way, a <code>list</code> call or other iteration tool starts the entire process of producing results. For example, the list comprehension in the following produces the same result as the <code>map</code> and generator equivalents that follow it, but makes two physical lists. The others generate just one integer at a time with nested generators, and the generator expression form may more clearly reflect its intent:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>[x * 2 for x in [abs(x) for x in (-1, -2, 3, 4)]]</strong></code>        <code><em># Nested list comps</em></code>
[2, 4, 6, 8]

&gt;&gt;&gt; <code><strong>list(map(lambda x: x * 2, map(abs, (-1, -2, 3, 4))))</strong></code>     <code><em># Nested maps
</em></code>[2, 4, 6, 8]

&gt;&gt;&gt; <code><strong>list(x * 2 for x in (abs(x) for x in (-1, -2, 3, 4)))</strong></code>    <code><em># Nested generators</em></code>
[2, 4, 6, 8]</pre>
<p>Although the effect of all three of these is to combine operations, the generators do so without making multiple temporary lists. In fact, the next example both nests <em>and</em> combines generators—the nested generator expression is activated by <code>map</code>, which in turn is only activated by <code>list</code>:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>import math</strong></code>
&gt;&gt;&gt; <code><strong>list(map(math.sqrt, (x ** 2 for x in range(4))))</strong></code>         <code><em># Nested combos</em></code>
[0.0, 1.0, 2.0, 3.0]</pre>
<p>Technically speaking, the <code>range</code> on the right in the preceding is a value generator too, activated by the generator expression itself—forming <em>three levels</em> of value generation, which produce individual values from inner to outer only on request, and which “just works” because of Python’s iteration tools and protocol. In fact, generator nestings can be arbitrarily mixed and deep, though some may be more valid than others:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>list(map(abs, map(abs, map(abs, (-1, 0, 1)))))</strong></code>           <code><em># Nesting gone bad?</em></code>
[1, 0, 1]
&gt;&gt;&gt; <code><strong>list(abs(x) for x in (abs(x) for x in (abs(x) for x in (-1, 0, 1))))</strong></code>
[1, 0, 1]</pre>
<p>These last examples illustrate how general generators can be, but are also coded in an intentionally complex form to underscore that generator expressions have the same potential for abuse as the list comprehensions discussed earlier—as usual, you should keep them simple unless they must be <span class="keep-together">complex</span>.</p>
<p>When used well, though, generator expressions combine the expressiveness of list comprehensions with the space and time benefits of other iterables. The following <em>nonnested</em> alternatives, for example, provide simpler solutions to the preceding three listings’ nested <a contenteditable="false" data-type="indexterm" data-primary="expressions" data-secondary="generator expressions" data-tertiary="versus map function" data-tertiary-sortas="map" data-startref="exgexvp" id="id3249"></a><a contenteditable="false" data-type="indexterm" data-primary="generator expressions" data-secondary="versus map function" data-secondary-sortas="map" data-startref="gtxpvmp" id="id3250"></a><a contenteditable="false" data-type="indexterm" data-primary="map function" data-secondary="versus generator expressions" data-startref="mpvgxprs" id="id3251"></a>codings, but still leverage generators’ strengths:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>list(abs(x) * 2 for x in (-1, -2, 3, 4))</strong></code>                 <code><em># Same, unnested</em></code>
[2, 4, 6, 8]
&gt;&gt;&gt; <code><strong>list(math.sqrt(x ** 2) for x in range(4))</strong></code>                <code><em># Flat may be better</em></code>
[0.0, 1.0, 2.0, 3.0]
&gt;&gt;&gt; <code><strong>list(abs(x) for x in (-1, 0, 1))</strong></code>
[1, 0, 1]</pre>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Generator expressions versus filter"><div class="sect3" id="generator_expressions_versus_filter">
<h3>Generator expressions versus filter</h3>
<p>Generator expressions also support all the <a contenteditable="false" data-type="indexterm" data-primary="expressions" data-secondary="generator expressions" data-tertiary="versus filter function" data-tertiary-sortas="filter function" id="id3252"></a><a contenteditable="false" data-type="indexterm" data-primary="generator expressions" data-secondary="versus filter function" data-secondary-sortas="filter function" id="id3253"></a><a contenteditable="false" data-type="indexterm" data-primary="filter function" id="id3254"></a><a contenteditable="false" data-type="indexterm" data-primary="list comprehensions" data-secondary="filter function" id="id3255"></a>usual list comprehension syntax—including <code>if</code> clauses, which work like the <code>filter</code> call we met earlier. Because <code>filter</code> is an iterable that generates its results on request, a generator expression with an <code>if</code> clause is operationally equivalent. Again, the <code>join</code> in the following is an iteration tool that suffices to force all forms to produce their results:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>line = 'aa bbb c'</strong></code>
&gt;&gt;&gt; <code><strong>''.join(x for x in line.split() if len(x) &gt; 1)</strong></code>           <code><em># Generator with if</em></code>
'aabbb'
&gt;&gt;&gt; <code><strong>''.join(filter(lambda x: len(x) &gt; 1, line.split()))</strong></code>      <code><em># Equivalent filter
</em></code>'aabbb'</pre>
<p>The generator seems just marginally simpler than the <code>filter</code> here. As for list comprehensions, though, adding processing steps to <code>filter</code> results requires a <code>map</code> too, which makes <code>filter</code> noticeably more complex:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>''.join(x.upper() for x in line.split() if len(x) &gt; 1)</strong></code>
'AABBB'
&gt;&gt;&gt; <code><strong>''.join(map(str.upper, filter(lambda x: len(x) &gt; 1, line.split())))</strong></code>
'AABBB'</pre>
<p>In effect, generator expressions provide more general coding structures that do not rely on functions, but still delay results production. Also like list comprehensions, there is always a statement-based equivalent to a generator expression, though it sometimes renders substantially more code:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>res = ''</strong></code>
&gt;&gt;&gt; <code><strong>for x in line.split():</strong></code>                              <code><em># Statement equivalent?</em></code>
        <code><strong>if len(x) &gt; 1:</strong></code>                                  <code><em># This is also a join</em></code>
            <code><strong>res += x.upper()
</strong></code>
&gt;&gt;&gt; <code><strong>res</strong></code>
'AABBB'</pre>
<p class="pagebreak-before">In this case, though, the statement form isn’t quite the same—it cannot produce items one at a time, and it’s also emulating the effect of the <code>join</code> that forces results to be produced all at once. The true equivalent to a generator expression would be a generator function with a <code>yield</code>, as the next section will show.</p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Generator Functions Versus Generator Expressions"><div class="sect2" id="generator_functions_versus_generator_ex">
<h2>Generator Functions Versus Generator Expressions</h2>
<p>Let’s recap what we’ve covered so far in this section:</p>
<dl>
<dt>Generator functions</dt>
<dd>A function <code>def</code> statement <a contenteditable="false" data-type="indexterm" data-primary="generator functions" id="id3256"></a><a contenteditable="false" data-type="indexterm" data-primary="functions" data-secondary="generator functions" id="id3257"></a><a contenteditable="false" data-type="indexterm" data-primary="generator objects" id="id3258"></a><a contenteditable="false" data-type="indexterm" data-primary="objects" data-secondary="generator objects" id="id3259"></a>that contains a <code>yield</code> statement is turned into a generator function. When called, it returns a new <em>generator object</em> with automatic retention of local scope and code position; an automatically created <code>__iter__</code> method that simply returns itself; and an automatically created <code>__next__</code> method that starts the function or resumes it where it last left off, and raises <code>StopIteration</code> when finished producing results.</dd>
<dt>Generator expressions</dt>
<dd>A comprehension expression enclosed in <a contenteditable="false" data-type="indexterm" data-primary="generator expressions" id="id3260"></a><a contenteditable="false" data-type="indexterm" data-primary="expressions" data-secondary="generator expressions" id="id3261"></a>parentheses is known as a generator expression. When run, it returns a new <em>generator object</em> with the same automatically created method interface and state retention as a generator function call’s results—with an <code>__iter__</code> method that simply returns itself; and a <code>__next__</code> method that starts the implied loop or resumes it where it last left off, and raises <code>StopIteration</code> when finished producing results.</dd>
</dl>
<p>The net effect is to automatically produce results on demand in all iteration tools that employ either of these.</p>
<p>As implied by preceding coverage, the same iteration can often be coded with <em>either</em> a generator function or a generator expression. The following generator <em>expression</em>, for example, repeats each character in a string four times:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>G = (c * 4 for c in 'hack')</strong></code>           <code><em># Generator expression</em></code>
&gt;&gt;&gt; <code><strong>list(G)</strong></code>                               <code><em># Force generator to produce results</em></code>
['hhhh', 'aaaa', 'cccc', 'kkkk']</pre>
<p>The equivalent generator <em>function</em> requires slightly more code, but its multiple-statement block will be able to code more logic and use more state information if needed. In fact, this is essentially the same as the prior chapter’s trade-off between <code>lambda</code> and <code>def</code>—expression conciseness versus statement power:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>def timesfour(S):</strong></code>                     <code><em># Generator function</em></code>
        <code><strong>for c in S:
            yield c * 4
</strong></code>
&gt;&gt;&gt; <code><strong>G = timesfour('hack')</strong></code>
&gt;&gt;&gt; <code><strong>list(G)</strong></code>                               <code><em># Iterate automatically</em></code>
['hhhh', 'aaaa', 'cccc', 'kkkk']</pre>
<p>To their clients, the two are more similar than different. For instance, both expressions and functions support both automatic and manual iteration—the prior <code>list</code> call iterates automatically, and the following iterate manually:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>G = (c * 4 for c in 'hack')</strong></code>
&gt;&gt;&gt; <code><strong>I = iter(G)</strong></code>                           <code><em># Iterate manually (expression)</em></code>
&gt;&gt;&gt; <code><strong>next(I)</strong></code>
'hhhh'
&gt;&gt;&gt; <code><strong>next(I)</strong></code>
'aaaa'

&gt;&gt;&gt; <code><strong>G = timesfour('hack')</strong></code>
&gt;&gt;&gt; <code><strong>I = iter(G)</strong></code>                           <code><em># Iterate manually (function)</em></code>
&gt;&gt;&gt; <code><strong>next(I)</strong></code>
'hhhh'
&gt;&gt;&gt; <code><strong>next(I)</strong></code>
'aaaa'</pre>
<p>In either case, Python automatically creates a generator object, which has both the methods required by the iteration protocol, and state retention for variables in the generator’s code and its current code location. Notice how we make new generators here to iterate again—as explained in the next section, generators are single-pass iterators.</p>
<p>First, though, here’s the true statement-based equivalent of the expression at the end of the prior section: a function that yields values—though the difference is irrelevant if the code using it produces all results with a tool like <code>join</code>:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>line = 'aa bbb c'</strong></code>

&gt;&gt;&gt; <code><strong>''.join(x.upper() for x in line.split() if len(x) &gt; 1)</strong></code>    <code><em># Expression</em></code>
'AABBB'

&gt;&gt;&gt; <code><strong>def gensub(line):</strong> </code>                                        <code><em># Function</em></code>
        <code><strong>for x in line.split():
            if len(x) &gt; 1:
                yield x.upper()
</strong></code>
&gt;&gt;&gt; <code><strong>''.join(gensub(line))</strong></code>                                     <code><em># But why generate?</em></code>
'AABBB'</pre>
<p>While generators have valid roles, in cases like this the use of generators over the simple statement equivalent shown earlier may be difficult to justify, except on stylistic grounds: if you’re just going to immediately <code>join</code> generated results anyhow, you might as well skip generators and use simple loops. On the other hand, trading four lines for the generator expression’s one may to many seem fairly compelling stylistic grounds!</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Generator Odds and Ends"><div class="sect2" id="generator_odds_and_ends">
<h2>Generator Odds and Ends</h2>
<p>This section wraps up generators with a quick rundown of associated but lesser topics. After this, we’ll move on to larger examples, but make sure you have a handle on the smaller bits before jumping ahead.</p>
<section data-type="sect3" data-pdf-bookmark="Generators are single-pass iterables"><div class="sect3" id="generators_are_single_pass_iterables">
<h3>Generators are single-pass iterables</h3>
<p>First up, a subtle but <a contenteditable="false" data-type="indexterm" data-primary="generators" data-secondary="single-pass iterables" id="gnrsgptr"></a><a contenteditable="false" data-type="indexterm" data-primary="iterables" data-secondary="single-pass" id="itrsgpss"></a><a contenteditable="false" data-type="indexterm" data-primary="iterables" data-secondary="generators" id="itbgnr"></a>important point: both generator functions and generator expressions are their own iterators and thus support just <em>one active iteration</em>—unlike some built-in types, you can’t have multiple iterators of either generator positioned at different locations in the stream of results. Because of this, a generator’s iterator is the generator itself; in fact, as suggested earlier, calling <code>iter</code> on a generator expression or function is an optional no-op:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>G = (c * 4 for c in 'hack')</strong></code>
&gt;&gt;&gt; <code><strong>iter(G) is G</strong></code>                          <code><em># My iterator is myself: G has __next__</em></code>
True</pre>
<p>If you do iterate over the results stream manually with multiple iterators, they will all point to the same position:</p>
<pre class="pagebreak-before" data-type="programlisting">&gt;&gt;&gt; <code><strong>G = (c * 4 for c in 'hack')</strong></code>           <code><em># Make a new generator</em></code>
&gt;&gt;&gt; <code><strong>I1 = iter(G)</strong></code>                          <code><em># Iterate manually</em></code>
&gt;&gt;&gt; <code><strong>next(I1)</strong></code>
'hhhh'
&gt;&gt;&gt; <code><strong>next(I1)</strong></code>
'aaaa'
&gt;&gt;&gt; <code><strong>I2 = iter(G)</strong></code>                          <code><em># Second iterator at same position!</em></code>
&gt;&gt;&gt; <code><strong>next(I2)</strong></code>
'cccc'</pre>
<p>Moreover, once any iteration runs to completion, all are exhausted—we have to make a new generator to start again:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>list(I1)</strong></code>                              <code><em># Collect the rest of I1's items
</em></code>['kkkk'] 
&gt;&gt;&gt; <code><strong>next(I2)</strong></code>                              <code><em># Other iterators exhausted too
</em></code>StopIteration

&gt;&gt;&gt; <code><strong>I3 = iter(G)</strong></code>                          <code><em># Ditto for new iterators
</em></code>&gt;&gt;&gt; <code><strong>next(I3)</strong></code>
StopIteration

&gt;&gt;&gt; <code><strong>I3 = iter(c * 4 for c in 'hack')</strong></code>      <code><em># New generator to start over</em></code>
&gt;&gt;&gt; <code><strong>next(I3)</strong></code>
'hhhh'</pre>
<p>The same holds true for generator functions—the following <code>def</code> statement-based equivalent supports just one active iterator and is exhausted after one pass:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>def timesfour(S):
        for c in S:
            yield c * 4
</strong></code>
&gt;&gt;&gt; <code><strong>G = timesfour('hack')</strong></code>                 <code><em># Generator functions work the same way</em></code>
&gt;&gt;&gt; <code><strong>iter(G) is G</strong> </code>                         <code><em># One scan per generator (call)</em></code>
True
&gt;&gt;&gt; <code><strong>I1, I2 = iter(G), iter(G)</strong></code>
&gt;&gt;&gt; <code><strong>next(I1)</strong></code>
'hhhh'
&gt;&gt;&gt; <code><strong>next(I1)</strong></code>
'aaaa'
&gt;&gt;&gt; <code><strong>next(I2)</strong></code>                              <code><em># I2 at same position as I1</em></code>
'cccc'</pre>
<p>This is different from the behavior of some built-in objects like lists, which support multiple iterators and passes and even reflect their in-place changes in active iterators:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>L = [1, 2, 3, 4]</strong></code>
&gt;&gt;&gt; <code><strong>I1, I2 = iter(L), iter(L)</strong></code>
&gt;&gt;&gt; <code><strong>next(I1)</strong></code>
1
&gt;&gt;&gt; <code><strong>next(I1)</strong></code>
2
&gt;&gt;&gt; <code><strong>next(I2)</strong></code>                              <code><em># Lists support multiple iterators
</em></code>1
&gt;&gt;&gt; <code><strong>del L[2:]</strong></code>                             <code><em># Changes reflected in iterators
</em></code>&gt;&gt;&gt; <code><strong>next(I1)</strong></code>
StopIteration</pre>
<p class="pagebreak-before">Though not readily apparent in these simple examples, this can matter in your code: if you wish to scan a generator’s values multiple times, you must either create a <em>new</em> generator for each scan or build a rescannable <em>list</em> out of its values—a single generator’s values will be consumed and exhausted after a single pass. See this chapter’s sidebar <a data-type="xref" href="#why_you_will_care_iteration_versus_pyth">“Why You Will Care: Iteration Versus Python Morph”</a> for a prime example of the sort of code impacted by this.</p>
<p>When we begin coding <em>class-based</em> iterables in <a data-type="xref" href="part06.html#classes_and_oop">Part VI</a>, you’ll also see that it’s up to us to decide how many iterations we wish to support for our objects, if any. In general, objects that wish to support <a contenteditable="false" data-type="indexterm" data-primary="generators" data-secondary="single-pass iterables" data-startref="gnrsgptr" id="id3262"></a><a contenteditable="false" data-type="indexterm" data-primary="iterables" data-secondary="single-pass" data-startref="itrsgpss" id="id3263"></a><a contenteditable="false" data-type="indexterm" data-primary="iterables" data-secondary="generators" data-startref="itbgnr" id="id3264"></a>multiple scans will return supplemental class objects instead of themselves for <code>iter</code>. The next section previews more of this model.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Generation in built-ins and classes"><div class="sect3" id="generation_in_built_ins_and_classes">
<h3>Generation in built-ins and classes</h3>
<p>Although we’ve focused <a contenteditable="false" data-type="indexterm" data-primary="generators" data-secondary="built-ins" id="gntbut"></a><a contenteditable="false" data-type="indexterm" data-primary="generators" data-secondary="classes" id="gttclss"></a><a contenteditable="false" data-type="indexterm" data-primary="built-ins" data-secondary="generators" id="bltgnrt"></a><a contenteditable="false" data-type="indexterm" data-primary="classes" data-secondary="generators" id="clssgr"></a>on coding value generators ourselves in this section, don’t forget that many built-in types behave the same way. As we saw in <a data-type="xref" href="ch14.html#iterations_and_comprehensions">Chapter 14</a>, for example, <em>dictionaries</em> and <em>files</em> generate results too:</p>
<pre data-type="programlisting">for key in <code><em>dictionary</em></code>: …                          <code><em># See Chapter 14 et al.</em></code>
for line in <code><em>file</em></code>: …</pre>
<p>Though beyond this book’s scope, many Python standard-library tools generate values too, including its <em>directory walker</em>—which at each level of a folder tree yields a tuple of the current directory, its subdirectories, and its files:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>import os</strong></code>
&gt;&gt;&gt; <code><strong>for (root, subs, files) in os.walk('..'):</strong></code>     <code><em># Directory-walk generator</em></code>
        <code><strong>for name in files:</strong></code>                        <code><em># A Python 'find' operation</em></code>
            <code><strong>if name.endswith('.py'):</strong></code>              <code><em># Also os.path.join(root, name)</em></code>
<code> <strong>               print(root, name)</strong></code>

../Chapter02 script0.py
../Chapter03 myfile.py
../Chapter03 script1.py
…<code><em>etc</em></code>…</pre>
<p>Because the current Python-coded implementation of <code>os.walk</code> uses <code>yield</code> to return results, it’s a normal generator function, and hence iterable object, that generates a three-item tuple on each iteration:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>G = os.walk('..')</strong>  </code>     <code><em># A single-scan iterator: iter(G) optional</em></code>
&gt;&gt;&gt; <code><strong>next(G)</strong></code>
('..', ['Chapter02', 'Chapter03', 'Chapter04', …<code><em>etc</em></code>… 'Chapter37'], [])
&gt;&gt;&gt; <code><strong>next(G)</strong></code>
('../Chapter02', ['__pycache__'], ['script0.py'])</pre>
<p>By yielding results as it goes, the walker does not require its clients to wait for an entire tree to be scanned. See Python’s manuals for more on this tool. For system-tools fans, also see the next chapter for an example that uses <code>os.popen</code>—a related iterable used to run a shell command and read its output. And for additional examples of built-in value generators and the iteration tools that use them, review <a data-type="xref" href="ch14.html#iterations_and_comprehensions">Chapter 14</a>.</p>
<p>Finally, although beyond the scope of this chapter, it is also possible to implement arbitrary user-defined generator objects with <em>classes</em> that conform to the iteration protocol. Such classes define <code>__iter__</code> and <code>__next__</code> methods explicitly to support the protocol:</p>
<pre data-type="programlisting">class SomeIterable:
    def __iter__(...): ...     <code><em># On iter(): return self or supplemental object</em></code>
    def __next__(...): ...     <code><em># On next(): coded here, or in another class</em></code></pre>
<p>As the prior section suggested, these classes usually return their objects directly for single-iteration behavior, or a supplemental object with scan-specific state for multiple-scan support.</p>
<p>Alternatively, a user-defined iterable class’s <code>__iter__</code> may use <code>yield</code> to transform itself into a generator, and a <code>__getitem__</code> indexing method is also available as a fallback option for iteration with trade-offs we’ll explore later. However this is coded, the iterator and generator story won’t really be complete until we’ve seen how it also maps to classes. For now, we’ll have <a contenteditable="false" data-type="indexterm" data-primary="generators" data-secondary="built-ins" data-startref="gntbut" id="id3265"></a><a contenteditable="false" data-type="indexterm" data-primary="generators" data-secondary="classes" data-startref="gttclss" id="id3266"></a><a contenteditable="false" data-type="indexterm" data-primary="built-ins" data-secondary="generators" data-startref="bltgnrt" id="id3267"></a><a contenteditable="false" data-type="indexterm" data-primary="classes" data-secondary="generators" data-startref="clssgr" id="id3268"></a>to settle for postponing its conclusion—and its final sequel—until <a data-type="xref" href="ch30.html#operator_overloading-id000103">Chapter 30</a>.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Comprehensions versus type calls and generators"><div class="sect3" id="comprehensions_versus_type_calls_and_ge">
<h3>Comprehensions versus type calls and generators</h3>
<p>We’ve also been focusing on list <a contenteditable="false" data-type="indexterm" data-primary="comprehensions" data-secondary="type calls" id="id3269"></a><a contenteditable="false" data-type="indexterm" data-primary="comprehensions" data-secondary="generators and" id="id3270"></a><a contenteditable="false" data-type="indexterm" data-primary="type calls, comprehensions" id="id3271"></a><a contenteditable="false" data-type="indexterm" data-primary="generators" data-secondary="comprehensions" id="id3272"></a>comprehensions and generators in this chapter, but keep in mind that there are two other comprehension expression forms: the set and dictionary <a contenteditable="false" data-type="indexterm" data-primary="set comprehensions" id="id3273"></a><a contenteditable="false" data-type="indexterm" data-primary="dictionaries" data-secondary="comprehensions" id="id3274"></a><a contenteditable="false" data-type="indexterm" data-primary="comprehensions" data-secondary="dictionary" id="id3275"></a><a contenteditable="false" data-type="indexterm" data-primary="comprehensions" data-secondary="set" id="id3276"></a>comprehensions we met earlier in <a data-type="xref" href="ch14.html#iterations_and_comprehensions">Chapter 14</a> and <a data-type="xref" href="part02.html#objects_and_operations">Part II</a>. For reference and closure, here’s a summary of all the comprehension forms in Python:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>[x * x for x in range(10)]</strong></code>               <code><em># List comprehension: builds list</em></code>
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]         <code><em># Fixed order, made all at once</em></code>

&gt;&gt;&gt; <code><strong>(x * x for x in range(10))</strong></code>               <code><em># Generator expression: yields items</em></code>
&lt;generator object &lt;genexpr&gt; at 0x100a1f920&gt;

&gt;&gt;&gt; <code><strong>{x * x for x in range(10)}</strong></code>               <code><em># Set comprehension: builds set
</em></code>{0, 1, 64, 4, 36, 9, 16, 49, 81, 25}         <code><em># Random order, no duplicates</em></code>

&gt;&gt;&gt; <code><strong>{x: x * x for x in range(10)}</strong></code>            <code><em># Dict comprehension: insert order</em></code>
{0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}</pre>
<p>All of these forms use the same formal comprehension syntax we met earlier, but their enclosing delimiters (and key, for dictionaries) denote their differing roles. In a sense, list, set, and dictionary comprehensions are syntactic sugar for passing generator expressions to type names. Because all accept any iterable, a generator works here too:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>list(x ** 2 for x in range(10))</strong></code>          <code><em># Generator plus type name</em></code>
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt; <code><strong>set(x * x for x in range(10))</strong></code>            <code><em># Similar to a set comprehension</em></code>
{0, 1, 64, 4, 36, 9, 16, 49, 81, 25}

&gt;&gt;&gt; <code><strong>dict((x, x * x) for x in range(10))</strong></code>
{0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}</pre>
<p>But don’t read too much into such equivalences. Because implementations may vary arbitrarily, you should generally collect performance data before adopting an alternative. In this case, generators are actually slower than the equivalent list comprehension today, as we’ll prove in the next chapter. Programs that run lots of them may need to care.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Scopes and comprehension variables"><div class="sect3" id="scopes_and_comprehension_variables">
<h3>Scopes and comprehension variables</h3>
<p>Now that we’ve seen all comprehension forms, <a data-type="xref" href="ch17.html#scopes">Chapter 17</a>’s overview of <a contenteditable="false" data-type="indexterm" data-primary="comprehensions" data-secondary="variables, scopes and" id="cphvrscp"></a><a contenteditable="false" data-type="indexterm" data-primary="variables" data-secondary="comprehensions" data-tertiary="scopes and" id="vrbmphsc"></a><a contenteditable="false" data-type="indexterm" data-primary="scopes" data-secondary="comprehension variables" id="scpcphvr"></a>the localization of loop variables in these expressions may make more sense. In all forms, the loop variable (or variables) after the <code>for</code> is local to the expression—it won’t clash with names outside, but is also not available there, and this differs from <code>for</code> statements:</p>
<pre class="pagebreak-before" data-type="programlisting">&gt;&gt;&gt; <code><strong>X = 99</strong></code>
&gt;&gt;&gt; <code><strong>[X for X in range(5)]</strong></code>         <code><em># All comprehensions localize loop variables</em></code>
[0, 1, 2, 3, 4]
&gt;&gt;&gt; <code><strong>X  </strong>  </code>                         <code><em># Enclosing-scope X was not changed</em></code>
99
&gt;&gt;&gt; <code><strong>for X in range(5): pass</strong></code>       <code><em># But loop statements do not localize!</em></code>
&gt;&gt;&gt; <code><strong>X</strong></code>
4</pre>
<p>As noted in <a data-type="xref" href="ch17.html#scopes">Chapter 17</a>, loop variables assigned in a comprehension really live in a further nested special-case scope, but other names referenced within these expressions follow the usual LEGB rules. In the following generator, for example, <code>Z</code> is localized in the comprehension, but <code>Y</code> and <code>X</code> are found in the enclosing local and global scopes as usual:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>X = 'aaa'</strong></code>
&gt;&gt;&gt; <code><strong>def func():
        Y = 'bbb'
        print('-'.join(Z for Z in X + Y))</strong></code>    <code><em># Z=comprehension, Y=local, X=global</em></code>

&gt;&gt;&gt; <code><strong>func()</strong></code>
a-a-a-b-b-b</pre>
<p>One exception here: names assigned by the <code>:=</code> expression inside a comprehension do leak out of comprehension, and generally behave as though they were assigned in the scope containing the comprehension itself:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>S = 'hack'</strong></code>
&gt;&gt;&gt; <code><strong>[(temp := S[i]) + temp.upper() for i in range(len(S))]</strong></code>
['hH', 'aA', 'cC', 'kK']
&gt;&gt;&gt; <code><strong>temp</strong></code>
'k'
&gt;&gt;&gt; <code><strong>i</strong></code>
NameError: name 'i' is not defined. Did you mean: 'id'?</pre>
<p>While this allows comprehensions to both reuse and export values, keep in mind that a <code>lambda</code> container’s local scope effectively plugs the leak—<code>temp</code> in the following, for example, lives only in the <code>lambda</code>’s scope:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>del temp</strong></code>
&gt;&gt;&gt; <code><strong>f = lambda: [(temp := S[i]) + temp.upper() for i in range(len(S))]</strong></code>
&gt;&gt;&gt; <code><strong>f()</strong></code>
['hH', 'aA', 'cC', 'kK']
&gt;&gt;&gt; <code><strong>temp</strong></code>
NameError: name 'temp' is not defined</pre>
<p>We’ll code such a <code>:=</code> nesting in a sequence-scrambler example ahead, though some observers may deem it much less <a contenteditable="false" data-type="indexterm" data-primary="comprehensions" data-secondary="variables, scopes and" data-startref="cphvrscp" id="id3277"></a><a contenteditable="false" data-type="indexterm" data-primary="variables" data-secondary="comprehensions" data-tertiary="scopes and" data-startref="vrbmphsc" id="id3278"></a><a contenteditable="false" data-type="indexterm" data-primary="scopes" data-secondary="comprehension variables" data-startref="scpcphvr" id="id3279"></a>transparent than simple assignment statements, and other real-world roles must await your discovery. See <a data-type="xref" href="ch11.html#assignmentscomma_expressionscomma_and_p">Chapter 11</a> for more background on <code>:=</code> named assignment.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Generating “infinite” (well, indefinite) results"><div class="sect3" id="generating_quotation_markinfinitequotat">
<h3>Generating “infinite” (well, indefinite) results</h3>
<p>Finally, it was noted earlier in passing that <a contenteditable="false" data-type="indexterm" data-primary="generators" data-secondary="results generation" id="gnrtrsg"></a>generators can even produce “infinite” results that tools like list comprehensions cannot. This may sound more impressive that it is; really, this just means that a generator can keep yielding results from its retained state’s local variables <em>indefinitely</em>—until its client grows tired of them:</p>
<pre class="pagebreak-before" data-type="programlisting">&gt;&gt;&gt; <code><strong>def squares(n):</strong></code>
<code> <strong>       while True:</strong>  </code>                    <code><em># Generate results "forever"</em></code>
<code> <strong>           yield n ** 2</strong>  </code>               <code><em># Or until no more next calls...</em></code>
<code> <strong>           n += 1</strong></code>

&gt;&gt;&gt; <code><strong>G = squares(2)</strong></code>
&gt;&gt;&gt; <code><strong>next(G)</strong></code>
4
&gt;&gt;&gt; <code><strong>next(G)</strong></code>
9
&gt;&gt;&gt; <code><strong>for i in range(10): print(next(G), end=' ')</strong></code>

16 25 36 49 64 81 100 121 144 169</pre>
<p>This pattern may be useful in limited roles like test-parameter generation, and other tools can’t compete in this event; list <a contenteditable="false" data-type="indexterm" data-primary="generators" data-secondary="results generation" data-startref="gnrtrsg" id="id3280"></a>comprehensions, for example, must collect all results at once. In the end, though, this is a narrow role, generators are mortal, and so are we—so let’s move on to some code that’s a bit more tangible in the next section.</p>
</div></section>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Example: Shuffling Sequences"><div class="sect1" id="example_shuffling_sequences">
<h1>Example: Shuffling Sequences</h1>
<p>To demonstrate the power of iteration and generation tools in action, let’s turn to some more complete examples. In <a data-type="xref" href="ch18.html#arguments">Chapter 18</a>, we wrote a testing function, based on earlier code in <a data-type="xref" href="ch13.html#while_and_for_loops">Chapter 13</a>, that scrambled the order of arguments used to verify generalized intersection and union functions. There, it was noted that this might be better coded as a generator of values. Now that we’ve learned how to write generators, this serves to illustrate a practical application.</p>
<p>One note up front: because they slice and concatenate objects, all the examples in the section (including the permutations at the end) work only on <em>sequences</em> like strings and lists, not on arbitrary <em>iterables</em> like files, maps, and other generators. That is, some of these examples will <em>be</em> generators themselves, producing values on request, but they cannot process generators as their <em>inputs</em>. Generalization for broader categories is left as an open issue, though the code here will suffice unchanged if you wrap nonsequence generators in <code>list</code> calls before passing them in.</p>
<section data-type="sect2" data-pdf-bookmark="Scrambling Sequences"><div class="sect2" id="scrambling_sequences">
<h2>Scrambling Sequences</h2>
<p>First, let’s review. As coded in <a data-type="xref" href="ch18.html#arguments">Chapter 18</a>, we can reorder a <a contenteditable="false" data-type="indexterm" data-primary="sequences" data-secondary="slicing" id="id3281"></a><a contenteditable="false" data-type="indexterm" data-primary="slicing" data-secondary="sequences" id="id3282"></a>sequence with slicing and concatenation, moving the front item to the end on each loop; <em>slicing</em> instead of indexing the item allows <code>+</code> to work for arbitrary sequence types:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <strong>L, S = [1, 2, 3], 'code'</strong>

&gt;&gt;&gt; <strong>for i in range(len(S)):</strong>            <code><em># Coding 1: for repeat counts 0..3</em></code>
        <strong>S = S[1:] + S[:1]</strong>              <code><em># Move front item to the end</em></code>
        <strong>print(S, end=' ')</strong>

odec deco ecod code

&gt;&gt;&gt; <code><strong>for i in range(len(L)):
        L = L[1:] + L[:1]</strong></code>              <code><em># Slice so any sequence type works</em></code>
        <code><strong>print(L, end=' ')</strong></code>

[2, 3, 1] [3, 1, 2] [1, 2, 3]</pre>
<p>Alternatively, as we also saw in <a data-type="xref" href="ch13.html#while_and_for_loops">Chapter 13</a>, we get the same results by moving an entire front section to the end, though the order of the results varies slightly:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>for i in range(len(S)):</strong></code>            <code><em># Coding 2: for positions 0..3</em></code>
        <code><strong>X = S[i:] + S[:i]</strong></code>              <code><em># Rear part + front part (same effect)</em></code>
        <code><strong>print(X, end=' ')</strong></code>

code odec deco ecod</pre>
<p>Trace this code to see how it works; each version produces <code><em>N</em></code> results for an <code><em>N</em></code>-item sequence passed in.</p>
<section data-type="sect3" data-pdf-bookmark="Simple functions"><div class="sect3" id="simple_functions">
<h3>Simple functions</h3>
<p>As is, this code works on specific <a contenteditable="false" data-type="indexterm" data-primary="sequences" data-secondary="slicing" data-tertiary="functions" id="id3283"></a><a contenteditable="false" data-type="indexterm" data-primary="slicing" data-secondary="sequences" data-tertiary="functions" id="id3284"></a><a contenteditable="false" data-type="indexterm" data-primary="functions" data-secondary="slicing sequences" id="id3285"></a>named variables only, and simply prints its result. As we’ve seen, it’s easy to generalize this by turning it into a normal <em><em>function</em></em> that can both work on any object passed to its argument and return its result for arbitrary use. The following does so for the second coding alternative; since its first cut exhibits the classic list comprehension pattern, we can also save some work by coding it as such in the second:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>def scramble(seq):
        res = []
        for i in range(len(seq)):
            res.append(seq[i:] + seq[:i])
        return res
</strong></code>
&gt;&gt;&gt; <code><strong>scramble('code')</strong></code>
['code', 'odec', 'deco', 'ecod']

&gt;&gt;&gt; <code><strong>def scramble(seq):
        return [seq[i:] + seq[:i] for i in range(len(seq))]</strong></code>

&gt;&gt;&gt; <code><strong>scramble('code')</strong></code>
['code', 'odec', 'deco', 'ecod']

&gt;&gt;&gt; <code><strong>for x in scramble((1, 2, 3)):</strong></code>
        <code><strong>print(x, end=' ')</strong></code>

(1, 2, 3) (2, 3, 1) (3, 1, 2)</pre>
<p>We could use recursion here as well, but it’s probably <a contenteditable="false" data-type="indexterm" data-primary="functions" data-secondary="slicing sequences" data-startref="fcslcsqc" id="id3286"></a>overkill in this fixed and linear context.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Generator functions"><div class="sect3" id="generator_functions">
<h3>Generator functions</h3>
<p>The preceding section’s simple approach works, but must build an entire result list in memory all <a contenteditable="false" data-type="indexterm" data-primary="sequences" data-secondary="slicing" data-tertiary="generator functions" id="sqslgrt"></a><a contenteditable="false" data-type="indexterm" data-primary="slicing" data-secondary="sequences" data-tertiary="generator functions" id="slcsqgfc"></a><a contenteditable="false" data-type="indexterm" data-primary="functions" data-secondary="generator functions" data-tertiary="slicing sequences" id="fcslcsqgf"></a><a contenteditable="false" data-type="indexterm" data-primary="generator functions" data-secondary="slicing sequences" id="genfslqc"></a>at once (not great on memory usage if it’s massive), and requires the caller to wait until the entire list is complete (less than ideal if this takes a substantial amount of time). You should know by now that we can do better on both fronts by translating this to a <em>generator function</em> that yields one result at a time, using either coding scheme:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>def scramble(seq):
        for i in range(len(seq)):
            seq = seq[1:] + seq[:1]</strong></code>               <code><em># Generator function, coding 1</em></code>
            <code><strong>yield seq</strong> </code>                            <code><em># Assignments work here</em></code>

&gt;&gt;&gt; <code><strong>def scramble(seq):
        for i in range(len(seq)):</strong></code>                 <code><em># Generator function, coding 2</em></code>
            <code><strong>yield seq[i:] + seq[:i]</strong></code>               <code><em># Yield one item per iteration</em></code></pre>
<p>Both of these alternatives produce values when used by an iteration tool like <code>list</code> or <code>for</code>, though the second version’s results order (shown here) again varies slightly in ways that probably won’t matter to future clients:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>list(scramble('code'))</strong></code>                        <code><em># list() generates all results</em></code>
['code', 'odec', 'deco', 'ecod'] 

&gt;&gt;&gt; <code><strong>list(scramble((1, 2, 3)))</strong></code>                     <code><em># Any sequence type works</em></code>
[(1, 2, 3), (2, 3, 1), (3, 1, 2)]

&gt;&gt;&gt; <code><strong>for x in scramble((1, 2, 3)):</strong></code>                 <code><em># for loops generate results</em></code>
        <code><strong>print(x, end=' ')</strong></code>

(1, 2, 3) (2, 3, 1) (3, 1, 2)</pre>
<p>Both generator functions retain their local scope state (<code>seq</code> and <code>i</code>) while active, minimize memory space requirements, and divide the work into shorter time slices. As full functions, they are also very general. Moreover, because iteration tools work the same whether stepping through a real list or a generator of <a contenteditable="false" data-type="indexterm" data-primary="sequences" data-secondary="slicing" data-tertiary="generator functions" data-startref="sqslgrt" id="id3287"></a><a contenteditable="false" data-type="indexterm" data-primary="slicing" data-secondary="sequences" data-tertiary="generator functions" data-startref="slcsqgfc" id="id3288"></a><a contenteditable="false" data-type="indexterm" data-primary="functions" data-secondary="generator functions" data-tertiary="slicing sequences" data-startref="fcslcsqgf" id="id3289"></a><a contenteditable="false" data-type="indexterm" data-primary="generator functions" data-secondary="slicing sequences" data-startref="genfslqc" id="id3290"></a>values, the function can select between the two codings freely, and even change strategies in the future without impacting callers.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Generator expressions"><div class="sect3" id="generator_expressions">
<h3>Generator expressions</h3>
<p>As we’ve also seen, <em>generator expressions</em>—comprehensions in parentheses instead of <a contenteditable="false" data-type="indexterm" data-primary="sequences" data-secondary="slicing" data-tertiary="generator expressions" id="id3291"></a><a contenteditable="false" data-type="indexterm" data-primary="slicing" data-secondary="sequences" data-tertiary="generator expressions" id="id3292"></a><a contenteditable="false" data-type="indexterm" data-primary="expressions" data-secondary="generator expressions" data-tertiary="slicing sequences" id="id3293"></a><a contenteditable="false" data-type="indexterm" data-primary="generator expressions" data-secondary="slicing sequences" id="id3294"></a>square brackets—also generate values on request and retain their local state. As expressions, they’re not as flexible as full functions, but because they yield their values automatically, generator expressions can often be more concise in specific use cases like this:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>S = 'code'</strong></code>
&gt;&gt;&gt; <code><strong>G = (S[i:] + S[:i] for i in range(len(S)))</strong> </code>        <code><em># Generator expr, coding 2</em></code>
&gt;&gt;&gt; <code><strong>list(G)</strong></code>
['code', 'odec', 'deco', 'ecod']</pre>
<p>A generator expression can’t use the <code>seq</code> assignment statement of the first generator-function coding, but it <em>can</em> achieve the same effect by nesting the <code>:=</code> <em>named-assignment</em> expression covered in <a data-type="xref" href="ch11.html#assignmentscomma_expressionscomma_and_p">Chapter 11</a>, because <code>:=</code> both changes assigned names in the containing scope and returns the assigned value so it appears in the results stream:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>S = 'code'</strong></code>
&gt;&gt;&gt; <code><strong>G = (S:=(S[1:] + S[:1]) for i in range(len(S)))</strong></code>    <code><em># Generator expr, coding 1</em></code>
&gt;&gt;&gt; <code><strong>list(G)</strong></code>
['odec', 'deco', 'ecod', 'code']</pre>
<p>Either way, we’re still operating on a specific variable here, <code>S</code>. To generalize a generator expression for an arbitrary subject, wrap it in a simple <code>lambda</code> function that takes an argument and returns a generator that uses it (subtle bit: note that <code>seq</code> in the second of these is not local to the generator, but is local to the <code>lambda</code> that encloses it):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>F = lambda seq: (seq[i:] + seq[:i] for i in range(len(seq)))</strong></code>
&gt;&gt;&gt; <code><strong>list(F(S))</strong></code>
['code', 'odec', 'deco', 'ecod']

&gt;&gt;&gt; <code><strong>F = lambda seq: (seq:=(seq[1:] + seq[:1]) for i in range(len(seq)))</strong></code>
&gt;&gt;&gt; <code><strong>list(F(S))</strong></code>
['odec', 'deco', 'ecod', 'code'] 

&gt;&gt;&gt; <code><strong>list(F([1, 2, 3]))</strong></code>
[[2, 3, 1], [3, 1, 2], [1, 2, 3]] 

&gt;&gt;&gt; <code><strong>F(S)</strong></code>
&lt;generator object &lt;lambda&gt;.&lt;locals&gt;.&lt;genexpr&gt; at 0x100b23300&gt;

&gt;&gt;&gt; <code><strong>for x in F((1, 2, 3)): print(x, end=' ')</strong></code>
(2, 3, 1) (3, 1, 2) (1, 2, 3)</pre>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Tester client"><div class="sect3" id="tester_client">
<h3>Tester client</h3>
<p>Finally, we can use either the generator <a contenteditable="false" data-type="indexterm" data-primary="sequences" data-secondary="slicing" data-tertiary="tester" id="id3295"></a><a contenteditable="false" data-type="indexterm" data-primary="slicing" data-secondary="sequences" data-tertiary="tester" id="id3296"></a><a contenteditable="false" data-type="indexterm" data-primary="tester, slicing sequences" id="id3297"></a>function or its expression equivalent in <a data-type="xref" href="ch18.html#arguments">Chapter 18</a>’s <code>tester</code> to produce scrambled arguments. As packaged in the module of <a data-type="xref" href="#example_twozero_onedot_scrambledotpy">Example 20-1</a>, the sequence scramblers become reusable tools.</p>
<div data-type="example" id="example_twozero_onedot_scrambledotpy">
<h5><span class="label">Example 20-1. </span>scramble.py</h5>
<pre data-type="programlisting">"Generate shuffles of a sequence, by function or expression"

def scramble1(seq):
    for i in range(len(seq)):                
        yield seq[i:] + seq[:i]        <code><em># Yield one shuffle per iteration</em></code>

scramble2 = lambda seq: (seq[i:] + seq[:i] for i in range(len(seq)))</pre>
</div>
<p>Though it requires a bit of page flipping to see how, moving the values generation out to an external tool like this also makes the testing function noticeably simpler:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>from scramble import scramble1</strong> </code>          <code><em># Choose your scrambler</em></code>
&gt;&gt;&gt; <code><strong>from inter2 import intersect, union</strong> </code>     <code><em># Functions to be tested</em></code>

&gt;&gt;&gt; <code><strong>def tester(func, items, trace=True):
        for args in scramble1(items):</strong></code>        <code><em># Use either generator</em></code>
            <code><strong>if trace: print(args)
            print(sorted(func(*args)))</strong>  </code>     <code><em># Test for this scramble</em></code>

&gt;&gt;&gt; <code><strong>tester(intersect, ('aab', 'abcde', 'ababab'), False)</strong></code>
['a', 'b']
['a', 'b']
['a', 'b']</pre>
<p>To make this work for yourself, make sure all imported files are in the current directory: either copy <em>inter2.py</em> from <a data-type="xref" href="ch18.html#arguments">Chapter 18</a>’s folder to <a data-type="xref" href="#comprehensions_and_generations">Chapter 20</a>’s, or copy <a data-type="xref" href="#example_twozero_onedot_scrambledotpy">Example 20-1</a>’s <em>scramble.py</em> to <a data-type="xref" href="ch18.html#arguments">Chapter 18</a>’s folder and work there (the examples package has already done the former). Alternatively, you can modify the module import search path’s <code>PYTHONPATH</code> setting to include any folder—as you’ll learn when we cover modules in full after the next chapter.</p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Permutating Sequences"><div class="sect2" id="permutating_sequences">
<h2>Permutating Sequences</h2>
<p>Generators have many other real-world <a contenteditable="false" data-type="indexterm" data-primary="sequences" data-secondary="permutation" id="sqcprm"></a><a contenteditable="false" data-type="indexterm" data-primary="permutation, sequences" id="prmtsqc"></a>applications—consider parsing attachments in an email message or computing points to be plotted in a GUI. Moreover, other types of sequence scrambles serve central roles in other applications, from searches to mathematics. As is, our sequence scrambler of the prior section is a simple reordering, but some programs warrant the more exhaustive set of all possible orderings we get from <em>permutations</em>—produced using recursive functions in both list-builder and generator forms by the module file in <a data-type="xref" href="#example_twozero_twodot_permutedotpy">Example 20-2</a>.</p>
<div data-type="example" class="pagebreak-before" id="example_twozero_twodot_permutedotpy">
<h5 class="less_space"><span class="label">Example 20-2. </span>permute.py</h5>
<pre data-type="programlisting">"Permute sequences: as a list or generator of values"

def permute1(seq):
    if not seq:                               <code><em># Shuffle any sequence: list</em></code>
        return [seq]                          <code><em># Empty sequence</em></code>
    else:
        res = []
        for i in range(len(seq)):
            rest = seq[:i] + seq[i+1:]        <code><em># Delete current node</em></code>
            for x in permute1(rest):          <code><em># Permute the others</em></code>
                res.append(seq[i:i+1] + x)    <code><em># Add node at front</em></code>
        return res

def permute2(seq):
    if not seq:                               <code><em># Shuffle any sequence: generator
</em></code>        yield seq                             <code><em># Empty sequence</em></code>
    else:
        for i in range(len(seq)):
            rest = seq[:i] + seq[i+1:]        <code><em># Delete current node</em></code>
            for x in permute2(rest):          <code><em># Permute the others</em></code>
                yield seq[i:i+1] + x          <code><em># Add node at front</em></code></pre>
</div>
<p>Both of these functions produce the same results, though the second defers much of its work until it is asked for a result. This code is a bit advanced, especially the second of these functions (and to some Python newcomers might even be categorized as cruel and unusual punishment!). Still, as you’ll learn in a moment, there are cases where the generator approach can be very useful—and even essential.</p>
<p>Study and test this code for more insight, and add prints to trace if it helps. If it’s still a mystery, try to make sense of the first version first; remember that generator functions simply return objects with methods that handle <code>next</code> operations run by <code>for</code> loops at each level, and don’t produce any results until iterated; and trace through some of the following examples to see how they’re handled by this code.</p>
<p>Permutations produce more orderings than the original scrambler—for <code><em>N</em></code> items, we get <code><em>N</em>!</code> (factorial, not surprise) results instead of just <code><em>N</em></code> (24 for 4: 4 * 3 * 2 * 1). In fact, that’s why we need <em>recursion</em> here: the number of nested loops is arbitrary, and depends on the length of the sequence permuted. Here’s a demo of both shufflers at work:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>from scramble import scramble1</strong></code>
&gt;&gt;&gt; <code><strong>from permute import permute1, permute2</strong></code>

&gt;&gt;&gt; <code><strong>list(scramble1('abc'))</strong>   </code>                      <code><em># Simple scrambles: N = 3</em></code>
['abc', 'bca', 'cab']

&gt;&gt;&gt; <code><strong>permute1('abc')</strong></code>                                <code><em># Permutations larger: N! = 6</em></code>
['abc', 'acb', 'bac', 'bca', 'cab', 'cba'] 
&gt;&gt;&gt; <code><strong>list(permute2('abc'))</strong></code>                          <code><em># Generate all ordered combos</em></code>
['abc', 'acb', 'bac', 'bca', 'cab', 'cba'] 

&gt;&gt;&gt; <code><strong>G = permute2('abc')</strong></code>                            <code><em># Iterate: iter() not needed</em></code>
&gt;&gt;&gt; <code><strong>next(G)</strong></code>
'abc'
&gt;&gt;&gt; <code><strong>next(G)</strong></code>
'acb'
&gt;&gt;&gt; <code><strong>for x in permute2('abc'): print(x)</strong></code>             <code><em># Automatic iteration</em></code>
…<code><em>prints six lines</em></code>…</pre>
<p>The list and generator versions’ results are the same, though the generator minimizes both space usage and delays for results. For larger items, the set of all permutations from both is much larger than the simpler scrambler’s:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>permute1('hack') == list(permute2('hack'))</strong></code>
True
&gt;&gt;&gt; <code><strong>len(list(permute2('hack'))), len(list(scramble1('hack')))</strong></code>
(24, 4)

&gt;&gt;&gt; <code><strong>list(scramble1('hack'))</strong></code>
['hack', 'ackh', 'ckha', 'khac'] 
&gt;&gt;&gt; <code><strong>list(permute2('hack'))</strong></code>
['hack', 'hakc', 'hcak', 'hcka', 'hkac', 'hkca', 'ahck', 'ahkc', 'achk', 'ackh',
 'akhc', 'akch', 'chak', 'chka', 'cahk', 'cakh', 'ckha', 'ckah', 'khac', 'khca', 
 'kahc', 'kach', 'kcha', 'kcah']</pre>
<p>Per <a data-type="xref" href="ch19.html#function_odds_and_ends">Chapter 19</a>, there are nonrecursive alternatives here too, using explicit stacks or queues, and other sequence orderings are common (e.g., fixed-size subsets and combinations that filter out duplicates of differing order), but these require coding extensions we’ll forgo here. Experiment further on your own for more insights.</p>
<section data-type="sect3" data-pdf-bookmark="Why generators here: Space, time, and more"><div class="sect3" id="why_generators_here_spacecomma_timecomm">
<h3>Why generators here: Space, time, and more</h3>
<p>Generators are a somewhat advanced tool, and might be better treated as an optional topic, but for the fact <a contenteditable="false" data-type="indexterm" data-primary="generators" data-secondary="permutation" id="gntmpr"></a>that they permeate the Python language today. As we’ve seen, fundamental built-in tools such as <code>range</code>, <code>map</code>, dictionary <code>keys</code>, and even files are now generators, so you must be familiar with the concept even if you don’t write new generators of your own. Moreover, user-defined generators are increasingly common in Python code that you might come across today—in the Python standard library, for instance.</p>
<p>Though your code is yours to code, the same guidelines given for list comprehensions apply here as well: don’t complicate your code with user-defined generators if they are not warranted. Especially for smaller programs and data sets, such tools may not make sense. Simple lists of results may suffice, may be easier to understand, will be garbage-collected automatically, and might be produced quicker (and are today: see the next chapter). Advanced tools like generators that rely on implicit “magic” can be fun to experiment with, but may be subpar when optional.</p>
<p>That being said, there are specific use <a contenteditable="false" data-type="indexterm" data-primary="generators" data-secondary="memory footprint" id="id3298"></a><a contenteditable="false" data-type="indexterm" data-primary="memory management" data-secondary="generators" id="id3299"></a>cases that generators can address well. They can reduce memory footprint in some programs, reduce delays in others, and can occasionally make the impossible possible. Consider, for example, a program that must produce all possible permutations of a nontrivial sequence. Since the number of combinations is a <em>factorial</em> that explodes exponentially, the preceding <code>permute1</code> recursive list-builder function will either introduce a noticeable and perhaps interminable pause, or fail completely due to memory requirements.</p>
<p>By contrast, the <code>permute2</code> recursive generator returns each individual result quickly, and can handle very large result sets. Even at just 10 items, for instance, the difference starts becoming stark (per Python’s <code>math</code> module):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>import math</strong></code>
&gt;&gt;&gt; <code><strong>f'{math.factorial(10):,}'</strong>   </code>     <code><em># 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1</em></code>
'3,628,800'

&gt;&gt;&gt; <code><strong>from permute import permute1, permute2</strong></code>
&gt;&gt;&gt; <code><strong>seq = list(range(10))</strong></code>

&gt;&gt;&gt; <code><strong>p1 = permute1(seq)</strong></code>               <code><em># ~17 seconds on a 2.3GHz i9 macOS host</em></code>
&gt;&gt;&gt; <code><strong>len(p1)</strong> </code>                         <code><em># Creates a list of 3.6M numbers</em></code>
3628800
&gt;&gt;&gt; <code><strong>p1[0], p1[-1]</strong></code>
([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [9, 8, 7, 6, 5, 4, 3, 2, 1, 0])</pre>
<p>In this case, the <code>permute1</code> list builder pauses for 17 seconds to build a 3.6-million-item list, but the <em>generator</em> can begin returning individual results immediately—neither <code>permute2</code> nor any <code>next</code> pause in the following:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>p2 = permute2(seq)</strong></code>               <code><em># Returns generator immediately</em></code>
&gt;&gt;&gt; <code><strong>next(p2)</strong></code>                         <code><em># Returns each result quickly on demand</em></code>
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
&gt;&gt;&gt; <code><strong>next(p2)</strong></code>
[0, 1, 2, 3, 4, 5, 6, 7, 9, 8]</pre>
<p>While collecting all results from the generator is still slow, it’s faster than the list builder, and not intended usage:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>p2 = list(permute2(seq))</strong></code>         <code><em># About 10 seconds, though still impractical</em></code>
&gt;&gt;&gt; <code><strong>p1 == p2</strong></code>                         <code><em># Same set of results generated</em></code>
True</pre>
<p>Naturally, we might be able to optimize the list builder’s code to run quicker (e.g., an explicit stack instead of recursion might change its performance), but for larger sequences, it’s not an option at all—at just 50 items, the number of permutations wholly precludes building a results list, and would take far too long for mere mortals like us in any event (and larger values will overflow the preset recursion stack depth limit: see the preceding chapter). The generator, however, is still viable—despite the factorial size of the problem, it is able to produce individual results immediately:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>math.factorial(50)</strong></code>
30414093201713378043612608166064768844377641568960512000000000000

&gt;&gt;&gt; <code><strong>p3 = permute2(list(range(50)))</strong>  </code>     <code><em># permute1 is not an option here!</em></code>
&gt;&gt;&gt; <code><strong>next(p3)</strong></code>
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,
23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
44, 45, 46, 47, 48, 49]</pre>
<p>For more fun—and to yield results that are more variable and less obviously deterministic—we could use Python’s <code>random</code> module of <a data-type="xref" href="ch05.html#numbers_and_expressions">Chapter 5</a> to randomly shuffle the sequence to be permuted before the permuter begins its work. In the following, for example, each <code>permute2</code> and <code>next</code> call returns immediately as before and permutes a random sequence, but <code>permute1</code> hangs (and presumably perishes from memory starvation if allowed to run long enough):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>seq = list(range(20))</strong></code>
&gt;&gt;&gt; <code><strong>print(f'{math.factorial(20):,}')</strong></code>     <code><em># permute1 is not an option here</em></code>
2,432,902,008,176,640,000
<code><strong>
</strong></code>&gt;&gt;&gt; <code><strong>import random</strong></code>
&gt;&gt;&gt; <code><strong>random.shuffle(seq)</strong></code>                  <code><em># Shuffle sequence randomly first</em></code>
&gt;&gt;&gt; <code><strong>p = permute2(seq)</strong></code>
&gt;&gt;&gt; <code><strong>next(p)</strong></code>
[10, 19, 5, 6, 2, 13, 1, 8, 11, 7, 14, 16, 4, 3, 0, 18, 9, 12, 17, 15]
&gt;&gt;&gt; <code><strong>next(p)</strong></code>
[10, 19, 5, 6, 2, 13, 1, 8, 11, 7, 14, 16, 4, 3, 0, 18, 9, 12, 15, 17]

&gt;&gt;&gt; <code><strong>random.shuffle(seq)</strong></code>
&gt;&gt;&gt; <code><strong>p = permute2(seq)</strong></code>
&gt;&gt;&gt; <code><strong>next(p)</strong></code>
[17, 15, 14, 7, 10, 8, 2, 6, 18, 19, 13, 4, 1, 12, 5, 0, 3, 9, 16, 11]
&gt;&gt;&gt; <code><strong>next(p)</strong></code>
[17, 15, 14, 7, 10, 8, 2, 6, 18, 19, 13, 4, 1, 12, 5, 0, 3, 9, 11, 16]</pre>
<p>In fact, we might be able to use the random shuffler instead of manual shuffles in some roles, as long as we either can assume that it won’t repeat shuffles during the time we consume them, or test its results against prior shuffles to avoid repeats—and hope that we do not live in the strange universe where a random sequence repeats the same result an infinite number of times! When full coverage is important, manual shuffles offer better control.</p>
<p>The main point here is that generators can sometimes produce results from large solution sets when list builders cannot. Then again, it’s not clear how common such use cases may be in the real world, and this doesn’t necessarily justify the <em>implicit</em> flavor of value generation that we get with generator functions and expressions. As you’ll see in <a data-type="xref" href="part06.html#classes_and_oop">Part VI</a>, value generation can also be coded as iterable objects with <em>classes</em>. Class-based iterables can produce items on request too, and are more <em>explicit</em> than the magic objects and methods produced for generator functions and expressions.</p>
<p>Part of programming is finding a balance among trade-offs like these, and there are no absolute rules here. While the benefits of generators may sometimes justify their use, maintainability counts too. Like comprehensions, generators also offer an <em>expressiveness</em> and <em>code economy</em> that’s hard to resist if you understand how they work—but you’ll want to weigh this against the frustration of <a contenteditable="false" data-type="indexterm" data-primary="sequences" data-secondary="permutation" data-startref="sqcprm" id="id3300"></a><a contenteditable="false" data-type="indexterm" data-primary="permutation, sequences" data-startref="prmtsqc" id="id3301"></a><a contenteditable="false" data-type="indexterm" data-primary="generators" data-secondary="permutation" data-startref="gntmpr" id="id3302"></a>coworkers who might not.</p>
</div></section>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Example: Emulating zip and map"><div class="sect1" id="example_emulating_zip_and_map">
<h1>Example: Emulating zip and map</h1>
<p>Let’s take a quick look at one more example of generators in action that illustrates just how expressive <a contenteditable="false" data-type="indexterm" data-primary="map function" data-secondary="emulating" id="mpfceml"></a><a contenteditable="false" data-type="indexterm" data-primary="zip function" data-secondary="emulating" id="zpfcmul"></a>they can be. Once you know about comprehensions, generators, and other iteration tools, you’ll find that emulating many of Python’s functional built-ins is both straightforward and instructive, and can be useful for custom roles.</p>
<p>For example, we’ve already seen how the built-in <code>zip</code> and <code>map</code> functions combine iterables and project functions across them, respectively. With multiple iterable arguments, <code>map</code> projects the function across items taken from each iterable in much the same way that <code>zip</code> combines them, and both functions truncate at the shortest iterable’s length:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>list(zip('abc', 'xyz123'))</strong></code>                 <code><em># zip combines items from iterables</em></code>
[('a', 'x'), ('b', 'y'), ('c', 'z')]
&gt;&gt;&gt; <code><strong>list(zip([1, 2, 3], [2, 3, 4, 5]))</strong></code>         <code><em># N M-ary iterables: M N-ary tuples</em></code>
[(1, 2), (2, 3), (3, 4)]
&gt;&gt;&gt; <code><strong>list(zip([−2, −1, 0, 1, 2]))</strong></code>               <code><em># 1 5-ary iterable: 5 1-ary tuples</em></code>
[(−2,), (−1,), (0,), (1,), (2,)]

&gt;&gt;&gt; <code><strong>list(map(abs, [−2, −1, 0, 1, 2]))</strong></code>          <code><em># Single iterable: 1-ary function</em></code>
[2, 1, 0, 1, 2]
&gt;&gt;&gt; <code><strong>list(map(pow, [1, 2, 3], [2, 3, 4, 5]))</strong></code>    <code><em># N iterables: N-ary function</em></code>
[1, 8, 81]</pre>
<p>As covered earlier, both also work on any type of iterable, including files that read their lines automatically. Though they’re ultimately used for different purposes, if you study these examples long enough, you might notice a relationship between <code>zip</code> results and <code>map</code> function arguments that our next example can exploit.</p>
<section data-type="sect2" data-pdf-bookmark="Coding Your Own map"><div class="sect2" id="coding_your_own_map">
<h2>Coding Your Own map</h2>
<p>Although the <code>map</code> and <code>zip</code> built-ins are fast and convenient, they’re easy to implement <a contenteditable="false" data-type="indexterm" data-primary="iterables" data-secondary="map function" id="id3303"></a><a contenteditable="false" data-type="indexterm" data-primary="map function" data-secondary="iterables, multiple" id="id3304"></a>in customizable code of our own. In the preceding chapter, for example, we wrote a function that emulated the <code>map</code> built-in for a <em>single</em> iterable argument. Per <a data-type="xref" href="#example_twozero_threedot_mymap_listsdot">Example 20-3</a>, it doesn’t take much more work to allow for <em>multiple</em> iterables, as the built-in does.</p>
<div data-type="example" id="example_twozero_threedot_mymap_listsdot">
<h5><span class="label">Example 20-3. </span>mymap-lists.py</h5>
<pre data-type="programlisting">"Emulate map: support multiple arguments, build a list result"

def mymap(func, *seqs):
    res = []
    for args in zip(*seqs):
        res.append(func(*args))
    return res

print(mymap(abs, [-2, -1, 0, 1, 2]))
print(mymap(pow, [1, 2, 3], [2, 3, 4, 5]))</pre>
</div>
<p>This version relies upon <code>*</code> argument syntax—it <em>collects</em> multiple sequence (really, iterable) arguments; <em>unpacks</em> them as <code>zip</code> arguments to combine; and then <em>unpacks</em> the combined <code>zip</code> results as arguments to the passed-in function. That is, we’re using the fact that the zipping is essentially a nested operation in mapping. The test code at the bottom applies this to both one and two sequences to test—with the same results generated by the built-in <code>map</code>:</p>
<pre data-type="programlisting">$ <code><strong>python3 mymap-list.py</strong></code>
[2, 1, 0, 1, 2]
[1, 8, 81]</pre>
<p>Really, though, the preceding <a contenteditable="false" data-type="indexterm" data-primary="list comprehension pattern, map function" id="id3305"></a><a contenteditable="false" data-type="indexterm" data-primary="map function" data-secondary="list comprehension pattern" id="id3306"></a>code exhibits the classic <em>list comprehension pattern</em>, building a list of operation results within a <code>for</code> loop. We can rewrite our mapper more concisely as an equivalent one-line list comprehension:</p>
<pre data-type="programlisting">def mymap(func, *seqs):
    return [func(*args) for args in zip(*seqs)]</pre>
<p>When this is run the result is the same as before, but the code is more concise and might run faster (more on performance in <a data-type="xref" href="ch21.html#the_benchmarking_interlude">Chapter 21</a>). Both of the preceding <code>mymap</code> versions build result lists all at once, though, and this can waste memory for larger lists. Now that we know about <em>generator</em> functions and expressions, it’s simple to recode both these alternatives to produce results on demand instead, per <a data-type="xref" href="#example_twozero_fourdot_mymap_generated">Example 20-4</a>.</p>
<div data-type="example" id="example_twozero_fourdot_mymap_generated">
<h5><span class="label">Example 20-4. </span>mymap-generate.py</h5>
<pre data-type="programlisting">"Emulate map: support multiple arguments, generate results on request"

def mymap_func(func, *seqs):
    for args in zip(*seqs):
        yield func(*args)

def mymap_expr(func, *seqs):
    return (func(*args) for args in zip(*seqs))

for mymap in (mymap_func, mymap_expr): 
    print(list(mymap(abs, [-2, -1, 0, 1, 2])))
    print(list(mymap(pow, [1, 2, 3], [2, 3, 4, 5])))</pre>
</div>
<p>Both these new versions produce the same results but return generators designed to support the iteration protocol—the first yields one result at a time explicitly, and the second returns a generator expression’s result to do the same implicitly. As generators, we must wrap them in <code>list</code> calls to force them to produce their values all at once:</p>
<pre data-type="programlisting">$ <code><strong>python3 mymap-generate.py</strong></code>
[2, 1, 0, 1, 2]
[1, 8, 81]
[2, 1, 0, 1, 2]
[1, 8, 81]</pre>
<p>No real work is done here until the <code>list</code> calls force the generators to run by activating the iteration protocol. The <code>list</code> calls allow for display in testing, but this is not generally desirable in other contexts. The generators returned by these functions themselves, as well as the generators returned by the <code>zip</code> built-in they use, produce results only on demand, and that’s the <em>whole point</em> of generators—delaying results saves memory space, and avoids pausing callers for full results.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Coding Your Own zip and 2.X map"><div class="sect2" id="coding_your_own_zip_and_twodotx_map">
<h2>Coding Your Own zip and 2.X map</h2>
<p>Of course, much of the secret behind the <a contenteditable="false" data-type="indexterm" data-primary="iterables" data-secondary="zip function" id="id3307"></a><a contenteditable="false" data-type="indexterm" data-primary="zip function" data-secondary="iterables" id="id3308"></a>success of the examples shown so far lies in their use of the <code>zip</code> built-in to combine arguments from multiple iterables. Using iteration tools, we can also code workalikes that emulate both today’s truncating <code>zip</code>, as well as the former padding behavior of Python 2.X’s <code>map</code> when passed a <code>None</code> for its function—a still potentially useful tool despite its demise in 3.X, and the sort of thing that custom code can provide. Per <a data-type="xref" href="#example_twozero_fivedot_myfptools_listd">Example 20-5</a>, <code>zip</code> and this padding <code>map</code> are related in utility and nearly the same in code.</p>
<div data-type="example" id="example_twozero_fivedot_myfptools_listd">
<h5><span class="label">Example 20-5. </span>myfptools-list.py</h5>
<pre data-type="programlisting"><em># Emulate zip and padding map: build lists</em>

def myzip(*seqs):
    seqs = [list(S) for S in seqs]
    res  = []
    while all(seqs):
        res.append(tuple(S.pop(0) for S in seqs))
    return res

def mymapPad(*seqs, pad=None):
    seqs = [list(S) for S in seqs]
    res  = []
    while any(seqs):
        res.append(tuple((S.pop(0) if S else pad) for S in seqs))
    return res

S1, S2 = 'abc', 'xyz123'
print(myzip(S1, S2))
print(mymapPad(S1, S2))
print(mymapPad(S1, S2, pad=99))</pre>
</div>
<p>Both of these functions work on any type of iterable object because they run their arguments through the <code>list</code> built-in to force result generation (e.g., files would work as arguments, in addition to sequences like strings). Notice the use of the <code>all</code> and <code>any</code> built-ins here—as we saw briefly in <a data-type="xref" href="ch14.html#iterations_and_comprehensions">Chapter 14</a>, these return <code>True</code> if all or any items in an iterable are <code>True</code> (or equivalently, nonempty), respectively. These built-ins are used to stop looping when any or all of the listified arguments become empty after <span class="keep-together">deletions</span>.</p>
<p>Also note the use of the <em>keyword-only</em> argument, <code>pad</code>; unlike the 2.X <code>map</code>, our version will allow any pad object to be specified. When these functions are run, the following results are printed—a <code>zip</code> and two padding <code>map</code>s:</p>
<pre data-type="programlisting">$ <code><strong>python3 myfptools-list.py</strong></code>
[('a', 'x'), ('b', 'y'), ('c', 'z')]
[('a', 'x'), ('b', 'y'), ('c', 'z'), (None, '1'), (None, '2'), (None, '3')]
[('a', 'x'), ('b', 'y'), ('c', 'z'), (99, '1'), (99, '2'), (99, '3')]</pre>
<p>These functions aren’t amenable to list comprehension translation because their loops are too specific. As before, though, while our <code>zip</code> and <code>map</code> workalikes currently build and return result lists, it’s just as easy to turn them into <em>generators</em> with <code>yield</code> so that they each return one piece of their result set at a time. <a data-type="xref" href="#example_twozero_sixdot_myfptools_genera">Example 20-6</a> shows how.</p>
<div data-type="example" id="example_twozero_sixdot_myfptools_genera">
<h5><span class="label">Example 20-6. </span>myfptools_generate.py</h5>
<pre data-type="programlisting"><em># Emulate zip and padding map: generate results</em>

def myzip(*seqs):
    seqs = [list(S) for S in seqs]
    while all(seqs):
        yield tuple(S.pop(0) for S in seqs)

def mymapPad(*seqs, pad=None):
    seqs = [list(S) for S in seqs]
    while any(seqs):
        yield tuple((S.pop(0) if S else pad) for S in seqs)</pre>
</div>
<p>The results are the same as before, but this file assumes it will be used or tested elsewhere (it has no self-test code), and we need to use <code>list</code> again to force the generators to yield their values for display in the REPL:</p>
<pre data-type="programlisting">$ <code><strong>python3</strong></code>
&gt;&gt;&gt; <code><strong>from myfptools_generate import myzip, mymapPad</strong></code>
&gt;&gt;&gt; <code><strong>list(myzip('abc', 'xyz123'))</strong></code>
[('a', 'x'), ('b', 'y'), ('c', 'z')]
&gt;&gt;&gt; <code><strong>list(mymapPad('abc', 'xyz123', pad=99))</strong></code>
[('a', 'x'), ('b', 'y'), ('c', 'z'), (99, '1'), (99, '2'), (99, '3')]</pre>
<p>Finally, here’s an alternative implementation of our <code>zip</code> and <code>map</code> emulators—rather than deleting arguments from lists with the <code>pop</code> method, the following versions do their job by calculating the minimum and maximum <em>argument lengths</em>. Armed with these lengths, it’s easy to code nested list comprehensions to step through argument index ranges:</p>
<pre data-type="programlisting">def myzip(*seqs):
    minlen = min(len(S) for S in seqs)
    return [tuple(S[i] for S in seqs) for i in range(minlen)]

def mymapPad(*seqs, pad=None):
    maxlen = max(len(S) for S in seqs)
    index  = range(maxlen)
    return [tuple((S[i] if len(S) &gt; i else pad) for S in seqs) for i in index]</pre>
<p>Because these use <code>len</code> and indexing, they assume that arguments are <em>sequences</em> or similar, not arbitrary iterables, much like our earlier sequence scramblers and permuters. The outer comprehensions here step through argument index ranges, and the inner comprehensions (passed to <code>tuple</code>) step through the passed-in sequences to pull out arguments in parallel (though not at the same time: see the next section!). When they’re run, the results are as before.</p>
<p>Most strikingly, generators and iterators seem to run rampant in this example. The arguments passed to <code>min</code> and <code>max</code> are generator expressions, which run to completion before the nested comprehensions begin iterating. Moreover, the nested list comprehensions employ two levels of delayed evaluation—the <code>range</code> built-in is an iterable, as is the generator expression argument to <code>tuple</code>.</p>
<p>In fact, <em>no</em> results are produced here until the square brackets of the list comprehensions request values to place in the result list—which forces all the comprehensions and generators to run. To turn these functions <em>themselves</em> into generators instead of list builders, simply use parentheses instead of square brackets again. Here’s the case for our zip:</p>
<pre data-type="programlisting">def myzip(*seqs):
    minlen = min(len(S) for S in seqs)
    return (tuple(S[i] for S in seqs) for i in range(minlen))

S1, S2 = 'abc', 'xyz123'
print(list(myzip(S1, S2)))         <code><em># Go!... [('a', 'x'), ('b', 'y'), ('c', 'z')]</em></code></pre>
<p>In this case, it takes a <code>list</code> call to activate the generators and other iterables to produce their results. Experiment with these on your own for more details. Developing further coding alternatives is left as a suggested exercise (but see the sidebar <a data-type="xref" href="#why_you_will_care_iteration_versus_pyth">“Why You Will Care: Iteration Versus Python Morph”</a> for an exploration of <a contenteditable="false" data-type="indexterm" data-primary="map function" data-secondary="emulating" data-startref="mpfceml" id="id3309"></a><a contenteditable="false" data-type="indexterm" data-primary="zip function" data-secondary="emulating" data-startref="zpfcmul" id="id3310"></a>one such option). Here, we have time for just one more related tale from the generations saga.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Asynchronous Functions: The Short Story"><div class="sect1" id="asynchronous_functions_the_short_story">
<h1>Asynchronous Functions: The Short Story</h1>
<p>Now that you’ve survived all the foregoing twists and turns of the functions story in Python, there’s one <a contenteditable="false" data-type="indexterm" data-primary="async function" id="id3311"></a><a contenteditable="false" data-type="indexterm" data-primary="functions" data-secondary="async" id="fctsych"></a>last topic to go. Python 3.5 debuted an extension called <em>asynchronous</em> (usually shortened to <em>async</em>) functions, which are able to manually pause their execution while waiting for a result, in order to allow other such functions to run.</p>
<p>Such tools are available in other languages (e.g., JavaScript), which provided some of the inspiration and blueprint for their appearance in Python. Indeed, <code>match</code>, <code>:=</code>, f-strings, type hinting, and a host of other Python tools owe their presence to this same programming-languages arms race, whose logical outcome would make all languages the same.</p>
<p>Origins aside, the pathological <a contenteditable="false" data-type="indexterm" data-primary="I/O (input/output) operations, async extension" id="id3312"></a><a contenteditable="false" data-type="indexterm" data-primary="async function" data-secondary="I/O (input/output) operations" id="id3313"></a>use case for the async extension is input/output (IO) operations: a function can pause itself until an IO transfer completes so that other parts of the program can run during the wait. While other tools like multiple threads can and still do address this need too, some may judge async functions to be a lighter-weight option.</p>
<p>That said, there are downsides to this topic. For one thing, it has been morphing almost constantly since its first murmurs in Python 3.4, which makes it difficult to document in books with lifespans much longer than web pages and blogs. For another, it’s something of an all-or-nothing proposition, because async code requires other async code.</p>
<p class="pagebreak-before">More fundamentally, async functions are part of <a contenteditable="false" data-type="indexterm" data-primary="parallel programming, async functions" id="id3314"></a>the applications-level domain of <em>parallel</em> <span class="keep-together"><em>programming</em>—a</span> category that also includes multiprocessing and multithreading. As such, they are a heavyweight subject of interest to only a subset of Python’s user base, and a lot to ask of newcomers to Python or programming in general. Especially given Python’s already skyrocketing complexity, this may be best taken as an optional add-on topic, and out of scope here.</p>
<p>Nevertheless, async functions are not truly optional in Python: they were added deeply to the language as new syntax, via the <code>async</code> and <code>await</code> reserved words, and are now fair game in code you may have to reuse (and job-interview tests you may have to suffer). For all these reasons, this section provides just enough of an overview to whet your appetite, but defers to Python’s online resources for more details when you’re ready to tackle this advanced topic.</p>
<section data-type="sect2" data-pdf-bookmark="Async Basics"><div class="sect2" id="async_basics">
<h2>Async Basics</h2>
<p>In a nutshell, async functions enable a <em>cooperative</em>, nonpreemptive multitasking model, with coding <a contenteditable="false" data-type="indexterm" data-primary="multitasking, async function" id="id3315"></a><a contenteditable="false" data-type="indexterm" data-primary="async function" data-secondary="multitasking" id="id3316"></a>trade-offs similar to those imposed by asynchronous network servers. For instance, tasks must generally be short-lived to avoid monopolizing the host device’s processor. Though begun earlier, Python 3.5 made this part of the language with the <code>async def</code> statement and <code>await</code> expression, as well as the <code>async for</code> iterator and <code>async with</code> context manager.</p>
<p>Async tools and syntax can be used only in functions defined with <code>async def</code>. Like the <code>yield</code> and <code>yield from</code> that this model extend, <code>async def</code> causes a function to be compiled specially: when called, instead of running its body, such a function returns an <em>awaitable</em> object that supports an expected method-based protocol.</p>
<p>To invoke this object, functions <code>await</code> results explicitly, or use an <code>async for</code> or <code>async with</code> that does so implicitly. Moreover, an <em>event loop</em> must be launched to run the show at large. Although the event loop runs just one task at a time (they’re not truly parallel), it can switch to other tasks when a task runs an <code>await</code> for a pending result.</p>
<section data-type="sect3" data-pdf-bookmark="Running serial tasks with normal blocking calls"><div class="sect3" id="running_serial_tasks_with_normal_blocki">
<h3>Running serial tasks with normal blocking calls</h3>
<p>As usual, this may be easier <a contenteditable="false" data-type="indexterm" data-primary="async function" data-secondary="serial tasks" id="id3317"></a>to grok in code than narrative, so let’s turn to some examples to demo the salient bits. All of this section’s example snippets live in the file <a class="orm:hideurl" href="https://learning-python.com/LP6E/Chapter20/all_async_demos.py"><em>all_async_demos.py</em></a> in the examples package, previewed in <a data-type="xref" href="#example_twozero_sevendot_all_async_demo">Example 20-7</a>. To work along, ether cut and paste from this file or emedia, or run the examples file in its entirety or with parts stubbed out with triple quotes. All examples here assume that the preamble at the top of <a data-type="xref" href="#example_twozero_sevendot_all_async_demo">Example 20-7</a> has been run.</p>
<div data-type="example" id="example_twozero_sevendot_all_async_demo">
<h5><span class="label">Example 20-7. </span>all_async_demos.py (preamble)</h5>
<pre data-type="programlisting">import time, asyncio
def now(): 
    return time.strftime('[%H:%M:%S]')      <code><em># Local time, as hour:minute:second</em></code>

…<code><em>all examples here</em></code>…</pre>
</div>
<p>We need a handful of standard-library tools here: some in the <code>asyncio</code> standard-library module are required, and we’ll display times with <code>time.strftime</code> and pause with sleep calls in both <code>time</code> and <code>asyncio</code> to simulate a long-running task. See Python’s library manual for these tools’ fine print that we’ll skip here for space and scope.</p>
<p>To get started, consider the following <em>non</em>-async code, in which a <code>main</code> function calls another, <code>producer</code>, that simply pauses for two seconds using the <code>time.sleep</code> call before returning a result. The sleep stands in for a real blocking operation—like an IO call, network transfer, or user interaction. As usual with normal functions, <code>main</code> simply waits for each <code>producer</code> call to run to completion and return a result, before it proceeds with a next step:</p>
<pre data-type="programlisting">def producer(label):
    time.sleep(2)                              <code><em># Pause for two seconds: blocking</em></code>
    return f'All done, {label}, {now()}'       <code><em># And return a result</em></code>

def main():
    print('Start =&gt;', now())
    print(producer(f'serial task 1'))          <code><em># Run three steps in sequence</em></code>
    print(producer(f'serial task 2'))          <code><em># Waiting for each one to finish</em></code>
    print(producer(f'serial task 3'))          <code><em># Before doing anything else</em></code>
    print('Stop  =&gt;', now())

main()</pre>
<p>When run, this code produces the following mundane results. As you can see, each <code>producer</code> call runs a two-second sleep before another starts, so the total time required is six seconds—two for each call run in series by <code>main</code>:</p>
<pre data-type="programlisting">Start =&gt; [19:00:28]
All done, serial task 1, [19:00:30]
All done, serial task 2, [19:00:32]
All done, serial task 3, [19:00:34]
Stop  =&gt; [19:00:34]</pre>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Running concurrent tasks with “await” and “async def”"><div class="sect3" id="running_concurrent_tasks_with-id00074">
<h3>Running concurrent tasks with “await” and “async def”<strong></strong></h3>
<p>Now, let’s do the same <a contenteditable="false" data-type="indexterm" data-primary="async function" data-secondary="concurrent tasks" data-tertiary="await" id="syfck"></a><a contenteditable="false" data-type="indexterm" data-primary="async function" data-secondary="concurrent tasks" data-tertiary="async def" id="syccrk"></a>work with async functions. In the next listing, the <code>producer</code> is coded as an <code>async def</code> function, which makes Python compile it specially: it’s now a <em>coroutine</em>—an object which, when called, doesn’t produce its result, but instead returns an automatically created object that supports the coroutine method protocol. That protocol generally includes a method named <code>__await__</code>, which returns an iterator that produces coroutine results on <code>__next__</code>, but may instead use <code>__anext__</code> for generators. We can safely ignore all of these here.</p>
<p>The <code>async def</code> syntax is always required for functions that use <code>await</code>, as well as <code>aync for</code> and <code>async with</code> demoed ahead. Because <code>async def</code> is required to <em>both</em> use and define awaitable coroutines, it tends to spread viruslike throughout code (in fact, some tools now come with libraries in two separate forms, asynchronous and not).</p>
<p>Also in the following, <code>producer</code> uses <code>await</code> to suspend itself until the sleep expires. <code>await</code> is similar to a <code>yield from</code>, but the event loop is free to pause the coroutine running the <code>await</code> and resume another if the awaited result is not ready. Notice that <code>await</code> is used as a statement in <code>producer</code>; it’s also an expression that returns the awaited result, as in <code>main</code>, where it returns the result of the awaited objects:</p>
<pre data-type="programlisting">async def producer(label):                     <code><em># await requires async</em></code>
    await asyncio.sleep(2)                     <code><em># Call nonblocking/awaitable sleep</em></code>
    return f'All done, {label}, {now()}'       <code><em># Result of await expression</em></code>

async def main():
    print('Start =&gt;', now())
    task1 = asyncio.create_task(producer(f'async task 1'))
    task2 = asyncio.create_task(producer(f'async task 2'))
    task3 = asyncio.create_task(producer(f'async task 3'))
    print(await task1) 
    print(await task2) 
    print(await task3)                         <code><em># Wait for tasks to finish</em></code>
    print('Stop  =&gt;', now())

asyncio.run(main())                            <code><em># Start event-loop schedule</em></code></pre>
<p>Crucially, the awaited <code>asyncio.sleep</code> call is like <code>time.sleep</code>, but is both <em>nonblocking</em>—it uses the event-loop’s API to ensure that the caller doesn’t pause for its completion—and <em>awaitable</em>—it uses <code>async def</code> to allow itself to be paused until a timeout elapses. Operations at the end of <code>await</code> chains must generally follow this model.</p>
<p>Also crucially, <code>main</code> uses <code>asyncio.create_task</code> to wrap each <code>producer</code> object in a <em>task</em>—an object run by the event loop that suspends execution of the coroutine it wraps while the coroutine waits for completion of a <em>future</em>, and returns the result of its wrapped coroutine when awaited itself. Future objects signal progress in ways that are too low level for this overview; here, it’s enough to know that each task suspends itself while its coroutine is sleeping.</p>
<p>As a result, tasks can be overlapped in time, to run <em>concurrently</em>. In our code, all three tasks—and the <code>producer</code> coroutines they manage—finish at the same time, and the total program takes just two seconds instead of six:</p>
<pre data-type="programlisting">Start =&gt; [19:00:34]
All done, async task 1, [19:00:36]
All done, async task 2, [19:00:36]
All done, async task 3, [19:00:36]
Stop  =&gt; [19:00:36]</pre>
<p>Naturally, we can use loops here to make the steps more automated. The following runs the same as the prior version—taking two total seconds, and two for each overlapped task:</p>
<pre data-type="programlisting">async def producer(label):
    await asyncio.sleep(2)
    return f'All done, {label}, {now()}'

async def main():
    print('Start =&gt;', now())
    tasks = []
    for i in range(3):
        tasks.append(asyncio.create_task(producer(f'async task {i+1}')))
    for task in tasks:
        print(await task)
    print('Stop  at', now())

asyncio.run(main())</pre>
<p>In both <code>producer</code> and <code>main</code>, an <code>await</code>, much like a <code>yield from</code>, suspends execution of the coroutine that runs it until the awaited object returns <a contenteditable="false" data-type="indexterm" data-primary="async function" data-secondary="concurrent tasks" data-tertiary="await" data-startref="syfck" id="id3318"></a><a contenteditable="false" data-type="indexterm" data-primary="async function" data-secondary="concurrent tasks" data-tertiary="async def" data-startref="syccrk" id="id3319"></a>its result. Together with the event loop and tasks, the net effect interleaves code.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="How not to use async functions"><div class="sect3" id="how_not_to_use_async_functions">
<h3>How not to use async functions</h3>
<p>To understand the preceding example, it may help <a contenteditable="false" data-type="indexterm" data-primary="async function" data-secondary="tasks to avoid" id="asyfskv"></a>to see other codings that do <em>not</em> work. In this example, the <code>await</code>s, tasks, and event loop are all essential: the code won’t work without them. For one thing, calling <code>main</code> directly without routing it to the event loop fails right out of the gate with a warning. The call to <code>main</code> simply creates an awaitable object but does nothing with it (for brevity, snippets in this section show just differing code, followed by its results):</p>
<pre class="pagebreak-before" data-type="programlisting">async def main():
    print(producer('xxx'))

main()

<code><em># Result…</em></code>
…/all_async_blunders.py:12: RuntimeWarning: coroutine 'main' was never awaited</pre>
<p>For another, calling <code>producer</code> directly instead of awaiting it fails too, and for the same reason. Much like generators, calling a coroutine returns the awaitable object, but doesn’t run it; we must <code>await</code> the awaitable to make it go, just like we have to run <code>next</code> to get results from a generator:</p>
<pre data-type="programlisting">async def main():
    print(producer('xxx'))

asyncio.run(main())

<code><em># Result…</em></code>
&lt;coroutine object producer at 0x10142e740&gt;
…/all_async_blunders.py:22: RuntimeWarning: coroutine 'producer' was never awaited</pre>
<p>More vitally, tasks are key to the <em>concurrency</em> here. If the example’s <code>main</code> simply runs an <code>await</code> for a <code>producer</code> directly, it will pause for the sleep too. In the following miscoding, both coroutines await the sleep’s end, and the two <code>producer</code>s run serially—yielding a total of four seconds for the program at large instead of two:</p>
<pre data-type="programlisting">async def main():
    print('Start =&gt;', now())
    print(await producer('xxx'))
    print(await producer('yyy'))
    print('Stop  =&gt;', now())

asyncio.run(main())

<code><em># Result…</em></code>
Start =&gt; [18:41:56]
All done, xxx, [18:41:58]
All done, yyy, [18:42:00]
Stop  =&gt; [18:42:00]</pre>
<p>This is also true if we defer the awaits by assignments—<code>main</code> continues to run after creating the <span class="keep-together"><code>producer</code></span> coroutine awaitables, but still hangs for each later <code>await</code> that runs the coroutine’s code, with no concurrency to be found:</p>
<pre data-type="programlisting">async def main():
    print('Start =&gt;', now())
    p1 = producer('xxx')
    p2 = producer('yyy')
    print('Await =&gt;', now())
    print(await p1)
    print(await p2)
    print('Stop  =&gt;', now())

asyncio.run(main())                            

<code><em># Result…</em></code>
Start =&gt; [18:42:00]
Await =&gt; [18:42:00]
All done, xxx, [18:42:02]
All done, yyy, [18:42:04]
Stop  =&gt; [18:42:04]</pre>
<p>That’s why tasks are needed in the prior example: they enable coroutines to be paused and run by the event loop to overlap their execution. That is, they enable <em>concurrency</em>—along with alternatives <a contenteditable="false" data-type="indexterm" data-primary="async function" data-secondary="tasks to avoid" data-startref="asyfskv" id="id3320"></a>like those of the next section.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Running concurrent tasks with “as_completed” and “gather” "><div class="sect3" id="running_concurrent_tasks_withid000108">
<h3>Running concurrent tasks with “as_completed” and “gather” </h3>
<p>But enough common <a contenteditable="false" data-type="indexterm" data-primary="async function" data-secondary="concurrent tasks" data-tertiary="as_completed" id="syfaspl"></a><a contenteditable="false" data-type="indexterm" data-primary="async function" data-secondary="concurrent tasks" data-tertiary="gather" id="syccgrth"></a>mistakes: let’s get back to coding concurrent coroutines the right way. Besides creating tasks, we can use the <code>gather</code> method to wait for all of our coroutines automatically, or <span class="keep-together"><code>as_completed</code></span> to wait for results as they finish. The latter can be used in a normal <code>for</code> to watch for completions:</p>
<pre data-type="programlisting">async def producer(label):
    await asyncio.sleep(2)
    return f'All done, {label}, {now()}'

async def main():
    print('Start =&gt;', now())
    coros = [producer(f'async task {i+1}') for i in range(3)]
    for nextdone in asyncio.as_completed(coros):
        print(await nextdone)
    print('Stop  at', now())

asyncio.run(main())</pre>
<p>This also finishes in two total seconds, though coroutine results may filter in in any order (<span class="keep-together"><code>as_completed</code></span> can also be used with <code>async for</code> of the next section in ways covered by Python’s <span class="keep-together">manuals</span>):</p>
<pre data-type="programlisting">Start =&gt; [19:00:38]
All done, async task 2, [19:00:40]
All done, async task 3, [19:00:40]
All done, async task 1, [19:00:40]
Stop  at [19:00:40]</pre>
<p>Alternatively, the <code>gather</code> call schedules tasks for coroutines, awaits all its arguments, and returns a list of task return values in the same order as its arguments when all have finished:</p>
<pre data-type="programlisting">async def producer(label):
    await asyncio.sleep(2)
    return f'All done, {label}, {now()}'

async def main():
    print('Start =&gt;', now())
    coro1 = producer(f'async task 1')
    coro2 = producer(f'async task 2')
    coro3 = producer(f'async task 3')
    results = await asyncio.gather(coro1, coro2, coro3)
    print(results) 
    print('Stop  at', now())

asyncio.run(main())</pre>
<p>Results vary because they are in a list (formatted for display here), but it’s still just two seconds for the entire gig:</p>
<pre data-type="programlisting">Start =&gt; [19:00:40]
['All done, async task 1, [19:00:42]', 
 'All done, async task 2, [19:00:42]', 
 'All done, async task 3, [19:00:42]']
Stop  at [19:00:42]</pre>
<p>For any line counters in the audience, a starred list comprehension can be used to create awaitables for <code>gather</code> more succinctly, and produces the same two-second result as the preceding version:</p>
<pre data-type="programlisting">async def producer(label):
    await asyncio.sleep(2)
    return f'All done, {label}, {now()}'

async def main():
    print('Start =&gt;', now())
    print(await asyncio.gather(*[producer(f'async task {i+1}') for i in range(3)]))
    print('Stop  at', now())

asyncio.run(main())</pre>
<p>While this code works, Python’s manuals today include a note that recommends <code>TaskGroup</code> over <code>gather</code> on the grounds of better exception handling. Should you care to follow <a contenteditable="false" data-type="indexterm" data-primary="async function" data-secondary="concurrent tasks" data-startref="syfccrk" id="id3321"></a><a contenteditable="false" data-type="indexterm" data-primary="async function" data-secondary="concurrent tasks" data-tertiary="as_completed" data-startref="syfaspl" id="id3322"></a><a contenteditable="false" data-type="indexterm" data-primary="async function" data-secondary="concurrent tasks" data-tertiary="gather" data-startref="syccgrth" id="id3323"></a>that advice, you’ll need to move on to the next section.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Running concurrent tasks with “async with” and “async for”"><div class="sect3" id="running_concurrent_tasks_withid000121">
<h3>Running concurrent tasks with “async with” and “async for”</h3>
<p>As yet another concurrency <a contenteditable="false" data-type="indexterm" data-primary="async function" data-secondary="concurrent tasks" data-tertiary="async with" id="syfassyw"></a><a contenteditable="false" data-type="indexterm" data-primary="async function" data-secondary="concurrent tasks" data-tertiary="async for" id="syccgsyfr"></a>option, the combination of the <code>async with</code> statement and a manager object can automatically handle both protocols and exceptions, and wait for tasks to finish. As half of this pair, <code>async with</code> internally awaits the awaitables returned by its subject’s <code>__aenter__</code> and <code>__aexit__</code> methods, the same way that the normal <code>with</code> statement calls the context-manager protocol’s <code>__enter__</code> and <code>__exit__</code>.</p>
<p>Having said that, we unfortunately won’t study either the normal <code>with</code> or its method protocols until <a data-type="xref" href="part07.html#exceptions">Part VII</a>, because they require knowledge of classes and OOP (yet again, Python’s toolset assumes you must already know Python to use Python!), so you’ll have to take this on faith for now. In the following code, though, it’s enough to know that using a <code>TaskGroup</code> asynchronous context manager in concert with <code>async with</code> will automatically await results from all of its tasks before the statement exits, as well as handle some thorny issues involving exceptions:</p>
<pre data-type="programlisting">async def producer(label):
    await asyncio.sleep(2)
    return f'All done, {label}, {now()}'

async def main():
    print('Start =&gt;', now())
    async with asyncio.TaskGroup() as tg:
        tasks = [tg.create_task(producer(f'async task {i+1}')) for i in range(3)]
    for task in tasks:
        print(task.result())
    print('Stop  at', now())

asyncio.run(main())</pre>
<p>The net effect runs all three <code>producer</code> calls concurrently in two seconds as before:</p>
<pre data-type="programlisting">Start =&gt; [19:00:44]
All done, async task 1, [19:00:46]
All done, async task 2, [19:00:46]
All done, async task 3, [19:00:46]
Stop  at [19:00:46]</pre>
<p>Finally, when a function is coded with <code>async def</code> and also uses <code>yield</code>, it’s considered an <em>asynchronous generator</em>. When called, it returns an asynchronous iterable object which uses the <code>__anext__</code> method noted earlier, and can be used in an <code>async for</code> statement to execute the body of the function. (And no, there are no <code>async</code> variants of other statements like <code>while</code> or <code>if</code>; <code>with</code> and <code>for</code> were the only targets deemed worthy of the <code>async</code> twist—so far.)</p>
<p>Internally, <code>async for</code> uses methods <code>__aiter__</code> and <code>__anext__</code> much like the normal iteration protocol’s <code>__iter__</code> and <code>__next__</code> that we studied in <a data-type="xref" href="ch14.html#iterations_and_comprehensions">Chapter 14</a>. The <code>__anext__</code> method returns an awaitable that produces a next value, and raises <code>StopAsyncIteration</code> to signal the end of values, instead of <code>StopIteration</code>. <code>async for</code> simply gets a next value by awaiting a call to <code>__anext__</code>, and running the loop’s block of code for every value obtained this way. This encroaches on classes and OOP again, but statement users may ignore the details.</p>
<p>To avoid confusion, keep in mind that <code>async for</code> awaits the <em>next</em> item in the iterable it scans—which is not the same as awaiting for something else in the loop body of a normal <code>for</code>, as in prior examples here. Moreover, <code>async for</code> does not automatically <em>parallelize</em> anything—it’s really just like a normal <code>for</code>, but adds an <code>await</code> for each next item obtained from its iterable, instead of issuing a potentially blocking call. <code>async for</code>’s implicit awaits between loops allow it to be interleaved with other ready-to-run tasks, but don’t help much otherwise:</p>
<pre data-type="programlisting">async def producer(label):
    for i in range(3):
        await asyncio.sleep(2)
        yield f'All done, {label} {i+1}, {now()}'

async def main():
    print('Start =&gt;', now())
    async for reply in producer('async task'):
        print(reply)
    print('Stop  at', now())

asyncio.run(main())</pre>
<p>As coded here, the result is the same six-second showing of the original serial version, because there’s nothing else to run in this simple demo during the sleeps:</p>
<pre data-type="programlisting">Start =&gt; [19:00:46]
All done, async task 1, [19:00:48]
All done, async task 2, [19:00:50]
All done, async task 3, [19:00:52]
Stop  at [19:00:52]</pre>
<p>And lest this section hasn’t yet managed to send <a contenteditable="false" data-type="indexterm" data-primary="async function" data-secondary="concurrent tasks" data-tertiary="async with" data-startref="syfassyw" id="id3324"></a><a contenteditable="false" data-type="indexterm" data-primary="async function" data-secondary="concurrent tasks" data-tertiary="async for" data-startref="syccgsyfr" id="id3325"></a>you screaming into the night, it’s also possible to use <code>await</code> and <code>async for</code> within a <em>comprehension</em> that’s coded in an <code>async def</code>—but this must remain a story for another day:</p>
<pre data-type="programlisting">async def hmm():
    result = [i async for i in asynciter() if i &gt; 0]      <code><em># This code is not real</em></code>
    result = [await func() for func in coroutines]        <code><em># It's also unreal…</em></code></pre>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="The Async Wrap-Up"><div class="sect2" id="the_async_wrap_up">
<h2>The Async Wrap-Up</h2>
<p>That’s all the time and space we have for this topic (humanely, perhaps). Python’s async functions may be more useful than type hinting (which, as we saw in <a data-type="xref" href="ch06.html#the_dynamic_typing_interlude">Chapter 6</a>, is both completely unused and at odds with Python’s core ideas), but a full survey of either topic could fill chapters or books, and would be of interest to only a subset of Python users.</p>
<p>Moreover, this text isn’t covering Python’s multithreading or multiprocessing tools at all, even though they are at least as valid as async functions for parallelizing tasks. The fact that <code>async</code> alone was afforded dedicated syntax in the language both subjectively favors just one option in this domain and raises the bar for Python newcomers.</p>
<p>That said, your goals and views may differ, so please see Python’s standard manuals for the full story if and when you wish to wade deeper into the async sea. Here, we must step back from the ledge of optional and stunningly convoluted extensions, and get back to the <a contenteditable="false" data-type="indexterm" data-primary="functions" data-secondary="async" data-startref="fctsych" id="id3326"></a>fundamentals that nearly all Python programs and programmers use.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Chapter Summary"><div class="sect1" id="chapter_summary-id00031">
<h1>Chapter Summary</h1>
<p>This chapter wrapped up our coverage of built-in comprehension and iteration tools. It explored list comprehensions in the context of functional tools, and presented generator functions and expressions as additional iteration protocol tools. As a finale, we also explored some larger examples of iterations, comprehensions, and generations in action, and briefly glimpsed the asynchronous-functions extension to pique further study. Though we’ve now seen all the built-in iteration tools, the subject will resurface when we explore user-defined iterable classes in <a data-type="xref" href="ch30.html#operator_overloading-id000103">Chapter 30</a>.</p>
<p>The next chapter is something of a continuation of the theme of this one—it rounds out this part of the book with a case study that times the performance of the tools we’ve studied here, and serves as a more realistic example at the midpoint of this book (yes, you’re half done!). Before we move ahead to benchmarking comprehensions and generators, though, this chapter’s quizzes give you a chance to review what you’ve learned about them here.</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Test Your Knowledge: Quiz"><div class="sect1" id="test_your_knowledge_quiz-id000161">
<h1>Test Your Knowledge: Quiz</h1>
<ol>
<li><p>What is the difference between enclosing a list comprehension in square brackets and parentheses?</p></li>
<li><p>How are generators and iterators related?</p></li>
<li><p>How can you tell if a function is a generator function?</p></li>
<li><p>What does a <code>yield</code> statement do?</p></li>
<li><p>How are <code>map</code> calls and list comprehensions related? Compare and contrast the two.</p></li>
<li><p>What do <code>async def</code> and <code>await</code> mean in a Python script?</p></li>
</ol>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Test Your Knowledge: Answers"><div class="sect1" id="test_your_knowledge_answers-id000160">
<h1>Test Your Knowledge: Answers</h1>
<ol>
<li><p>List comprehensions in square brackets produce the result list all at once in memory. When they are enclosed in parentheses instead, they are actually generator expressions—they have the same internal syntax and a similar meaning but do not produce the result list all at once. Instead, generator expressions return a generator object, which yields one item in the result at a time when used in an iteration tool or iterated manually with <code>next</code>.</p></li>
<li><p>Generators are iterable objects that support the iteration protocol automatically—they have an iterator with a <code>__next__</code> method (run by <code>next</code>) that repeatedly advances to the next item in a series of results and raises an exception at the end of the series. In Python, we can code generator <em>functions</em> with <code>def</code> and <code>yield</code>, generator <em>expressions</em> with parenthesized comprehensions, and generator objects with <em>classes</em> that define a special method named <code>__iter__</code> (discussed later in the book).</p></li>
<li><p>A generator function has a <code>yield</code> statement (with or without its <code>from</code> extension) somewhere in its code. Generator functions are otherwise identical to normal functions syntactically, but they are compiled specially to return an iterable generator object when called. That object retains state and code location between values. (This means that deleting <code>yield</code> makes a function normal, but code deletions can cause all sorts of issues.)</p></li>
<li><p>When present, this statement makes Python compile the function specially as a generator; when called, the function returns a generator object that supports the iteration protocol. When the <code>yield</code> statement is run, it sends a result back to the caller and suspends the function’s state; the function can then be resumed after the last <code>yield</code> statement, in response to a <code>next</code> built-in or <code>__next__</code> method call issued by the caller. In more advanced roles, the generator <code>send</code> method similarly resumes the generator, but can also pass a value that shows up as the <code>yield</code> expression’s value. Generator functions may also have a <code>return</code> statement, which terminates the generator (and attaches an optional value to the automatic <code>StopIteration</code> exception).</p></li>
<li><p>The <code>map</code> call is similar to a list comprehension—both produce a series of values, by collecting the results of applying an operation to each item in a sequence or other iterable, one item at a time. The primary difference is that <code>map</code> applies a <em>function</em> call to each item, and list comprehensions apply arbitrary <em>expressions</em>. Because of this, list comprehensions are more general; they can apply a function call expression like <code>map</code>, but <code>map</code> requires a function to apply other kinds of expressions. List comprehensions also support extended syntax—nested <code>for</code> loops, and <code>if</code> clauses that subsume the <code>filter</code> built-in. <code>map</code> also differs by producing a <em>generator</em> of values; the list comprehension materializes the result list in memory all at once, and this may matter for large lists.</p></li>
<li><p>The <code>async def</code> is used to define an asynchronous function (usually called a <em>coroutine</em>), and <code>await</code> waits for another asynchronous object to produce its value, possibly yielding control back to an event loop to allow other code to run during the wait. <code>async def</code> is required to use <code>await</code>, <code>async for</code>, and <code>async with</code>, and both an event loop and scheduling calls in module <code>asyncio</code> are generally required to achieve concurrency in this model. There’s more to the async story than told here; see Python’s manuals for next steps on this topic, as well as its multithreading and multiprocessing alternatives in Python’s standard library.</p></li>
</ol>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="why_you_will_care_iteration_versus_pyth">
<h1>Why You Will Care: Iteration Versus Python Morph</h1>
<p>In <a data-type="xref" href="ch14.html#iterations_and_comprehensions">Chapter 14</a>, we noted that some built-ins (like <code>map</code>) support only a single traversal <a contenteditable="false" data-type="indexterm" data-primary="iteration" data-secondary="Python morph and" id="id3327"></a>and are empty after it occurs, and this book promised to show you an example of why that can be important in practice. Now that we’ve studied iteration topics in full, it can make good on this promise—and demo the negative impacts of Python changes on your code at the same time.</p>
<p>In earlier editions of this book, the following clever coding for <code>zip</code> emulation, adapted from a version in Python’s docs at the time, worked because <code>map</code> returned a physical list instead of a generator of values:</p>
<pre data-type="programlisting">def myzip(*args):                           <code><em># Before 3.0...</em></code>
    iters = map(iter, args)                 
    while iters:                            <code><em># Guarantee &gt;=1, force looping</em></code>
        res = [next(i) for i in iters]      <code><em># Any empty? StopIteration=return</em></code>
        yield tuple(res)                    <code><em># Else return res, suspend state</em></code>                  
                                            <code><em># Exit=return=StopIteration</em></code>
&gt;&gt;&gt; <code><strong>list(myzip('ab', 'lmn'))</strong></code>
KeyboardInterrupt</pre>
<p><em>Except this broke in Python 3.0</em>. This code relied on that fact that <code>map</code>’s result supported multiple scans. When it mutated into a <em>single-scan</em> generator in 3.0, as soon as the list comprehension traversed <code>iters</code> once, the generator was exhausted but still <code>True</code>; later list comprehensions returned <code>[]</code>; and this code would loop until killed by a Ctrl+C. To fix, the prior edition added a <code>list</code> around <code>map</code> to make it reiterable:</p>
<pre data-type="programlisting">def myzip(*args):                           <code><em># Before 3.7...</em></code>
    iters = list(map(iter, args))           <code><em># &lt;== Make iters reiterable, 3.0+</em></code>
    while iters:                            <code><em># map() is a one-scan generator</em></code>
        res = [next(i) for i in iters]
        yield tuple(res)                                      

&gt;&gt;&gt; <code><strong>list(myzip('ab', 'lmn'))</strong></code>
RuntimeError: generator raised StopIteration</pre>
<p><em>Except this broke in Python 3.7</em>. This code relied on the fact that an uncaught <code>StopIteration</code> from any iterable in <code>iters</code> was propagated through this function and sufficed to terminate its generation of values. Python 3.7 changed to suppress this “bubbling” propagation of <code>StopIteration</code> through a generator and issue a <code>RunTimeError</code> in response. The workaround is to explicitly catch the <span class="keep-together"><code>StopIteration</code></span> and <code>return</code>—even though <code>return</code> simply raises <code>StopIteration</code>:</p>
<pre data-type="programlisting">def myzip(*args):                           <code><em># After 3.7, and before ?...</em></code>
    iters = list(map(iter, args))
    while iters:
        try:                                <code><em># &lt;== Catch StopIteration, 3.7+</em></code>
            res = [next(i) for i in iters]  <code><em># StopIteration won't propagate</em></code>
        except StopIteration: 
            return                          <code><em># How generators should exit</em></code>
        yield tuple(res)                    <code><em># But exit=return=StopIteration!</em></code>

&gt;&gt;&gt; <code><strong>list(myzip('ab', 'lmn'))</strong></code>
[('a', 'l'), ('b', 'm')]</pre>
<p>You’ll have to wait until <a data-type="xref" href="part07.html#exceptions">Part VII</a> for more on the <code>try</code> statement, and may have to similarly translate exceptions to returns this way in rare generators that rely on the former bubbling behavior. And while this final version works today, we’re not placing any bets on the future.</p>
<p>The takeaways here: wrapping <code>map</code> calls in <code>list</code> calls is not just for display; generators no longer propagate exit exceptions from code they run; and Python mods can and do break code—both subtly and repeatedly!</p>
</div></aside>
</div></section>
</div></section></div>
</div>
</body>
</html>