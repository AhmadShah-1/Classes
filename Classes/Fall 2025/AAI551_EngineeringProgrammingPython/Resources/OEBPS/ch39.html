<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xml:lang="en"
lang="en"
xmlns="http://www.w3.org/1999/xhtml"
xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<title>Learning Python, 6th Edition</title>
<link rel="stylesheet" type="text/css" href="override_v1.css"/>
<link rel="stylesheet" type="text/css" href="epub.css"/>
</head>
<body>
<div id="book-content">
<div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 39. Decorators"><div class="chapter" id="decorators">
<h1><span class="label">Chapter 39. </span>Decorators</h1>
<p>In <a data-type="xref" href="ch32.html#class_odds_and_ends">Chapter 32</a>’s survey of class odds and ends, we met properties and static and class methods, took a quick look at the <code>@</code> decorator syntax Python offers for declaring them, and previewed decorator coding techniques. We also met function decorators briefly while exploring the <code>property</code> built-in in <a data-type="xref" href="ch38.html#managed_attributes">Chapter 38</a>, in the context of abstract superclasses in <a data-type="xref" href="ch29.html#class_coding_details">Chapter 29</a>, and in capsule form in <a data-type="xref" href="ch19.html#function_odds_and_ends">Chapter 19</a>.</p>
<p>This chapter picks up where all this previous decorator coverage left off. Here, we’ll dig deeper into the mechanics of decorators and study more ways to code new decorators ourselves with tools like arguments and nesting. As we’ll find, other concepts we studied earlier—especially state retention—show up regularly in decorators.</p>
<p>This is a somewhat advanced topic, and decorator construction tends to be of more interest to tool builders than to application programmers. Still, given that decorators are becoming increasingly common in popular Python frameworks, a basic understanding can help demystify their role, even if you’re just a decorator user.</p>
<p>Besides covering decorator construction details, this chapter serves as a more realistic <em>case study</em> of Python in action. Because its examples grow larger than many of the others we’ve seen in this book, they better illustrate how code comes together into more complete systems and tools. As an extra perk, some of the code we’ll write here may be used as general-purpose tools in your day-to-day programs.</p>
<section data-type="sect1" data-pdf-bookmark="What’s a Decorator?"><div class="sect1" id="whatapostrophes_a_decoratorquestion_mar">
<h1>What’s a Decorator?</h1>
<p>Simply put, <em><em>decoration</em></em> is a way to specify management or augmentation code for functions and classes. Decorators <a contenteditable="false" data-type="indexterm" data-primary="decoration" id="id4756"></a>themselves take the form of callable objects (e.g., functions) that process other callable objects. As suggested earlier in this book, Python decorators come in two related flavors:</p>
<ul>
<li><p><em>Function decorators</em>, added first, do name <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="function decorators" id="id4757"></a><a contenteditable="false" data-type="indexterm" data-primary="function decorators" id="id4758"></a>rebinding at function definition time, providing a layer of logic that can manage functions and methods or later calls to them.</p></li>
<li><p><em>Class decorators</em>, added later, do <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="class decorators" id="id4759"></a><a contenteditable="false" data-type="indexterm" data-primary="class decorators" id="id4760"></a>name rebinding at class definition time, providing a layer of logic that can manage classes or the instances created by later calls to them.</p></li>
</ul>
<p>In short, decorators provide a way to insert <em>automatically run code</em> at the close of function and class definition statements—at the end of a <code>def</code> for function decorators and at the end of a <code>class</code> for class decorators. Such code can play a variety of roles, as described in the following sections.</p>
<section data-type="sect2" data-pdf-bookmark="Managing Calls and Instances"><div class="sect2" id="managing_calls_and_instances">
<h2>Managing Calls and Instances</h2>
<p>In typical use, this automatically run code may be used to augment calls to functions and classes. It arranges this by installing <em>wrapper</em> (a.k.a. <em>proxy</em>) objects to be invoked later:</p>
<dl>
<dt>Call proxies</dt>
<dd>Function decorators install <a contenteditable="false" data-type="indexterm" data-primary="call proxies" id="id4761"></a><a contenteditable="false" data-type="indexterm" data-primary="wrappers" data-secondary="call proxies" id="id4762"></a><a contenteditable="false" data-type="indexterm" data-primary="function decorators" data-secondary="call proxies" id="id4763"></a><a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="function decorators" data-tertiary="call proxies" id="id4764"></a>wrapper objects to intercept later <em>function calls</em> and process them as needed, usually passing the call on to the original function to run the managed action.</dd>
<dt>Interface proxies</dt>
<dd>Class decorators install <a contenteditable="false" data-type="indexterm" data-primary="interface proxies, wrappers" id="id4765"></a><a contenteditable="false" data-type="indexterm" data-primary="wrappers" data-secondary="class decorators" id="id4766"></a><a contenteditable="false" data-type="indexterm" data-primary="class decorators" data-secondary="interface proxies" id="id4767"></a><a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="class decorators" data-tertiary="interface proxies" id="id4768"></a>wrapper objects to intercept later <em>instance-creation calls</em> and process them as required, usually passing the call on to the original class to create a managed instance.</dd>
</dl>
<p>Decorators achieve these effects by automatically rebinding function and class names to other callables at the end of <code>def</code> and <code>class</code> statements. When later invoked, these callables can perform tasks such as tracing and timing function calls, managing access to class instance attributes, and so on.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Managing Functions and Classes"><div class="sect2" id="managing_functions_and_classes">
<h2>Managing Functions and Classes</h2>
<p>Although most examples in this chapter deal with using wrappers to intercept later calls to functions and classes, this is not the only way decorators can be used:</p>
<dl>
<dt>Function managers</dt>
<dd>Function decorators can also be used to <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="function decorators" data-tertiary="function managers" id="id4769"></a><a contenteditable="false" data-type="indexterm" data-primary="function decorators" data-secondary="function managers" id="id4770"></a><a contenteditable="false" data-type="indexterm" data-primary="function managers" id="id4771"></a>manage <em>function objects</em> instead of or in addition to later calls to them—to register a function to an API, for instance. Our primary focus here, though, will be on their more commonly used call-wrapper application.</dd>
<dt>Class managers</dt>
<dd>Class decorators can also be used to <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="class decorators" data-tertiary="class managers" id="id4772"></a><a contenteditable="false" data-type="indexterm" data-primary="class decorators" data-secondary="class managers" id="id4773"></a><a contenteditable="false" data-type="indexterm" data-primary="class managers" id="id4774"></a>manage <em>class objects</em> directly, instead of or in addition to instance-creation calls—to augment a class with new methods or data, for example. Because this role intersects strongly with that of <em>metaclasses</em>, we’ll explore additional decorator use cases in the next chapter. As detailed there, both tools run at the end of the class creation process, but class decorators often offer a lighter-weight solution.</dd>
</dl>
<p>In other words, function decorators can be used to manage both function calls and function objects, and class decorators can be used to manage both class instances and classes themselves. By returning the decorated object itself instead of a wrapper, decorators become a simple post-creation step for functions and classes.</p>
<p>Regardless of the role they play, decorators provide a convenient and explicit way to code tools useful both during program development and in live production systems.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Using and Defining Decorators"><div class="sect2" id="using_and_defining_decorators">
<h2>Using and Defining Decorators</h2>
<p>Depending on your job description, you might encounter decorators as a user or a provider. As we’ve seen, Python itself comes with built-in decorators that have specialized roles—static and class method declaration, property creation, and more. In addition, many popular Python toolkits include decorators to perform tasks such as managing database or user-interface logic. In such cases, we can get by without knowing how the decorators are coded.</p>
<p class="pagebreak-before">For more general tasks, programmers can code arbitrary decorators of their own. For example, function decorators may be used to augment functions with code that adds call tracing or logging, caches call results, performs argument validity testing during debugging, times calls made to functions for <span class="keep-together">optimization</span>, and so on. Any behavior you can imagine adding to—really, wrapping around—a function call is a candidate for custom function decorators.</p>
<p>On the other hand, function decorators are designed to augment only a specific function or method call, not an entire <em>object interface</em>. Class decorators fill the latter role better—because they can intercept instance-creation calls, they can be used to implement arbitrary object interface augmentation or management tasks. For example, custom class decorators can trace, validate, or otherwise augment every attribute reference made for an object. They can also be used to implement proxy objects, singleton classes, and other common coding patterns. In fact, you’ll find that many class decorators are a prime application of the <em>delegation</em> coding pattern we met in <a data-type="xref" href="ch31.html#designing_with_classes">Chapter 31</a>.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Why Decorators?"><div class="sect2" id="why_decoratorsquestion_mark">
<h2>Why Decorators?</h2>
<p>Like many advanced Python tools, decorators are never required from a purely technical perspective: we can often implement their functionality instead using simple helper function calls or other techniques. And at a base level, we can always manually code the name rebinding that decorators perform automatically.</p>
<p>That said, decorators provide an explicit syntax for such tasks, which makes intent clearer, can minimize augmentation <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="syntax" id="id4775"></a><a contenteditable="false" data-type="indexterm" data-primary="syntax" data-secondary="decorators" id="id4776"></a>code redundancy, and may help ensure correct API usage:</p>
<ul>
<li><p>Decorators have a very <em>explicit</em> syntax, which makes them easier to spot than helper function calls that may be arbitrarily far removed from the subject functions or classes.</p></li>
<li><p>Decorators are applied <em>once</em> when the subject function or class is defined; it’s not necessary to add extra code at every call to the class or function, which may have to be changed in the future.</p></li>
<li><p>Because of both of the prior points, decorators make it less likely that a user of an API will <em>forget</em> to augment a function or class according to API requirements.</p></li>
</ul>
<p>In other words, beyond their technical model, decorators offer some advantages in terms of both code maintenance and consistency. Moreover, as structuring tools, decorators naturally foster <em>encapsulation</em> of code, which reduces redundancy and makes future changes easier.</p>
<p>Like most tools, decorators have some potential <em>drawbacks</em>, too—when they insert wrapper logic, they can alter the types of the decorated objects, and they may incur extra calls when used as call or interface proxies. On the other hand, the same considerations apply to any technique that adds wrapping logic to objects.</p>
<p>We’ll explore these trade-offs in the context of real code later in this chapter. Although the choice to use decorators is ultimately subjective, their advantages are compelling enough to have escalated them to common practice in the Python world. To help you decide for yourself, let’s turn to the details.</p>
<aside data-type="sidebar" epub:type="sidebar" class="pagebreak-before less_space"><div class="sidebar" id="decorators_versus_macros">
<h1>Decorators Versus Macros</h1>
<p>Python’s decorators bear similarities to <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="versus macros" data-secondary-sortas="macros" id="id4777"></a><a contenteditable="false" data-type="indexterm" data-primary="aspect-oriented programming" id="id4778"></a>what some call <em>aspect-oriented programming</em> in other languages—code inserted to run automatically before or after a function call runs. Their syntax also very closely resembles (and is likely borrowed from) Java’s <em>annotations</em>, though Python’s model may be considered more flexible and general.</p>
<p>Some liken decorators to <em>macros</em> too, but this isn’t entirely apt and can be misleading. Macros, like C’s <code>#define</code> preprocessor directive, are associated with textual replacement and expansion and designed for generating code. By contrast, Python’s decorators are a <em>runtime</em> operation based upon name rebinding, callable objects, and often, proxies. While the two may have use cases that sometimes overlap, decorators and macros are fundamentally different in scope, implementation, and coding patterns. Comparing the two seems akin to comparing Python’s <code>import</code> with a C <code>#include</code>, which similarly confuses a runtime object-based operation with text insertion.</p>
<p>Of course, the term <em>macro</em> has also been diluted over time—to some, it now can also refer to any canned series of steps or procedure—and users of other languages might find the analogy to decorators useful anyhow. But they should also keep in mind that decorators are about callable <em>objects</em> managing callable <em>objects</em>, not text expansion. Python tends to be best understood and used in terms of Python idioms.</p>
</div></aside>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="The Basics"><div class="sect1" id="the_basics-id000132">
<h1>The Basics</h1>
<p>Let’s get started with a first-pass look at decoration behavior from an abstract perspective. We’ll write real and more substantial code soon, but since most of the magic of decorators boils down to an automatic rebinding operation, it’s important to understand this mapping first—for both functions and classes.</p>
<section data-type="sect2" data-pdf-bookmark="Function Decorator Basics"><div class="sect2" id="function_decorator_basics-id00096">
<h2>Function Decorator Basics</h2>
<p>As previewed earlier in this book, function <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="function decorators" data-tertiary="usage" id="id4779"></a><a contenteditable="false" data-type="indexterm" data-primary="function decorators" data-secondary="usage" id="id4780"></a>decorators are largely just syntactic “sugar” that runs one function through another at the end of a <code>def</code> statement and rebinds the original function name to the result.</p>
<section data-type="sect3" data-pdf-bookmark="Usage"><div class="sect3" id="usage-id00082">
<h3>Usage</h3>
<p>A function decorator is a sort of <em>runtime declaration</em> about the function whose definition follows. The <a contenteditable="false" data-type="indexterm" data-primary="function decorators" data-secondary="runtime declarations" id="id4781"></a><a contenteditable="false" data-type="indexterm" data-primary="runtime declarations" id="id4782"></a><a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="function decorators" data-tertiary="runtime declarations" id="id4783"></a><a contenteditable="false" data-type="indexterm" data-primary="runtime declarations" data-secondary="function decorators" id="id4784"></a><a contenteditable="false" data-type="indexterm" data-primary="function decorators" data-secondary="metafunctions" id="id4785"></a><a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="function decorators" data-tertiary="metafunctions" id="id4786"></a><a contenteditable="false" data-type="indexterm" data-primary="metafunctions" data-secondary="function decorators" id="id4787"></a>decorator is coded on a line just before the <code>def</code> statement that defines a function or method, and it consists of the <code>@</code> symbol followed by a reference to a <em>metafunction</em>—a function (or other callable object) that manages another function. As of Python 3.9, the code after the <code>@</code> can be any <em>expression</em> returning a metafunction, but it’s usually a simple name.</p>
<p>In terms of code, function decorators <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="function decorators" data-tertiary="syntax" id="id4788"></a><a contenteditable="false" data-type="indexterm" data-primary="function decorators" data-secondary="syntax" id="id4789"></a><a contenteditable="false" data-type="indexterm" data-primary="syntax" data-secondary="function decorators" id="id4790"></a>automatically map the following syntax:</p>
<pre data-type="programlisting">@decorator              <code><em># Decorate function</em></code>
def F(arg):
    …

F(99)                   <code><em># Call function</em></code></pre>
<p>into this equivalent form, where <code>decorator</code> is a one-argument callable object that returns a callable object with the same number of arguments as <code>F</code>, if not <code>F</code> itself:</p>
<pre data-type="programlisting">def F(arg):
    …
F = decorator(F)        <code><em># Rebind function name to decorator result</em></code>

F(99)                   <code><em># Essentially calls decorator(F)(99)</em></code></pre>
<p>This automatic name rebinding works on any <code>def</code> statement, whether it’s for a simple <em>function</em> or a <em>method</em> within a class. When the function <code>F</code> is later called, it’s actually calling the object <em>returned</em> by the decorator, which may be either another object that implements required wrapping logic or the original function itself.</p>
<p>In other words, decoration essentially maps the first of the following into the second—though the decorator is really run only once, at decoration time:</p>
<pre data-type="programlisting">func(6, 7)
decorator(func)(6, 7)</pre>
<p>This automatic name rebinding accounts for the static-method and property decoration syntax we met earlier in the book:</p>
<pre data-type="programlisting">class C:
    @staticmethod
    def meth(…): …            <code><em># meth = staticmethod(meth)</em></code>

class C:
    @property
    def name(self): …         <code><em># name = property(name)</em></code></pre>
<p>In both cases, the method name is rebound to the result of a built-in function decorator at the end of the <code>def</code> statement. Calling the original name later invokes whatever object the decorator returns. In these specific cases, the original names are rebound to a static-method router and property descriptor, but the process is much more general than this—as the next section explains.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Implementation"><div class="sect3" id="implementation-id00065">
<h3>Implementation</h3>
<p>A decorator itself is a <em>callable that returns a callable</em>. That is, it returns the object to be called <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="callables returning callables" id="id4791"></a><a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="implementation" id="dcrtplmn"></a>later when the decorated function is invoked through its original name—either a wrapper object to intercept later calls or the original function augmented in some way. In fact, decorators can <em>be</em> any type of callable and <em>return</em> any type of callable: any combination of functions and classes may be used, though some are better suited to certain contexts.</p>
<p>For example, to tap into the decoration protocol in order to manage a function just after it is created, we might code a decorator of this form:</p>
<pre data-type="programlisting">def decorator(F):
   <code> <em># Process function F here</em></code>
    return F

@decorator
def func(): …                 <code><em># func = decorator(func)</em></code></pre>
<p>Because the original decorated function is assigned back to its name, this simply adds a post-creation step to function definition. Such a structure might be used to register a function to an API, initialize function attributes, and so on.</p>
<p>In more typical use, to insert logic that intercepts later calls to a function, we might code a decorator to return a different object than the original function—a <em>proxy</em> for later calls:</p>
<pre data-type="programlisting">def decorator(F):
<code> <em>   # Save or use function F
    # Return a different callable: nested def, class instance with __call__, etc.

</em></code>@decorator
def func(): …                 <code><em># func = decorator(func)</em></code></pre>
<p>This decorator is invoked at decoration time, and the callable it returns is invoked when the original function name is later called. The decorator itself receives the decorated function; the callable returned receives whatever arguments are later passed to the decorated function’s name. When coded properly, this works the same for class-level <em>methods</em>: the implied instance object simply shows up in the first argument of the returned callable.</p>
<p>In skeleton terms, here’s one common coding pattern that captures this idea—the decorator returns a wrapper that retains the original function in an enclosing scope:</p>
<pre data-type="programlisting">def decorator(F):                     <code><em># On @ decoration</em></code>
    def wrapper(*args):               <code><em># On wrapped function call</em></code>
        <code><em># Use F and args
</em></code>        <code><em># F(*args) calls original function
</em></code>    return wrapper

@decorator                            <code><em># func = decorator(func)</em></code>
def func(x, y):                       <code><em># func is passed to decorator's F</em></code>
    …

func(6, 7)                            <code><em># 6, 7 are passed to wrapper's *args</em></code></pre>
<p>When the name <code>func</code> is later called, it really invokes the <code>wrapper</code> function returned by <code>decorator</code>; the <code>wrapper</code> function can then <a contenteditable="false" data-type="indexterm" data-primary="scopes" data-secondary="enclosing" id="id4792"></a><a contenteditable="false" data-type="indexterm" data-primary="enclosing scopes" id="id4793"></a>run the original <code>func</code> because it is still available in an <em>enclosing scope</em>. When coded this way, each decorated function produces a new scope to retain state.</p>
<p>To do the same with <em>classes</em>, we can overload the call operation and use instance attributes instead of enclosing scopes:</p>
<pre data-type="programlisting">class decorator:
    def __init__(self, func):         <code><em># On @ decoration</em></code>
        self.func = func
    def __call__(self, *args):        <code><em># On wrapped function call</em></code>
        <code><em># Use self.func and args
        # self.func(*args) calls original function</em></code>

@decorator
def func(x, y):                       <code><em># func = decorator(func)</em></code>
    …                                 <code><em># func is passed to __init__</em></code>

func(6, 7)                            <code><em># 6, 7 are passed to __call__'s *args</em></code></pre>
<p>When the name <code>func</code> is later called now, it really invokes the <code>__call__</code> operator-overloading method of the instance created by <code>decorator</code>; the <code>__call__</code> method can then run the original <code>func</code> because it is still available in an <em>instance attribute</em>. When coded this way, each <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="implementation" data-startref="dcrtplmn" id="id4794"></a>decorated function produces a new instance to retain state.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Supporting method decoration"><div class="sect3" id="supporting_method_decoration">
<h3>Supporting method decoration</h3>
<p>One subtle point about the prior class-based coding <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="methods" id="id4795"></a><a contenteditable="false" data-type="indexterm" data-primary="methods" data-secondary="decorators" id="id4796"></a>is that while it works to intercept simple <em>function</em> calls, it does not quite work when applied to class-level <em>method</em> functions:</p>
<pre data-type="programlisting">class decorator:
    def __init__(self, func):           <code><em># func is method without instance</em></code>
        self.func = func
    def __call__(self, *args):          <code><em># self is decorator instance</em></code>
        <code><em># self.func(*args) fails!       # C instance not in args!</em></code>

class C:
    @decorator
    def method(self, x, y):             <code><em># method = decorator(method)</em></code>
        …                               <code><em># Rebound to decorator instance</em></code></pre>
<p>When coded this way, the decorated method is rebound to an <em>instance</em> of the decorator class instead of a simple function.</p>
<p>The problem with this is that the <code>self</code> in the decorator’s <code>__call__</code> receives the <code>decorator</code> class instance when the method is later run, and the instance of class <code>C</code> is never included in <code>*args</code>. This makes it impossible to dispatch the call to the original method—the decorator object retains the original method function, but it has no instance to pass to it.</p>
<p>To support <em>both</em> functions and methods, the nested function alternative works better:</p>
<pre data-type="programlisting">def decorator(F):                       <code><em># F is func or method without instance
</em></code>    def wrapper(*args):                 <code><em># class instance in args[0] for method</em></code>
        <code><em># F(*args) runs func or method</em></code>
    return wrapper

@decorator
def func(x, y):                         <code><em># func = decorator(func)</em></code>
    …
func(6, 7)                              <code><em># Really calls wrapper(6, 7)</em></code>

class C:
    @decorator
    def method(self, x, y):             <code><em># method = decorator(method)</em></code>
        …                               <code><em># Rebound to simple function
</em></code>
X = C()
X.method(6, 7)                          <code><em># Really calls wrapper(X, 6, 7)</em></code></pre>
<p>When coded this way, <code>wrapper</code> receives the <code>C</code> class instance in its first argument, so it can dispatch to the original method and access state information.</p>
<p>Technically, this nested-function version works because Python creates a <em>bound method</em> object and thus passes the subject class instance to the <code>self</code> argument only when a method attribute references a simple function; when it references an instance of a callable class instead, the callable class’s instance is passed to <code>self</code> to give the callable class access to its own state information. You’ll see how this subtle difference can matter in more realistic examples later in this chapter.</p>
<p>Also note that nested functions are perhaps the most straightforward way to support decoration of both functions and methods, but not necessarily the only way. The prior chapter’s <em>descriptors</em>, for example, receive both the descriptor-class and subject-class instance when called. Though more complex, later in this chapter you’ll see how this tool can be leveraged in this context as well.</p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Class Decorator Basics"><div class="sect2" id="class_decorator_basics">
<h2>Class Decorator Basics</h2>
<p>Function decorators proved so useful <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="class decorators" id="id4797"></a><a contenteditable="false" data-type="indexterm" data-primary="class decorators" id="id4798"></a>that the model was extended to allow class decoration. They were initially resisted because of role overlap with the next chapter’s <em>metaclasses</em>; in the end, though, they were adopted because they provide a simpler way to achieve many of the same goals.</p>
<p>Class decorators are strongly related to function decorators; in fact, they use the same syntax and very similar coding patterns. Rather than wrapping individual functions or methods, though, class decorators are a way to manage classes or wrap up instance-creation calls with extra logic that manages or augments instances created from a class. In the latter role, they may manage full object <em>interfaces</em> instead of a single callable object.</p>
<section data-type="sect3" data-pdf-bookmark="Usage"><div class="sect3" id="usage-id000116">
<h3>Usage</h3>
<p>Syntactically, class decorators appear just before <code>class</code> statements, in the same way that function decorators appear just before <code>def</code> statements. In symbolic terms, for a <code>decorator</code> that must be a one-argument callable that returns a callable, the class decorator syntax:</p>
<pre data-type="programlisting">@decorator                 <code><em># Decorate class</em></code>
class C:
    …

x = C(99)                  <code><em># Make an instance</em></code></pre>
<p>is equivalent to the following—the class is automatically passed to the decorator function, and the decorator’s result is assigned back to the class name:</p>
<pre data-type="programlisting">class C:
    …
C = decorator(C)           <code><em># Rebind class name to decorator result</em></code>

x = C(99)                  <code><em># Essentially calls decorator(C)(99)</em></code></pre>
<p>The net effect is that calling the class name later to create an instance winds up triggering the callable returned by the decorator, which may or may not call the original class itself.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Implementation"><div class="sect3" id="implementation-id00099">
<h3>Implementation</h3>
<p>New class decorators are coded with <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="class decorators" data-tertiary="implementation" id="dccdcpl"></a><a contenteditable="false" data-type="indexterm" data-primary="class decorators" data-secondary="implementation" id="cldcplmn"></a>many of the same techniques used for function decorators, though some may involve <em>two levels</em> of augmentation—to manage both instance-construction calls as well as instance-interface access. Because a class decorator is also a <em>callable that returns a callable</em>, most combinations of functions and classes suffice.</p>
<p>However it’s coded, the decorator’s result is what runs when an instance is later created. For example, to simply manage a class just after it is created, return the original class itself:</p>
<pre data-type="programlisting">def decorator(C):
    <code><em># Process class C here</em></code>
    return C

@decorator
class C: …                                      <code><em># C = decorator(C)</em></code></pre>
<p class="pagebreak-after">To instead insert a wrapper layer that intercepts later instance-creation calls, return a different callable object:</p>
<pre data-type="programlisting">def decorator(C):
    <code><em># Save or use class C
    # Return a different callable: nested def, class instance with __call__, etc.</em></code>

@decorator
class C: …                                      <code><em># C = decorator(C)</em></code></pre>
<p>The callable returned by such a class decorator typically creates and returns a new instance of the original class, augmented in some way to manage its interface. For example, the following inserts an object that intercepts undefined attributes of a class instance:</p>
<pre data-type="programlisting">def decorator(cls):                             <code><em># On @ decoration</em></code>
    class Wrapper:
        def __init__(self, *args):              <code><em># On instance creation</em></code>
            self.wrapped = cls(*args)
        def __getattr__(self, name):            <code><em># On attribute fetch</em></code>
            return getattr(self.wrapped, name)
    return Wrapper

@decorator
class C:                             <code><em># C = decorator(C)
</em></code>    def __init__(self, x, y):        <code><em># Run by Wrapper.__init__</em></code>
        self.attr = 'hack'

x = C(6, 7)                          <code><em># Really calls Wrapper(6, 7)</em></code>
print(x.attr)                        <code><em># Runs Wrapper.__getattr__, prints "hack"</em></code></pre>
<p>In this example, the decorator rebinds the class name to another class, which retains the original class in an enclosing scope and creates and embeds an instance of the original class when it’s called. When an attribute is later fetched from the instance, it is intercepted by the wrapper’s <code>__getattr__</code> and delegated to the embedded instance of the original class. Moreover, each decorated class creates a new scope, which remembers the original class. We’ll flesh out this example into some more useful code later in this chapter.</p>
<p>Like function decorators, class decorators are commonly coded as either <em>closure</em> (a.k.a. “factory”) functions that create and return callables, classes that use <code>__init__</code> or <code>__call__</code> methods to intercept call operations, or some combination <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="class decorators" data-tertiary="implementation" data-startref="dccdcpl" id="id4799"></a><a contenteditable="false" data-type="indexterm" data-primary="class decorators" data-secondary="implementation" data-startref="cldcplmn" id="id4800"></a>thereof. Closure functions typically retain state in enclosing-scope references, and classes retain state in attributes.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Supporting multiple instances"><div class="sect3" id="supporting_multiple_instances">
<h3>Supporting multiple instances</h3>
<p>As for function decorators, some callable-type <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="class decorators" data-tertiary="instances, multiple" id="dccdmlp"></a><a contenteditable="false" data-type="indexterm" data-primary="class decorators" data-secondary="instances, multiple" id="cldcstmpl"></a><a contenteditable="false" data-type="indexterm" data-primary="instances" data-secondary="class decorators" id="istdct"></a>combinations work better for class decorators than others. Consider the following <em>invalid</em> alternative to the class decorator of the prior example:</p>
<pre data-type="programlisting">class Decorator:
    def __init__(self, C):                    <code><em># On @ decoration
</em></code>        self.C = C
    def __call__(self, *args):                <code><em># On instance creation</em></code>
        self.wrapped = self.C(*args)
        return self
    def __getattr__(self, attrname):          <code><em># On attribute fetch</em></code>
        return getattr(self.wrapped, attrname)

@Decorator
class C: …                                    <code><em># C = Decorator(C)</em></code>

x = C()
y = C()                                       <code><em># Overwrites x!</em></code></pre>
<p>This code handles multiple decorated classes (each makes a new <code>Decorator</code> instance) and will intercept instance-creation calls (each runs <code>__call__</code>). Unlike the prior version, however, this version fails to handle <em>multiple instances</em> of a given class—each instance-creation call overwrites the prior saved instance. The prior version does support multiple instances because each instance-creation call makes a new independent wrapper object. More generally, either of the following patterns supports multiple wrapped instances:</p>
<pre data-type="programlisting">def decorator(C):                             <code><em># On @ decoration
</em></code>    class Wrapper:
        def __init__(self, *args):            <code><em># On instance creation: new Wrapper</em></code>
            self.wrapped = C(*args)           <code><em># Embed instance in instance
</em></code>    return Wrapper

class Wrapper: …
def decorator(C):                             <code><em># On @ decoration</em></code>
    def onCall(*args):                        <code><em># On instance creation: new Wrapper
</em></code>        return Wrapper(C(*args))              <code><em># Embed instance in instance
</em></code>    return onCall</pre>
<p>We’ll study this phenomenon in a more realistic context later in the chapter too; in practice, though, we must be careful to combine callable types properly to support our intent and <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="class decorators" data-tertiary="instances, multiple" data-startref="dccdmlp" id="id4801"></a><a contenteditable="false" data-type="indexterm" data-primary="class decorators" data-secondary="instances, multiple" data-startref="cldcstmpl" id="id4802"></a><a contenteditable="false" data-type="indexterm" data-primary="instances" data-secondary="class decorators" data-startref="istdct" id="id4803"></a>choose state policies wisely.</p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Decorator Nesting"><div class="sect2" id="decorator_nesting-id00056">
<h2>Decorator Nesting</h2>
<p>Sometimes, one decorator isn’t enough. For <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="nesting" id="dcrtnts"></a><a contenteditable="false" data-type="indexterm" data-primary="nesting" data-secondary="decorators" id="nstdcrt"></a>instance, suppose you’ve coded <em>two</em> function decorators to be used during development—one to test argument types before function calls and another to test return value types after function calls. You can use either independently, but what to do if you want to employ both on a single function? What you really need is a way to <em>nest</em> the two, such that the result of one decorator is the function decorated by the other. It’s irrelevant which is nested, as long as both steps run on later calls.</p>
<p>To support multiple nested steps of augmentation this way, decorator syntax allows you to add multiple layers of wrapper logic to a decorated function or method. When this feature is used, each decorator must appear on a line of its own. Decorator syntax of this form:</p>
<pre data-type="programlisting">@A
@B
@C
def f(…):
    …</pre>
<p>runs the same as the following:</p>
<pre data-type="programlisting">def f(…):
    …
f = A(B(C(f)))</pre>
<p>Here, the original function is passed through three different decorators, and the resulting callable object is assigned back to the original name. Each decorator processes the result of the prior, which may be the original function or an inserted wrapper.</p>
<p>If all the decorators insert wrappers, the net effect <em>stacks</em> them: when the original function <a contenteditable="false" data-type="indexterm" data-primary="wrappers" data-secondary="stacking" id="id4804"></a>name is called, three different layers of wrapping object logic will be invoked to augment the original function in three different ways. The last decorator listed is the first applied and, thus, the most deeply nested when the original function name is later called.</p>
<p>Just as for functions, multiple class decorators result in multiple nested function calls and possibly multiple levels and steps of wrapper logic around instance-creation calls. For example, the following code:</p>
<pre data-type="programlisting">@hack
@code
class C:
    …

X = C()</pre>
<p>is equivalent to the following:</p>
<pre data-type="programlisting">class C:
    …
C = hack(code(C))

X = C()</pre>
<p>Again, each decorator is free to return either the original class or an inserted wrapper object. With wrappers, when an instance of the original <code>C</code> class is finally requested, the call is redirected to the wrapping layer objects provided by both the <code>hack</code> and <code>code</code> decorators, which may have arbitrarily different roles—they might trace and validate attribute access for example, and both steps would be run in turn on later requests.</p>
<p>For instance, the following do-nothing decorators simply return the decorated function:</p>
<pre data-type="programlisting">def d1(F): return F
def d2(F): return F
def d3(F): return F

@d1
@d2
@d3
def func():               <code><em># func = d1(d2(d3(func)))</em></code>
    print('hack')

func()                    <code><em># Prints "hack"</em></code></pre>
<p>The same syntax works on classes, as do these same do-nothing decorators.</p>
<p>When decorators insert <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="wrapper function objects" id="id4805"></a>wrapper function objects, though, they may augment the original function when called—the following concatenates to its result in the decorator layers, as it runs the layers from inner to outer:</p>
<pre data-type="programlisting">def d1(F): return lambda: 'X' + F()
def d2(F): return lambda: 'Y' + F()
def d3(F): return lambda: 'Z' + F()

@d1
@d2
@d3
def func():               <code><em># func = d1(d2(d3(func)))
</em></code>    return 'hack'

print(func())             <code><em># Prints "XYZhack"</em></code></pre>
<p>We use <code>lambda</code> functions to implement wrapper layers here (each retains the <a contenteditable="false" data-type="indexterm" data-primary="wrappers" data-secondary="layers" id="id4806"></a><a contenteditable="false" data-type="indexterm" data-primary="lambda functions" data-secondary="wrapper layers" id="id4807"></a>wrapped function <code>F</code> in an enclosing scope); in practice, wrappers can take the form of functions, callable classes, and more. When designed well, decorator <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="nesting" data-startref="dcrtnts" id="id4808"></a><a contenteditable="false" data-type="indexterm" data-primary="nesting" data-secondary="decorators" data-startref="nstdcrt" id="id4809"></a>nesting allows us to combine augmentation steps in a wide variety of ways.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Decorator Arguments"><div class="sect2" id="decorator_arguments-id00055">
<h2>Decorator Arguments</h2>
<p>Both function and class decorators can also seem to take <em>arguments</em>. Really, though, the role of <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="arguments" id="id4810"></a><a contenteditable="false" data-type="indexterm" data-primary="arguments" data-secondary="decorators" id="id4811"></a>these arguments is simpler than it may seem: decorator arguments are passed to a callable that <em>returns</em> the decorator—which in turn returns a callable. By nature, this usually sets up multiple levels of state retention. The following, for instance:</p>
<pre data-type="programlisting">@decorator(A, B)
def F(arg):
    …

F(99)</pre>
<p>is automatically mapped into this equivalent form, where <code>decorator</code> is a callable that <em>returns</em> the actual decorator. The returned decorator in turn returns the callable run later for calls to the original function name:</p>
<pre data-type="programlisting">def F(arg):
    …
F = decorator(A, B)(F)    <code><em># Rebind F to result of decorator's return value</em></code>

F(99)                     <code><em># Essentially calls decorator(A, B)(F)(99)</em></code></pre>
<p>Decorator arguments are resolved <em>before</em> decoration ever occurs, and they are usually used to retain state information for use in later calls. The decorator function in this example, for instance, might take a form like the following:</p>
<pre data-type="programlisting">def decorator(A, B):
    <code><em># Save or use A, B</em></code>
    def actualDecorator(F):
        <code><em># Save or use function F
        # Return a callable: nested def, class instance with __call__, etc.</em></code>
        return callable
    return actualDecorator</pre>
<p>The outer function in this structure generally saves the decorator arguments away as state information for use in the actual decorator, the callable it returns, or both. This code snippet retains the state information argument in enclosing function scope references, but class attributes would work as well.</p>
<p>In other words, decorator <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="arguments" data-tertiary="callables" id="id4812"></a><a contenteditable="false" data-type="indexterm" data-primary="arguments" data-secondary="decorators" data-tertiary="callables" id="id4813"></a>arguments often imply <em>three levels of callables</em>: a callable to accept decorator arguments, which returns a callable to serve as decorator, which returns a callable to handle calls to the original function or class. Each of the three levels may be a function or class and may retain state in the form of scopes or class attributes.</p>
<p>Decorator arguments can be used to provide attribute initialization values, call-trace message labels, attribute names to be validated, and much more—any sort of configuration <em>parameter</em> for objects or their proxies is a candidate. We’ll code concrete examples of decorator arguments later in this chapter.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Decorators Manage Functions and Classes, Too"><div class="sect2" id="decorators_manage_functions_and_classes">
<h2>Decorators Manage Functions and Classes, Too</h2>
<p>To wrap up, although much of <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="function management" id="id4814"></a><a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="class management" id="id4815"></a>the rest of this chapter focuses on wrapping later calls to functions and classes, it’s important to remember that the decorator mechanism is more general than this—it is simply a protocol for passing functions and classes through any callable immediately after they are created. As such, it can also be used to invoke arbitrary post-creation processing:</p>
<pre class="pagebreak-before" data-type="programlisting">def decorator(O):
    <code><em># Augment function or class O
</em></code>    return O

@decorator
def F(): …                 <code><em># F = decorator(F)</em></code>

@decorator
class C: …                 <code><em># C = decorator(C)</em></code></pre>
<p>If we return the original decorated object this way instead of a proxy, we can manage functions and classes <em>themselves</em> rather than later calls to them. Such decorators might be used to register callable objects to an API, initialize attributes in functions or classes when they are created, and so on. Decorator roles are limited only by your imagination.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Coding Function Decorators"><div class="sect1" id="coding_function_decorators">
<h1>Coding Function Decorators</h1>
<p>On to the code. In the rest of this chapter, we are going to study working examples that demonstrate the decorator concepts we just surveyed. This section presents a handful of function decorators in complete form, and the next shows tangible class decorators in action. Following that, we’ll close out with two larger case studies that showcase typical decorator roles and code full-scale implementations of class privacy and argument range tests.</p>
<section data-type="sect2" data-pdf-bookmark="Tracing Function Calls"><div class="sect2" id="tracing_function_calls">
<h2>Tracing Function Calls</h2>
<p>To get started, let’s revive the call <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="call tracers" id="decracer"></a><a contenteditable="false" data-type="indexterm" data-primary="function calls" data-secondary="tracing, decorators" id="fccltrcc"></a>tracer example we met in <a data-type="xref" href="ch32.html#class_odds_and_ends">Chapter 32</a>. <a data-type="xref" href="#example_threenine_onedot_decoratoronedo">Example 39-1</a> defines and applies a function decorator that counts the number of calls made to the decorated function and prints a trace message for each call.</p>
<div data-type="example" id="example_threenine_onedot_decoratoronedo">
<h5><span class="label">Example 39-1. </span>decorator1.py</h5>
<pre data-type="programlisting">class tracer:
    def __init__(self, func):         <code><em># On @ decoration: save original func</em></code>
        self.calls = 0
        self.func = func
    def __call__(self, *args):        <code><em># On later calls: run original func</em></code>
        self.calls += 1
        print(f'call {self.calls} to {self.func.__name__}')
        self.func(*args)

@tracer
def hack(a, b, c):           <code><em># hack = tracer(hack)</em></code>
    print(a + b + c)         <code><em># Wraps hack in a decorator object</em></code></pre>
</div>
<p>Notice how each function decorated with this class will create a new instance with its own saved function object and calls counter. Also, observe how the <code>*args</code> argument syntax is used to pack and unpack arbitrarily many passed-in arguments. This generality enables this decorator to be used to wrap any function with any number of positional arguments; this version doesn’t yet work on keyword arguments or class-level methods and doesn’t return results, but we’ll fix these shortcomings later in this section.</p>
<p class="pagebreak-before">Now, if we import this module’s function and test it interactively in a REPL, we get the following sort of behavior—each call generates a trace message initially because the decorator class intercepts it:</p>
<pre data-type="programlisting">$ <code><strong>python3</strong></code>
&gt;&gt;&gt; <code><strong>from decorator1 import hack

</strong></code>&gt;&gt;&gt; <code><strong>hack(1, 2, 3)</strong></code>            <code><em># Really calls the tracer wrapper object</em></code>
call 1 to hack
6

&gt;&gt;&gt; <code><strong>hack('a', 'b', 'c')</strong></code>      <code><em># Invokes __call__ in class</em></code>
call 2 to hack
abc

&gt;&gt;&gt; <code><strong>hack.calls</strong></code>               <code><em># Number calls in wrapper state information</em></code>
2
&gt;&gt;&gt; <code><strong>hack</strong></code>
&lt;decorator1.tracer object at 0x10cafc680&gt;</pre>
<p>When run, the <code>tracer</code> class saves away the decorated function and intercepts later calls to it in order to add a layer of logic that counts and prints each call. Notice how the total number of calls shows up as an attribute of the decorated function—<code>hack</code> is really an instance of the <code>tracer</code> class when decorated, a finding that may have ramifications for programs that do type checking, but is generally benign.</p>
<p>For function calls, the <code>@</code> decoration syntax can be more convenient than modifying each call to account for the extra logic level, and it avoids accidentally calling the original function directly. Consider a <em>nondecorator</em> equivalent such as the following:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>calls = 0</strong></code>
&gt;&gt;&gt; <code><strong>def tracer(func, *args):</strong></code>
<code> <strong>       global calls</strong></code>
<code> <strong>       calls += 1</strong></code>
<code> <strong>       print(f'call {calls} to {func.__name__}')</strong></code>
<code> <strong>       func(*args)</strong></code>
 
&gt;&gt;&gt; <code><strong>def hack(a, b, c):</strong>  </code>     <code><em># Nondecorated function</em></code>
<code> <strong>       print(a, b, c)</strong></code>
 
&gt;&gt;&gt; <code><strong>hack(1, 2, 3)</strong></code>            <code><em># Normal nontraced call: accidental?</em></code>
1 2 3
&gt;&gt;&gt; 
&gt;&gt;&gt; <code><strong>tracer(hack, 1, 2, 3)</strong></code>    <code><em># Special traced call without decorators</em></code>
call 1 to hack
1 2 3</pre>
<p>This alternative can be used on any function without the special <code>@</code> syntax, but unlike the decorator version, it requires extra syntax at every place where the function is <em>called</em> in your code. Furthermore, its intent may not be as obvious, and it does not ensure that the extra layer will be invoked for normal calls. Although decorators are never <em>required</em> (we can always rebind names manually), they are <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="call tracers" data-startref="decracer" id="id4816"></a><a contenteditable="false" data-type="indexterm" data-primary="function calls" data-secondary="tracing, decorators" data-startref="fccltrcc" id="id4817"></a>often the most convenient and uniform augmentation option.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Decorator State Retention Options"><div class="sect2" id="decorator_state_retention_options">
<h2>Decorator State Retention Options</h2>
<p>The preceding example raises an important point. Decorators have a variety of options for retaining state information provided at decoration time to be used during later calls to decorated objects. They generally need to support multiple decorated objects and multiple later calls, but there are several ways to implement these goals: instance attributes, global variables, nonlocal closure variables, and function attributes can all be used for retaining state.</p>
<p>This topic parallels the initial state coverage in <a data-type="xref" href="ch17.html#scopes">Chapter 17</a> but can be fleshed out here with class details, and it is so endemic to decorators that it qualifies as a prerequisite. This topic also applies to both function and class decorators, but let’s explore it in the narrower function-decorator realm.</p>
<section data-type="sect3" data-pdf-bookmark="State with class-instance attributes"><div class="sect3" id="state_with_class_instance_attributes">
<h3>State with class-instance attributes</h3>
<p>As an opening act in the state-retention show, <a data-type="xref" href="#example_threenine_twodot_decorator_stat">Example 39-2</a> codes an augmented version of <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="state retention" data-tertiary="class-instance attributes" id="id4818"></a><a contenteditable="false" data-type="indexterm" data-primary="state" data-secondary="retaining" data-tetiary="decorators" id="strtdcrt"></a><a contenteditable="false" data-type="indexterm" data-primary="instances" data-secondary="state, decorators and" id="id4819"></a>the prior example, which adds support for <em>keyword</em> arguments with <code>**</code> syntax and <em>returns</em> the wrapped function’s result to support more use cases (for nonlinear readers, we first studied keyword arguments in <span class="keep-together"><a data-type="xref" href="ch18.html#arguments">Chapter 18</a>)</span>.</p>
<div data-type="example" id="example_threenine_twodot_decorator_stat">
<h5><span class="label">Example 39-2. </span>decorator_state_classes.py</h5>
<pre data-type="programlisting">class tracer:                                <code><em># State via instance attributes</em></code>
    def __init__(self, func):                <code><em># On @ decorator</em></code>
        self.calls = 0                       <code><em># Save func for later call</em></code>
        self.func  = func
    def __call__(self, *args, **kwargs):     <code><em># On call to original function</em></code>
        self.calls += 1
        print(f'call {self.calls} to {self.func.__name__}')
        return self.func(*args, **kwargs)

@tracer
def hack(a, b, c):           <code><em># Same as: hack = tracer(hack)
</em></code>    print(a + b + c)         <code><em># Triggers tracer.__init__</em></code>

@tracer
def code(x, y):              <code><em># Same as: code = tracer(code)</em></code>
    print(x ** y)            <code><em># Wraps code in a tracer object</em></code>

if __name__ == '__main__':
    hack(1, 2, 3)            <code><em># Really calls tracer instance: runs tracer.__call__</em></code>
    hack(a=4, b=5, c=6)      <code><em># hack is an instance attribute</em></code>

    code(4, 2)               <code><em># Really calls tracer instance: self.func is code</em></code>
    code(2, y=16)            <code><em># self.calls is per-decoration here</em></code></pre>
</div>
<p>Like the original, this <a contenteditable="false" data-type="indexterm" data-primary="classes" data-secondary="instances" data-tertiary="attributes" id="id4820"></a>uses <em>class instance attributes</em> to save state explicitly. Both the wrapped function and the calls counter are <em>per-instance</em> information—each decoration gets its own copy. When run as a script, the output of this version is as follows; notice how the <code>hack</code> and <code>code</code> functions each have their own calls counter because each decoration creates a new class instance:</p>
<pre data-type="programlisting">$ <code><strong>python3 decorator_state_classes.py</strong></code>
call 1 to hack
6
call 2 to hack
15
call 1 to code
16
call 2 to code
65536</pre>
<p>While useful for decorating functions, this coding scheme still has issues when applied to <em>methods</em>—a shortcoming we’ll address in a later revision.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="State with global variables"><div class="sect3" id="state_with_global_variables">
<h3>State with global variables</h3>
<p>For simpler tasks that don’t require per-function data, moving <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="state retention" data-tertiary="global variables and" id="id4821"></a><a contenteditable="false" data-type="indexterm" data-primary="global variables" data-secondary="state, decorators and" id="id4822"></a><a contenteditable="false" data-type="indexterm" data-primary="variables" data-secondary="global" data-tertiary="state, decorators and" id="id4823"></a>state variables out to the <em>global scope</em>, as illustrated by <a data-type="xref" href="#example_threenine_threedot_decorator_st">Example 39-3</a>, might suffice. This code still uses an enclosing-scope reference for the original decorated function but pushes the call counter out to the enclosing module.</p>
<div data-type="example" id="example_threenine_threedot_decorator_st">
<h5><span class="label">Example 39-3. </span>decorator_state_globals.py</h5>
<pre data-type="programlisting">calls = 0
def tracer(func):                         <code><em># State via enclosing scope and global</em></code>
    def wrapper(*args, **kwargs):         <code><em># Instead of class attributes</em></code>
        global calls                      <code><em># calls is global, not per-function</em></code>
        calls += 1
        print(f'call {calls} to {func.__name__}')
        return func(*args, **kwargs)
    return wrapper

@tracer
def hack(a, b, c):           <code><em># Same as: hack = tracer(hack)</em></code>
    print(a + b + c)

@tracer
def code(x, y):              <code><em># Same as: code = tracer(code)</em></code>
    print(x ** y)

if __name__ == '__main__':
    hack(1, 2, 3)            <code><em># Really calls wrapper, assigned to hack</em></code>
    hack(a=4, b=5, c=6)      <code><em># wrapper calls hack</em></code>

    code(4, 2)               <code><em># Really calls wrapper, assigned to code</em></code>
    code(2, y=16)            <code><em># Global calls is not per-decoration here!</em></code></pre>
</div>
<p>Unfortunately, moving the counter out to the common global scope to allow it to be changed like this also means that it will be <em>shared</em> by every wrapped function. Unlike class instance attributes, global counters are cross-program, not per-function—the counter is incremented for <em>any</em> traced function call. You can tell the difference if you compare this version’s output with the prior version’s—the single, shared global call counter is incorrectly updated by calls to every decorated function:</p>
<pre data-type="programlisting">$ <code><strong>python3 decorator_state_globals.py</strong></code>
call 1 to hack
6
call 2 to hack
15
call 3 to code
16
call 4 to code
65536</pre>
</div></section>
<section data-type="sect3" data-pdf-bookmark="State with enclosing-scope nonlocals"><div class="sect3" id="state_with_enclosing_scope_nonlocals">
<h3>State with enclosing-scope nonlocals</h3>
<p>Shared global state may be what we <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="state retention" data-tertiary="enclosing-scope nonlocals" id="dctecsll"></a>want in some cases. If we really want a <em>per-function</em> counter, though, we can either use classes as before or make use of <em>closure</em> functions and the <code>nonlocal</code> statement described in <a data-type="xref" href="ch17.html#scopes">Chapter 17</a>. Because this statement allows enclosing function scope variables to be <em>changed</em>, they can serve as per-decoration, changeable data. <a data-type="xref" href="#example_threenine_fourdot_decorator_sta">Example 39-4</a> demos the basics of this scheme.</p>
<div data-type="example" id="example_threenine_fourdot_decorator_sta">
<h5><span class="label">Example 39-4. </span>decorator_state_nonlocals.py</h5>
<pre data-type="programlisting">def tracer(func):                        <code><em># State via enclosing scope and nonlocal</em></code>
    calls = 0                            <code><em># Instead of class attrs or global</em></code>
    def wrapper(*args, **kwargs):        <code><em># calls is per-function, not global</em></code>
        nonlocal calls
        calls += 1
        print(f'call {calls} to {func.__name__}')
        return func(*args, **kwargs)
    return wrapper

@tracer
def hack(a, b, c):           <code><em># Same as: hack = tracer(hack)</em></code>
    print(a + b + c)

@tracer
def code(x, y):              <code><em># Same as: code = tracer(code)</em></code>
    print(x ** y)

if __name__ == '__main__':
    hack(1, 2, 3)            <code><em># Really calls wrapper, bound to hack</em></code>
    hack(a=4, b=5, c=6)      <code><em># wrapper calls hack</em></code>

    code(4, 2)               <code><em># Really calls wrapper, bound to code</em></code>
    code(2, y=16)            <code><em># Nonlocal calls _is_ per-decoration here</em></code></pre>
</div>
<p>Now, because enclosing-scope variables <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="state retention" data-tertiary="enclosing-scope nonlocals" data-startref="dctecsll" id="id4824"></a>are not cross-program globals, each wrapped function gets its own counter again, just as for classes and attributes. Here’s the new output:</p>
<pre data-type="programlisting">$ <code><strong>python3 decorator_state_nonlocals.py</strong></code>
call 1 to hack
6
call 2 to hack
15
call 1 to code
16
call 2 to code
65536</pre>
</div></section>
<section data-type="sect3" data-pdf-bookmark="State with function attributes"><div class="sect3" id="state_with_function_attributes">
<h3>State with function attributes</h3>
<p>Finally, you can also avoid globals and <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="state retention" data-tertiary="function attributes" id="dctefattb"></a><a contenteditable="false" data-type="indexterm" data-primary="functions" data-secondary="attributes" data-tertiary="state" id="fcttstt"></a>classes by making use of <em>function attributes</em> for some changeable state instead of <code>nonlocal</code>. As we saw in Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch17.html#scopes">17</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch19.html#function_odds_and_ends">19</a>, we can attach arbitrary attributes to functions by assignment, with <code><em>func</em>.<em>attr</em>=<em>value</em></code>. Because a factory function makes a new function on each call, its attributes become per-call state. Moreover, you need to use this technique only for state variables that must <em>change</em>; enclosing-scope references are still retained and work normally.</p>
<p>To demo, <a data-type="xref" href="#example_threenine_fivedot_decorator_sta">Example 39-5</a> simply uses <code>wrapper.calls</code> for state. It works the same as the preceding <span class="keep-together"><code>nonlocal</code></span> version because the counter is again per-decorated-function.</p>
<div data-type="example" id="example_threenine_fivedot_decorator_sta">
<h5><span class="label">Example 39-5. </span>decorator_state_attributes.py</h5>
<pre data-type="programlisting">def tracer(func):                        <code><em># State via enclosing scope and func attr</em></code>
    def wrapper(*args, **kwargs):        <code><em># calls is per-function, not global
</em></code>        wrapper.calls += 1
        print(f'call {wrapper.calls} to {func.__name__}')
        return func(*args, **kwargs)
    wrapper.calls = 0
    return wrapper

@tracer
def hack(a, b, c):           <code><em># Same as: hack = tracer(hack)</em></code>
    print(a + b + c)

@tracer
def code(x, y):              <code><em># Same as: code = tracer(code)</em></code>
    print(x ** y)

if __name__ == '__main__':
    hack(1, 2, 3)            <code><em># Really calls wrapper, assigned to hack</em></code>
    hack(a=4, b=5, c=6)      <code><em># wrapper calls hack</em></code>

    code(4, 2)               <code><em># Really calls wrapper, assigned to code</em></code>
    code(2, y=16)            <code><em># wrapper.calls _is_ per-decoration here</em></code></pre>
</div>
<p>As we learned in <a data-type="xref" href="ch17.html#scopes">Chapter 17</a>, this works only because the name <code>wrapper</code> is retained in the enclosing <code>tracer</code> function’s scope. When we later increment <code>wrapper.calls</code>, we are not changing the name <span class="keep-together"><code>wrapper</code></span> itself, so no <code>nonlocal</code> declaration is required:</p>
<pre data-type="programlisting">$ <code><strong>python3 decorator_state_attributes.py</strong></code>
…<code><em>same output as prior version</em></code>…</pre>
<p>This scheme was almost relegated to a footnote because it may be more obscure than <code>nonlocal</code> and might be better saved for cases where other schemes don’t help. However, function attributes also have a substantial advantage: like class instances, they allow access to the saved state from <em>outside</em> the decorator’s code; nonlocals can only be seen inside the nested function itself, but function attributes have wider visibility.</p>
<p>We will employ function attributes again in an answer to one of the end-of-chapter questions, where their visibility outside callables becomes an asset. As changeable state associated with a context of use, though, they are equivalent to enclosing-scope nonlocals. As usual, choosing from multiple tools is an inherent part of the programming task.</p>
<p>Because decorators often imply multiple levels of callables, you can combine functions with enclosing scopes, classes with attributes, and function attributes to achieve a variety of coding structures. As you’ll see later, though, this sometimes may be subtler than you expect—each decorated function should have its own state, and each decorated class may require state both for itself and for each generated instance.</p>
<p>In fact, as the next section will explain in more detail, if we want to apply function decorators to class-level methods, too, we also have to be careful about the distinction Python makes between decorators based on callable class instance objects and <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="state retention" data-tertiary="function attributes" data-startref="dctefattb" id="id4825"></a><a contenteditable="false" data-type="indexterm" data-primary="state" data-secondary="retaining" data-tertiary="decorators" data-startref="strtdcrt" id="id4826"></a><a contenteditable="false" data-type="indexterm" data-primary="functions" data-secondary="attributes" data-tertiary="state" data-startref="fcttstt" id="id4827"></a>decorators based on nested functions.</p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Class Pitfall: Decorating Methods"><div class="sect2" id="class_pitfall_decorating_methods">
<h2>Class Pitfall: Decorating Methods</h2>
<p>When the preceding section’s class-based <code>tracer</code> function decorator, <a data-type="xref" href="#example_threenine_twodot_decorator_stat">Example 39-2</a>, was initially coded, it was assumed that it could also be <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="methods" id="id4828"></a><a contenteditable="false" data-type="indexterm" data-primary="methods" data-secondary="decorators" id="id4829"></a>applied to any <em>method</em>—decorated methods should work the same, but the automatic <code>self</code> instance argument would simply be included at the front of <code>*args</code>. The only real downside to this assumption is that it is <em>completely wrong</em>, though the reasons for the failure are far from obvious.</p>
<p>In short, when applied to a class’s method, this version of the <code>tracer</code> fails because <code>self</code> is the instance of the decorator class and the instance of the decorated subject class is not included in <code>*args</code> at all. Here’s a relisting of the class in question to avoid page flipping:</p>
<pre data-type="programlisting">class tracer:                                <code><em># State via instance attributes</em></code>
    def __init__(self, func):                <code><em># On @ decorator
</em></code>        self.calls = 0                       <code><em># Save func for later call</em></code>
        self.func  = func
    def __call__(self, *args, **kwargs):     <code><em># On call to original function
</em></code>        self.calls += 1
        print(f'call {self.calls} to {self.func.__name__}')
        return self.func(*args, **kwargs)</pre>
<p>This phenomenon was introduced abstractly earlier in this chapter, but now we can see it in the context of working code. <a data-type="xref" href="#example_threenine_twodot_decorator_stat">Example 39-2</a>’s class-based decorator works as advertised earlier for plain functions (copy/pasters: don’t copy the initial “...” REPL prompts included in this chapter to preserve indentation after decorator lines):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>from decorator_state_classes import tracer</strong></code>
&gt;&gt;&gt; <code><strong>@tracer</strong></code>
... <code><strong>def hack(a, b, c):</strong></code>                       <code><em># hack = tracer(hack</em></code>)
        <code><strong>print(a + b + c)</strong></code>                     <code><em># Triggers tracer.__init__</em></code>
 
&gt;&gt;&gt; <code><strong>hack(1, 2, 3)</strong></code>                            <code><em># Runs tracer.__call__</em></code>
call 1 to hack
6
&gt;&gt;&gt; <code><strong>hack(a=4, b=5, c=6)</strong>  </code>                    <code><em># hack saved in an instance attribute</em></code>
call 2 to hack
15</pre>
<p>However, decoration of class-level methods fails (more lucid sequential readers might recognize this as an adaptation of our <code>Person</code> class resurrected from the object-oriented tutorial in <a data-type="xref" href="ch28.html#a_more_realistic_example">Chapter 28</a>):</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>class Person:</strong></code>
        <code><strong>def __init__(self, name, pay):</strong></code>
            <code><strong>self.name = name</strong></code>
            <code><strong>self.pay  = pay</strong></code>
        <code><strong>@tracer</strong></code>
        <code><strong>def giveRaise(self, percent):</strong></code>        <code><em># giveRaise = tracer(giveRaise)</em></code>
            <code><strong>self.pay *= (1.0 + percent)</strong></code>
 
&gt;&gt;&gt; <code><strong>pat = Person('Pat Jones', 50_000)</strong></code>        <code><em># tracer remembers method funcs</em></code>
&gt;&gt;&gt; <code><strong>pat.giveRaise(.10)</strong></code>                       <code><em># Runs tracer.__call__(???, .10)</em></code>
call 1 to giveRaise
TypeError: Person.giveRaise() missing 1 required positional argument: 'percent'</pre>
<p>The root of the problem here is in the <code>self</code> argument of the tracer class’s <code>__call__</code> method—is it a <code>tracer</code> instance or a <code>Person</code> instance? We ultimately need <em>both</em> as it’s coded: the <code>tracer</code> for decorator state, and the <code>Person</code> for routing on to the original method. Really, <code>self</code> <em>must</em> be the <code>tracer</code> object to provide access to <code>tracer</code>’s state information (its <code>calls</code> and <code>func</code>); this is true whether decorating a simple function or a method.</p>
<p>Unfortunately, when our decorated method name is rebound to a class instance object with a <code>__call__</code>, Python passes only the <code>tracer</code> instance to <code>self</code>; it doesn’t pass along the <code>Person</code> subject in the arguments list at all. Moreover, because the <code>tracer</code> knows nothing about the <code>Person</code> instance we are trying to process with method calls, there’s no way to create a bound method with an instance, and thus, no way to correctly dispatch the call. This isn’t a bug, but it’s wildly subtle.</p>
<p>In the end, the prior listing winds up passing too few arguments to the decorated method, and results in an error. Add a line to the decorator’s <code>__call__</code> to print all its arguments to verify this—as you can see, <code>self</code> is the <code>tracer</code> instance, and the <code>Person</code> instance is entirely absent:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>pat.giveRaise(.10)</strong></code>
&lt;__main__.tracer object at 0x108a02c00&gt; (0.10,) {}</pre>
<p>As mentioned earlier, this happens because Python passes the implied subject instance to <code>self</code> when a method name is bound to a simple function only; when it is an instance of a callable class, that class’s instance is passed instead. That is, Python makes a <em>bound method</em> object containing the subject instance <em>only</em> when the method is a simple function, not when it is a callable instance of another class.</p>
<section data-type="sect3" data-pdf-bookmark="Using nested functions to decorate methods"><div class="sect3" id="using_nested_functions_to_decorate_meth">
<h3>Using nested functions to decorate methods</h3>
<p>If you want your function <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="methods" data-tertiary="nested functions" id="id4830"></a><a contenteditable="false" data-type="indexterm" data-primary="methods" data-secondary="decorators" data-tertiary="nested functions" id="id4831"></a><a contenteditable="false" data-type="indexterm" data-primary="nesting" data-secondary="functions, decorating methods" id="id4832"></a><a contenteditable="false" data-type="indexterm" data-primary="functions" data-secondary="nested, decorating methods" id="id4833"></a>decorators to work on <em>both</em> simple functions and class-level methods, the most straightforward solution lies in using one of the other state retention solutions described earlier—code your function decorator as <em>nested</em> <code>def</code> statements so that you don’t depend on a single <code>self</code> instance argument to be both the wrapper class instance and the subject class instance.</p>
<p>In fact, we already <em>have</em>—both Examples <a data-type="xref" data-xrefstyle="select:labelnumber" href="#example_threenine_fourdot_decorator_sta">39-4</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="#example_threenine_fivedot_decorator_sta">39-5</a> work for both functions and class methods by using nested functions along with <code>nonlocal</code> variables or function attributes:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>from decorator_state_nonlocals import tracer</strong>  </code>     <code><em># See Example 39-4</em></code>

&gt;&gt;&gt; <code><strong>@tracer</strong></code>
... <code><strong>def hack(a, b, c):      </strong>  </code>                         <code><em># Works for functions</em></code>
        <code><strong>print(a + b + c)</strong></code>
 
&gt;&gt;&gt; <code><strong>hack(1, 2, 3)</strong></code>
call 1 to hack
6

&gt;&gt;&gt; <code><strong>class Person:           </strong>  </code>                         <code><em># AND works for methods</em></code>
<code> <strong>       def __init__(self, name, pay):</strong></code>
<code> <strong>           self.name = name</strong></code>
<code> <strong>           self.pay  = pay</strong></code>
<code> <strong>       @tracer</strong></code>
<code> <strong>       def giveRaise(self, percent):</strong>   </code>               <code><em># self included in args</em></code>
<code> <strong>           self.pay *= (1.0 + percent)</strong> </code>               <code><em># Counter in nonlocals</em></code>
 
&gt;&gt;&gt; <code><strong>pat = Person('Pat Jones', 50_000)</strong></code>
&gt;&gt;&gt; <code><strong>pat.giveRaise(.10)</strong></code>
call 1 to giveRaise
&gt;&gt;&gt; <code><strong>pat.giveRaise(.10)</strong></code>
call 2 to giveRaise
&gt;&gt;&gt; <code><strong>f'{pat.pay:,.2f}'</strong></code>
'60,500.00'

&gt;&gt;&gt; <code><strong>from decorator_state_attributes import tracer</strong> </code>     <code><em># See Example 39-5</em></code>
…<code><em>same correct results</em></code>…                                 <code><em># Counter in attributes</em></code></pre>
<p>Because decorated methods here are rebound to simple functions instead of instance objects, Python correctly passes the <code>Person</code> object as the first argument, and the decorator propagates it on in the first item of <code>*args</code> to the <code>self</code> argument of the real, decorated methods. Trace through these results and decorators to make sure you have a handle on this model; the next section provides an alternative to it that supports classes but is also substantially more complex.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Using descriptors to decorate methods"><div class="sect3" id="using_descriptors_to_decorate_methods">
<h3>Using descriptors to decorate methods</h3>
<p>Although the nested function solution <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="methods" data-tertiary="descriptors" id="crtmthdd"></a><a contenteditable="false" data-type="indexterm" data-primary="methods" data-secondary="decorators" data-tertiary="descriptors" id="mtcrscr"></a><a contenteditable="false" data-type="indexterm" data-primary="descriptors" data-secondary="decorating methods" id="scrcrmt"></a>illustrated in the prior section is the most straightforward way to support decorators that apply to both functions and class-level methods, other schemes are possible. The <em>descriptor</em> feature we explored in the prior chapter, for example, can help here as well.</p>
<p>Recall from our discussion in the prior chapter that a descriptor is normally a class attribute assigned to an object with a <code>__get__</code> method run automatically whenever that attribute is referenced and fetched:</p>
<pre data-type="programlisting">class Descriptor:
    def __get__(self, instance, owner): …

class Subject:
    attr = Descriptor()

X = Subject()
X.attr           <code><em># Roughly runs Descriptor.__get__(Subject.attr, X, Subject)</em></code></pre>
<p>Descriptors may also have <code>__set__</code> and <code>__del__</code> access methods, but we don’t need them here. More relevant to this chapter’s topic: because the descriptor’s <code>__get__</code> method receives <em>both</em> the descriptor class instance and subject class instance when invoked, it’s well suited to decorating methods when we need both the decorator’s state and the original class instance for dispatching calls. Consider the alternative tracing decorator in <a data-type="xref" href="#example_threenine_sixdot_calltracer_des">Example 39-6</a>, which <em>also</em> happens to be a descriptor when used for a class-level method (its “…” are the same as in the prior REPL session).</p>
<div data-type="example" id="example_threenine_sixdot_calltracer_des">
<h5><span class="label">Example 39-6. </span>calltracer_desc_class.py</h5>
<pre data-type="programlisting">class tracer(object):                        <code><em># A decorator+descriptor
</em></code>    def __init__(self, func):                <code><em># On @ decorator</em></code>
        self.calls = 0                       <code><em># Save func for later call</em></code>
        self.func  = func
    def __call__(self, *args, **kwargs):     <code><em># On call to original func/meth</em></code>
        self.calls += 1
        print(f'call {self.calls} to {self.func.__name__}')
        return self.func(*args, **kwargs)
    def __get__(self, instance, owner):      <code><em># On method attribute fetch</em></code>
        return wrapper(self, instance)

class wrapper:
    def __init__(self, desc, subj):          <code><em># Save both instances</em></code>
        self.desc = desc                     <code><em># Route calls back to deco/desc
</em></code>        self.subj = subj
    def __call__(self, *args, **kwargs):
        return self.desc(self.subj, *args, **kwargs)  <code><em># Runs tracer.__call__</em></code>

@tracer
def hack(a, b, c):                           <code><em># hack = tracer(hack)</em></code>
    …                                        <code><em># Uses __call__ only</em></code>

class Person:
    …
    @tracer
    def giveRaise(self, percent):            <code><em># giveRaise = tracer(giveRaise)</em></code>
        …<code> <em>                    </em></code>               <code><em># Makes giveRaise a descriptor</em></code></pre>
</div>
<p class="pagebreak-before">This works the same as the preceding nested function coding. Its operation varies by usage context:</p>
<ul>
<li><p>Decorated <em>functions</em> invoke only its <code>__call__</code>, and never invoke its <code>__get__</code>.</p></li>
<li><p>Decorated <em>methods</em> invoke its <code>__get__</code> first to resolve the method name fetch (on <code><em>I</em>.<em>method</em></code>); the object returned by <code>__get__</code> retains the subject class instance and is then invoked to complete the call expression, thereby triggering the decorator’s <code>__call__</code> (on <code>()</code>).</p></li>
</ul>
<p>For example, given the same testing code, the call to:</p>
<pre data-type="programlisting">pat.giveRaise(.10)                           <code><em># Runs __get__ then __call__</em></code></pre>
<p>runs <code>tracer.__get__</code> first because the <code>giveRaise</code> attribute in the <code>Person</code> class has been rebound to a descriptor by the method function decorator. The call expression then triggers the <code>__call__</code> method of the returned <code>wrapper</code> object, which in turn invokes <code>tracer.__call__</code>. In other words, decorated method calls trigger a <em>five-step</em> process: <code>tracer.__get__</code>, which invokes <code>wrapper.__init__</code>, followed by three call operations—<code>wrapper.__call__</code>, <code>tracer.__call__</code>, and finally the original wrapped method.</p>
<p>The <code>wrapper</code> object retains both descriptor and subject instances, so it can route control back to the original decorator/descriptor class instance. In effect, the <code>wrapper</code> object saves the subject class instance available during method attribute fetch and adds it to the later call’s arguments list, which is passed to the decorator<code>__call__</code>. Routing the call back to the descriptor class instance this way is required in this application so that all calls to a wrapped method use the same <code>calls</code> counter state information in the descriptor instance object.</p>
<p>Alternatively, we could use a nested function and enclosing-scope references to achieve the same effect—<a data-type="xref" href="#example_threenine_sevendot_calltracer_d">Example 39-7</a> works the same as the preceding one by swapping a wrapper class and attributes for a nested function and scope references. It requires noticeably less code but follows a similar multistep process on each decorated method call.</p>
<div data-type="example" id="example_threenine_sevendot_calltracer_d">
<h5><span class="label">Example 39-7. </span>calltracer_desc_func.py</h5>
<pre data-type="programlisting">class tracer(object):
    def __init__(self, func):                <code><em># On @ decorator</em></code>
        self.calls = 0                       <code><em># Save func for later call</em></code>
        self.func  = func
    def __call__(self, *args, **kwargs):     <code><em># On call to original func</em></code>
        self.calls += 1
        print(f'call {self.calls} to {self.func.__name__}')
        return self.func(*args, **kwargs)
    def __get__(self, instance, owner):                <code><em># On method fetch</em></code>
        def wrapper(*args, **kwargs):                  <code><em># Retain both inst</em></code>
            return self(instance, *args, **kwargs)     <code><em># Runs __call__</em></code>
        return wrapper

…<code><em>rest same as Example 39-6</em></code>…</pre>
</div>
<p>These two descriptor-based tracers work the same as the nested-functions version, so we’ll skip their output here. Add <code>print</code> statements to their methods to trace their multistep get/call processes if it helps. In either coding, this descriptor-based scheme is also substantially subtler than the nested-function option, and so is probably a second choice here. To be more blunt, if its complexity doesn’t send you screaming into the night, its performance costs probably should! Still, this may be a useful coding pattern in other contexts.</p>
<p>Before moving on, it’s also worth briefly noting that we might code this descriptor-based decorator more simply as in <a data-type="xref" href="#example_threenine_eightdot_calltracer_d">Example 39-8</a>, but it would then <em>apply only to methods</em>, not to simple functions—an intrinsic limitation of attribute descriptors, and just the inverse of the problem we’re trying to solve (application to both functions and methods).</p>
<div data-type="example" id="example_threenine_eightdot_calltracer_d">
<h5><span class="label">Example 39-8. </span>calltracer_desc_fail.py</h5>
<pre data-type="programlisting">class tracer(object):                         <code><em># For methods, but not functions!</em></code>
    def __init__(self, meth):                 <code><em># On @ decorator</em></code>
        self.calls = 0                         
        self.meth  = meth
    def __get__(self, instance, owner):       <code><em># On method fetch
</em></code>        def wrapper(*args, **kwargs):         <code><em># On method call: proxy with self+inst
</em></code>            self.calls += 1
            print(f'call {self.calls} to {self.meth.__name__}')
            return self.meth(instance, *args, **kwargs)
        return wrapper

@tracer                                <code><em># OK for methods but FAILS for functions
</em></code>def hack(a, b, c):                     <code><em># hack = tracer(hack)</em></code>
    …                                  <code><em># No attribute fetch occurs on calls!</em></code>

…<code><em>rest same as Example 39-6</em></code>…</pre>
</div>
<p>In the rest of this chapter we’re going to be casual about using classes or functions to code our function decorators, as long as they are applied only to functions. Some decorators may not require the instance of the original class, and will still work on both functions and methods if coded as a class—something like Python’s own <code>staticmethod</code> decorator, for example, wouldn’t require an instance of the subject class (indeed, its whole point is to remove the instance from the call).</p>
<p>The simpler moral of this story, though, is that if you want your decorators to work on both simple functions and methods, you’re probably better off using the <em>nested-function</em> coding pattern <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="methods" data-tertiary="descriptors" data-startref="crtmthdd" id="id4834"></a><a contenteditable="false" data-type="indexterm" data-primary="methods" data-secondary="decorators" data-tertiary="descriptors" data-startref="mtcrscr" id="id4835"></a><a contenteditable="false" data-type="indexterm" data-primary="descriptors" data-secondary="decorating methods" data-startref="scrcrmt" id="id4836"></a>instead of a class with call interception.</p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Timing Function Calls"><div class="sect2" id="timing_function_calls">
<h2>Timing Function Calls</h2>
<p>To better sample what function <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="function decorators" data-tertiary="function call timing" id="dcrrcdfcc"></a><a contenteditable="false" data-type="indexterm" data-primary="function decorators" data-secondary="function call timing" id="fdfcctmi"></a><a contenteditable="false" data-type="indexterm" data-primary="function calls" data-secondary="timing" id="fctclltmi"></a>decorators are capable of, let’s turn to a different use case. Our next decorator times <em>calls</em> made to a decorated function—both the time for one call and the total time among all calls. As coded in <a data-type="xref" href="#example_threenine_ninedot_timerdecooned">Example 39-9</a>, the decorator is applied to two functions to compare the speeds of list comprehensions and the <code>map</code> built-in.</p>
<div data-type="example" id="example_threenine_ninedot_timerdecooned">
<h5><span class="label">Example 39-9. </span>timerdeco1.py</h5>
<pre data-type="programlisting"><code>"Caveat: timer won't work on methods as coded (see quiz solution)"</code>
import time, sys

class timer:
    def __init__(self, func):
        self.func    = func
        self.alltime = 0
    def __call__(self, *args, **kargs):
        start   = time.perf_counter()
        result  = self.func(*args, **kargs)
        elapsed = time.perf_counter() - start
        self.alltime += elapsed
        print(f'{self.func.__name__}: {elapsed:.5f}, {self.alltime:.5f}')
        return result

@timer
def listcomp(N):
    return [x * 2 for x in range(N)]

@timer
def mapcall(N):
    return list(map((lambda x: x * 2), range(N)))

if __name__ == '__main__':
    for func in (listcomp, mapcall):
        result = func(5)                        <code><em># Time for this call, result</em></code>
        func(50_000)
        func(500_000)
        func(1_000_000)
        print(result)
        print(f'allTime = {func.alltime}\n')    <code><em># Total time for all func calls</em></code>

    print('**map/comp =', round(mapcall.alltime / listcomp.alltime, 3))</pre>
</div>
<p>When run on a macOS host by CPython 3.12, the output of this file’s self-test code is as follows—giving for each function call the function name, time for this call, and time for all calls so far, along with the first call’s return value, cumulative time for each function, and the map-to-comprehension time ratio at the end:</p>
<pre data-type="programlisting">$ <code><strong>python3 timerdeco1.py</strong></code>
listcomp: 0.00000, 0.00000
listcomp: 0.00366, 0.00366
listcomp: 0.03134, 0.03500
listcomp: 0.05213, 0.08713
[0, 2, 4, 6, 8]
allTime = 0.08712841104716063

mapcall: 0.00001, 0.00001
mapcall: 0.00396, 0.00397
mapcall: 0.04082, 0.04479
mapcall: 0.07789, 0.12268
[0, 2, 4, 6, 8]
allTime = 0.12268476499593817

**map/comp = 1.408</pre>
<p>Times vary per Python version, test machine, and other variables, of course, and cumulative time is available as a class instance attribute here. As usual, <code>map</code> calls are slower than list comprehensions when the latter can avoid a function call (or equivalently, its requirement of function calls may make <code>map</code> slower).</p>
<p>For comparison, see <a data-type="xref" href="ch21.html#the_benchmarking_interlude">Chapter 21</a> for a <em>nondecorator</em> approach to timing iteration alternatives like these. As a review, we saw two per-call timing techniques there, homegrown and library—here deployed to time the 1M list comprehension case of the decorator’s test code, though incurring extra admin costs that skew results slightly (add <a data-type="xref" href="ch21.html#the_benchmarking_interlude">Chapter 21</a>’s folder to your <code>PYTHONPATH</code> or <code>sys.path</code>, or go there to run this):</p>
<pre class="pagebreak-before" data-type="programlisting">&gt;&gt;&gt; <code><strong>def listcomp(N): [x * 2 for x in range(N)]

</strong></code>&gt;&gt;&gt; <code><strong>import timer</strong></code>                                    <code><em># Chapter 21 techniques</em></code>
&gt;&gt;&gt; <code><strong>timer.total(1, listcomp, 1_000_000)</strong></code>
(0.08150088600814342, None)
&gt;&gt;&gt; <code><strong>timer.bestoftotal(5, 1, listcomp, 1_000_000)</strong></code>
(0.059792334999656305, None)

&gt;&gt;&gt; <code><strong>import timeit</strong></code>
&gt;&gt;&gt; <code><strong>timeit.timeit(number=1, stmt=lambda: listcomp(1_000_000))</strong></code>
0.08125517799635418
&gt;&gt;&gt; <code><strong>min(timeit.repeat(repeat=5, number=1, stmt=lambda: listcomp(1_000_000)))</strong></code>
0.06156357398140244</pre>
<p>In this specific case, a nondecorator approach would allow the subject functions to be used with or without timing, but it would also complicate the call signature when timing is desired—we’d need to add code at every call instead of once at the <code>def</code>. Moreover, in the nondecorator scheme, there would be no direct way to guarantee that all list builder calls in a program are routed through timer logic, short of finding and potentially changing them all. This may make it difficult to collect cumulative data for all calls.</p>
<p>In general, <em>decorators</em> may be preferred when functions are already deployed as part of a larger system and may not be easily passed to analysis functions at calls. On the other hand, because decorators charge each call to a function with augmentation logic, a <em>nondecorator</em> approach may be better if you wish to augment calls more <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="function decorators" data-tertiary="function call timing" data-startref="dcrrcdfcc" id="id4837"></a><a contenteditable="false" data-type="indexterm" data-primary="function decorators" data-secondary="function call timing" data-startref="fdfcctmi" id="id4838"></a><a contenteditable="false" data-type="indexterm" data-primary="function calls" data-secondary="timing" data-startref="fctclltmi" id="id4839"></a>selectively. As usual, different tools serve different roles.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Adding Decorator Arguments"><div class="sect2" id="adding_decorator_arguments">
<h2>Adding Decorator Arguments</h2>
<p>The timer decorator of the prior <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="arguments" id="dcrrgm"></a><a contenteditable="false" data-type="indexterm" data-primary="arguments" data-secondary="decorators" id="rgumdctr"></a>section works, but it would be nice if it were more configurable—providing an output label and turning trace messages on and off, for instance, might be useful in a general-purpose tool like this. Decorator <em>arguments</em> come in handy here: when they’re coded properly, we can use them to specify configuration options that can vary for each decorated function. A label, for instance, might be added as abstractly follows:</p>
<pre data-type="programlisting">def timer(label=''):
    def decorator(func):
        def onCall(*args):        <code><em># Multilevel state retention:</em></code>
            …                     <code><em># args passed to function</em></code>
            func(*args)           <code><em># func retained in enclosing scope</em></code>
            print(label, …)       <code><em># label retained in enclosing scope</em></code>
        return onCall
    return decorator              <code><em># Returns the actual decorator
</em></code>
@timer('==&gt;')                     <code><em># Like listcomp = timer('==&gt;')(listcomp)</em></code>
def listcomp(N): …                <code><em># listcomp is rebound to new onCall
</em></code>
listcomp(…)                       <code><em># Really calls onCall</em></code></pre>
<p>This code adds an enclosing scope to retain a decorator argument for use on a later actual call. When the <code>listcomp</code> function is defined, Python really invokes <code>decorator</code>—the result of <code>timer</code>, run before decoration actually occurs—with the <code>label</code> value available in its enclosing scope. That is, <code>timer</code> <em>returns</em> the decorator, which remembers both the decorator argument and the original function, and returns the callable <code>onCall</code>, which ultimately invokes the original function on later calls. Because this structure creates new <code>decorator</code> and <code>onCall</code> functions, their enclosing scopes are per-decoration state retention.</p>
<p>We can put this structure to use in our timer to allow a label and a trace control flag to be passed in at decoration time. <a data-type="xref" href="#example_threenine_onezerodot_timerdecot">Example 39-10</a> does just that, coded in a module file so it can be imported as a general tool; it uses a class for the second state retention level instead of a nested function, but the net result is similar.</p>
<div data-type="example" id="example_threenine_onezerodot_timerdecot">
<h5><span class="label">Example 39-10. </span>timerdeco2.py</h5>
<pre data-type="programlisting">import time

def timer(label='', trace=True):                  <code><em># On decorator args: retain args</em></code>
    class Timer:
        def __init__(self, func):                 <code><em># On @: retain decorated func</em></code>
            self.func    = func
            self.alltime = 0
        def __call__(self, *args, **kargs):       <code><em># On calls: call original
</em></code>            start   = time.perf_counter()
            result  = self.func(*args, **kargs)
            elapsed = time.perf_counter() - start
            self.alltime += elapsed
            if trace:
                if label: print(label, end=' ')
                print(f'{self.func.__name__}: {elapsed:.5f}, {self.alltime:.5f}')
            return result
    return Timer</pre>
</div>
<p>Mostly, all we’ve done here is embed the original <code>Timer</code> class in an enclosing function in order to create a scope that retains the decorator arguments per deployment. The outer <code>timer</code> function is called before decoration occurs, and it simply returns the <code>Timer</code> class to serve as the actual decorator. On decoration, an instance of <code>Timer</code> is made that remembers the decorated function itself, but also has access to the decorator arguments in the enclosing function scope.</p>
<p>This time, rather than embedding self-test code in this file, we’ll run the decorator in a different file. <a data-type="xref" href="#example_threenine_oneonedot_testseqsdot">Example 39-11</a> is a client of our timer decorator, applying it to sequence iteration alternatives again.</p>
<div data-type="example" id="example_threenine_oneonedot_testseqsdot">
<h5><span class="label">Example 39-11. </span>testseqs.py</h5>
<pre data-type="programlisting">import sys
from timerdeco2 import timer

@timer(label='[CCC]==&gt;')
def listcomp(N):                             <code><em># Like listcomp = timer(...)(listcomp)</em></code>
    return [x * 2 for x in range(N)]         <code><em># listcomp(...) triggers Timer.__call__</em></code>

@timer(trace=True, label='[MMM]==&gt;')
def mapcall(N):
    return list(map((lambda x: x * 2), range(N)))

for func in (listcomp, mapcall):
    result = func(5)                         <code><em># Time for this call, return value</em></code>
    func(50_000)
    func(500_000)
    func(1_000_000)
    print(result)
    print(f'allTime = {func.alltime}\n')     <code><em># Total time for all calls</em></code>

print('**map/comp =', round(mapcall.alltime / listcomp.alltime, 3))</pre>
</div>
<p>When run, this file prints the following—each decorated function now has a label of its own defined by decorator arguments, which may be more useful when we need to find trace displays mixed in with a larger program’s output:</p>
<pre data-type="programlisting">$ <code><strong>python3 testseqs.py</strong></code>
[CCC]==&gt; listcomp: 0.00000, 0.00000
[CCC]==&gt; listcomp: 0.00379, 0.00379
[CCC]==&gt; listcomp: 0.03142, 0.03521
[CCC]==&gt; listcomp: 0.05188, 0.08709
[0, 2, 4, 6, 8]
allTime = 0.08709081003325991

[MMM]==&gt; mapcall: 0.00001, 0.00001
[MMM]==&gt; mapcall: 0.00401, 0.00402
[MMM]==&gt; mapcall: 0.04025, 0.04427
[MMM]==&gt; mapcall: 0.07776, 0.12203
[0, 2, 4, 6, 8]
allTime = 0.12203056103317067

**map/comp = 1.401</pre>
<p>Run additional tests on your own to see how the decorator’s configuration arguments come into play. As is, this timing function decorator can be used for any function, both in modules and interactively. In other words, it automatically serves as a <em>general-purpose tool</em> for timing code in our scripts. Watch for additional examples of decorator arguments ahead when we code decorators to implement attribute privacy and argument range checking.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><em>Timing methods</em>: This section’s timer decorator works on any <em>function</em>, but a minor rewrite is <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="timer decorator" id="id4840"></a><a contenteditable="false" data-type="indexterm" data-primary="timer decorator" id="id4841"></a>required to apply it to class-level <em>methods</em> too. In short, and per <a data-type="xref" href="#class_pitfall_decorating_methods">“Class Pitfall: Decorating Methods”</a>, it must avoid <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="arguments" data-startref="dcrrgm" id="id4842"></a><a contenteditable="false" data-type="indexterm" data-primary="arguments" data-secondary="decorators" data-startref="rgumdctr" id="id4843"></a>using a nested class. Because this last mutation is being saved for an end-of-chapter quiz question, though, you’ll have to stay tuned for its final code.</p>
</div>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Coding Class Decorators"><div class="sect1" id="coding_class_decorators">
<h1>Coding Class Decorators</h1>
<p>So far, we’ve been coding function decorators to manage function <em>calls</em>, but as we’ve seen, decorators work on classes too. As described earlier, while similar in concept to function decorators, class decorators are applied to classes instead—they may be used either to manage <em>classes</em> themselves or to intercept instance-creation calls in order to manage <em>instances</em>. Also like function decorators, class decorators are really just optional syntactic sugar, though they can make a programmer’s intent more obvious and minimize erroneous or missed calls.</p>
<section data-type="sect2" data-pdf-bookmark="Singleton Classes"><div class="sect2" id="singleton_classes">
<h2>Singleton Classes</h2>
<p>Let’s start with something simple. By intercepting <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="class decorators" data-tertiary="singleton classes" id="dcclcglc"></a><a contenteditable="false" data-type="indexterm" data-primary="class decorators" data-secondary="singleton classes" id="cldglcl"></a>instance-creation calls, class decorators can be used to either manage all the instances of a class, or augment the interfaces of those instances. <a data-type="xref" href="#example_threenine_onetwodot_singletonso">Example 39-12</a> lists a first class decorator example that does the former—managing all instances of a class. This code implements the classic <em>singleton</em> coding pattern, where at most one instance of a class ever exists. Its <code>singleton</code> function defines and returns a function for managing instances, and the <code>@</code> syntax automatically wraps up a subject class in this function.</p>
<div data-type="example" id="example_threenine_onetwodot_singletonso">
<h5><span class="label">Example 39-12. </span>singletons1.py</h5>
<pre data-type="programlisting">instances = {}

def singleton(aClass):                          <code><em># On @ decoration</em></code>
    def onCall(*args, **kwargs):                <code><em># On instance creation</em></code>
        if aClass not in instances:             <code><em># One dict entry per class
</em></code>            instances[aClass] = aClass(*args, **kwargs)
        return instances[aClass]
    return onCall</pre>
</div>
<p>To use this, decorate the classes for which you want to enforce a single-instance model, as in <a data-type="xref" href="#example_threenine_onethreedot_singleton">Example 39-13</a>.</p>
<div data-type="example" id="example_threenine_onethreedot_singleton">
<h5><span class="label">Example 39-13. </span>singletons-test.py</h5>
<pre data-type="programlisting">from singletons1 import singleton

@singleton                                      <code><em># Person = singleton(Person)
</em></code>class Person:                                   <code><em># Rebinds Person to onCall
</em></code>     def __init__(self, name, hours, rate):     <code><em># onCall remembers Person</em></code>
        self.name = name
        self.hours = hours
        self.rate = rate
     def pay(self):
        return self.hours * self.rate

@singleton                                      <code><em># Hack = singleton(Hack)</em></code>
class Hack:                                     <code><em># Rebinds Hack to onCall</em></code>
    def __init__(self, val):                    <code><em># onCall remembers Hack</em></code>
        self.attr = val

sue = Person('Sue', 50, 20)                     <code><em># Really calls onCall</em></code>
print(sue.name, sue.pay())

bob = Person('Bob', 40, 10)                     <code><em># Same, single object</em></code>
print(bob.name, bob.pay())

X = Hack(val=42)                                <code><em># One Person, one Hack</em></code>
Y = Hack(99)
print(X.attr, Y.attr)</pre>
</div>
<p>Now, when the <code>Person</code> or <code>Hack</code> class is later used to create an instance, the wrapping logic layer provided by the decorator routes instance-creation calls to <code>onCall</code>, which in turn ensures a single instance per class, regardless of how many construction calls are made. Here’s this code’s output when run via command line:</p>
<pre data-type="programlisting">$ <code><strong>python3 singletons.py</strong></code>
Sue 1000
Sue 1000
42 42</pre>
<section data-type="sect3" data-pdf-bookmark="Singleton coding alternatives"><div class="sect3" id="singleton_coding_alternatives">
<h3>Singleton coding alternatives</h3>
<p>Interestingly, you can code a more self-contained solution here with the <code>nonlocal</code> statement to change <em>enclosing-scope</em> names as described earlier. The following alternative achieves an identical effect, by using one enclosing scope per class, instead of one global table entry per class. It works the same, but it does not depend on names in the global scope outside the decorator (the <code>None</code> check could use <code>is</code> instead of <code>==</code> here, but it’s a trivial test either way):</p>
<pre data-type="programlisting">def singleton(aClass):                                   <code><em># On @ decoration</em></code>
    instance = None
    def onCall(*args, **kwargs):                         <code><em># On instance creation</em></code>
        nonlocal instance 
        if instance == None:
            instance = aClass(*args, **kwargs)           <code><em># One scope per class</em></code>
        return instance
    return onCall</pre>
<p>You can also code a self-contained solution with either function attributes or a class instead. The first of the following codes the former, leveraging the fact that there will be one <code>onCall</code> <em>function</em> per <span class="keep-together">decoration—the</span> function object’s namespace serves the same role as an enclosing scope. The second uses one <em>instance</em> per decoration, rather than an enclosing scope, function object, or global table. In fact, the second option relies on the same coding pattern that we will later label a common decorator class pitfall—here we <em>want</em> just one instance, but that’s not often the case:</p>
<pre data-type="programlisting">def singleton(aClass):                                   <code><em># On @ decoration</em></code>
    def onCall(*args, **kwargs):                         <code><em># On instance creation</em></code>
        if onCall.instance == None:
            onCall.instance = aClass(*args, **kwargs)    <code><em># One function per class</em></code>
        return onCall.instance
    onCall.instance = None
    return onCall

class singleton:
    def __init__(self, aClass):                          <code><em># On @ decoration</em></code>
        self.aClass = aClass
        self.instance = None
    def __call__(self, *args, **kwargs):                 <code><em># On instance creation</em></code>
        if self.instance == None:
            self.instance = self.aClass(*args, **kwargs) <code><em># One instance per class</em></code>
        return self.instance</pre>
<p>To make this singleton decorator a fully general-purpose tool, choose one version, store it in an importable module file, and indent the self-test code under a <code>__name__</code> check—steps we’ll leave as suggested exercise. The final class-based version offers an explicit <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="class decorators" data-tertiary="singleton classes" data-startref="dcclcglc" id="id4844"></a><a contenteditable="false" data-type="indexterm" data-primary="class decorators" data-secondary="singleton classes" data-startref="cldglcl" id="id4845"></a>option with extra structure that may better support later evolution, but OOP might not be warranted in all contexts.</p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Tracing Object Interfaces"><div class="sect2" id="tracing_object_interfaces">
<h2>Tracing Object Interfaces</h2>
<p>The singleton example of the prior section <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="class decorators" data-tertiary="object interfaces" id="dtrclssbf"></a><a contenteditable="false" data-type="indexterm" data-primary="class decorators" data-secondary="object interfaces" id="decbjrf"></a>illustrated using class decorators to manage <em>all</em> the instances of a class. Another common use case for class decorators augments the interface of <em>each</em> generated instance. Class decorators can essentially install a wrapper or “<em>proxy</em>” logic layer atop instances that manages access to their interfaces.</p>
<p>For example, in <a data-type="xref" href="ch31.html#designing_with_classes">Chapter 31</a>, the <code>__getattr__</code> operator-overloading method was shown as a way to wrap up entire object interfaces of embedded instances in order to implement the <em>delegation</em> coding pattern. We saw similar examples in the managed attribute coverage of the prior chapter. Recall that <code>__getattr__</code> is run when an undefined attribute name is fetched; we can use this hook to intercept method calls in a controller class and propagate them to an embedded object.</p>
<section data-type="sect3" data-pdf-bookmark="The nondecorator approach"><div class="sect3" id="the_nondecorator_approach">
<h3>The nondecorator approach</h3>
<p>For reference and review, here’s the original <em>nondecorator</em> delegation example:</p>
<pre data-type="programlisting">class Wrapper:
    def __init__(self, object):
        self.wrapped = object                    <code><em># Save object</em></code>
    def __getattr__(self, attrname):
        print('Trace:', attrname)                <code><em># Trace fetch
</em></code>        return getattr(self.wrapped, attrname)   <code><em># Delegate fetch</em></code>

x = Wrapper([1,2,3])       <code><em># Wrap a list object</em></code>
x.append(4)                <code><em># Delegate to list method</em></code></pre>
<p>In this code, the <code>Wrapper</code> class intercepts access to any of the wrapped object’s explicitly named attributes, prints a trace message, and uses the <code>getattr</code> built-in to pass off the request to the wrapped object. Specifically, it traces attribute accesses made <em>outside</em> the wrapped object’s class; accesses inside the wrapped object’s methods are not caught and run normally by design. This <em>whole-interface</em> model differs from the behavior of function decorators, which wrap up just one specific method.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="The class-decorator approach"><div class="sect3" id="the_class_decorator_approach">
<h3>The class-decorator approach</h3>
<p>Class decorators provide an alternative and convenient way to code this <code>__getattr__</code> technique and wrap an entire interface. The preceding code, for example, can be coded as a class decorator that triggers wrapped instance creation instead of passing a premade instance into the wrapper’s constructor. <a data-type="xref" href="#example_threenine_onefourdot_interfacet">Example 39-14</a> codes this mod, also supports keyword arguments with <code>**kargs</code>, and counts the number of accesses to illustrate changeable state.</p>
<div data-type="example" id="example_threenine_onefourdot_interfacet">
<h5><span class="label">Example 39-14. </span>interfacetracer.py</h5>
<pre data-type="programlisting">def Tracer(aClass):                                   <code><em># On @ decorator
</em></code>    class Wrapper:
        def __init__(self, *args, **kargs):           <code><em># On instance creation</em></code>
            self.fetches = 0
            self.wrapped = aClass(*args, **kargs)     <code><em># Use enclosing-scope name</em></code>
        def __getattr__(self, attrname):
            print('Trace: ' + attrname)               <code><em># Catches all but own attrs</em></code>
            self.fetches += 1
            return getattr(self.wrapped, attrname)    <code><em># Delegate to wrapped obj
</em></code>    return Wrapper


if __name__ == '__main__':

    @Tracer
    class Hack:                                  <code><em># Hack = Tracer(Hack)</em></code>
        def display(self):                       <code><em># Hack is rebound to Wrapper</em></code>
            print('Hack!' * 3)

    @Tracer
    class Person:                                <code><em># Person = Tracer(Person)
</em></code>        def __init__(self, name, hours, rate):   <code><em># Wrapper remembers Person</em></code>
            self.name = name
            self.hours = hours
            self.rate = rate
        def pay(self):                           <code><em># Accesses outside class traced</em></code>
            return self.hours * self.rate        <code><em># In-method accesses not traced</em></code>

    work = Hack()                                <code><em># Triggers Wrapper()
</em></code>    work.display()                               <code><em># Triggers __getattr__</em></code>
    print([work.fetches])

    print()
    bob = Person('Bob', 40, 50)                  <code><em># bob is really a Wrapper</em></code>
    print(bob.name)                              <code><em># Wrapper embeds a Person</em></code>
    print(bob.pay())

    print()
    sue = Person('Sue', rate=100, hours=60)      <code><em># sue is a different Wrapper</em></code>
    print(sue.name)                              <code><em># With a different Person</em></code>
    print(sue.pay())

    print()
    print(bob.name)                              <code><em># bob's state != sue's state
</em></code>    print(bob.pay())
    print('calls:', [bob.fetches, sue.fetches])  <code><em># Wrapper attrs are not traced</em></code></pre>
</div>
<p>It’s important to note that this is very different from the tracer decorator we met earlier (despite the name!). In <a data-type="xref" href="#coding_function_decorators">“Coding Function Decorators”</a>, we looked at decorators that enabled us to trace and time <em>calls</em> to a given function or method. In contrast, by intercepting instance-creation calls, the class decorator here allows us to trace an entire object <em>interface</em>—that is, accesses to any of the instance’s attributes.</p>
<p>It’s also important to note that this decorator’s <code>__getattr__</code> won’t catch the implicit attribute fetches of <em>built-in operations</em> per the prior chapter, but we’ll defer more on this subject until we code attribute privacy ahead.</p>
<p>The following is the output produced by this code: attribute fetches on instances of both the <code>Hack</code> and <code>Person</code> classes invoke the <code>__getattr__</code> logic in the <code>Wrapper</code> class because <code>work</code>, and <code>bob</code>, and <code>sue</code> are really instances of <code>Wrapper</code>, thanks to the decorator’s redirection of instance-creation calls:</p>
<pre data-type="programlisting">$ <code><strong>python3 interfacetracer.py</strong></code>
Trace: display
Hack!Hack!Hack!
[1]

Trace: name
Bob
Trace: pay
2000

Trace: name
Sue
Trace: pay
6000

Trace: name
Bob
Trace: pay
2000
calls: [4, 2]</pre>
<p>Notice how there is one <code>Wrapper</code> class with state retention per decoration, generated by the nested <code>class</code> statement in the <code>Tracer</code> function, and how each instance gets its own fetches counter by virtue of generating a new <code>Wrapper</code> instance. As you’ll see ahead, orchestrating this is trickier than you may expect.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Applying class decorators to built-in types"><div class="sect3" id="applying_class_decorators_to_built_in_t">
<h3>Applying class decorators to built-in types</h3>
<p>Also notice that the preceding <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="class decorators" data-tertiary="built-in types" id="id4846"></a><a contenteditable="false" data-type="indexterm" data-primary="class decorators" data-secondary="built-in types" id="id4847"></a>decorates a user-defined class. Just like in the original example in <a data-type="xref" href="ch31.html#designing_with_classes">Chapter 31</a>, we can also use the decorator to wrap up a built-in object type such as a list, as long as we either subclass to allow decoration syntax or perform the decoration rebinding manually—decorator syntax requires a <code>class</code> statement for the <code>@</code> line. In the following, <code>x</code> is really a <code>Wrapper</code> again due to the indirection of decoration:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>from interfacetracer import Tracer

</strong></code>&gt;&gt;&gt; <code><strong>@Tracer</strong></code>
... <code><strong>class MyList(list): pass</strong></code>      <code><em># MyList = Tracer(MyList)

</em></code>&gt;&gt;&gt; <code><strong>x = MyList([1, 2, 3])</strong></code>         <code><em># Triggers Wrapper()</em></code>
&gt;&gt;&gt; <code><strong>x.append(4)</strong></code>                   <code><em># Triggers __getattr__, append</em></code>
Trace: append
&gt;&gt;&gt; <code><strong>x.wrapped</strong></code>
[1, 2, 3, 4]

&gt;&gt;&gt; <code><strong>MyList = Tracer(list)</strong></code>         <code><em># Or perform decoration manually</em></code>
&gt;&gt;&gt; <code><strong>x = MyList([4, 5, 6])</strong></code>         <code><em># Else subclass statement required</em></code>
&gt;&gt;&gt; <code><strong>x.append(7)</strong></code>
Trace: append
&gt;&gt;&gt; <code><strong>x.wrapped</strong></code>
[4, 5, 6, 7]</pre>
<p>The decorator approach allows us to move instance creation into the decorator itself instead of requiring a premade object to be passed in. Although this seems like a minor difference, it lets us retain normal instance-creation syntax and limits augmentation syntax to class definition. Rather than requiring all instance-creation calls to route objects through a wrapper manually, we need only augment class definitions with decorator syntax:</p>
<pre data-type="programlisting">@Tracer                                          <code><em># Decorator approach</em></code>
class Person: …
bob = Person('Bob', 40, 50)
sue = Person('Sue', rate=100, hours=60)

class Person: …                                  <code><em># Nondecorator approach</em></code>
bob = Wrapper(Person('Bob', 40, 50))
sue = Wrapper(Person('Sue', rate=100, hours=60))</pre>
<p>Assuming you will make more than one instance of a class and want to apply the augmentation to every instance of a class, decorators will generally be a net win in terms of both code size and <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="class decorators" data-tertiary="singleton classes" data-startref="dcclcglc" id="id4848"></a><a contenteditable="false" data-type="indexterm" data-primary="class decorators" data-secondary="singleton classes" data-startref="cldglcl" id="id4849"></a>code <span class="keep-together">maintenance.</span></p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Class Pitfall: Retaining Multiple Instances"><div class="sect2" id="class_pitfall_retaining_multiple_instan">
<h2>Class Pitfall: Retaining Multiple Instances</h2>
<p>Curiously, the decorator function in the <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="class decorators" data-tertiary="instances, multiple" id="drtcdstm"></a><a contenteditable="false" data-type="indexterm" data-primary="class decorators" data-secondary="instances, multiple" id="cldstcmp"></a><a contenteditable="false" data-type="indexterm" data-primary="instances" data-secondary="class decorators" id="istmpcld"></a>preceding example can <em>almost</em> be coded as a class instead of a function with the proper operator-overloading protocol. <a data-type="xref" href="#example_threenine_onefivedot_interfacet">Example 39-15</a>’s alternative coding works similarly because its <code>__init__</code> is triggered when the <code>@</code> decorator is applied to the class, and its <code>__call__</code> is triggered when a subject class instance is created. Our objects are really instances of <code>Tracer</code> this time, and we essentially just trade an enclosing-scope reference for an instance attribute here.</p>
<div data-type="example" class="pagebreak-before less_space" id="example_threenine_onefivedot_interfacet">
<h5><span class="label">Example 39-15. </span>interfacetracer-fail.py (start)</h5>
<pre data-type="programlisting">class Tracer:
    def __init__(self, aClass):               <code><em># On @decorator
</em></code>        self.aClass = aClass                  <code><em># Use instance attribute</em></code>
    def __call__(self, *args):                <code><em># On instance creation</em></code>
        self.wrapped = self.aClass(*args)     <code><em># ONE (LAST) INSTANCE PER CLASS!</em></code>
        return self
    def __getattr__(self, attrname):
        print('Trace:', attrname)
        return getattr(self.wrapped, attrname)

@Tracer                                       <code><em># Triggers __init__</em></code>
class Hack:                                   <code><em># Like: Hack = Tracer(Hack)</em></code>
    def display(self):
        print('Hack!' * 3)

work = Hack()                                 <code><em># Triggers __call__</em></code>
work.display()                               <code> <em># Triggers __getattr__</em></code></pre>
</div>
<p>As we saw in the abstract earlier, though, this class-only alternative handles multiple <em>classes</em> as before, but it won’t quite work for multiple <em><em>instances</em></em> of a given class: each instance-creation call triggers <code>__call__</code>, which overwrites the prior instance. The net effect is that <code>Tracer</code> saves just one instance—the last one created. <a data-type="xref" href="#example_threenine_onesixdot_interfacetr">Example 39-16</a> extends this file to demo the problem.</p>
<div data-type="example" id="example_threenine_onesixdot_interfacetr">
<h5><span class="label">Example 39-16. </span>interfacetracer-fail.py (continued)</h5>
<pre data-type="programlisting">@Tracer
class Person:                                 <code><em># Person = Tracer(Person)</em></code>
    def __init__(self, name):                 <code><em># Person rebound to a Tracer</em></code>
        self.name = name

bob = Person('Bob')                           <code><em># bob is really a Tracer</em></code>
print(bob.name)                               <code><em># Tracer embeds a Person
</em></code>sue = Person('Sue')
print(sue.name)                               <code><em># sue overwrites bob</em></code>
print(bob.name)                               <code><em># OOPS: now bob's name is 'Sue'!</em></code></pre>
</div>
<p>This code’s output follows—because this tracer only has a single shared instance, the second overwrites the first:</p>
<pre data-type="programlisting">$ <code><strong>python3 interfacetracer-fail.py</strong></code> 
Trace: display
Hack!Hack!Hack!
Trace: name
Bob
Trace: name
Sue
Trace: name
Sue</pre>
<p>The problem here is bad <em>state retention</em>—we make one decorator instance per class but not per class instance, such that only the last instance is retained. The solution, as in our prior class pitfall for decorating methods, lies in abandoning class-based decorators.</p>
<p>The earlier function-based <code>Tracer</code> version of <a data-type="xref" href="#example_threenine_onefourdot_interfacet">Example 39-14</a>, however, <em>does</em> work for multiple instances. Because it returns a <em>class</em> instead of an <em>instance</em> of that class, each instance-creation call makes a new <code>Wrapper</code> instance instead of overwriting the state of a single shared <code>Tracer</code> instance. The original nondecorator <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="class decorators" data-tertiary="instances, multiple" data-startref="drtcdstm" id="id4850"></a><a contenteditable="false" data-type="indexterm" data-primary="class decorators" data-secondary="instances, multiple" data-startref="cldstcmp" id="id4851"></a><a contenteditable="false" data-type="indexterm" data-primary="instances" data-secondary="class decorators" data-startref="istmpcld" id="id4852"></a>version handles multiple instances correctly for the same reason. The moral here: decorators are not only arguably magical, they can also be incredibly subtle!</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Example: “Private” and “Public” Attributes"><div class="sect1" id="example_quotation_markprivatequotation">
<h1>Example: “Private” and “Public” Attributes</h1>
<p>The final two sections of this chapter present larger examples of decorator use, which give us a chance to see how concepts come together in more useful code. Both are presented with minimal description, partly to conserve space but mostly because you should already understand decorator basics well enough to be able to study these on your own.</p>
<section data-type="sect2" data-pdf-bookmark="Implementing Private Attributes"><div class="sect2" id="implementing_private_attributes">
<h2>Implementing Private Attributes</h2>
<p>First up, the <em>class decorator</em> in <a data-type="xref" href="#example_threenine_onesevendot_accessone">Example 39-17</a> implements a <code>Private</code> declaration <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="class decorators" data-tertiary="private attributes" id="dcpvtg"></a><a contenteditable="false" data-type="indexterm" data-primary="class decorators" data-secondary="private attributes" id="cldcpvtr"></a><a contenteditable="false" data-type="indexterm" data-primary="attributes" data-secondary="private, class decorators" id="atpvcdc"></a>and access checks for class instance attributes—that is, for attributes stored on an instance, or inherited from one of its classes.</p>
<p>This decorator disallows fetch and change access to such attributes from <em>outside</em> the decorated class but still allows the class itself to access those names freely within its own methods. It’s not quite the same as “private” in C++ or Java—and Python is not about control in general—but this decorator demo provides similar access validations as an option in Python for the rare and atypical cases where this might be useful during development.</p>
<p>We saw an initial and incomplete implementation of instance attribute privacy for <em>changes</em> only in <a data-type="xref" href="ch30.html#operator_overloading-id000103">Chapter 30</a>. The version here extends this concept to validate attribute <em>fetches</em>, too, and it uses delegation instead of inheritance to implement the model. In a sense, this is also just an extension to the attribute-tracer class decorator we met earlier.</p>
<p>Although this example utilizes the syntactic sugar of class decorators to code attribute privacy, its attribute interception is ultimately still based upon the <code>__getattr__</code> and <code>__setattr__</code> operator-overloading methods we met in prior chapters. When a private attribute access is detected, this version uses the <code>raise</code> statement to raise an exception, along with an error message; the exception may be caught in a <code>try</code> or allowed to terminate the accessing script.</p>
<p><a data-type="xref" href="#example_threenine_onesevendot_accessone">Example 39-17</a> lists the decorator’s first-cut code, along with a self-test at the bottom of the file. As coded, it catches all explicit attribute fetches, but not the implicit fetches of built-in operations (more on this in a moment).</p>
<div data-type="example" id="example_threenine_onesevendot_accessone">
<h5><span class="label">Example 39-17. </span>access1.py</h5>
<pre data-type="programlisting">"""
Class decorator with Private attribute declarations.

Privacy for attributes fetched from class instances.
See self-test code at end of file for a usage example.

Rebinding is: Doubler = Private('data', 'size')(Doubler).
Private returns onDecorator, onDecorator returns onInstance,
and each onInstance instance embeds a new Doubler instance.
"""

traceMe = False
def trace(*args):
    if traceMe: print(f'[{' '.join(map(str, args))}]')   <em># Python 3.12+ f-string</em>

def Private(*privates):                              <code><em># privates in enclosing scope</em></code>
    def onDecorator(aClass):                         <code><em># aClass in enclosing scope</em></code>
        class onInstance:                            <code><em># wrapped in instance attribute</em></code>
            def __init__(self, *args, **kargs):
                self.wrapped = aClass(*args, **kargs)

            def __getattr__(self, attr):             <code><em># My attrs don't call getattr</em></code>
                trace('get:', attr)                  <code><em># Others assumed in wrapped</em></code>
                if attr in privates:
                    raise TypeError('private attribute fetch, ' + attr)
                else:
                    return getattr(self.wrapped, attr)

            def __setattr__(self, attr, value):             <code><em># Outside accesses</em></code>
                trace('set:', attr, value)                  <code><em># Others run normally</em></code>
                if attr == 'wrapped':                       <code><em># Allow my attrs</em></code>
                    self.__dict__[attr] = value             <code><em># Avoid looping
</em></code>                elif attr in privates:
                    raise TypeError('private attribute change, ' + attr)
                else:
                    setattr(self.wrapped, attr, value)      <code><em># Wrapped obj attrs</em></code>
        return onInstance
    return onDecorator


if __name__ == '__main__':
    traceMe = True

    @Private('data', 'size')                   <code><em># Doubler = Private(...)(Doubler)</em></code>
    class Doubler:
        def __init__(self, label, start):
            self.label = label                 <code><em># Accesses inside the subject class</em></code>
            self.data  = start                 <code><em># Not intercepted: run normally</em></code>
        def size(self):
            return len(self.data)              <code><em># Method bodies run with no checking</em></code>
        def double(self):                      <code><em># Because privacy not inherited</em></code>
            for i in range(self.size()):
                self.data[i] = self.data[i] * 2
        def display(self):
            print(f'{self.label} =&gt; {self.data}')

    print('Making instances...')
    X = Doubler('X is', [1, 2, 3])
    Y = Doubler('Y is', [-10, -20, -30])

    <code><em># The following all succeed properly</em></code>

    print('\nExploring X instance...')
    print(X.label)                             <code><em># Accesses outside subject class</em></code>
    X.display(); X.double(); X.display()       <code><em># Intercepted: validated, delegated</em></code>

    print('\nExploring Y instance...')
    print(Y.label)
    Y.display(); Y.double()
    Y.label = 'Hack'
    Y.display()

    <code><em># The following all fail properly</em></code>
    """
    print(X.size())          <code><em># Prints "TypeError: private attribute fetch, size"</em></code>
    print(X.data)
    X.data = [1, 1, 1]       <code><em># Prints "TypeError: private attribute change, data"</em></code>
    X.size = lambda S: 0
    print(Y.data)
    print(Y.size())
    """</pre>
</div>
<p>When its <code>traceMe</code> is <code>True</code>, the module file’s self-test code produces the following output. Notice how the decorator catches and validates both attribute fetches and assignments run <em>outside</em> of the wrapped class but does not catch attribute accesses <em>inside</em> the class itself:</p>
<pre data-type="programlisting">$ <code><strong>python3 access1.py</strong></code>
Making instances...
[set: wrapped &lt;__main__.Doubler object at 0x1059c7d70&gt;]
[set: wrapped &lt;__main__.Doubler object at 0x1059c7da0&gt;]

Exploring X instance...
[get: label]
X is
[get: display]
X is =&gt; [1, 2, 3]
[get: double]
[get: display]
X is =&gt; [2, 4, 6]

Exploring Y instance...
[get: label]
Y is
[get: display]
Y is =&gt; [-10, -20, -30]
[get: double]
[set: label Hack]
[get: display]
Hack =&gt; [-20, -40, -60]</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Implementation Details I"><div class="sect2" id="implementation_details_i">
<h2>Implementation Details I</h2>
<p>This code is nontrivial, and you’re probably best off tracing through it on your own to see how it works. To help you study, though, here are a few highlights worth mentioning.</p>
<section data-type="sect3" data-pdf-bookmark="Inheritance versus delegation"><div class="sect3" id="inheritance_versus_delegation">
<h3>Inheritance versus delegation</h3>
<p>The initial and limited privacy example <a contenteditable="false" data-type="indexterm" data-primary="inheritance" data-secondary="versus delegation" data-secondary-sortas="delegation" id="id4853"></a><a contenteditable="false" data-type="indexterm" data-primary="delegation" data-secondary="versus inheritance" data-secondary-sortas="inheritance" id="id4854"></a>shown in <a data-type="xref" href="ch30.html#operator_overloading-id000103">Chapter 30</a> used <em>inheritance</em> to mix in a <code>__setattr__</code> to catch accesses. Inheritance makes this difficult, however, because differentiating between accesses from inside or outside the class is not straightforward (inside access should be allowed to run normally, and outside access should be restricted). To work around this, the <a data-type="xref" href="ch30.html#operator_overloading-id000103">Chapter 30</a> example requires inheriting classes to use <code>__dict__</code> assignments to set attributes—an incomplete solution at best.</p>
<p>The version here uses <em>delegation</em> (embedding one object inside another) instead of inheritance; this pattern is better suited to our task as it makes it much easier to distinguish between accesses inside and outside of the subject class. Attribute accesses from outside the subject class are intercepted by the wrapper layer’s overloading methods and delegated to the class if valid. Accesses inside the class itself (i.e., through <code>self</code> within its methods’ code) are not intercepted and are allowed to run normally without checks because privacy is not inherited in this version.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Decorator arguments"><div class="sect3" id="decorator_arguments-id00089">
<h3>Decorator arguments</h3>
<p>The class decorator used here <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="class decorators" data-tertiary="arguments" id="id4855"></a><a contenteditable="false" data-type="indexterm" data-primary="class decorators" data-secondary="arguments" id="id4856"></a><a contenteditable="false" data-type="indexterm" data-primary="arguments" data-secondary="decorators" data-tertiary="class decorators" id="id4857"></a>accepts any number of arguments to name private attributes. Again, though, this simply means that the arguments are passed to the <code>Private</code> function, and <code>Private</code> returns the decorator function to be applied to the subject class. That is, the arguments are used before decoration ever occurs; <code>Private</code> returns the decorator, which in turn “remembers” the privates list as an enclosing-scope reference.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="State retention and enclosing scopes"><div class="sect3" id="state_retention_and_enclosing_scopes">
<h3>State retention and enclosing scopes</h3>
<p>Speaking of enclosing scopes, there are <a contenteditable="false" data-type="indexterm" data-primary="scopes" data-secondary="enclosing" data-tertiary="state retention and" id="id4858"></a><a contenteditable="false" data-type="indexterm" data-primary="enclosing scopes" data-secondary="state retention and" id="id4859"></a><a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="class decorators" data-tertiary="state, enclosing scopes and" id="id4860"></a><a contenteditable="false" data-type="indexterm" data-primary="class decorators" data-secondary="state, enclosing scopes and" id="id4861"></a>actually <em>three levels</em> of state retention at work in this code:</p>
<ul>
<li><p>The arguments to <code>Private</code> are used before decoration occurs and are retained as an enclosing-scope reference for use in both <code>onDecorator</code> and <code>onInstance</code>.</p></li>
<li><p>The class argument to <code>onDecorator</code> is used at decoration time and is retained as an enclosing-scope reference for use at instance-creation time.</p></li>
<li><p>The wrapped instance object is retained as an instance attribute in the <code>onInstance</code> proxy object for use when attributes are later accessed from outside the class.</p></li>
</ul>
<p>This all works fairly naturally, given Python’s scope and namespace rules.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Using __dict__ and __slots__ (and other virtuals)"><div class="sect3" id="using_dict_and_slots_left_paren">
<h3>Using __dict__ and __slots__ (and other virtuals)</h3>
<p>The <code>__setattr__</code> method in this code relies on an instance object’s <code>__dict__</code> attribute namespace dictionary in order to set <code>onInstance</code>’s own <code>wrapped</code> attribute. As we learned in the prior chapter, this method cannot assign an attribute directly without looping. However, it uses the <code>setattr</code> built-in instead of <code>__dict__</code> to set attributes in the <em>wrapped</em> object itself. Moreover, <code>getattr</code> is used to fetch attributes in the <em>wrapped</em> object since they may be stored in the object itself or inherited by it.</p>
<p>Because of that, this code will work for most classes—including those with “virtual” class-level attributes based on <em>slots</em>, <em>properties</em>, <em>descriptors</em>, and even <code>__getattr__</code> and its ilk. By assuming a namespace dictionary for itself only and using storage-neutral tools for the wrapped object, the wrapper class avoids limitations imposed by other tools.</p>
<p>For example, you may recall from <a data-type="xref" href="ch32.html#class_odds_and_ends">Chapter 32</a> that classes with <code>__slots__</code> may not store attributes in a <code>__dict__</code>, and in fact, may not even have one of these at all. However, because we rely on a <code>__dict__</code> only at the <code>onInstance</code> level here and not in the wrapped instance, this concern does not apply. Class <code>onInstance</code> will have a <code>__dict__</code> itself because it does not use slots. In addition, because <code>setattr</code> and <code>getattr</code> apply to attributes based on both <code>__dict__</code> and <code>__slots__</code>, our decorator applies to wrapped classes using either storage scheme.</p>
<p>By the same reasoning, the decorator also applies to properties and similar tools: delegated names will be looked up anew in the wrapped instance, irrespective of attributes of the <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="class decorators" data-tertiary="private attributes" data-startref="dcpvtg" id="id4862"></a><a contenteditable="false" data-type="indexterm" data-primary="class decorators" data-secondary="private attributes" data-startref="cldcpvtr" id="id4863"></a><a contenteditable="false" data-type="indexterm" data-primary="attributes" data-secondary="private, class decorators" data-startref="atpvcdc" id="id4864"></a>decorator proxy object itself.</p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Generalizing for Public Declarations"><div class="sect2" id="generalizing_for_public_declarations">
<h2>Generalizing for Public Declarations</h2>
<p>Now that we have a <code>Private</code> attribute implementation, it’s straightforward to generalize the code to <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="class decorators" data-tertiary="public attributes" id="drtrccd"></a><a contenteditable="false" data-type="indexterm" data-primary="class decorators" data-secondary="public attributes" id="cdpbbtt"></a><a contenteditable="false" data-type="indexterm" data-primary="attributes" data-secondary="public, class decorators" id="atbbdcr"></a>allow for <code>Public</code> declarations too—they are essentially the inverse of <code>Private</code> declarations, so we need only negate the inner test. The example listed in <a data-type="xref" href="#example_threenine_oneeightdot_accesstwo">Example 39-18</a> allows a class to use decorators to define a set of either <code>Private</code> or <code>Public</code> instance attributes—attributes of any kind stored on an instance or inherited from its classes—with the following semantics:</p>
<ul>
<li><p><code>Private</code> declares attributes of a class’s instances that <em>cannot</em> be fetched or assigned except from within the code of the class’s methods. That is, any name declared <code>Private</code> cannot be accessed from outside the class, while any name not declared <code>Private</code> can be freely fetched or assigned from outside the class.</p></li>
<li><p><code>Public</code> declares attributes of a class’s instances that <em>can</em> be fetched or assigned from both outside the class and within the class’s methods. That is, any name declared <code>Public</code> can be freely accessed anywhere, while any name not declared <code>Public</code> cannot be accessed from outside the class.</p></li>
</ul>
<p><code>Private</code> and <code>Public</code> declarations are mutually exclusive: when using <code>Private</code>, all undeclared names are considered <code>Public</code>, and when using <code>Public</code>, all undeclared names are considered <span class="keep-together"><code>Private</code></span>. They are essentially opposites, though undeclared names not created by a class’s methods behave slightly <span class="keep-together">differently—new</span> names can be assigned and thus created outside the class under <span class="keep-together"><code>Private</code></span> (all undeclared names are accessible) but not under <code>Public</code> (all undeclared names are <span class="keep-together">inaccessible</span>).</p>
<p>Again, study this code on your own to get a feel for how this works. Notice that this scheme adds an additional <em>fourth level of state retention</em> at the top, beyond that described in the preceding section: the validation functions used by the <code>lambda</code>s are saved in an extra enclosing scope coded separately. This version comes with the same caveat as its predecessor for attributes of built-in operations, noted in the file’s docstring and expanded on after the example.</p>
<div data-type="example" id="example_threenine_oneeightdot_accesstwo">
<h5><span class="label">Example 39-18. </span>access2.py</h5>
<pre class="less_codespace1" data-type="programlisting">"""
Class decorator with Private and Public attribute declarations.

Controls external access to attributes stored on an instance, or
inherited by it from its classes.  Private declares attribute names
that cannot be fetched or assigned outside the decorated class,
and Public declares all the names that can.  Choose either decorator.

Caveat: as is, this works for explicitly-named attributes only.  The
__X__ operator-overloading methods fetched implicitly for built-in 
operations do not trigger either __getattr__ or __getattribute__, and
hence won't be delegated to any wrapped objects that define them.  If 
needed, add __X__ methods to catch and delegate built-ins (per ahead).
"""

traceMe = False
def trace(*args):
    if traceMe: print('[' + ' '.join(map(str, args)) + ']')

def accessControl(failIf):
    def onDecorator(aClass):
        class onInstance:
            def __init__(self, *args, **kargs):
                self.__wrapped = aClass(*args, **kargs)

            def __getattr__(self, attr):
                trace('get:', attr)
                if failIf(attr):
                    raise TypeError('private attribute fetch, ' + attr)
                else:
                    return getattr(self.__wrapped, attr)

            def __setattr__(self, attr, value):
                trace('set:', attr, value)
                if attr == '_onInstance__wrapped':
                    self.__dict__[attr] = value
                elif failIf(attr):
                    raise TypeError('private attribute change, ' + attr)
                else:
                    setattr(self.__wrapped, attr, value)
        return onInstance
    return onDecorator

def Private(*attributes):
    return accessControl(failIf=(lambda attr: attr in attributes))

def Public(*attributes):
    return accessControl(failIf=(lambda attr: attr not in attributes))</pre>
</div>
<p>See the prior example’s self-test code for a usage example—the effect is the same for <code>Private</code>. Here’s a quick look at these class decorators in action at the interactive prompt. As advertised, non-<code>Private</code> or <code>Public</code> names can be fetched and changed from outside the subject class, but <code>Private</code> or non-<code>Public</code> names cannot:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>from access2 import Private, Public</strong></code>

&gt;&gt;&gt; <code><strong>@Private('age')</strong></code>                             <code><em># Person = Private('age')(Person)</em></code>
... <code><strong>class Person:</strong></code>                               <code><em># Person = onInstance with state</em></code>
        <code><strong>def __init__(self, name, age):</strong></code>
            <code><strong>self.name = name</strong></code>
            <code><strong>self.age  = age</strong></code>                     <code><em># Inside accesses run normally</em></code>
 
&gt;&gt;&gt; <code><strong>X = Person('Pat', 40)</strong></code>
&gt;&gt;&gt; <code><strong>X.name           </strong>  </code>                         <code><em># Outside accesses validated</em></code>
'Pat'
&gt;&gt;&gt; <code><strong>X.name = 'Sue'</strong></code>
&gt;&gt;&gt; <code><strong>X.name</strong></code>
'Sue'
&gt;&gt;&gt; <code><strong>X.age</strong></code>
TypeError: private attribute fetch, age
&gt;&gt;&gt; <code><strong>X.age = 'Bob'</strong></code>
TypeError: private attribute change, age

&gt;&gt;&gt; <code><strong>@Public('name')</strong></code>
... <code><strong>class Person:</strong></code>
        <code><strong>def __init__(self, name, age):</strong></code>
            <code><strong>self.name = name</strong></code>
            <code><strong>self.age  = age</strong></code>
 
&gt;&gt;&gt; <code><strong>X = Person('Pat', 40)</strong></code>                       <code><em># X is an onInstance</em></code>
&gt;&gt;&gt; <code><strong>X.name</strong></code>                                      <code><em># onInstance embeds Person</em></code>
'Pat'
&gt;&gt;&gt; <code><strong>X.name = 'Sue'</strong></code>
&gt;&gt;&gt; <code><strong>X.name</strong></code>
'Sue'
&gt;&gt;&gt; <code><strong>X.age</strong></code>
TypeError: private attribute fetch, age
&gt;&gt;&gt; <code><strong>X.age = 'Bob'</strong></code>
TypeError: private attribute change, age</pre>
</div></section>
<section data-type="sect2" class="pagebreak-before" data-pdf-bookmark="Implementation Details II"><div class="sect2" id="implementation_details_ii">
<h2 class="less_space">Implementation Details II</h2>
<p>To help you analyze <a data-type="xref" href="#example_threenine_oneeightdot_accesstwo">Example 39-18</a>’s code, here are a few final notes on this version. Since this is just a generalization of the preceding section’s version, the implementation notes there apply here as well.</p>
<section data-type="sect3" data-pdf-bookmark="Using “__X” pseudoprivate names"><div class="sect3" id="using_x_pseudoprivate_names">
<h3>Using “__X” pseudoprivate names</h3>
<p>Besides generalizing, this version also makes <a contenteditable="false" data-type="indexterm" data-primary="__X pseudoprivate name mangling" data-primary-sortas="X pseudoprivate name mangling" id="id4865"></a>use of Python’s <code>__<em>X</em></code> pseudoprivate name mangling feature, which we met in <a data-type="xref" href="ch31.html#designing_with_classes">Chapter 31</a>, to localize the <code>wrapped</code> attribute to the proxy control class by automatically prefixing it with this class’s name. This avoids the prior version’s risk for collisions with a <code>wrapped</code> attribute that may be used by the real, wrapped class, and it’s useful in a general tool like this. It’s not quite “privacy,” though, because the mangled version of the name can be used freely outside the class. Notice that we also have to use the fully expanded name string—<code>'_onInstance__wrapped'</code>—as an admin-name test value in <code>__setattr__</code> because that’s what Python changes it to.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Breaking privacy"><div class="sect3" id="breaking_privacy">
<h3>Breaking privacy</h3>
<p>Although this example does implement access controls for attributes of an instance and its classes, <span class="keep-together">it is possible</span> to subvert these controls trivially—for instance, by fetching through the expanded version of the <code>wrapped</code> attribute explicitly (<code>bob.pay</code> might not work, but the fully mangled <span class="keep-together"><code>bob._onInstance__wrapped.pay</code></span> could!). If you have to try that hard to break them, though, these tools probably suffice for intended roles. Of course, privacy can generally be subverted in other languages too (e.g., <code>#define private public</code> may work in some C++ implementations). Although access controls may reduce accidental mods, much of this is up to programmers in any language; whenever source code may be changed, airtight access control will always be a pipe dream. More fundamentally, Python is about <em>enabling</em>, not controlling; privacy is a tool best used sparingly (if at all).</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Decorator trade-offs"><div class="sect3" id="decorator_trade_offs">
<h3>Decorator trade-offs</h3>
<p>We could again achieve the same results without decorators by using helper functions or coding the name rebinding of decorators manually; the decorator syntax, however, makes this consistent and obvious in code. The chief potential downsides of this and any other wrapper-based approach are that attribute access incurs an extra call, and instances of decorated classes are not really instances of the original decorated class—if you test their type with <code><em>X</em>.__class__</code> or <code>isinstance(<em>X</em>, <em>C</em>)</code>, for example, you’ll find that they are instances of the <em>wrapper</em> class. Unless you plan to do introspection on objects’ types, though, the type issue is irrelevant, and the extra call may apply mostly to development time; as you’ll see later, it’s possible to remove decorations automatically (via <code>-O</code>) if desired.</p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Delegating Built-In Operations"><div class="sect2" id="delegating_built_in_operations">
<h2>Delegating Built-In Operations</h2>
<p>As is, this section’s examples work as planned <a contenteditable="false" data-type="indexterm" data-primary="built-in operations" data-secondary="delegating" id="id4866"></a>for methods and other attributes fetched <em>explicitly</em> by name. As with most software, though, there is always room for improvement. Most notably, this tool turns in mixed performance on operator-overloading methods if they are used by client classes.</p>
<p>Specifically, the proxy class fails to validate or delegate operator-overloading methods fetched <em>implicitly</em> by built-in operations unless such methods are redefined in the proxy. Clients that do not use operator overloading are fully supported, but others may require additional code. It’s unclear that operator-overloading methods <em>should</em> be validated as private or public, but they are a part of an object’s interface and should at least be routed to wrapped objects that define them.</p>
<p>We’ve encountered this issue a few times already in this book, but let’s take a quick look at its impact on the realistic code we’ve written here and explore workarounds for it. The basic issue is easy to demo—as we’ve learned, the following is how a class that overloads <code>print</code> calls and <code>+</code> expressions normally works:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>class Tally:</strong></code>
<code> <strong>       def __init__(self):</strong></code>
<code> <strong>           self.sum = 0</strong></code>
<code> <strong>       def __str__(self):</strong></code>
<code> <strong>           return f'Tally: {self.sum}'</strong></code>
<code> <strong>       def __add__(self, add):</strong></code>
<code> <strong>           self.sum += add</strong></code>
 
&gt;&gt;&gt; <code><strong>X = Tally()</strong></code>
&gt;&gt;&gt; <code><strong>X.sum</strong>   </code>          <code><em># All attributes accessible</em></code>
0
&gt;&gt;&gt; <code><strong>print(X)</strong></code>          <code><em># Same as X.__str__() {sort of}</em></code>
Tally: 0
&gt;&gt;&gt; <code><strong>X + 5</strong>   </code>          <code><em># Same as X.__add__(5) {ditto}</em></code>
&gt;&gt;&gt; <code><strong>print(X)</strong></code>
Tally: 5</pre>
<p>Unfortunately, objects that implement built-in operations like this fail in our proxy classes because built-in operations <em>skip</em> instance-level lookup protocols like <code>__getattr__</code>, and instead search namespaces of classes:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>from access2 import Private</strong></code>
&gt;&gt;&gt; <code><strong>@Private('sum', '__add__')</strong></code>
... <code><strong>class Tally:</strong></code>
        …<code><em>same as before</em></code>…

&gt;&gt;&gt; <code><strong>X = Tally()</strong></code>
&gt;&gt;&gt; <code><strong>X.sum</strong></code>             
TypeError: private attribute fetch, sum

&gt;&gt;&gt; <code><strong>X.__add__(5)</strong></code>
TypeError: private attribute fetch, __add__

&gt;&gt;&gt; <code><strong>print(X)</strong></code>    
&lt;access2.accessControl.&lt;locals&gt;.onDecorator.&lt;locals&gt;.onInstance object at 0x…<code><em>etc</em></code>…&gt;
 
&gt;&gt;&gt; <code><strong>X + 5</strong></code>             
TypeError: unsupported operand type(s) for +: 'onInstance' and 'int'</pre>
<p>In this session, the first two <em>explicit</em> fetches of <code>sum</code> and <code>__add__</code> are kicked out as privates as they <em>should</em> be. Because the last two <em>implicit</em> fetches of <code>print</code> and <code>+</code> aren’t caught by the proxy, though, they are never delegated to the wrapped <code>Tally</code> object. The <code>print</code> here only works at all because it runs an <code>object</code> default to print the proxy itself. Per the prior chapter, this is an inconsistency in Python; per the following sections, it can also be avoided in full.</p>
<section data-type="sect3" data-pdf-bookmark="Workaround: Coding operator-overloading methods inline"><div class="sect3" id="workaround_coding_operator-id00085">
<h3>Workaround: Coding operator-overloading methods inline</h3>
<p>The most straightforward way to support built-ins in delegation proxies is to redefine operator-overloading <a contenteditable="false" data-type="indexterm" data-primary="operator overloading" data-secondary="methods" data-tertiary="inline coding" id="opvlinl"></a><a contenteditable="false" data-type="indexterm" data-primary="built-in operations" data-secondary="delegating" data-tertiary="operator overloading methods" id="opdgopov"></a>names that may appear in embedded objects. This creates some code redundancy, but it isn’t impossibly onerous; can be automated with tools or superclasses; and can choose to run or skip validations for operator-overloading names declared <code>Private</code> or <code>Public</code>, depending on redefinitions’ routing.</p>
<p>For instance, the partial listing of <a data-type="xref" href="#example_threenine_oneninedot_access_bui">Example 39-19</a> sketches an <em>inline</em> redefinition approach—it catches and delegates built-ins by adding method definitions to the proxy itself for every operator-overloading method a wrapped object may define. It adds just four operation interceptors to illustrate, but others are similar (in this section, new code is in bold font, and all examples are based on the decorator of <em>access2.py</em> in <a data-type="xref" href="#example_threenine_oneeightdot_accesstwo">Example 39-18</a>).</p>
<div data-type="example" id="example_threenine_oneninedot_access_bui">
<h5><span class="label">Example 39-19. </span>access_builtins_inline_direct.py</h5>
<pre data-type="programlisting"><code>"Inline methods, skip validations"</code>

def accessControl(failIf):
    def onDecorator(aClass):
        class onInstance:
            def __init__(self, *args, **kargs):
                self.__wrapped = aClass(*args, **kargs)

<code> <em>           # Intercept and delegate built-in implicit access specifically</em></code>
<code><em>
</em> <strong>           def __add__(self, other):
                return self.__wrapped + other</strong></code>           <code><em># Or getattr(), __getattr__()</em></code>
            <code><strong>def __str__(self):
                return str(self.__wrapped)</strong></code>              <code><em># Or self.__wrapped.__str__()</em></code>
            <code><strong>def __getitem__(self, index):
                return self.__wrapped[index]</strong></code>
            <code><strong>def __call__(self, *args, **kargs):
                return self.__wrapped(*args, **kargs)</strong></code>
            <code><em># Plus any others needed</em></code>

            <code><em># Intercept and delegate explicit attribute access generically</em></code>

            def __getattr__(self, attr): …<code><em>same</em></code>…
            def __setattr__(self, attr, value): …<code><em>same</em></code>…
        return onInstance
    return onDecorator</pre>
</div>
<p>This works because built-ins will find their requisite methods in the proxy <em>class</em> after skipping the proxy instance. As coded, the new interceptor methods trigger the wrapped object’s operator-overloading methods <em>directly</em> and so bypass the access controls of <code>__getattr__</code>, which may or may not be desirable. For <a contenteditable="false" data-type="indexterm" data-primary="operator overloading" data-secondary="methods" data-tertiary="inline coding" data-startref="opvlinl" id="id4867"></a>alternative codings, let’s move on.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Workaround: Coding operator-overloading methods in superclasses"><div class="sect3" id="workaround_coding_operator-id000119">
<h3>Workaround: Coding operator-overloading methods in superclasses</h3>
<p>More usefully, the prior section’s <a contenteditable="false" data-type="indexterm" data-primary="operator overloading" data-secondary="methods" data-tertiary="superclasses" id="opvlspcr"></a><a contenteditable="false" data-type="indexterm" data-primary="superclasses" data-secondary="operator overloading method coding" id="spcoomc"></a>added methods can be added by a common <em>superclass</em>. Given that there are dozens of such methods, an external class may be better suited to the task, especially if it is general enough to be used in any such interface-proxy class.</p>
<p>To demo, the superclass of <a data-type="xref" href="#example_threenine_twozerodot_access_bui">Example 39-20</a> catches built-ins and reroutes to the wrapped object <em>directly</em> again. It’s largely just a repackaging of the prior section’s inline scheme, but as a separate class it requires a proxy attribute named <code>_wrapped</code>, giving access to the embedded object. The decorator itself must use this name instead of <code>__wrapped</code> in <code>self</code> references, and sans mangling in <code>__setattr__</code>. This may be subpar because it precludes the same name in wrapped objects and creates a subclass dependency, but it’s better than using the mangled and subclass-specific <code>_onInstance__wrapped</code> and is no worse than a similarly named method.</p>
<div data-type="example" id="example_threenine_twozerodot_access_bui">
<h5><span class="label">Example 39-20. </span>access_builtins_mixin_direct.py</h5>
<pre data-type="programlisting"><code>"Inherit methods, skip validations"</code>

<code><strong>class BuiltinsMixin:
    def __add__(self, other):
        return self._wrapped + other</strong></code>                          <code><em># Assume a _wrapped</em></code>
    <code><strong>def __str__(self):</strong></code>                                        <code><em># Bypass __getattr__</em></code>
        <code><strong>return str(self._wrapped)
    def __getitem__(self, index):
        return self._wrapped[index]
    def __call__(self, *args, **kargs):
        return self._wrapped(*args, **kargs)
</strong></code>    <code><em># Plus any others needed</em></code>

def accessControl(failIf):
    def onDecorator(aClass):
        <code><strong>class onInstance(BuiltinsMixin):</strong></code>
            …<code><em>rest same, but use unmangled _wrapped instead of __wrapped</em></code>…</pre>
</div>
<p>Alternatively, the superclass in <a data-type="xref" href="#example_threenine_twoonedot_access_buil">Example 39-21</a> catches built-ins and reroutes them down through the subclass <code>__getattr__</code> to apply its access controls to the operation’s method name. It requires that operator-overloading names be non-<code>Private</code> or <code>Public</code> per the decorator’s arguments if they are to be run, but it treats the implicit fetches of built-in operations the same as explicit-name fetches, and no <code>_wrapped</code> is required in subclasses.</p>
<div data-type="example" id="example_threenine_twoonedot_access_buil">
<h5><span class="label">Example 39-21. </span>access_builtins_mixin_getattr.py</h5>
<pre data-type="programlisting"><code>"Inherit methods, run validations"</code>

<code><strong>class BuiltinsMixin:
    def __add__(self, other):
        return self.__getattr__('__add__')(other)</strong>   </code>          <code><em># Route to validator</em><strong>
    def __str__(self):             </strong>  </code>                         <code><em># Finish operations</em><strong>
        return self.__getattr__('__str__')()
    def __getitem__(self, index):
        return self.__getattr__('__getitem__')(index)
    def __call__(self, *args, **kargs):
        return self.__getattr__('__call__')(*args, **kargs)</strong></code>
    <code><em># Plus any others needed</em></code>

def accessControl(failIf):
    def onDecorator(aClass):
        <code><strong>class onInstance(BuiltinsMixin):</strong>  </code>                    <code><em># Inherit methods</em></code>
            …<code><em>rest unchanged</em></code>…</pre>
</div>
<p>Like the inline approach, both of these mix-ins also require one method per built-in operation in general tools <a contenteditable="false" data-type="indexterm" data-primary="operator overloading" data-secondary="methods" data-tertiary="superclasses" data-startref="opvlspcr" id="id4868"></a><a contenteditable="false" data-type="indexterm" data-primary="superclasses" data-secondary="operator overloading method coding" data-startref="spcoomc" id="id4869"></a>that proxy arbitrary objects’ interfaces. The next idea does marginally better.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Workaround: Generating operator-overloading descriptors"><div class="sect3" id="workaround_generating_operator_overload">
<h3>Workaround: Generating operator-overloading descriptors</h3>
<p>Finally, all of the inline and mix-in workarounds for built-ins we’ve seen so far code each operator-overloading <a contenteditable="false" data-type="indexterm" data-primary="operator overloading" data-secondary="descriptors" id="povoor"></a><a contenteditable="false" data-type="indexterm" data-primary="descriptors" data-secondary="operator overloading" id="scppvld"></a>method explicitly, and intercept the actual <em>call</em> issued for the operation, including its arguments. That makes them responsible for completing the operation, whether by operation syntax or equivalent calls.</p>
<p>With an alternative coding, we could instead intercept only the attribute <em>fetch</em> preceding the call by using the class-level <em>descriptors</em> of the prior chapter. Moreover, because all such descriptors will run the same, they can be generated automatically from a list of method names. <a data-type="xref" href="#example_threenine_twotwodot_access_buil">Example 39-22</a> shows one way to code this scheme. Like <a data-type="xref" href="#example_threenine_twoonedot_access_buil">Example 39-21</a>, it routes built-in operations through the decorator’s validations logic to <em>apply</em> private or public checks.</p>
<div data-type="example" id="example_threenine_twotwodot_access_buil">
<h5><span class="label">Example 39-22. </span>access_builtins_mixin_desc.py</h5>
<pre data-type="programlisting"><code>"Inherit descriptors, run validations"</code>

<code><strong>class BuiltinsMixin:
    class ProxyDesc:               </strong>  </code>                         <code><em># Define descriptor</em></code>
        <code><strong>def __init__(self, attrname):
            self.attrname = attrname
        def __get__(self, instance, owner):</strong></code>
            <code><strong>return instance.__getattr__(self.attrname)</strong></code>        <code><em># Run validations</em></code>

    <code><strong>builtins = ['add', 'str', 'getitem', 'call']</strong></code>              <code><em># Plus any others</em></code>
    <code><strong>for attr in builtins:
        exec(f'__{attr}__ = ProxyDesc("__{attr}__")')</strong></code>         <code><em># Make descriptors</em></code>

def accessControl(failIf):
    def onDecorator(aClass):
        <code><strong>class onInstance(BuiltinsMixin):</strong>  </code>                    <code><em># Inherit descriptors</em></code>
            …<code><em>rest unchanged</em></code>…</pre>
</div>
<p>This coding may be the most concise but also the most implicit and complex. Recall that the <code>exec</code> built-in by default runs a string of code as if the string was somehow pasted where the <code>exec</code> appears. Hence, the loop at the end of this mix-in class is equivalent to the following statements, run in the mix-in class’s local scope:</p>
<pre data-type="programlisting">    __add__ = ProxyDesc("__add__")
    __str__ = ProxyDesc("__str__")
    …<code><em>etc</em></code>…</pre>
<p>The net effect creates inherited descriptor instances that respond to initial name lookups by fetching from the wrapped object in <code>__get__</code> rather than catching the later operation call itself (which happens after this step). If you still find this code confusing (and you probably should), it’s equivalent to this stripped-down version, though the <code>name</code> fetch occurs implicitly in a built-in operation that skips the instance’s protocols:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>class B:</strong></code>
<code> <strong>       class D:</strong></code>
<code> <strong>           def __get__(s, i, o): return i.meth()</strong></code>
<code> <strong>       name = D()</strong></code>
 
&gt;&gt;&gt; <code><strong>class A(B):</strong></code>
<code> <strong>       def meth(self): return 'hack'</strong></code>
 
&gt;&gt;&gt; <code><strong>I = A()</strong></code>
&gt;&gt;&gt; <code><strong>I.name</strong></code>
'hack'</pre>
<p>We could also <em>skip</em> the decorator’s validations for built-in operations in this scheme by routing attribute fetches directly to the wrapped object—though this requires an accessible <code>_wrapped</code> in the decorator just like <a data-type="xref" href="#example_threenine_twozerodot_access_bui">Example 39-20</a>:</p>
<pre data-type="programlisting">    class ProxyDesc:                                             
        …
        def __get__(self, instance, owner):
            return getattr(instance._wrapped, self.attrname)     <code><em># Assume a _wrapped</em></code></pre>
<p>In the end, all of these workarounds make classes that overload built-in operations work correctly with our private and public decorators—and other delegation-based decorators like them:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>from access_builtins_mixin_desc import Private</strong></code>

&gt;&gt;&gt; <code><strong>@Private('sum')</strong></code>
... <code><strong>class Tally:</strong></code> 
<code> <strong>       def __init__(self):</strong></code>
<code> <strong>           self.sum = 0</strong></code>
<code> <strong>       def __str__(self):</strong></code>
<code> <strong>           return f'Tally: {self.sum}'</strong></code>
<code> <strong>       def __add__(self, add):</strong></code>
<code> <strong>           self.sum += add</strong></code>

&gt;&gt;&gt; <code><strong>X = Tally()</strong></code>
&gt;&gt;&gt; <code><strong>X.sum               </strong>  </code>                         <code><em># Explicit validated</em></code>
TypeError: private attribute fetch, sum
&gt;&gt;&gt; <code><strong>X + 10              </strong>  </code>                         <code><em># Built-in delegated</em></code>
&gt;&gt;&gt; <code><strong>print(X)            </strong>  </code>                         <code><em># Built-in delegated</em></code>
Tally: 10</pre>
<p>Public (nonprivate) built-ins are now delegated and work, but private built-ins are validated and <span class="keep-together">canceled</span>:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>@Private('sum', '__add__')</strong></code>
... <code><strong>class Tally:</strong></code> 
        …<code><em>same as before</em></code>…

&gt;&gt;&gt; <code><strong>X = Tally()</strong></code>
&gt;&gt;&gt; <code><strong>X.sum               </strong>  </code>                         <code><em># Explicit validated</em></code>
TypeError: private attribute fetch, sum
&gt;&gt;&gt; <code><strong>X + 10              </strong>  </code>                         <code><em># Built-in canceled: private</em></code>
TypeError: private attribute fetch, __add__
&gt;&gt;&gt; <code><strong>print(X)            </strong>  </code>                         <code><em># Built-in allowed: public</em></code>
Tally: 0

&gt;&gt;&gt; <code><strong>@Private('__str__')</strong></code>
... <code><strong>class Tally:</strong></code> 
        …<code><em>same as before</em></code>…

&gt;&gt;&gt; <code><strong>print(Tally())      </strong>  </code>                         <code><em># Built-in canceled: private</em></code>
TypeError: private attribute fetch, __str__</pre>
<p>If you care to experiment further with this section’s examples, see the book examples package for their complete code, as well as its comprehensive <em>access_builtins_TEST.py</em> test script and results. Here, it’s time to move on to this chapter’s next <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="class decorators" data-tertiary="public attributes" data-startref="drtrccd" id="id4870"></a><a contenteditable="false" data-type="indexterm" data-primary="class decorators" data-secondary="public attributes" data-startref="cdpbbtt" id="id4871"></a><a contenteditable="false" data-type="indexterm" data-primary="attributes" data-secondary="public, class decorators" data-startref="atbbdcr" id="id4872"></a><a contenteditable="false" data-type="indexterm" data-primary="built-in operations" data-secondary="delegating" data-tertiary="operator overloading methods" data-startref="opdgopov" id="id4873"></a><a contenteditable="false" data-type="indexterm" data-primary="operator overloading" data-secondary="descriptors" data-startref="povoor" id="id4874"></a><a contenteditable="false" data-type="indexterm" data-primary="descriptors" data-secondary="operator overloading" data-startref="scppvld" id="id4875"></a>and final decorators case study.</p>
</div></section>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Example: Validating Function Arguments"><div class="sect1" id="example_validating_function_arguments">
<h1>Example: Validating Function Arguments</h1>
<p>As a final example of the utility of decorators, this section develops a <em>function decorator</em> that <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="function decorators" data-tertiary="argument validation" id="dctrfguv"></a><a contenteditable="false" data-type="indexterm" data-primary="functions" data-secondary="arguments" data-tertiary="validation" id="vctgrvld"></a><a contenteditable="false" data-type="indexterm" data-primary="arguments" data-secondary="validation" id="argvld"></a><a contenteditable="false" data-type="indexterm" data-primary="function decorators" data-secondary="argument validation" id="fdcgvlad"></a>automatically tests whether arguments passed to a function or method are within a valid numeric range. It’s designed to be used during either development or production, and it can be used as a template for similar tasks (e.g., argument type testing, if you must). Again, this example is largely self-study content with a limited narrative; read the code for more details.</p>
<section data-type="sect2" data-pdf-bookmark="The Goal"><div class="sect2" id="the_goal">
<h2>The Goal</h2>
<p>In the object-oriented tutorial of <a data-type="xref" href="ch28.html#a_more_realistic_example">Chapter 28</a>, we wrote a class that gave a pay raise to objects representing fictitious people, based upon a passed-in percentage:</p>
<pre data-type="programlisting">class Person:
     …
     def giveRaise(self, percent):
        self.pay = int(self.pay * (1 + percent))</pre>
<p>There, we noted that if we wanted the code to be robust, it would be a good idea to check the percentage to make sure it’s not too large or too small. We could implement such a check with either <code>if</code> or <code>assert</code> statements in the method itself, using <em>inline tests</em>:</p>
<pre data-type="programlisting">class Person:
    def giveRaise(self, percent):                <code><em># Validate with inline code
</em></code>        if percent &lt; 0.0 or percent &gt; 1.0:
            raise TypeError, 'percent invalid'
        self.pay = int(self.pay * (1 + percent))

class Person:                                    <code><em># Validate with asserts</em></code>
    def giveRaise(self, percent):
        assert percent &gt;= 0.0 and percent &lt;= 1.0, 'percent invalid'
        self.pay = int(self.pay * (1 + percent))</pre>
<p>However, this approach clutters the method with inline tests that will probably be useful only during development. For more complex cases, this can become tedious (imagine trying to inline the code needed to implement the attribute privacy provided by the last section’s decorator). Perhaps worse, if the validation logic ever needs to change, there may be arbitrarily many inline copies to find and update.</p>
<p>A more useful and interesting alternative would be to develop a general tool that can perform range tests for us automatically for the arguments of any function or method we might code now or in the future. A <em>decorator</em> approach makes this explicit and convenient, and easy to disable once development is complete:</p>
<pre data-type="programlisting">class Person:
    @rangetest(percent=(0.0, 1.0))               <code><em># Use decorator to validate</em></code>
    def giveRaise(self, percent):
        self.pay = int(self.pay * (1 + percent))</pre>
<p>Isolating validation logic in a decorator simplifies both clients and future maintenance.</p>
<p>Notice that our goal here is different than the attribute validations coded in the prior chapter’s final example. Here, we mean to validate the values of <em>function arguments</em> when passed rather <a contenteditable="false" data-type="indexterm" data-primary="arguments" data-secondary="validation" data-startref="argvld" id="id4876"></a><a contenteditable="false" data-type="indexterm" data-primary="function decorators" data-secondary="argument validation" data-startref="fdcgvlad" id="id4877"></a>than <em>attribute values</em> when accessed. Python’s decorator and introspection tools allow us to code this new task just as easily.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="A Basic Range-Testing Decorator for Positional Arguments"><div class="sect2" id="a_basic_range_testing_decorator_for_pos">
<h2>A Basic Range-Testing Decorator for Positional Arguments</h2>
<p>Let’s start with a basic range-test implementation. To keep things simple, we’ll begin by coding a <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="range-testing" id="decorangt"></a><a contenteditable="false" data-type="indexterm" data-primary="range-testing decorator" id="rgttdct"></a><a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="function validation" data-tertiary="positional arguments" id="dcrfcdcprg"></a><a contenteditable="false" data-type="indexterm" data-primary="function validation" data-secondary="positional arguments" id="fucdrpgru"></a><a contenteditable="false" data-type="indexterm" data-primary="positional arguments" id="posargu"></a><a contenteditable="false" data-type="indexterm" data-primary="arguments" data-secondary="positional" id="rgumsit"></a>decorator that works only for <em>positional</em> arguments and assumes they always appear at the same position in every call; they cannot be passed by keyword name because this can invalidate the positions declared in the decorator. <a data-type="xref" href="#example_threenine_twothreedot_rangetest">Example 39-23</a> is our first-cut checker.</p>
<div data-type="example" id="example_threenine_twothreedot_rangetest">
<h5><span class="label">Example 39-23. </span>rangetest0.py</h5>
<pre data-type="programlisting">def rangetest(*argchecks):                  <code><em># Validate positional arg ranges</em></code>
    def onDecorator(func):
        if not __debug__:                   <code><em># True if "python -O main.py args..."
</em></code>            return func                     <code><em># No-op: call original directly</em></code>
        else:                               <code><em># Else wrapper while debugging</em></code>
            def onCall(*args):
                for (ix, low, high) in argchecks:
                    if args[ix] &lt; low or args[ix] &gt; high:
                        errmsg = f'Argument {ix} not in {low}..{high}'
                        raise TypeError(errmsg)
                return func(*args)
            return onCall
    return onDecorator</pre>
</div>
<p>As is, this code is mostly a rehash of the coding patterns we explored earlier: we use decorator <em>arguments</em>, nested <em>scopes</em> for state retention, and so on.</p>
<p>We also use nested <code>def</code> statements to ensure that this works for both simple functions and <em>methods</em>, as we learned earlier. When used for a class’s method, <code>onCall</code> receives the subject class’s instance in the first item in <code>*args</code> and passes this along to <code>self</code> in the original method function; explicitly passed argument numbers coded in the <code>@</code> decorator line start at 1 in this case, not 0, to accommodate the implicit <code>self</code>.</p>
<p>New here, notice this code’s use of the <code>__debug__</code> built-in variable introduced in <a data-type="xref" href="ch34.html#exception_coding_details">Chapter 34</a>. In brief, Python sets this variable to <code>True</code> unless the program is being run with the <code>–O</code> optimize command-line flag (e.g., <code>python –O main.py</code>). As discussed earlier, using options in the <code>compile</code> built-in function and <code>compileall</code> standard-library module before code is run can have a similar effect.</p>
<p>Either way, when <code>__debug__</code> is <code>False</code>, the decorator returns the original function unchanged to avoid extra later calls and their associated performance penalty. In other words, the decorator automatically <em>removes</em> its augmentation logic when <code>–O</code> or similar is used without requiring you to physically remove the decoration lines in your code.</p>
<p><a data-type="xref" href="#example_threenine_twofourdot_rangetestz">Example 39-24</a> demos how this first-iteration solution is used.</p>
<div data-type="example" id="example_threenine_twofourdot_rangetestz">
<h5><span class="label">Example 39-24. </span>rangetest0_test.py</h5>
<pre data-type="programlisting">from rangetest0 import rangetest
print(f'{__debug__=}')                     <code><em># False if "python -O main.py"
</em></code>
@rangetest((1, 0, 120))                    <code><em># persinfo = rangetest(...)(persinfo)
</em></code>def persinfo(name, age):                   <code><em># age must be in 0..120</em></code>
    print(f'{name} is {age} years old')

@rangetest([0, 1, 12], [1, 1, 31], [2, 0, 2024])
def birthday(M, D, Y):
    print(f'birthday = {M}/{D}/{Y}')

class Person:
    def __init__(self, name, job, pay):
        self.job  = job
        self.pay  = pay

    @rangetest([1, 0.0, 1.0])              <code><em># giveRaise = rangetest(...)(giveRaise)</em></code>
    def giveRaise(self, percent):          <code><em># Arg 0 is the self instance here</em></code>
        self.pay = int(self.pay * (1 + percent))

<code><em># Comment lines raise TypeError unless "python -O" used on shell command line
</em></code>
persinfo('Bob Smith', 45)                  <code><em># Really runs onCall(...) with state
</em></code>#persinfo('Bob Smith', 200)                <code><em># Or persinfo if -O cmd line argument</em></code>

birthday(8, 31, 2024)
#birthday(8, 32, 2024)

sue = Person('Sue Jones', 'dev', 100_000)
sue.giveRaise(.10)                         <code><em># Really runs onCall(self, .10)</em></code>
print(sue.pay)                             <code><em># Or giveRaise(self, .10) if -O
</em></code>#sue.giveRaise(1.10)</pre>
</div>
<p>When run, valid calls in this code produce the following output:</p>
<pre data-type="programlisting">$ <code><strong>python3 rangetest0_test.py</strong></code>
__debug__=True
Bob Smith is 45 years old
birthday = 8/31/2024
110000</pre>
<p>Uncommenting any of the invalid calls causes a <code>TypeError</code> to be raised by the decorator. Here’s the result when the last line is allowed to run (as usual, some of the error message text was trimmed here to save space):</p>
<pre data-type="programlisting">$ <code><strong>python3 rangetest0_test.py</strong></code>
__debug__=True
Bob Smith is 45 years old
birthday = 8/31/2024
110000
TypeError: Argument 1 not in 0.0..1.0</pre>
<p>Running Python with its <code>-O</code> flag at a system command line will disable range testing but also avoid the performance overhead of the wrapping layer—we wind up calling the original undecorated function directly. Assuming this is a debugging tool only, you can <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="function validation" data-tertiary="positional arguments" data-startref="dcrfcdcprg" id="id4878"></a><a contenteditable="false" data-type="indexterm" data-primary="function validation" data-secondary="positional arguments" data-startref="fucdrpgru" id="id4879"></a><a contenteditable="false" data-type="indexterm" data-primary="positional arguments" data-startref="posargu" id="id4880"></a><a contenteditable="false" data-type="indexterm" data-primary="arguments" data-secondary="positional" data-startref="rgumsit" id="id4881"></a>use this flag to optimize your program for production use. Here is the effect with the last line still run and a print added to show <code>sue</code>’s fantastical pay raise:</p>
<pre data-type="programlisting">$ <code><strong>python3 -O rangetest0_test.py</strong></code>
__debug__=False
Bob Smith is 45 years old
birthday = 8/31/2024
110000
231000</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Generalizing for Keywords and Defaults"><div class="sect2" id="generalizing_for_keywords_and_defaults">
<h2>Generalizing for Keywords and Defaults</h2>
<p>The prior version illustrates the basics we need to employ, but it’s fairly limited—it supports validating arguments passed <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="function validation" data-tertiary="keywords" id="drcfccr"></a><a contenteditable="false" data-type="indexterm" data-primary="function validation" data-secondary="keywords" id="fcdrkwy"></a><a contenteditable="false" data-type="indexterm" data-primary="keywords" data-secondary="function validation" id="kywfcdc"></a>by position only, and it does not validate keyword arguments (in fact, it assumes that no keywords are passed in a way that makes argument position numbers incorrect). Additionally, it does nothing about arguments with defaults that may be omitted in a given call. That’s fine if all your arguments are passed by position and never defaulted, but it’s less than ideal in a general tool. As we learned in <a data-type="xref" href="ch18.html#arguments">Chapter 18</a>, Python supports much more flexible argument-passing modes, which we’re not yet addressing.</p>
<p>The level up of our decorator in <a data-type="xref" href="#example_threenine_twofivedot_rangetestd">Example 39-25</a> does better. By matching the wrapped function’s expected arguments against the actual arguments passed in a call, it supports range validations for <span class="keep-together">arguments</span> passed by either position or keyword name, and it skips testing for default arguments omitted in the call. Arguments to be validated are specified by keyword arguments to the decorator itself, which later steps through both the call’s <code>*pargs</code> positionals tuple and its <code>**kargs</code> keywords dictionary to <span class="keep-together">validate</span>.</p>
<div data-type="example" id="example_threenine_twofivedot_rangetestd">
<h5><span class="label">Example 39-25. </span>rangetest.py</h5>
<pre data-type="programlisting">"""
A function decorator that performs range-test validation for
arguments passed to any function or method.  Usage synopsis:

    @rangetest(percent=(0.0, 1.0), month=(1, 12))
    def func-or-method(..., percent, ..., month=5, ...):
        ...
    func-or-method(..., value, month=8, ...)

Arguments are specified by keyword to the decorator. In the actual
call, arguments may be passed by position or keyword, and defaults
may be omitted.  See rangetest_test.py for example use cases.
"""
trace = True

def rangetest(**argchecks):                 <code><em># Validate ranges for both+defaults</em></code>
    def onDecorator(func):                  <code><em># onCall remembers func and argchecks</em></code>
        if not __debug__:                   <code><em># True if "python -O main.py args..."</em></code>
            return func                     <code><em># Wrap if debugging; else use original</em></code>
        else:
            funcname = func.__name__
            funccode = func.__code__
            funcargs = funccode.co_varnames[:funccode.co_argcount]

            def onCall(*pargs, **kargs):
<code> <em>               # All pargs match first N expected args by position</em></code>
<code> <em>               # The rest must be in kargs or be omitted defaults</em></code>
                positionals = funcargs[:len(pargs)]
                errormsg    = lambda *args: '%s argument "%s" not in %s..%s' % args

                for (argname, (low, high)) in argchecks.items():
<code> <em>                   # For all args to be checked</em></code>
                    if argname in kargs:
<code> <em>                       # Was passed by name</em></code>
                        if kargs[argname] &lt; low or kargs[argname] &gt; high:
                            raise TypeError(errormsg(funcname, argname, low, high))

                    elif argname in positionals:
<code> <em>                       # Was passed by position</em></code>
                        position = positionals.index(argname)
                        if pargs[position] &lt; low or pargs[position] &gt; high:
                            raise TypeError(errormsg(funcname, argname, low, high))

                    else:
<code> <em>                       # Assume not passed: default</em></code>
                        if trace:
                            print(f'-Argument "{argname}" defaulted')

                return func(*pargs, **kargs)    <code><em># OK: run original call</em></code>
            return onCall
    return onDecorator</pre>
</div>
<p>Next, the test script in <a data-type="xref" href="#example_threenine_twosixdot_rangetest_t">Example 39-26</a> shows how the decorator is used—arguments to be validated are given by keyword decorator arguments, and at actual calls, we can pass by name or position and omit arguments with defaults even if they are to be validated otherwise.</p>
<div data-type="example" id="example_threenine_twosixdot_rangetest_t">
<h5><span class="label">Example 39-26. </span>rangetest_test.py</h5>
<pre data-type="programlisting">"""
Test the rangetest decorator (usage differs from rangetest0).
Comment lines raise TypeError unless "python -O" or similar in compileall.
"""
from rangetest import rangetest
def announce(what): print(what.center(24, '-'))   <code><em># str method</em></code>

<code><em># Test functions, positional and keyword
</em></code>announce('Functions')

@rangetest(age=(0, 120))                  <code><em># persinfo = rangetest(...)(persinfo)
</em></code>def persinfo(name, age):
    print(f'{name} is {age} years old')

@rangetest(M=(1, 12), D=(1, 31), Y=(0, 2024))
def birthday(M, D, Y):
    print(f'birthday = {M}/{D}/{Y}')

persinfo('Pat', 40)
persinfo(age=40, name='Pat')
birthday(8, D=31, Y=2024)
#persinfo('Pat', 150)
#persinfo(age=150, name='Pat')
#birthday(8, Y=2025, D=40)

<code><em># Test methods, positional and keyword</em></code>
announce('Methods')

class Person:
    def __init__(self, name, job, pay):
        self.job  = job
        self.pay  = pay
                                          <code><em># giveRaise = rangetest(...)(giveRaise)</em></code>
    @rangetest(percent=(0.0, 1.0))        <code><em># percent passed by name or position
</em></code>    def giveRaise(self, percent):
        self.pay = int(self.pay * (1 + percent))

sue = Person('Sue Jones', 'dev', 100_000)
bob = Person('Bob Smith', 'dev', 100_000)
sue.giveRaise(percent=.20)
bob.giveRaise(.10)
print(f'sue=&gt;{sue.pay}, bob=&gt;{bob.pay}')
#sue.giveRaise(1.20)
#bob.giveRaise(percent=1.20)

<code><em># Test omitted defaults: skipped</em></code>
announce('Defaults')

@rangetest(a=(1, 10), b=(1, 10), c=(1, 10), d=(1, 10))
def omitargs(a, b=7, c=8, d=9):
    print(a, b, c, d)

omitargs(1, 2, 3, 4)           <code><em># Positionals
</em></code>omitargs(1, 2, 3)              <code><em># Default d</em></code>
omitargs(1, 2, 3, d=4)         <code><em># Keyword d</em></code>
omitargs(1, d=4)               <code><em># Default b and c</em></code>
omitargs(d=4, a=1)             <code><em># Ditto</em></code>
omitargs(1, b=2, d=4)          <code><em># Default c</em></code>
omitargs(d=8, c=7, a=1)        <code><em># Default b</em></code>

#omitargs(1, 2, 3, 11)         <code><em># Bad d</em></code>
#omitargs(1, 2, 11)            <code><em># Bad c</em></code>
#omitargs(1, 2, 3, d=11)       <code><em># Bad d</em></code>
#omitargs(11, d=4)             <code><em># Bad a</em></code>
#omitargs(d=4, a=11)           <code><em># Bad a
</em></code>#omitargs(1, b=11, d=4)        <code><em># Bad b</em></code>
#omitargs(d=8, c=7, a=11)      <code><em># Bad a</em></code></pre>
</div>
<p>When this script is run, out-of-range arguments raise an exception as before, but arguments may be passed by either name or position, and omitted defaults are not validated. Trace its output and test this further on your own to experiment; it works like its simpler predecessor, but its scope has been greatly broadened:</p>
<pre data-type="programlisting">$ <code><strong>python3 rangetest_test.py</strong></code>
-------Functions--------
Pat is 40 years old
Pat is 40 years old
birthday = 8/31/2024
--------Methods---------
sue=&gt;120000, bob=&gt;110000
--------Defaults--------
1 2 3 4
-Argument "d" defaulted
1 2 3 9
1 2 3 4
-Argument "b" defaulted
-Argument "c" defaulted
1 7 8 4
-Argument "b" defaulted
-Argument "c" defaulted
1 7 8 4
-Argument "c" defaulted
1 2 8 4
-Argument "b" defaulted
1 7 7 8</pre>
<p>Notice that argument checks are run in the <em>order</em> they are listed in the decorator because Python retains insertion order in dictionaries. On validation errors, we get an exception as before unless the <code>-O</code> command-line argument is passed to Python <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="function validation" data-tertiary="keywords" data-startref="drcfccr" id="id4882"></a><a contenteditable="false" data-type="indexterm" data-primary="function validation" data-secondary="keywords" data-startref="fcdrkwy" id="id4883"></a><a contenteditable="false" data-type="indexterm" data-primary="keywords" data-secondary="function validation" data-startref="kywfcdc" id="id4884"></a>to disable the decorator’s logic. Here’s the scene when one of the method-test lines is uncommented:</p>
<pre data-type="programlisting">$ <code><strong>python3 rangetest_test.py</strong></code>
-------Functions--------
Pat is 40 years old
Pat is 40 years old
birthday = 8/31/2024
--------Methods---------
sue=&gt;120000, bob=&gt;110000
TypeError: giveRaise argument "percent" not in 0.0..1.0

$ <code><strong>python3 -O rangetest_test.py</strong></code>
…<code><em>no error messages or default traces</em></code>…</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Implementation Details"><div class="sect2" id="implementation_details">
<h2>Implementation Details</h2>
<p>This range-tester decorator’s code relies on both introspection APIs and subtle constraints of argument passing. To be fully general, we could try to mimic Python’s argument-matching logic in its entirety to see which names have been passed in which modes, but that’s too much complexity for our tool and is prone to change over time. It would be better if we could somehow match the names of testable arguments given to the decorator against the names of actual arguments expected by the function to determine how the former map to the latter during a given call.</p>
<section data-type="sect3" data-pdf-bookmark="Function introspection"><div class="sect3" id="function_introspection-id00097">
<h3>Function introspection</h3>
<p>It turns out that the <a contenteditable="false" data-type="indexterm" data-primary="functions" data-secondary="introspection" id="id4885"></a><a contenteditable="false" data-type="indexterm" data-primary="introspection" data-secondary="functions" id="id4886"></a>introspection API available on function objects and their associated code objects has exactly the tool we need. This API was briefly introduced in <a data-type="xref" href="ch19.html#function_odds_and_ends">Chapter 19</a>, but we’ve actually put it to use here. The set of expected <em>argument names</em> is simply the first <em>N</em> variable names attached to a function’s code object:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>def func(a, b, c, e=True, f=None):</strong></code>       <code><em># Args: three required, two defaults</em></code>
        <code><strong>x = 1</strong></code>                                <code><em># Plus two more local variables</em></code>
        <code><strong>y = 2</strong></code>

&gt;&gt;&gt; <code><strong>code = func.__code__</strong></code>                     <code><em># Code object of function object</em></code>
&gt;&gt;&gt; <code><strong>code.co_nlocals</strong></code>
7
&gt;&gt;&gt; <code><strong>code.co_varnames</strong></code>                         <code><em># All local variable names</em></code>
('a', 'b', 'c', 'e', 'f', 'x', 'y')
&gt;&gt;&gt; <code><strong>code.co_varnames[:code.co_argcount]</strong></code>      <code><em># &lt;== First N locals are expected args</em></code>
('a', 'b', 'c', 'e', 'f')</pre>
<p>And as usual, <em>starred-argument</em> names in the call proxy allow it to collect arbitrarily many arguments to be matched against the expected arguments so obtained from the function’s introspection API:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>def catcher(*pargs, **kargs): print(f'{pargs}, {kargs}')

</strong></code>&gt;&gt;&gt; <code><strong>catcher(1, 2, 3, 4, 5)</strong></code>
(1, 2, 3, 4, 5), {}
&gt;&gt;&gt; <code><strong>catcher(1, 2, c=3, d=4, e=5)</strong></code>             <code><em># Arguments at calls</em></code>
(1, 2), {'d': 4, 'e': 5, 'c': 3}</pre>
<p>Run a <code>dir</code> call on function and code objects for more details.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Argument assumptions"><div class="sect3" id="argument_assumptions">
<h3>Argument assumptions</h3>
<p>Given the decorated function’s set of expected argument names, the solution relies upon two constraints on argument passing <em>order</em> imposed by Python and covered in <a data-type="xref" href="ch18.html#arguments">Chapter 18</a>:</p>
<ul>
<li><p>At the call, all positional arguments appear before all keyword arguments.</p></li>
<li><p>In the <code>def</code>, all nondefault arguments appear before all default arguments.</p></li>
</ul>
<p>That is, a nonkeyword argument cannot generally follow a keyword argument at a <em>call</em>, and a nondefault argument cannot follow a default argument at a <em>definition</em>. All <code><em>name</em>=<em>value</em></code> syntax must appear after any simple <code><em>name</em></code> in both places. As we’ve also learned, Python matches argument values passed by position to argument names in function headers from left to right, such that these values always match the <em>leftmost</em> names in headers. Keywords match by name instead, and a given argument can receive only one value.</p>
<p>To simplify our work, we can also make the assumption that a call is <em>valid</em> in general—that is, that all arguments either will receive values (by name or position) or will be omitted intentionally to pick up defaults. This assumption won’t necessarily hold because the function has not yet actually been called when the wrapper logic tests validity—the call may still fail later when invoked by the wrapper layer due to incorrect argument passing. As long as that doesn’t cause the wrapper to fail any worse, though, we can ignore the validity of the call. This helps because validating calls before they are actually made would require us to emulate Python’s argument-matching algorithm in full.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Matching algorithm"><div class="sect3" id="matching_algorithm">
<h3>Matching algorithm</h3>
<p>Now, given these constraints and assumptions, we can allow for both keywords and omitted default arguments in the call with this algorithm. When a call is intercepted, we can make the following assumptions and deductions:</p>
<ol>
<li><p>Let <em>N</em> be the number of passed positional arguments, obtained from the length of the <code>*pargs</code> tuple.</p></li>
<li><p>All <em>N</em> positional arguments in <code>*pargs</code> must match the first <em>N</em> expected arguments obtained from the function’s code object. This is true per Python’s call ordering rules, outlined earlier, since all positionals precede all keywords in a call.</p></li>
<li><p>To obtain the names of arguments actually passed by position, we can slice the list of all expected arguments up to the length <em>N</em> of the <code>*pargs</code> passed positionals tuple.</p></li>
<li><p>Any arguments after the first <em>N</em> expected arguments either were passed by keyword or were defaulted by omission at the call.</p></li>
<li><p>For each argument name to be validated by the decorator:</p>
<ol>
<li><p>If the name is in <code>**kargs</code>, it was passed by name—indexing <code>**kargs</code> gives its passed value.</p></li>
<li><p>If the name is in the first <em>N</em> expected arguments, it was passed by position—its relative position in the expected list gives its relative position in <code>*pargs</code>.</p></li>
<li><p>Otherwise, we can assume it was omitted in the call and defaulted and need not be checked.</p></li>
</ol></li>
</ol>
<p>In other words, we can skip tests for arguments that were omitted in a call by assuming that the first <em>N</em> actually passed positional arguments in <code>*pargs</code> must match the first <em>N</em> argument names in the list of all expected arguments, and that any others must either have been passed by keyword and thus be in <code>**kargs</code>, or have been defaulted. Under this scheme, the decorator will simply skip any argument to be checked that was omitted between the rightmost positional argument and the leftmost keyword argument, between keyword arguments, or after the rightmost positional in general. Trace through the decorator and its test script to see how this is realized in code.</p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Open Issues"><div class="sect2" id="open_issues">
<h2>Open Issues</h2>
<p>Although our range-testing tool works as planned, three caveats remain—it doesn’t detect invalid calls, doesn’t handle some arbitrary-argument signatures, and doesn’t fully support nesting. Improvements may require extension or altogether different approaches. Here’s a quick rundown of the issues.</p>
<section data-type="sect3" data-pdf-bookmark="Invalid calls"><div class="sect3" id="invalid_calls">
<h3>Invalid calls</h3>
<p>First, as mentioned earlier, calls to the original function that are <em>not valid</em> still fail in our final decorator. The following, for example, both trigger <code>TypeError</code> exceptions for a missing positional argument <code>a</code>:</p>
<pre data-type="programlisting">omitargs()
omitargs(d=8, c=7, b=6)</pre>
<p>These only fail, though, where we try to <em>invoke</em> the original function, at the end of the wrapper. While we could try to imitate Python’s argument matching to avoid this, there’s not much reason to do so—since the call would fail at this point anyhow, we might as well let Python’s own argument-matching logic detect the problem for us.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Arbitrary arguments"><div class="sect3" id="arbitrary_arguments">
<h3>Arbitrary arguments</h3>
<p>Second, although our final version handles positional arguments, keyword arguments, and omitted defaults, it still doesn’t do anything explicit about <code>*<em>pargs</em></code> and <code>**<em>kargs</em></code> starred-argument names that may be used in a decorated function <code>def</code> that accepts <em>arbitrarily many</em> arguments itself. This is probably moot for our purposes, though:</p>
<ul>
<li><p>If an extra <em>keyword</em> argument <em>is</em> passed, its name will show up in <code>**kargs</code> and can be tested normally if mentioned to the decorator.</p></li>
<li><p>If an extra keyword argument is <em>not</em> passed, its name won’t be in either <code>**kargs</code> or the sliced expected positionals list, and it will thus not be checked—it is treated as though it were defaulted, even though it is really an optional extra argument.</p></li>
<li><p>If an extra <em>positional</em> argument is passed, there’s no way to reference it in the decorator anyhow—its name won’t be in either <code>**kargs</code> or the sliced expected arguments list, so it will simply be skipped. Because such arguments are not listed in the function’s definition, there’s no way to map a name given to the decorator back to an expected relative position.</p></li>
</ul>
<p>In other words, as it is the code supports testing arbitrary keyword arguments by name, but not arbitrary positionals that are unnamed and hence have no set position in the function’s argument signature. In terms of the function object’s API, here’s the effect of these tools in decorated functions:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <code><strong>def func(*pargs, **kargs): pass
</strong></code>&gt;&gt;&gt; <code><strong>code = func.__code__
</strong></code>&gt;&gt;&gt; <code><strong>code.co_nlocals, code.co_varnames</strong></code>
(2, ('pargs', 'kargs'))
&gt;&gt;&gt; <code><strong>code.co_argcount, code.co_varnames[:code.co_argcount]</strong></code>
(0, ())

&gt;&gt;&gt; <code><strong>def func(a, b, *pargs, **kargs): pass
</strong></code>&gt;&gt;&gt; <code><strong>code = func.__code__
</strong></code>&gt;&gt;&gt; <code><strong>code.co_argcount, code.co_varnames[:code.co_argcount]</strong></code>
(2, ('a', 'b'))</pre>
<p>Because starred-argument names show up as locals but <em>not</em> as expected arguments, they won’t be a factor in our matching algorithm—names preceding them in function headers can be validated as usual, but not any extra positional arguments passed. In principle, we could extend the decorator’s interface to support <code>*<em>pargs</em></code> in the decorated function, too, for the rare cases where this might be useful (e.g., a special argument name with a test to apply to all arguments in <code>*<em>pargs</em></code> beyond the length of the expected arguments list), but we’ll pass on such an extension here.</p>
<p>Also, bear in mind that this pertains to values in starred <em>collectors</em> in <code>def</code> headers only; given that starred <em>unpackings</em> in <em>calls</em> are flattened before they ever reach our decorator, they are irrelevant to its code. To borrow a pathological example from <a data-type="xref" href="ch18.html#arguments">Chapter 18</a>:</p>
<pre data-type="programlisting" class="pagebreak-before">&gt;&gt;&gt; <code><strong>def f(a, b, c, d, e, f, g, h, i): pass</strong></code>
&gt;&gt;&gt; <code><strong>f.__code__.co_varnames[:f.__code__.co_argcount]</strong></code>
('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i')

&gt;&gt;&gt; <code><strong>def f(*p, **k): print(p, k)</strong></code>
&gt;&gt;&gt; <code><strong>f(*[1], 2, *[3], 4, f=6, *[5], **dict(g=7), h=8, **{'i': 9})</strong></code>
(1, 2, 3, 4, 5) {'f': 6, 'g': 7, 'h': 8, 'i': 9}</pre>
<p>The call’s stars here are resolved <em>before</em> the function is started. Because our decorator finds values passed to argument names by indexing keywords and mapping expected to actual positionals, it can remain blissfully ignorant of stars in the call and will work normally in this example (though, to be fair, “normally” may be an exaggeration here).</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Decorator nesting"><div class="sect3" id="decorator_nesting-id00090">
<h3>Decorator nesting</h3>
<p>Finally, and perhaps most subtly, this code’s <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="nesting" id="id4887"></a><a contenteditable="false" data-type="indexterm" data-primary="nesting" data-secondary="decorators" id="id4888"></a>approach does not fully support the use of <em>decorator nesting</em> to combine steps. Because it analyzes arguments using names in function definitions, and the names of the call proxy function returned by a nested decoration won’t correspond to argument names in either the original function or decorator arguments, it does not fully support use in nested mode.</p>
<p>Technically, when nested, only the most deeply nested appearance’s validations are run in full; all other nesting levels run tests on arguments passed by keyword only. Trace the code to see why; because the <code>onCall</code> proxy’s call signature expects no named positional arguments, any to-be-validated arguments passed to it by position are treated as if they were omitted and hence defaulted and are thus skipped.</p>
<p>This may be inherent in this tool’s approach—proxies change the argument name signatures at their levels, making it impossible to directly map names in decorator arguments to positions in passed argument sequences. When proxies are present, argument <em>names</em> ultimately apply to keywords only; by contrast, the first-cut solution’s argument <em>positions</em> may support proxies better but do not fully support keywords.</p>
<p>In lieu of this nesting capability, we’ll generalize this decorator to support <em>multiple kinds</em> of validations in a single decoration in an end-of-chapter quiz solution, which also gives examples of the nesting limitation in action. Since we’ve already neared the space allocation for this example, though, if you care about these or any other further improvements, you’ve officially crossed over into the realm of suggested exercises.</p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Decorator Arguments Versus Function Annotations"><div class="sect2" id="decorator_arguments_versus_function_ann">
<h2>Decorator Arguments Versus Function Annotations</h2>
<p>In closing, Python’s annotation feature <a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="arguments" data-tertiary="function annotations" id="id4889"></a>introduced in <a data-type="xref" href="ch19.html#function_odds_and_ends">Chapter 19</a> could also provide an alternative to the decorator arguments used by our example to specify range tests. As we learned earlier, annotations allow us to associate expressions with arguments and return values by coding them in the <code>def</code> header line itself; Python collects annotations in a dictionary and attaches it to the annotated function.</p>
<p>We could use this in our example to code range limits in the header line instead of in decorator arguments. We would still need a function decorator to wrap the function in order to intercept later calls, but we would essentially trade decorator argument syntax:</p>
<pre data-type="programlisting">@rangetest(a=(1, 5), c=(0.0, 1.0))
def func(a, b, c):                         <code><em># func = rangetest(...)(func)</em></code>
    print(a + b + c)</pre>
<p>for annotation syntax like this:</p>
<pre data-type="programlisting">@rangetest
def func(a:(1, 5), b, c:(0.0, 1.0)):
    print(a + b + c)</pre>
<p>That is, the range constraints would be moved into the function itself instead of being coded externally in a decorator line. <a data-type="xref" href="#example_threenine_twosevendot_decoargs">Example 39-27</a> illustrates the structure of the resulting decorators under both schemes in incomplete skeleton code for brevity. The decorator-arguments code pattern is that of our complete solution shown earlier; the annotations alternative requires one less level of nesting because it doesn’t need to retain decorator arguments as state.</p>
<div data-type="example" id="example_threenine_twosevendot_decoargs">
<h5><span class="label">Example 39-27. </span>decoargs-vs-annotation.py</h5>
<pre data-type="programlisting"><code><em># Using decorator arguments
</em></code>
def rangetest(**argchecks):
    def onDecorator(func):
        def onCall(*pargs, **kargs):
            print(argchecks)
            for check in argchecks:
                pass                         <code><em># Add validation code here</em></code>
            return func(*pargs, **kargs)
        return onCall
    return onDecorator

@rangetest(a=(1, 5), c=(0.0, 1.0))
def func(a, b, c):                           <code><em># func = rangetest(...)(func)
</em></code>    print(a + b + c)

func(1, 2, c=3)                              <code><em># Runs onCall, argchecks in scope</em></code>

<code><em># Using function annotations
</em></code>
def rangetest(func):
    def onCall(*pargs, **kargs):
        argchecks = func.__annotations__
        print(argchecks)
        for check in argchecks:
            pass                             <code><em># Add validation code here</em></code>
        return func(*pargs, **kargs)
    return onCall

@rangetest
def func(a:(1, 5), b, c:(0.0, 1.0)):         <code><em># func = rangetest(func)</em></code>
    print(a + b + c)

func(1, 2, c=3)                              <code><em># Runs onCall, annotations on func</em></code></pre>
</div>
<p>When run, both schemes have access to the same validation test information but in different forms—the decorator argument version’s information is retained in an argument in an enclosing scope, and the annotation version’s information is retained in an attribute of the function itself:</p>
<pre data-type="programlisting">$ <code><strong>python3 decoargs-vs-annotation.py</strong></code>
{'a': (1, 5), 'c': (0.0, 1.0)}
6
{'a': (1, 5), 'c': (0.0, 1.0)}
6</pre>
<p>Fleshing out the rest of the annotation-based version is left as a suggested exercise; its code would be almost identical to that of our earlier solution because range-test information is simply on the function instead of in an enclosing scope. Really, all this buys us is a different user interface for our tool—it will still need to match argument names against expected argument names to obtain relative positions as before.</p>
<p>In fact, using annotation instead of decorator arguments in this example actually <em>limits its utility</em>. By moving the validation specifications into the <code>def</code> header, we essentially commit the function to a <em>single role</em>—since annotation directly allows us to code only one expression per argument, it can have only one purpose. For instance, we cannot use range-test annotations for any other role (including the optional and unused type hinting of <a data-type="xref" href="ch06.html#the_dynamic_typing_interlude">Chapter 6</a>).</p>
<p>By contrast, because decorator arguments are coded outside the function itself, they are both easier to remove and <em>more general</em>—the code of the function itself does not imply a single decoration purpose. Crucially, by <em>nesting</em> decorators with arguments, we can often apply multiple augmentation steps to the same function; annotation directly supports only one. With decorator arguments, the function itself also retains a simpler, normal appearance.</p>
<p>Still, if you have a single purpose in mind, the choice between annotation and decorator arguments is largely stylistic and subjective. As is so often true in life, one person’s decoration or <a contenteditable="false" data-type="indexterm" data-primary="functions" data-secondary="arguments" data-tertiary="validation" data-startref="vctgrvld" id="id4890"></a><a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="function decorators" data-tertiary="argument validation" data-startref="dctrfguv" id="id4891"></a><a contenteditable="false" data-type="indexterm" data-primary="decorators" data-secondary="range-testing" data-startref="decorangt" id="id4892"></a><a contenteditable="false" data-type="indexterm" data-primary="range-testing decorator" data-startref="rgttdct" id="id4893"></a>annotation may well be another’s syntactic clutter.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Chapter Summary"><div class="sect1" id="chapter_summary-id00050">
<h1>Chapter Summary</h1>
<p>In this chapter, we explored decorators—both the function and class varieties. As we learned, decorators are a way to insert code to be run automatically when a function or class is defined. When a decorator is used, Python rebinds a function or class name to the callable object that the decorator returns. This hook allows us to manage functions and classes themselves or later calls to them. By adding a layer of wrapper logic to catch later calls, we can augment both function calls and instance interfaces. Decorators provide an explicit and uniform way to achieve such goals.</p>
<p>As we also learned, class decorators can be used to manage classes themselves rather than just their instances. Because this functionality overlaps with <em>metaclasses</em>—the topic of the next and final technical chapter—you’ll have to read on for the conclusion to this story and that of this book at large.</p>
<p>First, though, let’s work through the following quiz. Because this chapter was mostly focused on its examples, the quiz will ask you to modify some of its examples’ code in order to review their concepts. Both the examples’ code and the quiz’s solutions are located in the book’s <em>examples package</em> (see the <a href="preface01.html#preface">Preface</a> for access pointers). Look for the solutions’ code there in this chapter’s <em>_QuizAnswers</em> subfolder. If you’re pressed for time, you’re welcome to jump right into studying the solutions; programming is often as much about reading code as writing it.</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Test Your Knowledge: Quiz"><div class="sect1" id="test_your_knowledge_quiz-id000199">
<h1>Test Your Knowledge: Quiz</h1>
<ol>
<li><p><em>Method decorators</em>: As mentioned in one of this chapter’s notes, the <em>timerdeco2.py</em> module’s call-timer decorator that we wrote in <a data-type="xref" href="#example_threenine_onezerodot_timerdecot">Example 39-10</a> of <a data-type="xref" href="#adding_decorator_arguments">“Adding Decorator Arguments”</a> can be applied only to simple <em>functions</em> because it uses a nested class with a <code>__call__</code> operator-overloading method to catch calls. This structure does not work for a class’s <em>methods</em> because the <em>decorator</em> instance is passed to <code>self</code>, not the subject-class instance. Rewrite this decorator so that it can be applied to <em>both</em> simple functions and methods in classes, and test it on both functions and methods. (Hint: see <a data-type="xref" href="#class_pitfall_decorating_methods">“Class Pitfall: Decorating Methods”</a> for pointers.) Note that you will probably need to use function-object <em>attributes</em> to keep track of total time, since you won’t have a nested class for state retention and can’t access nonlocals from outside the decorator code.</p></li>
<li><p><em>Class decorators</em>: The <code>Public</code>/<code>Private</code> class decorators we wrote in module <em>access2.py</em> of <a data-type="xref" href="#example_threenine_oneeightdot_accesstwo">Example 39-18</a> in this chapter’s first case study example will add <em>performance costs</em> to every attribute fetch in a decorated class. Although we could simply delete the <code>@</code> decoration line to gain speed, we could also augment the decorator itself to check the <code>__debug__</code> switch and perform no wrapping at all when the <code>–O</code> Python flag is passed on the command line—just as we did for the argument range-test decorators. That way, we can speed our program without changing its source via command-line arguments (<code>python –O main.py</code>). While we’re at it, we could also use one of the mix-in superclass techniques we studied to catch a few <em>built-in operations</em> too. Code and test these two extensions.</p></li>
<li><p><em>Generalized argument validations</em>: The function and method decorator we wrote in <em>rangetest.py</em> of <a data-type="xref" href="#example_threenine_twofivedot_rangetestd">Example 39-25</a> checks that passed arguments are in a valid range, but the same code pattern could apply to similar goals such as argument type testing and possibly more. Generalize the range tester so that its single code base can be used for <em>multiple kinds</em> of argument validations. Passed-in validation functions may be the simplest solution given the coding structure here, though subclasses that provide expected methods can often provide similar generalization routes as well. This is substantially challenging, so be sure to see the solution for tips.</p></li>
</ol>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Test Your Knowledge: Answers"><div class="sect1" id="test_your_knowledge_answers-id000198">
<h1>Test Your Knowledge: Answers</h1>
<p>As noted, coding solutions for this quiz are in this chapter’s <em>_QuizAnswers</em> subfolder of the book examples package. Each question has its own subfolder there for its files, with a <em>_Notes.txt</em> plain-text file giving background info. This edition opted to move these solutions online instead of listing them here because it saves about 10 pages and because this internet thing just might take off after all.</p>
</div></section>
</div></section></div>
</div>
</body>
</html>